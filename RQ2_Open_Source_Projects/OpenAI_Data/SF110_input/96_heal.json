[
	{
		"original_code": "// EmailValidationAction.java\npackage org.heal.servlet;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.Vector;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.UserBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\n\n/**\n * An {@link Action} used to validate a user's email address and activate their account.\n * @author Jason Varghese\n */\npublic class EmailValidationAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String emailId = request.getParameter(\"emailId\");\n        String email = request.getParameter(\"email\");\n        int id = 0;\n        try {\n            id = Integer.parseInt(emailId);\n        } catch (NumberFormatException nfe) {\n            id = 0;\n        }\n        String mailingListURL = \"http://lib.med.utah.edu/mailman/listinfo/heal-announce\";\n        if (emailId != null && email != null) {\n            UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n            boolean update = false;\n            update = userRegistry.validateEmail(email, id);\n            NotificationServicesBean notificationServices = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n            try {\n                if (update) {\n                    notificationServices.sendWelcomeMessage(email, mailingListURL);\n                }\n            } catch (MessagingException mhe) {\n                mhe.printStackTrace();\n            }\n            if (update) {\n                response.sendRedirect(\"/user/email_validation.jsp\");\n            } else {\n                Vector errorMessage = new Vector();\n                errorMessage.addElement(\"Your email address could not be validated.  Please request a password reminder for further account information.  \");\n                request.setAttribute(\"errorMessage\", errorMessage);\n                RequestDispatcher rd;\n                rd = request.getRequestDispatcher(\"/user/password.jsp\");\n                rd.forward(request, response);\n            }\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/EmailValidationActionTest.java",
		"test_prompt": "// EmailValidationActionTest.java\npackage org.heal.servlet;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.Vector;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.UserBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmailValidationAction}.\n* It contains ten unit test cases for the {@link EmailValidationAction#actionRequiresLogin()} method.\n*/\nclass EmailValidationActionTest {"
	},
	{
		"original_code": "// ListIMSXMLAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.metadata.MetadataDAO;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.sql.SQLException;\n\npublic class ListIMSXMLAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // MetadataServicesBean metadataServices = (MetadataServicesBean) servlet.getServletContext().getAttribute(\"metadataServices\");\n        MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        String metadataId = request.getParameter(\"metadataId\");\n        try {\n            if (metadataId != null && metadataId.length() > 0) {\n                PrintWriter out = response.getWriter();\n                out.println(metadataServices.getIMSRecord(metadataId));\n            }\n        } catch (NumberFormatException ex) {\n            ex.printStackTrace();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/ListIMSXMLActionTest.java",
		"test_prompt": "// ListIMSXMLActionTest.java\npackage org.heal.servlet;\n\nimport org.heal.module.metadata.MetadataDAO;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ListIMSXMLAction}.\n* It contains ten unit test cases for the {@link ListIMSXMLAction#actionRequiresLogin()} method.\n*/\nclass ListIMSXMLActionTest {"
	},
	{
		"original_code": "// AddToDownloadAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class AddToDownloadAction implements Action {\n\n    private final static String VIEW_QUEUE_URL = \"viewqueue.jsp\";\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        DownloadQueueBean downloadQueue = (DownloadQueueBean) request.getSession().getAttribute(\"downloadQueue\");\n        String[] downloadIds = request.getParameterValues(\"downloadIds\");\n        if (downloadIds != null && downloadIds.length > 0) {\n            for (int i = 0; i < downloadIds.length; i++) {\n                downloadQueue.addToQueue(downloadIds[i]);\n            }\n        }\n        String origURL = request.getParameter(\"origURL\");\n        if (origURL == null) {\n            origURL = VIEW_QUEUE_URL;\n        }\n        response.sendRedirect(origURL);\n        return;\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/AddToDownloadActionTest.java",
		"test_prompt": "// AddToDownloadActionTest.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AddToDownloadAction}.\n* It contains ten unit test cases for the {@link AddToDownloadAction#actionRequiresLogin()} method.\n*/\nclass AddToDownloadActionTest {"
	},
	{
		"original_code": "// ModifyRegistrationAction.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\n\npublic class ModifyRegistrationAction implements Action {\n\n    /**\n     * An {@link Action} used to modify registration info of users (to new format).\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        Vector errorMessages = new Vector();\n        RequestDispatcher rd;\n        String areaOfExpertise, professionalRoleOther, professionalRoleOtherText, userName = \"\", emailConfirm = \"\", email = \"\";\n        String[] instructionalLevel = null, professionalRole = null;\n        UserBean userEntry = new UserBean();\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        /* TODO - SOme of these duplicate form retrievel and validation code in multiple registration related files\n     * can be combined into a single tool.  This can handled much nicer if we move to Struts.\n     */\n        email = request.getParameter(\"email\");\n        emailConfirm = request.getParameter(\"emailConfirm\");\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        areaOfExpertise = request.getParameter(\"areaOfExpertise\");\n        instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n        professionalRole = request.getParameterValues(\"professionalRole\");\n        userName = user.getUserName();\n        if (isStringEmpty(userName)) {\n            errorMessages.addElement(\"Unable to determine the username, please logout.\");\n        }\n        if (!StringFormat.isValidEmailAddr(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Invalid E-mail address\");\n        }\n        if (!emailConfirm.equals(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Email confirmation does not match\");\n        }\n        if ((professionalRole = request.getParameterValues(\"professionalRole\")) == null || professionalRole.length == 0 || professionalRole[0].length() == 0) {\n            errorMessages.addElement(\"Professional Role missing\");\n        }\n        if (professionalRole != null) {\n            for (int a = 0; a < professionalRole.length; a++) {\n                if (\"Other\".equals(professionalRole[a])) {\n                    if (isStringEmpty(professionalRoleOtherText)) {\n                        errorMessages.addElement(\"Enter value for Professional Role: Other\");\n                    }\n                }\n            }\n        }\n        if (isStringEmpty(areaOfExpertise)) {\n            errorMessages.addElement(\"Area of Expertise missing\");\n        }\n        if ((errorMessages.size() > 0)) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            ArrayList ilb = new ArrayList();\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        ilb.add(instructionalLevel[a]);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        prb.add(professionalRole[a]);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            userEntry.setEmail(email);\n            request.setAttribute(\"validUser\", userEntry);\n            // TODO links should be moved to config file rather than hardcoded\n            rd = request.getRequestDispatcher(\"/user/modifyLogin.jsp\");\n            rd.forward(request, response);\n        } else {\n            user.setLoginModified(true);\n            user.setInstructionalLevel(new ArrayList());\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.setInstructionalLevel(instructionalLevel[a]);\n                        user.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                user.setProfessionalRole(new ArrayList());\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        if (\"Other\".equalsIgnoreCase(professionalRole[a]))\n                            prb.setProfessionalRole(professionalRoleOtherText);\n                        else\n                            prb.setProfessionalRole(professionalRole[a]);\n                        user.addProfessionalRole(prb);\n                    }\n                }\n            }\n            user.setProfessionalSpecialty(areaOfExpertise);\n            String userId = \"\";\n            String userId2 = \"\";\n            try {\n                userId2 = userRegistry.saveRegistration(user);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            userId = user.getUserId();\n            if (userId == null || userId.length() == 0) {\n                userId = userId2;\n            }\n            NotificationServicesBean nsb = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n            FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n            try {\n                // TODO links should be moved to cofnig file rather than hardcoded\n                nsb.sendUsernameValidationEmail(user, healFileLocator.getServerBaseURL() + \"/healapp/emailValidation?emailId=\" + userId + \"&email=\" + user.getEmail());\n            } catch (MessagingException m) {\n                m.printStackTrace();\n            }\n            request.getSession().setAttribute(\"validUser\", user);\n            String origURL = request.getParameter(\"origURL\");\n            //<%-- Redirect to the notice page--%>\n            // TODO links should be moved to config file rather than hardcoded\n            String redirect = \"../index.jsp\";\n            if ((origURL != null) && (origURL.length() > 0))\n                redirect = origURL;\n            response.sendRedirect(redirect);\n        }\n    }\n\n    public boolean isStringEmpty(String st) {\n        if (st == null || st.length() == 0)\n            return true;\n        else\n            return false;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/registration/ModifyRegistrationActionTest0.java",
		"test_prompt": "// ModifyRegistrationActionTest0.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyRegistrationAction}.\n* It contains ten unit test cases for the {@link ModifyRegistrationAction#isStringEmpty(String)} method.\n*/\nclass ModifyRegistrationActionTest0 {"
	},
	{
		"original_code": "// ModifyRegistrationAction.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\n\npublic class ModifyRegistrationAction implements Action {\n\n    /**\n     * An {@link Action} used to modify registration info of users (to new format).\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        Vector errorMessages = new Vector();\n        RequestDispatcher rd;\n        String areaOfExpertise, professionalRoleOther, professionalRoleOtherText, userName = \"\", emailConfirm = \"\", email = \"\";\n        String[] instructionalLevel = null, professionalRole = null;\n        UserBean userEntry = new UserBean();\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        /* TODO - SOme of these duplicate form retrievel and validation code in multiple registration related files\n     * can be combined into a single tool.  This can handled much nicer if we move to Struts.\n     */\n        email = request.getParameter(\"email\");\n        emailConfirm = request.getParameter(\"emailConfirm\");\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        areaOfExpertise = request.getParameter(\"areaOfExpertise\");\n        instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n        professionalRole = request.getParameterValues(\"professionalRole\");\n        userName = user.getUserName();\n        if (isStringEmpty(userName)) {\n            errorMessages.addElement(\"Unable to determine the username, please logout.\");\n        }\n        if (!StringFormat.isValidEmailAddr(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Invalid E-mail address\");\n        }\n        if (!emailConfirm.equals(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Email confirmation does not match\");\n        }\n        if ((professionalRole = request.getParameterValues(\"professionalRole\")) == null || professionalRole.length == 0 || professionalRole[0].length() == 0) {\n            errorMessages.addElement(\"Professional Role missing\");\n        }\n        if (professionalRole != null) {\n            for (int a = 0; a < professionalRole.length; a++) {\n                if (\"Other\".equals(professionalRole[a])) {\n                    if (isStringEmpty(professionalRoleOtherText)) {\n                        errorMessages.addElement(\"Enter value for Professional Role: Other\");\n                    }\n                }\n            }\n        }\n        if (isStringEmpty(areaOfExpertise)) {\n            errorMessages.addElement(\"Area of Expertise missing\");\n        }\n        if ((errorMessages.size() > 0)) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            ArrayList ilb = new ArrayList();\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        ilb.add(instructionalLevel[a]);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        prb.add(professionalRole[a]);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            userEntry.setEmail(email);\n            request.setAttribute(\"validUser\", userEntry);\n            // TODO links should be moved to config file rather than hardcoded\n            rd = request.getRequestDispatcher(\"/user/modifyLogin.jsp\");\n            rd.forward(request, response);\n        } else {\n            user.setLoginModified(true);\n            user.setInstructionalLevel(new ArrayList());\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.setInstructionalLevel(instructionalLevel[a]);\n                        user.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                user.setProfessionalRole(new ArrayList());\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        if (\"Other\".equalsIgnoreCase(professionalRole[a]))\n                            prb.setProfessionalRole(professionalRoleOtherText);\n                        else\n                            prb.setProfessionalRole(professionalRole[a]);\n                        user.addProfessionalRole(prb);\n                    }\n                }\n            }\n            user.setProfessionalSpecialty(areaOfExpertise);\n            String userId = \"\";\n            String userId2 = \"\";\n            try {\n                userId2 = userRegistry.saveRegistration(user);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            userId = user.getUserId();\n            if (userId == null || userId.length() == 0) {\n                userId = userId2;\n            }\n            NotificationServicesBean nsb = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n            FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n            try {\n                // TODO links should be moved to cofnig file rather than hardcoded\n                nsb.sendUsernameValidationEmail(user, healFileLocator.getServerBaseURL() + \"/healapp/emailValidation?emailId=\" + userId + \"&email=\" + user.getEmail());\n            } catch (MessagingException m) {\n                m.printStackTrace();\n            }\n            request.getSession().setAttribute(\"validUser\", user);\n            String origURL = request.getParameter(\"origURL\");\n            //<%-- Redirect to the notice page--%>\n            // TODO links should be moved to config file rather than hardcoded\n            String redirect = \"../index.jsp\";\n            if ((origURL != null) && (origURL.length() > 0))\n                redirect = origURL;\n            response.sendRedirect(redirect);\n        }\n    }\n\n    public boolean isStringEmpty(String st) {\n        if (st == null || st.length() == 0)\n            return true;\n        else\n            return false;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/registration/ModifyRegistrationActionTest1.java",
		"test_prompt": "// ModifyRegistrationActionTest1.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyRegistrationAction}.\n* It contains ten unit test cases for the {@link ModifyRegistrationAction#actionRequiresLogin()} method.\n*/\nclass ModifyRegistrationActionTest1 {"
	},
	{
		"original_code": "// UpdateRegistrationAction.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.servlet.*;\n\n/**\n * An {@link Action} that is used to update registered users' info.\n */\npublic class UpdateRegistrationAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        Vector errorMessages = new Vector();\n        RequestDispatcher rd;\n        String firstName, lastName, areaOfExpertise, professionalRoleOther, professionalRoleOtherText, userName = \"\", institutionName, mailingListS = \"\", city, state, country, email = \"\", emailConfirm = \"\", password = \"\", passwordConfirm;\n        String[] instructionalLevel = null, professionalRole = null;\n        UserBean userEntry = new UserBean();\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        /* TODO -  Some of these duplicate form retrievel and validation code in multiple registration related files \n         * can be combined into a single tool.  This can handled much nicer if we move to Struts.\n         */\n        Boolean IAMSEMemberS = false;\n        String IAMSEMemberValue = request.getParameter(\"IAMSEMember\");\n        if (IAMSEMemberValue != null) {\n            IAMSEMemberS = true;\n        }\n        userName = request.getParameter(\"email\");\n        password = request.getParameter(\"password\");\n        passwordConfirm = request.getParameter(\"passwordconfirm\");\n        emailConfirm = request.getParameter(\"emailConfirm\");\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        areaOfExpertise = request.getParameter(\"areaOfExpertise\");\n        firstName = request.getParameter(\"firstName\").trim();\n        lastName = request.getParameter(\"lastName\").trim();\n        mailingListS = request.getParameter(\"isMailingList\");\n        institutionName = request.getParameter(\"institutionName\").trim();\n        city = request.getParameter(\"city\").trim();\n        state = request.getParameter(\"state\").trim();\n        country = request.getParameter(\"country\").trim();\n        String minorS = (request.getParameter(\"aminor\"));\n        instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n        professionalRole = request.getParameterValues(\"professionalRole\");\n        userName = user.getUserName();\n        if (isStringEmpty(userName)) {\n            errorMessages.addElement(\"Unable to determine the username, please logout.\");\n        }\n        //we didn't receive a password setting from the form...\n        if (isStringEmpty(password)) {\n            //but we did get one for password confirm, so there is a mismatch\n            if (!isStringEmpty(passwordConfirm)) {\n                errorMessages.addElement(\"Password and password confirmation do not match.\");\n            } else {\n                //both were empty, so we set the password to that in the bean\n                password = user.getPassword();\n            }\n        } else {\n            //password entry in the form wasn't empty\n            if (isStringEmpty(passwordConfirm)) {\n                errorMessages.addElement(\"Password confirmation was empty.\");\n            } else if (!passwordConfirm.equals(password)) {\n                errorMessages.addElement(\"Password and password confirmation do not match.\");\n            }\n        }\n        if ((professionalRole = request.getParameterValues(\"professionalRole\")) == null || professionalRole.length == 0 || professionalRole[0].length() == 0) {\n            errorMessages.addElement(\"Professional Role missing\");\n        }\n        if (professionalRole != null) {\n            for (int a = 0; a < professionalRole.length; a++) {\n                if (\"Other\".equals(professionalRole[a])) {\n                    if (professionalRoleOtherText == null || professionalRoleOtherText.length() == 0) {\n                        errorMessages.addElement(\"Enter value for Professional Role: Other\");\n                    }\n                }\n            }\n        }\n        if (isStringEmpty(areaOfExpertise)) {\n            errorMessages.addElement(\"Area of Expertise missing\");\n        }\n        if (isStringEmpty(firstName)) {\n            errorMessages.addElement(\"First Name missing\");\n        }\n        if (isStringEmpty(lastName)) {\n            errorMessages.addElement(\"Last Name missing\");\n        }\n        if (isStringEmpty(mailingListS)) {\n            errorMessages.addElement(\"Please indicate if you want to be on the mailing list\");\n        }\n        if (isStringEmpty(institutionName)) {\n            errorMessages.addElement(\"Institution Name missing\");\n        }\n        if (isStringEmpty(city)) {\n            errorMessages.addElement(\"City missing\");\n        }\n        if (isStringEmpty(state)) {\n            errorMessages.addElement(\"State missing\");\n        }\n        if (isStringEmpty(country)) {\n            errorMessages.addElement(\"Country missing\");\n        }\n        if (errorMessages.size() > 0) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            userEntry.setFirstName(firstName);\n            userEntry.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            userEntry.setLastName(lastName);\n            ArrayList ilb = new ArrayList();\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        ilb.add(instructionalLevel[a]);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        prb.add(professionalRole[a]);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            userEntry.setEmail(email);\n            userEntry.setInstitutionName(institutionName);\n            userEntry.setCountry(country);\n            userEntry.setState(state);\n            userEntry.setCity(city);\n            userEntry.setIAMSEMember(IAMSEMemberS);\n            //not being used but in DB\n            /*\n            userEntry.setAddress1(request.getParameter(\"address1\"));\n            userEntry.setAddress2(request.getParameter(\"address2\"));\n            userEntry.setZipCode(request.getParameter(\"zipCode\"));\n            */\n            request.setAttribute(\"validUser\", userEntry);\n            // TODO move to config file instead of hardcoding\n            rd = request.getRequestDispatcher(\"/user/update.jsp\");\n            rd.forward(request, response);\n        } else {\n            user.setFirstName(firstName);\n            user.setLastName(lastName);\n            user.setInstitutionName(institutionName);\n            user.setState(state);\n            user.setCity(city);\n            user.setCountry(country);\n            //user.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            //user.setAddress1(request.getParameter(\"address1\"));\n            //user.setAddress2(request.getParameter(\"address2\"));\n            //user.setZipCode(request.getParameter(\"zipCode\"));\n            boolean minor = false;\n            boolean mailingList = true;\n            if (\"yes\".equals(minorS))\n                minor = true;\n            if (\"no\".equals(mailingListS))\n                mailingList = false;\n            user.setMinor(minor);\n            user.setMailingList(mailingList);\n            user.setLoginModified(true);\n            user.setIAMSEMember(IAMSEMemberS);\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            user.setInstructionalLevel(new ArrayList());\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.setInstructionalLevel(instructionalLevel[a]);\n                        user.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                user.setProfessionalRole(new ArrayList());\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        if (\"Other\".equalsIgnoreCase(professionalRole[a]))\n                            prb.setProfessionalRole(professionalRoleOtherText);\n                        else\n                            prb.setProfessionalRole(professionalRole[a]);\n                        user.addProfessionalRole(prb);\n                    }\n                }\n            }\n            user.setProfessionalSpecialty(areaOfExpertise);\n            user.setPassword(password);\n            String userId = \"\";\n            String userId2 = \"\";\n            try {\n                userId2 = userRegistry.saveRegistration(user);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            userId = user.getUserId();\n            if (userId == null || userId.length() == 0) {\n                userId = userId2;\n            }\n            request.getSession().setAttribute(\"validUser\", user);\n            String from = request.getParameter(\"action\");\n            String origURL = request.getParameter(\"origURL\");\n            //<%-- Redirect to the notice page--%>\n            // TODO move to config file instead of hardcoding\n            String redirect = \"../index.jsp\";\n            if (\"modify\".equals(from)) {\n                if ((origURL != null) && (origURL.length() > 0))\n                    redirect = origURL;\n            }\n            // TODO move to config file instead of hardcoding\n            response.sendRedirect(\"../user/update_response.jsp \");\n        }\n    }\n\n    public boolean isStringEmpty(String st) {\n        if ((st == null) || (st.length() == 0)) {\n            return true;\n        } else\n            return false;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/registration/UpdateRegistrationActionTest0.java",
		"test_prompt": "// UpdateRegistrationActionTest0.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.servlet.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UpdateRegistrationAction}.\n* It contains ten unit test cases for the {@link UpdateRegistrationAction#isStringEmpty(String)} method.\n*/\nclass UpdateRegistrationActionTest0 {"
	},
	{
		"original_code": "// UpdateRegistrationAction.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.servlet.*;\n\n/**\n * An {@link Action} that is used to update registered users' info.\n */\npublic class UpdateRegistrationAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        Vector errorMessages = new Vector();\n        RequestDispatcher rd;\n        String firstName, lastName, areaOfExpertise, professionalRoleOther, professionalRoleOtherText, userName = \"\", institutionName, mailingListS = \"\", city, state, country, email = \"\", emailConfirm = \"\", password = \"\", passwordConfirm;\n        String[] instructionalLevel = null, professionalRole = null;\n        UserBean userEntry = new UserBean();\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        /* TODO -  Some of these duplicate form retrievel and validation code in multiple registration related files \n         * can be combined into a single tool.  This can handled much nicer if we move to Struts.\n         */\n        Boolean IAMSEMemberS = false;\n        String IAMSEMemberValue = request.getParameter(\"IAMSEMember\");\n        if (IAMSEMemberValue != null) {\n            IAMSEMemberS = true;\n        }\n        userName = request.getParameter(\"email\");\n        password = request.getParameter(\"password\");\n        passwordConfirm = request.getParameter(\"passwordconfirm\");\n        emailConfirm = request.getParameter(\"emailConfirm\");\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        areaOfExpertise = request.getParameter(\"areaOfExpertise\");\n        firstName = request.getParameter(\"firstName\").trim();\n        lastName = request.getParameter(\"lastName\").trim();\n        mailingListS = request.getParameter(\"isMailingList\");\n        institutionName = request.getParameter(\"institutionName\").trim();\n        city = request.getParameter(\"city\").trim();\n        state = request.getParameter(\"state\").trim();\n        country = request.getParameter(\"country\").trim();\n        String minorS = (request.getParameter(\"aminor\"));\n        instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n        professionalRole = request.getParameterValues(\"professionalRole\");\n        userName = user.getUserName();\n        if (isStringEmpty(userName)) {\n            errorMessages.addElement(\"Unable to determine the username, please logout.\");\n        }\n        //we didn't receive a password setting from the form...\n        if (isStringEmpty(password)) {\n            //but we did get one for password confirm, so there is a mismatch\n            if (!isStringEmpty(passwordConfirm)) {\n                errorMessages.addElement(\"Password and password confirmation do not match.\");\n            } else {\n                //both were empty, so we set the password to that in the bean\n                password = user.getPassword();\n            }\n        } else {\n            //password entry in the form wasn't empty\n            if (isStringEmpty(passwordConfirm)) {\n                errorMessages.addElement(\"Password confirmation was empty.\");\n            } else if (!passwordConfirm.equals(password)) {\n                errorMessages.addElement(\"Password and password confirmation do not match.\");\n            }\n        }\n        if ((professionalRole = request.getParameterValues(\"professionalRole\")) == null || professionalRole.length == 0 || professionalRole[0].length() == 0) {\n            errorMessages.addElement(\"Professional Role missing\");\n        }\n        if (professionalRole != null) {\n            for (int a = 0; a < professionalRole.length; a++) {\n                if (\"Other\".equals(professionalRole[a])) {\n                    if (professionalRoleOtherText == null || professionalRoleOtherText.length() == 0) {\n                        errorMessages.addElement(\"Enter value for Professional Role: Other\");\n                    }\n                }\n            }\n        }\n        if (isStringEmpty(areaOfExpertise)) {\n            errorMessages.addElement(\"Area of Expertise missing\");\n        }\n        if (isStringEmpty(firstName)) {\n            errorMessages.addElement(\"First Name missing\");\n        }\n        if (isStringEmpty(lastName)) {\n            errorMessages.addElement(\"Last Name missing\");\n        }\n        if (isStringEmpty(mailingListS)) {\n            errorMessages.addElement(\"Please indicate if you want to be on the mailing list\");\n        }\n        if (isStringEmpty(institutionName)) {\n            errorMessages.addElement(\"Institution Name missing\");\n        }\n        if (isStringEmpty(city)) {\n            errorMessages.addElement(\"City missing\");\n        }\n        if (isStringEmpty(state)) {\n            errorMessages.addElement(\"State missing\");\n        }\n        if (isStringEmpty(country)) {\n            errorMessages.addElement(\"Country missing\");\n        }\n        if (errorMessages.size() > 0) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            userEntry.setFirstName(firstName);\n            userEntry.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            userEntry.setLastName(lastName);\n            ArrayList ilb = new ArrayList();\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        ilb.add(instructionalLevel[a]);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        prb.add(professionalRole[a]);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            userEntry.setEmail(email);\n            userEntry.setInstitutionName(institutionName);\n            userEntry.setCountry(country);\n            userEntry.setState(state);\n            userEntry.setCity(city);\n            userEntry.setIAMSEMember(IAMSEMemberS);\n            //not being used but in DB\n            /*\n            userEntry.setAddress1(request.getParameter(\"address1\"));\n            userEntry.setAddress2(request.getParameter(\"address2\"));\n            userEntry.setZipCode(request.getParameter(\"zipCode\"));\n            */\n            request.setAttribute(\"validUser\", userEntry);\n            // TODO move to config file instead of hardcoding\n            rd = request.getRequestDispatcher(\"/user/update.jsp\");\n            rd.forward(request, response);\n        } else {\n            user.setFirstName(firstName);\n            user.setLastName(lastName);\n            user.setInstitutionName(institutionName);\n            user.setState(state);\n            user.setCity(city);\n            user.setCountry(country);\n            //user.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            //user.setAddress1(request.getParameter(\"address1\"));\n            //user.setAddress2(request.getParameter(\"address2\"));\n            //user.setZipCode(request.getParameter(\"zipCode\"));\n            boolean minor = false;\n            boolean mailingList = true;\n            if (\"yes\".equals(minorS))\n                minor = true;\n            if (\"no\".equals(mailingListS))\n                mailingList = false;\n            user.setMinor(minor);\n            user.setMailingList(mailingList);\n            user.setLoginModified(true);\n            user.setIAMSEMember(IAMSEMemberS);\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            user.setInstructionalLevel(new ArrayList());\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.setInstructionalLevel(instructionalLevel[a]);\n                        user.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                user.setProfessionalRole(new ArrayList());\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        if (\"Other\".equalsIgnoreCase(professionalRole[a]))\n                            prb.setProfessionalRole(professionalRoleOtherText);\n                        else\n                            prb.setProfessionalRole(professionalRole[a]);\n                        user.addProfessionalRole(prb);\n                    }\n                }\n            }\n            user.setProfessionalSpecialty(areaOfExpertise);\n            user.setPassword(password);\n            String userId = \"\";\n            String userId2 = \"\";\n            try {\n                userId2 = userRegistry.saveRegistration(user);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            userId = user.getUserId();\n            if (userId == null || userId.length() == 0) {\n                userId = userId2;\n            }\n            request.getSession().setAttribute(\"validUser\", user);\n            String from = request.getParameter(\"action\");\n            String origURL = request.getParameter(\"origURL\");\n            //<%-- Redirect to the notice page--%>\n            // TODO move to config file instead of hardcoding\n            String redirect = \"../index.jsp\";\n            if (\"modify\".equals(from)) {\n                if ((origURL != null) && (origURL.length() > 0))\n                    redirect = origURL;\n            }\n            // TODO move to config file instead of hardcoding\n            response.sendRedirect(\"../user/update_response.jsp \");\n        }\n    }\n\n    public boolean isStringEmpty(String st) {\n        if ((st == null) || (st.length() == 0)) {\n            return true;\n        } else\n            return false;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/registration/UpdateRegistrationActionTest1.java",
		"test_prompt": "// UpdateRegistrationActionTest1.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.servlet.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UpdateRegistrationAction}.\n* It contains ten unit test cases for the {@link UpdateRegistrationAction#actionRequiresLogin()} method.\n*/\nclass UpdateRegistrationActionTest1 {"
	},
	{
		"original_code": "// RegistrationAction.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\n\n/**\n * An {@link Action} that used to register users.\n */\npublic class RegistrationAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        Vector errorMessages = new Vector();\n        RequestDispatcher rd;\n        String firstName, lastName, areaOfExpertise, professionalRoleOther, professionalRoleOtherText, userName = \"\", institutionName, mailingListS = \"\", city, state, country, emailConfirm = \"\", password = \"\", passwordConfirm;\n        String[] instructionalLevel = null, professionalRole = null;\n        UserBean userEntry = new UserBean();\n        /* TODO -  Some of duplicate form retrievel and validation code in multiple registration related files \n         * can be combined into a single tool.  This can handled much nicer if we move to Struts.\n         */\n        Boolean IAMSEMemberS = false;\n        String IAMSEMemberValue = request.getParameter(\"IAMSEMember\");\n        if (IAMSEMemberValue != null) {\n            IAMSEMemberS = true;\n        }\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        userName = request.getParameter(\"email\").trim();\n        password = request.getParameter(\"password\");\n        passwordConfirm = request.getParameter(\"passwordconfirm\");\n        emailConfirm = request.getParameter(\"emailConfirm\");\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        areaOfExpertise = request.getParameter(\"areaOfExpertise\");\n        System.out.println(\"areaofE:\" + areaOfExpertise);\n        firstName = request.getParameter(\"firstName\").trim();\n        lastName = request.getParameter(\"lastName\").trim();\n        mailingListS = request.getParameter(\"isMailingList\");\n        institutionName = request.getParameter(\"institutionName\").trim();\n        city = request.getParameter(\"city\").trim();\n        System.out.println(\"city:\" + city);\n        state = request.getParameter(\"state\").trim();\n        System.out.println(\"State:\" + state);\n        country = request.getParameter(\"country\").trim();\n        System.out.println(\"country:\" + country);\n        instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n        professionalRole = request.getParameterValues(\"professionalRole\");\n        System.out.println(\"IAMSE:\" + IAMSEMemberS);\n        user = new UserBean();\n        try {\n            if (isStringEmpty(userName)) {\n                errorMessages.addElement(\"E-mail address missing\");\n            } else if (userRegistry.userExists(userName)) {\n                errorMessages.addElement(\"User \" + userName + \" already exists, please try another email address.\");\n            } else {\n                user.setUserName(userName);\n            }\n            if (isStringEmpty(password)) {\n                errorMessages.addElement(\"Password missing\");\n            }\n            if (isStringEmpty(passwordConfirm)) {\n                errorMessages.addElement(\"Password confirmation missing\");\n            }\n            if (!passwordConfirm.equals(password)) {\n                errorMessages.addElement(\"Password and password confirmation do not match.\");\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        if (!StringFormat.isValidEmailAddr(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Invalid E-mail address\");\n        }\n        if (!emailConfirm.equals(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Email confirmation does not match\");\n        }\n        if ((professionalRole = request.getParameterValues(\"professionalRole\")) == null || professionalRole.length == 0 || professionalRole[0].length() == 0) {\n            errorMessages.addElement(\"Professional Role missing\");\n        }\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        if (professionalRole != null) {\n            for (int a = 0; a < professionalRole.length; a++) {\n                if (\"Other\".equals(professionalRole[a])) {\n                    if (professionalRoleOtherText == null || professionalRoleOtherText.length() == 0) {\n                        errorMessages.addElement(\"Enter value for Professional Role: Other\");\n                    }\n                }\n            }\n        }\n        if ((areaOfExpertise = request.getParameter(\"areaOfExpertise\")) == null || areaOfExpertise.length() == 0) {\n            errorMessages.addElement(\"Area of Expertise missing\");\n        }\n        if (isStringEmpty(firstName)) {\n            errorMessages.addElement(\"First Name missing\");\n        }\n        if (isStringEmpty(lastName)) {\n            errorMessages.addElement(\"Last Name missing\");\n        }\n        if (isStringEmpty(mailingListS)) {\n            errorMessages.addElement(\"Please indicate if you want to be on the mailing list\");\n        }\n        if (isStringEmpty(institutionName)) {\n            errorMessages.addElement(\"Institution Name missing\");\n        }\n        if (isStringEmpty(city)) {\n            errorMessages.addElement(\"City missing\");\n        }\n        if (isStringEmpty(state)) {\n            errorMessages.addElement(\"State missing\");\n        }\n        if (isStringEmpty(country)) {\n            errorMessages.addElement(\"Country missing\");\n        }\n        if (errorMessages.size() > 0) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            request.setAttribute(\"validUser\", userEntry);\n            ArrayList ilb = new ArrayList();\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        ilb.add(instructionalLevel[a]);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        prb.add(professionalRole[a]);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            // TODO move to config file instead of hardcoding\n            rd = request.getRequestDispatcher(\"/user/register.jsp\");\n            rd.forward(request, response);\n            return;\n        } else {\n            user.setFirstName(firstName);\n            user.setLastName(lastName);\n            user.setInstitutionName(institutionName);\n            user.setState(state);\n            user.setCity(city);\n            user.setCountry(country);\n            user.setIAMSEMember(IAMSEMemberS);\n            //user.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            //user.setAddress1(request.getParameter(\"address1\"));\n            //user.setAddress2(request.getParameter(\"address2\"));\n            //user.setZipCode(request.getParameter(\"zipCode\"));\n            boolean minor = false;\n            boolean mailingList = true;\n            String minorS = (request.getParameter(\"aminor\"));\n            if (\"yes\".equals(minorS))\n                minor = true;\n            if (\"no\".equals(mailingListS))\n                mailingList = false;\n            user.setMinor(minor);\n            user.setMailingList(mailingList);\n            user.setLoginModified(true);\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            user.setInstructionalLevel(new ArrayList());\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.setInstructionalLevel(instructionalLevel[a]);\n                        user.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                user.setProfessionalRole(new ArrayList());\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        if (\"Other\".equalsIgnoreCase(professionalRole[a]))\n                            prb.setProfessionalRole(professionalRoleOtherText);\n                        else\n                            prb.setProfessionalRole(professionalRole[a]);\n                        user.addProfessionalRole(prb);\n                    }\n                }\n            }\n            user.setProfessionalSpecialty(areaOfExpertise);\n            user.setEmail(userName);\n            user.setPassword(password);\n            String userId = \"\";\n            String userId2 = \"\";\n            try {\n                userId2 = userRegistry.saveRegistration(user);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            userId = user.getUserId();\n            if (userId == null || userId.length() == 0) {\n                userId = userId2;\n            }\n            NotificationServicesBean nsb = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n            FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n            try {\n                // TODO move to config file instead of hardcoding\n                nsb.sendUsernameValidationEmail(user, healFileLocator.getServerBaseURL() + \"/healapp/emailValidation?emailId=\" + userId + \"&email=\" + user.getEmail());\n            } catch (MessagingException m) {\n                m.printStackTrace();\n            }\n            // TODO move to config file instead of hardcoding\n            response.sendRedirect(\"../user/register_response.jsp?email=\" + userName);\n        }\n    }\n\n    public boolean isStringEmpty(String st) {\n        if ((st == null) || (st.length() == 0)) {\n            return true;\n        } else\n            return false;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/registration/RegistrationActionTest0.java",
		"test_prompt": "// RegistrationActionTest0.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistrationAction}.\n* It contains ten unit test cases for the {@link RegistrationAction#isStringEmpty(String)} method.\n*/\nclass RegistrationActionTest0 {"
	},
	{
		"original_code": "// RegistrationAction.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\n\n/**\n * An {@link Action} that used to register users.\n */\npublic class RegistrationAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        Vector errorMessages = new Vector();\n        RequestDispatcher rd;\n        String firstName, lastName, areaOfExpertise, professionalRoleOther, professionalRoleOtherText, userName = \"\", institutionName, mailingListS = \"\", city, state, country, emailConfirm = \"\", password = \"\", passwordConfirm;\n        String[] instructionalLevel = null, professionalRole = null;\n        UserBean userEntry = new UserBean();\n        /* TODO -  Some of duplicate form retrievel and validation code in multiple registration related files \n         * can be combined into a single tool.  This can handled much nicer if we move to Struts.\n         */\n        Boolean IAMSEMemberS = false;\n        String IAMSEMemberValue = request.getParameter(\"IAMSEMember\");\n        if (IAMSEMemberValue != null) {\n            IAMSEMemberS = true;\n        }\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        userName = request.getParameter(\"email\").trim();\n        password = request.getParameter(\"password\");\n        passwordConfirm = request.getParameter(\"passwordconfirm\");\n        emailConfirm = request.getParameter(\"emailConfirm\");\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        areaOfExpertise = request.getParameter(\"areaOfExpertise\");\n        System.out.println(\"areaofE:\" + areaOfExpertise);\n        firstName = request.getParameter(\"firstName\").trim();\n        lastName = request.getParameter(\"lastName\").trim();\n        mailingListS = request.getParameter(\"isMailingList\");\n        institutionName = request.getParameter(\"institutionName\").trim();\n        city = request.getParameter(\"city\").trim();\n        System.out.println(\"city:\" + city);\n        state = request.getParameter(\"state\").trim();\n        System.out.println(\"State:\" + state);\n        country = request.getParameter(\"country\").trim();\n        System.out.println(\"country:\" + country);\n        instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n        professionalRole = request.getParameterValues(\"professionalRole\");\n        System.out.println(\"IAMSE:\" + IAMSEMemberS);\n        user = new UserBean();\n        try {\n            if (isStringEmpty(userName)) {\n                errorMessages.addElement(\"E-mail address missing\");\n            } else if (userRegistry.userExists(userName)) {\n                errorMessages.addElement(\"User \" + userName + \" already exists, please try another email address.\");\n            } else {\n                user.setUserName(userName);\n            }\n            if (isStringEmpty(password)) {\n                errorMessages.addElement(\"Password missing\");\n            }\n            if (isStringEmpty(passwordConfirm)) {\n                errorMessages.addElement(\"Password confirmation missing\");\n            }\n            if (!passwordConfirm.equals(password)) {\n                errorMessages.addElement(\"Password and password confirmation do not match.\");\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        if (!StringFormat.isValidEmailAddr(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Invalid E-mail address\");\n        }\n        if (!emailConfirm.equals(request.getParameter(\"email\"))) {\n            errorMessages.addElement(\"Email confirmation does not match\");\n        }\n        if ((professionalRole = request.getParameterValues(\"professionalRole\")) == null || professionalRole.length == 0 || professionalRole[0].length() == 0) {\n            errorMessages.addElement(\"Professional Role missing\");\n        }\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        if (professionalRole != null) {\n            for (int a = 0; a < professionalRole.length; a++) {\n                if (\"Other\".equals(professionalRole[a])) {\n                    if (professionalRoleOtherText == null || professionalRoleOtherText.length() == 0) {\n                        errorMessages.addElement(\"Enter value for Professional Role: Other\");\n                    }\n                }\n            }\n        }\n        if ((areaOfExpertise = request.getParameter(\"areaOfExpertise\")) == null || areaOfExpertise.length() == 0) {\n            errorMessages.addElement(\"Area of Expertise missing\");\n        }\n        if (isStringEmpty(firstName)) {\n            errorMessages.addElement(\"First Name missing\");\n        }\n        if (isStringEmpty(lastName)) {\n            errorMessages.addElement(\"Last Name missing\");\n        }\n        if (isStringEmpty(mailingListS)) {\n            errorMessages.addElement(\"Please indicate if you want to be on the mailing list\");\n        }\n        if (isStringEmpty(institutionName)) {\n            errorMessages.addElement(\"Institution Name missing\");\n        }\n        if (isStringEmpty(city)) {\n            errorMessages.addElement(\"City missing\");\n        }\n        if (isStringEmpty(state)) {\n            errorMessages.addElement(\"State missing\");\n        }\n        if (isStringEmpty(country)) {\n            errorMessages.addElement(\"Country missing\");\n        }\n        if (errorMessages.size() > 0) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            request.setAttribute(\"validUser\", userEntry);\n            ArrayList ilb = new ArrayList();\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        ilb.add(instructionalLevel[a]);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        prb.add(professionalRole[a]);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            // TODO move to config file instead of hardcoding\n            rd = request.getRequestDispatcher(\"/user/register.jsp\");\n            rd.forward(request, response);\n            return;\n        } else {\n            user.setFirstName(firstName);\n            user.setLastName(lastName);\n            user.setInstitutionName(institutionName);\n            user.setState(state);\n            user.setCity(city);\n            user.setCountry(country);\n            user.setIAMSEMember(IAMSEMemberS);\n            //user.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            //user.setAddress1(request.getParameter(\"address1\"));\n            //user.setAddress2(request.getParameter(\"address2\"));\n            //user.setZipCode(request.getParameter(\"zipCode\"));\n            boolean minor = false;\n            boolean mailingList = true;\n            String minorS = (request.getParameter(\"aminor\"));\n            if (\"yes\".equals(minorS))\n                minor = true;\n            if (\"no\".equals(mailingListS))\n                mailingList = false;\n            user.setMinor(minor);\n            user.setMailingList(mailingList);\n            user.setLoginModified(true);\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            user.setInstructionalLevel(new ArrayList());\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.setInstructionalLevel(instructionalLevel[a]);\n                        user.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                user.setProfessionalRole(new ArrayList());\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        if (\"Other\".equalsIgnoreCase(professionalRole[a]))\n                            prb.setProfessionalRole(professionalRoleOtherText);\n                        else\n                            prb.setProfessionalRole(professionalRole[a]);\n                        user.addProfessionalRole(prb);\n                    }\n                }\n            }\n            user.setProfessionalSpecialty(areaOfExpertise);\n            user.setEmail(userName);\n            user.setPassword(password);\n            String userId = \"\";\n            String userId2 = \"\";\n            try {\n                userId2 = userRegistry.saveRegistration(user);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            userId = user.getUserId();\n            if (userId == null || userId.length() == 0) {\n                userId = userId2;\n            }\n            NotificationServicesBean nsb = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n            FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n            try {\n                // TODO move to config file instead of hardcoding\n                nsb.sendUsernameValidationEmail(user, healFileLocator.getServerBaseURL() + \"/healapp/emailValidation?emailId=\" + userId + \"&email=\" + user.getEmail());\n            } catch (MessagingException m) {\n                m.printStackTrace();\n            }\n            // TODO move to config file instead of hardcoding\n            response.sendRedirect(\"../user/register_response.jsp?email=\" + userName);\n        }\n    }\n\n    public boolean isStringEmpty(String st) {\n        if ((st == null) || (st.length() == 0)) {\n            return true;\n        } else\n            return false;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/registration/RegistrationActionTest1.java",
		"test_prompt": "// RegistrationActionTest1.java\npackage org.heal.servlet.registration;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.heal.servlet.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistrationAction}.\n* It contains ten unit test cases for the {@link RegistrationAction#actionRequiresLogin()} method.\n*/\nclass RegistrationActionTest1 {"
	},
	{
		"original_code": "// ModifyApprovalQueueEntryAction.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Modifies an approval queue entry.\n *\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class ModifyApprovalQueueEntryAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        final String approvalQueueEntryId = request.getParameter(\"approvalQueueEntryId\");\n        final String status = request.getParameter(\"status\");\n        if (false == AuthenticationTools.isApprover(request) || null == approvalQueueEntryId || null == status) {\n            // The user does not have the access to view this page\n            // or an Approval Queue entry id or status is missing\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        // Creates an QueuedRecordBean based on the form data\n        final QueuedRecordBean approvalEntry = new QueuedRecordBean();\n        approvalEntry.setQueuedRecordId(approvalQueueEntryId);\n        approvalEntry.setComments(request.getParameter(\"comment\"));\n        approvalEntry.getShortMetadata().setMetadataId(request.getParameter(\"metadataId\"));\n        approvalEntry.setStatus(status);\n        final QueueDAO queueManager = (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        final String statusTest = status.toLowerCase();\n        if (\"waiting\".equals(statusTest)) {\n            // If the status is 'waiting', then we just save the approval queue entry\n            approvalEntry.setType(QueueDAO.TYPE_APPROVAL);\n            queueManager.saveQueuedRecord(approvalEntry);\n        } else if (\"approved\".equals(statusTest)) {\n            approvalEntry.setType(QueueDAO.TYPE_CATALOG);\n            approvalEntry.setStatus(\"Waiting\");\n            queueManager.markRecordApproved(approvalEntry.getShortMetadata().getMetadataId());\n            queueManager.saveQueuedRecord(approvalEntry);\n        } else if (\"rejected\".equals(statusTest)) {\n            // If the status is 'rejected', we mark it as such in the database\n            queueManager.rejectRecord(approvalEntry.getShortMetadata().getMetadataId());\n            queueManager.dequeue(approvalEntry.getQueuedRecordId());\n        }\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        response.sendRedirect(\"showApprovalQueue\");\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/approver/ModifyApprovalQueueEntryActionTest.java",
		"test_prompt": "// ModifyApprovalQueueEntryActionTest.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyApprovalQueueEntryAction}.\n* It contains ten unit test cases for the {@link ModifyApprovalQueueEntryAction#actionRequiresLogin()} method.\n*/\nclass ModifyApprovalQueueEntryActionTest {"
	},
	{
		"original_code": "// ShowApprovalQueueAction.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * An {@link org.heal.servlet.Action} which fetches the information needed to\n * display the approval queue.\n *\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class ShowApprovalQueueAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (false == AuthenticationTools.isApprover(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final QueueDAO queueManager = (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        final List queue = queueManager.getApprovalQueue();\n        request.setAttribute(\"approvalQueue\", queue);\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        RequestDispatcher rd = request.getRequestDispatcher(\"/approval/viewqueue.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/approver/ShowApprovalQueueActionTest.java",
		"test_prompt": "// ShowApprovalQueueActionTest.java\npackage org.heal.servlet.approver;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowApprovalQueueAction}.\n* It contains ten unit test cases for the {@link ShowApprovalQueueAction#actionRequiresLogin()} method.\n*/\nclass ShowApprovalQueueActionTest {"
	},
	{
		"original_code": "// SubmitPeerReviewSurveyAction.java\npackage org.heal.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.List;\nimport java.util.ArrayList;\n\n/**\n * Comments here!\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class SubmitPeerReviewSurveyAction extends DelimitedFileWriterAction {\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n\n    /**\n     * @return The name of the file to write the delimited data to.  This file\n     *      need not include path information -- it will show up in the /private/logs/\n     *      folder as specified in {@link org.heal.servlet.DelimitedFileWriterAction}.\n     */\n    public String getLogFilename() {\n        return \"PeerReviewSurvey.txt\";\n    }\n\n    /**\n     * @return A <code>String</code> representation of the page to forward\n     *      to upon a successful form submission.\n     */\n    public String getSuccessPage() {\n        return \"/peerReview/surveySuccess.html\";\n    }\n\n    public List getData(HttpServletRequest request) {\n        List ret = new ArrayList();\n        ret.add(getFormParameter(request, \"firstName\"));\n        ret.add(getFormParameter(request, \"lastName\"));\n        ret.add(getFormParameter(request, \"affiliation\"));\n        ret.add(getFormParameter(request, \"address1\"));\n        ret.add(getFormParameter(request, \"address2\"));\n        ret.add(getFormParameter(request, \"city\"));\n        ret.add(getFormParameter(request, \"state\"));\n        ret.add(getFormParameter(request, \"postalCode\"));\n        ret.add(getFormParameter(request, \"country\"));\n        ret.add(getFormParameter(request, \"email\"));\n        ret.add(getFormParameter(request, \"phoneNumber\"));\n        ret.add(getFormParameter(request, \"faxNumber\"));\n        ret.add(getFormParameter(request, \"discipline\"));\n        ret.add(getFormParameter(request, \"teachingExperience\"));\n        ret.add(getFormParameter(request, \"experienceLevel\"));\n        ret.add(getFormParameter(request, \"attendedGeaMeeting\"));\n        ret.add(getFormParameter(request, \"attendedPreviousSOL\"));\n        ret.add(getFormParameter(request, \"willAttendSOL\"));\n        ret.add(getFormParameter(request, \"willAttendIAMSE\"));\n        ret.add(getFormParameter(request, \"willAttendAAMC\"));\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/SubmitPeerReviewSurveyActionTest.java",
		"test_prompt": "// SubmitPeerReviewSurveyActionTest.java\npackage org.heal.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SubmitPeerReviewSurveyAction}.\n* It contains ten unit test cases for the {@link SubmitPeerReviewSurveyAction#actionRequiresLogin()} method.\n*/\nclass SubmitPeerReviewSurveyActionTest {"
	},
	{
		"original_code": "// EmailReminderAction.java\npackage org.heal.servlet;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport javax.mail.MessagingException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport org.heal.util.FileLocator;\n\n/**\n * An {@link Action} sends out the password reminder for users.\n * @author Jason Varghese\n */\npublic class EmailReminderAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        NotificationServicesBean notificationServices = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n        Vector errorMessage = new Vector();\n        String email = request.getParameter(\"email\");\n        if (email != null && email.length() > 0) {\n            try {\n                UserBean user = userRegistry.getUserFromEmail(email);\n                if (user != null) {\n                    FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n                    errorMessage = notificationServices.sendPasswordReminder(user, healFileLocator.getServerBaseURL());\n                    if (errorMessage.size() == 0)\n                        errorMessage.addElement(\"Password reminder has been sent.\");\n                } else {\n                    errorMessage.addElement(\"User email of \" + email + \"  not found\");\n                }\n            } catch (SQLException se) {\n                System.err.println(se.toString());\n            } catch (MessagingException m) {\n                m.printStackTrace();\n                errorMessage.addElement(\"System error: \" + m.toString());\n            }\n        } else {\n            errorMessage.addElement(\"Please Enter an Email Address\");\n        }\n        if (errorMessage.size() > 0)\n            request.setAttribute(\"errorMessage\", errorMessage);\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(\"/user/password.jsp\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/EmailReminderActionTest.java",
		"test_prompt": "// EmailReminderActionTest.java\npackage org.heal.servlet;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport javax.mail.MessagingException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport org.heal.util.FileLocator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmailReminderAction}.\n* It contains ten unit test cases for the {@link EmailReminderAction#actionRequiresLogin()} method.\n*/\nclass EmailReminderActionTest {"
	},
	{
		"original_code": "// ModifyRegistrationAction.java\npackage org.heal.servlet;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.Vector;\nimport org.heal.module.user.UserBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\n\npublic class ModifyRegistrationAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String username = request.getParameter(\"username\");\n        String action = request.getParameter(\"action\");\n        if (\"skip\".equals(action)) {\n            UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n            user.setLoginModified(true);\n            String origURL = request.getParameter(\"origURL\");\n            if (origURL != null && origURL.length() > 0)\n                response.sendRedirect(origURL);\n            else\n                response.sendRedirect(\"../index.jsp\");\n            return;\n        }\n        if (\"reset\".equals(action)) {\n            UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n            userRegistry.reset(username);\n            response.sendRedirect(\"../index.jsp\");\n            return;\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/ModifyRegistrationActionTest.java",
		"test_prompt": "// ModifyRegistrationActionTest.java\npackage org.heal.servlet;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.Vector;\nimport org.heal.module.user.UserBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyRegistrationAction}.\n* It contains ten unit test cases for the {@link ModifyRegistrationAction#actionRequiresLogin()} method.\n*/\nclass ModifyRegistrationActionTest {"
	},
	{
		"original_code": "// SubmitDetailedViewSurveyAction.java\npackage org.heal.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * An {@link Action} that stores information submitted in the Detailed View survey\n * into a delimited text file.\n */\npublic class SubmitDetailedViewSurveyAction extends DelimitedFileWriterAction {\n\n    public SubmitDetailedViewSurveyAction() {\n    }\n\n    public String getLogFilename() {\n        return \"DetailedViewSurvey.txt\";\n    }\n\n    public String getSuccessPage() {\n        return \"../feedback/mail_logged_response.html\";\n    }\n\n    public List getData(HttpServletRequest request) {\n        List ret = new ArrayList();\n        ret.add(getFormParameter(request, \"metadataId\"));\n        ret.add(getFormParameter(request, \"userId\"));\n        ret.add(getFormParameter(request, \"rating\"));\n        ret.add(getFormParameter(request, \"use\"));\n        ret.add(getFormParameter(request, \"comments\"));\n        return ret;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/SubmitDetailedViewSurveyActionTest.java",
		"test_prompt": "// SubmitDetailedViewSurveyActionTest.java\npackage org.heal.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SubmitDetailedViewSurveyAction}.\n* It contains ten unit test cases for the {@link SubmitDetailedViewSurveyAction#actionRequiresLogin()} method.\n*/\nclass SubmitDetailedViewSurveyActionTest {"
	},
	{
		"original_code": "// DownloadAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.download.DownloadDAO;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class DownloadAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        DownloadQueueBean downloadQueue = (DownloadQueueBean) request.getSession().getAttribute(\"downloadQueue\");\n        // DownloadServicesBean downloadServices = (DownloadServicesBean) servlet.getServletContext().getAttribute(\"downloadServices\");\n        DownloadDAO downloadServices = (DownloadDAO) servlet.getServletContext().getAttribute(\"downloadDAO\");\n        if (downloadQueue == null) {\n            downloadQueue = new DownloadQueueBean();\n            request.getSession().setAttribute(\"downloadQueue\", downloadQueue);\n        }\n        String format = request.getParameter(\"packageFormat\");\n        String url = new String();\n        if (format == null) {\n            //default format is ZIP\n            format = org.heal.module.download.DownloadDAO.ZIPFORMAT;\n        }\n        try {\n            url = downloadServices.createPackage(downloadQueue, format);\n        } catch (java.io.IOException ex) {\n            ex.printStackTrace();\n        } catch (java.sql.SQLException ex) {\n            ex.printStackTrace();\n        }\n        if (url == null) {\n            url = \"../downloads/viewqueue.jsp\";\n        }\n        response.sendRedirect(url);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/DownloadActionTest.java",
		"test_prompt": "// DownloadActionTest.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.download.DownloadDAO;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadAction}.\n* It contains ten unit test cases for the {@link DownloadAction#actionRequiresLogin()} method.\n*/\nclass DownloadActionTest {"
	},
	{
		"original_code": "// GenerateReportAction.java\npackage org.heal.servlet.admin;\n\nimport java.io.BufferedReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.SortedSet;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.servlet.*;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.PrintWriter;\nimport java.sql.SQLException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\nimport org.heal.util.AuthenticationTools;\n\npublic class GenerateReportAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // doo something\n        String type = request.getParameter(\"type\");\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        MetadataDAO metadataDao = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        if (!AuthenticationTools.isAdministrator(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        if (\"sample\".equals(type)) {\n            PrintWriter out = response.getWriter();\n            out.println(\"sampleData72\");\n        }\n        if (\"userCount\".equals(type)) {\n            int count = 0;\n            try {\n                count = userRegistry.getCountOfUsers();\n                PrintWriter out = response.getWriter();\n                out.println(count);\n            } catch (SQLException se) {\n                se.toString();\n            }\n        }\n        if (\"getUsers\".equals(type)) {\n            try {\n                PrintWriter out = response.getWriter();\n                HashMap users = new HashMap();\n                //UserRegistryBean userRegistry = (UserRegistryBean)request.getSession().getAttribute(\"userRegistry\");\n                Vector userNames = new Vector();\n                userNames = userRegistry.getAllUserIds();\n                Iterator it = null;\n                it = userNames.iterator();\n                UserBean userBean = new UserBean();\n                out.println(\"UserId|Email|First Name|Last Name|Institution|City|State|Country|Area of Expertise|Instructional Level|Professional Role\");\n                for (int a = 0; a < userNames.size(); a++) {\n                    String userId = null;\n                    userId = (String) userNames.get(a);\n                    userBean = userRegistry.getUserFromID(userId);\n                    if (userBean != null) {\n                        out.print(userId + \"|\");\n                        out.print(userBean.getEmail() + \"|\");\n                        out.print(userBean.getFirstName() + \"|\");\n                        out.print(userBean.getLastName() + \"|\");\n                        out.print(userBean.getInstitutionName() + \"|\");\n                        out.print(userBean.getCity() + \"|\");\n                        out.print(userBean.getState() + \"|\");\n                        out.print(userBean.getCountry() + \"|\");\n                        out.print(userBean.getProfessionalSpecialty() + \"|\");\n                        InstructionalLevelBean ilb = null;\n                        ArrayList ilbs = null;\n                        ilbs = userBean.getInstructionalLevel();\n                        it = null;\n                        it = ilbs.iterator();\n                        while (it.hasNext()) {\n                            ilb = (InstructionalLevelBean) it.next();\n                            if (it.hasNext())\n                                out.print(ilb.getInstructionalLevel() + \"/\");\n                            else\n                                out.print(ilb.getInstructionalLevel());\n                        }\n                        out.print(\"|\");\n                        ProfessionalRoleBean prb = null;\n                        ArrayList prbs = null;\n                        prbs = userBean.getProfessionalRole();\n                        it = null;\n                        it = prbs.iterator();\n                        int loopCount = 0;\n                        while (it.hasNext()) {\n                            prb = (ProfessionalRoleBean) it.next();\n                            if (it.hasNext())\n                                out.print(prb.getProfessionalRole() + \"/\");\n                            else\n                                out.print(prb.getProfessionalRole());\n                        }\n                        out.print(\"\\n\");\n                    }\n                }\n            } catch (SQLException se) {\n                se.toString();\n            }\n        }\n        if (\"getAreaofExpertise\".equals(type)) {\n            try {\n                PrintWriter out = response.getWriter();\n                HashMap users = new HashMap();\n                //UserRegistryBean userRegistry = (UserRegistryBean)request.getSession().getAttribute(\"userRegistry\");\n                Vector userNames = new Vector();\n                userNames = userRegistry.getAreaofExpertiseValues();\n                Iterator it = null;\n                it = userNames.iterator();\n                out.println(\"Area of Expertise|Count\");\n                for (int a = 0; a < userNames.size(); a++) {\n                    out.print(userNames.get(a) + \"|\");\n                    out.println(userRegistry.getAreaofExpertiseSummary((String) userNames.get(a)));\n                }\n            } catch (SQLException se) {\n                se.printStackTrace();\n            }\n        }\n        if (\"detailedViewAccessReport\".equals(type)) {\n            try {\n                PrintWriter out = response.getWriter();\n                BufferedReader fr = new BufferedReader(new FileReader(servlet.getServletContext().getRealPath(\"/\") + \"../private/logs/\" + \"detailedViewAccess.txt\"));\n                HashMap users = new HashMap();\n                //UserRegistryBean userRegistry = (UserRegistryBean)request.getSession().getAttribute(\"userRegistry\");\n                UserBean userBean = new UserBean();\n                String str = new String();\n                int c;\n                char[] ch = new char[100];\n                //while ((c = (fr.read(ch))) != -1)\n                out.println(\"Email|First Name|Last Name|Instition|City|State|Country|Area of Expertise|Instructional Level|Professional Role|UserId|MetadataId|SessionId|Date\");\n                while ((str = fr.readLine()) != null) {\n                    String userId = null;\n                    String metadataId = null;\n                    StringTokenizer st = new StringTokenizer(str, \"|\");\n                    if (st != null && st.hasMoreTokens())\n                        userId = st.nextToken();\n                    if (st != null && st.hasMoreTokens())\n                        metadataId = st.nextToken();\n                    ArrayList taxonPathBeans = new ArrayList();\n                    try {\n                        taxonPathBeans = metadataDao.getTaxonPaths(metadataId);\n                        userBean = userRegistry.getUserFromID(userId);\n                    } catch (SQLException se) {\n                        se.printStackTrace();\n                    }\n                    if (userBean != null) {\n                        out.print(userBean.getEmail() + \"|\");\n                        out.print(userBean.getFirstName() + \"|\");\n                        out.print(userBean.getLastName() + \"|\");\n                        out.print(userBean.getInstitutionName() + \"|\");\n                        out.print(userBean.getCity() + \"|\");\n                        out.print(userBean.getState() + \"|\");\n                        out.print(userBean.getCountry() + \"|\");\n                        out.print(userBean.getProfessionalSpecialty() + \"|\");\n                        InstructionalLevelBean ilb = null;\n                        ArrayList ilbs = null;\n                        ilbs = userBean.getInstructionalLevel();\n                        Iterator it = null;\n                        it = ilbs.iterator();\n                        while (it.hasNext()) {\n                            ilb = (InstructionalLevelBean) it.next();\n                            if (it.hasNext())\n                                out.print(ilb.getInstructionalLevel() + \"/\");\n                            else\n                                out.print(ilb.getInstructionalLevel());\n                        }\n                        out.print(\"|\");\n                        ProfessionalRoleBean prb = null;\n                        ArrayList prbs = null;\n                        prbs = userBean.getProfessionalRole();\n                        it = null;\n                        it = prbs.iterator();\n                        int loopCount = 0;\n                        while (it.hasNext()) {\n                            prb = (ProfessionalRoleBean) it.next();\n                            if (it.hasNext())\n                                out.print(prb.getProfessionalRole() + \"/\");\n                            else\n                                out.print(prb.getProfessionalRole());\n                        }\n                        out.print(\"|\");\n                        TaxonPathBean tpb = null;\n                        SortedSet taxonPaths = null;\n                        TaxonBean tb = null;\n                        Iterator it2 = null;\n                        it = null;\n                        boolean firstItem = true;\n                        it = taxonPathBeans.iterator();\n                        while (it.hasNext()) {\n                            tpb = (TaxonPathBean) it.next();\n                            if (tpb.getSource().equalsIgnoreCase(\"mesh\")) {\n                                taxonPaths = tpb.getTaxons();\n                                it2 = taxonPaths.iterator();\n                                while (it2.hasNext()) {\n                                    tb = (TaxonBean) it2.next();\n                                    if (firstItem) {\n                                        out.print(tb.getEntry());\n                                        firstItem = false;\n                                    } else\n                                        out.print(\"/\" + tb.getEntry());\n                                }\n                            }\n                        }\n                    }\n                    out.println(\"|\" + str);\n                }\n                fr.close();\n            } catch (FileNotFoundException se) {\n                se.toString();\n            }\n        }\n        if (\"detailedViewSurveyReport\".equals(type)) {\n            try {\n                PrintWriter out = response.getWriter();\n                BufferedReader fr = new BufferedReader(new FileReader(servlet.getServletContext().getRealPath(\"/\") + \"../private/logs/\" + \"detailedViewSurvey.txt\"));\n                //FileReader fr = new FileReader(new File(servlet.getServletContext().getRealPath(\"/\") +\"../private/logs/\" +\"detailedViewAccess.txt\"));\n                int c;\n                UserBean userBean = new UserBean();\n                String str = new String();\n                char[] ch = new char[100];\n                out.println(\"Email|First Name|Last Name|Instition|City|State|Country|Area of Expertise|Instructional Level|Professional Role|MetadataId|UserId|Rating|User|Comment\");\n                while ((str = fr.readLine()) != null) {\n                    String userId = null;\n                    StringTokenizer st = new StringTokenizer(str, \"|\");\n                    if (st != null && st.hasMoreTokens())\n                        userId = st.nextToken();\n                    System.err.println(\"userId=\" + userId);\n                    try {\n                        userBean = userRegistry.getUserFromID(userId);\n                    } catch (SQLException se) {\n                        se.printStackTrace();\n                    }\n                    if (userBean != null) {\n                        out.print(userBean.getEmail() + \"|\");\n                        out.print(userBean.getFirstName() + \"|\");\n                        out.print(userBean.getLastName() + \"|\");\n                        out.print(userBean.getInstitutionName() + \"|\");\n                        out.print(userBean.getCity() + \"|\");\n                        out.print(userBean.getState() + \"|\");\n                        out.print(userBean.getCountry() + \"|\");\n                        out.print(userBean.getProfessionalSpecialty());\n                        InstructionalLevelBean ilb = null;\n                        ArrayList ilbs = null;\n                        ilbs = userBean.getInstructionalLevel();\n                        Iterator it = null;\n                        it = ilbs.iterator();\n                        while (it.hasNext()) {\n                            ilb = (InstructionalLevelBean) it.next();\n                            if (it.hasNext())\n                                out.print(ilb.getInstructionalLevel() + \"/\");\n                            else\n                                out.print(ilb.getInstructionalLevel());\n                        }\n                        out.print(\"|\");\n                        ProfessionalRoleBean prb = null;\n                        ArrayList prbs = null;\n                        prbs = userBean.getProfessionalRole();\n                        it = null;\n                        it = prbs.iterator();\n                        int loopCount = 0;\n                        while (it.hasNext()) {\n                            prb = (ProfessionalRoleBean) it.next();\n                            if (it.hasNext())\n                                out.print(prb.getProfessionalRole() + \"/\");\n                            else\n                                out.print(prb.getProfessionalRole());\n                        }\n                    }\n                    out.println(\"|\" + str);\n                    //ch = new char[100];\n                }\n                fr.close();\n            } catch (FileNotFoundException se) {\n                se.toString();\n            }\n        }\n        if (\"getUser\".equals(type)) {\n            try {\n                String email = request.getParameter(\"email\");\n                UserBean user = new UserBean();\n                user = userRegistry.getUserFromEmail(email);\n                String emailValidationPath = \"dev.healcentral.org\" + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n                PrintWriter out = response.getWriter();\n                out.println(\"Firstname=\" + user.getFirstName() + \"<Br><br>\");\n                out.println(\"Validated=\" + user.isEmailValidated() + \"<br><br>\");\n                out.println(\"Validation Link = \" + emailValidationPath + \"<br><br>\");\n            } catch (SQLException se) {\n                se.printStackTrace();\n            }\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/admin/GenerateReportActionTest.java",
		"test_prompt": "// GenerateReportActionTest.java\npackage org.heal.servlet.admin;\n\nimport java.io.BufferedReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.SortedSet;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.servlet.*;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.PrintWriter;\nimport java.sql.SQLException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\nimport org.heal.util.AuthenticationTools;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GenerateReportAction}.\n* It contains ten unit test cases for the {@link GenerateReportAction#actionRequiresLogin()} method.\n*/\nclass GenerateReportActionTest {"
	},
	{
		"original_code": "// AdminAction.java\npackage org.heal.servlet.admin;\n\nimport java.io.IOException;\nimport java.util.Vector;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.heal.servlet.*;\nimport org.heal.util.CommonDAO;\n\npublic class AdminAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String action = \"\";\n        String metadataId = \"\";\n        action = request.getParameter(\"action\");\n        metadataId = request.getParameter(\"metadataId\");\n        CommonDAO common = (CommonDAO) servlet.getServletContext().getAttribute(\"CommonDAO\");\n        if (common == null)\n            System.err.println(\"common null\");\n        common.deleteMetadata(metadataId);\n        RequestDispatcher rd;\n        Vector message = new Vector();\n        message.addElement(\"Item deleted.  To delete another item please enter metadataID and press submit.\");\n        request.setAttribute(\"messages\", message);\n        rd = request.getRequestDispatcher(\"../admins/delete.jsp\");\n        rd.forward(request, response);\n        return;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/admin/AdminActionTest.java",
		"test_prompt": "// AdminActionTest.java\npackage org.heal.servlet.admin;\n\nimport java.io.IOException;\nimport java.util.Vector;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.heal.servlet.*;\nimport org.heal.util.CommonDAO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminAction}.\n* It contains ten unit test cases for the {@link AdminAction#actionRequiresLogin()} method.\n*/\nclass AdminActionTest {"
	},
	{
		"original_code": "// LinkCheckerAction.java\npackage org.heal.servlet.admin;\n\nimport java.io.IOException;\nimport java.util.Vector;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.heal.servlet.*;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.CommonDAO;\n\npublic class LinkCheckerAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isAdministrator(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/admin/LinkCheckerActionTest.java",
		"test_prompt": "// LinkCheckerActionTest.java\npackage org.heal.servlet.admin;\n\nimport java.io.IOException;\nimport java.util.Vector;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.heal.servlet.*;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.CommonDAO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LinkCheckerAction}.\n* It contains ten unit test cases for the {@link LinkCheckerAction#actionRequiresLogin()} method.\n*/\nclass LinkCheckerActionTest {"
	},
	{
		"original_code": "// EditAdvSearchAction.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport org.heal.servlet.Action;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class EditAdvSearchAction implements Action {\n\n    public EditAdvSearchAction() {\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String redirectURL = null;\n        redirectURL = request.getParameter(\"pam\");\n        response.sendRedirect(redirectURL);\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/EditAdvSearchActionTest.java",
		"test_prompt": "// EditAdvSearchActionTest.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport org.heal.servlet.Action;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditAdvSearchAction}.\n* It contains ten unit test cases for the {@link EditAdvSearchAction#actionRequiresLogin()} method.\n*/\nclass EditAdvSearchActionTest {"
	},
	{
		"original_code": "// AdvSearchAction.java\npackage org.heal.servlet.search;\n\nimport org.heal.module.search.AdvSearchDAO;\nimport org.heal.module.search.ParameterBean;\nimport org.heal.module.search.ParameterNode;\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class AdvSearchAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        request.getSession().setAttribute(\"searchResults\", null);\n        AdvSearchDAO sd = (AdvSearchDAO) servlet.getServletContext().getAttribute(\"AdvSearchDAO\");\n        request.getSession().setAttribute(\"prekeywords\", null);\n        SearchResultBean resultBean;\n        // searchType is unused for now...\n        String searchType = request.getParameter(\"searchtype\");\n        ParameterBean param = new ParameterBean();\n        String columInfo;\n        String keyWord = \"\";\n        String relation;\n        ParameterNode pam;\n        param.setHidden(false);\n        String type;\n        String input;\n        String logic;\n        boolean validate = true;\n        String keywords = \"\";\n        String[] sourceArray = null;\n        String[] publicationNames = null;\n        String[] primall = { \"all\" };\n        if (searchType == null) {\n            searchType = \"advanced\";\n            publicationNames = request.getParameterValues(\"publicationName\");\n            if ((null != publicationNames) && (!\"all\".equals(publicationNames[0]))) {\n                param.setPublicationNames(publicationNames);\n            }\n            String[] publicationIds = request.getParameterValues(\"publicationId\");\n            if ((null != publicationIds) && (!\"all\".equals(publicationIds[0]))) {\n                param.setPublicationIds(publicationIds);\n                param.setPrimaryArray(primall);\n            }\n        } else if (searchType.equals(\"collection\")) {\n            sourceArray = request.getParameterValues(\"source\");\n            param.setSourceCollection(sourceArray);\n            param.setPrimaryArray(primall);\n        } else {\n            for (int i = 0; i < 4; i++) {\n                type = \"type\";\n                input = \"input\";\n                logic = \"logic\";\n                columInfo = request.getParameter(type + i);\n                keyWord = request.getParameter(input + i);\n                if (i != 0) {\n                    relation = request.getParameter(logic + i);\n                } else {\n                    relation = \"AND\";\n                }\n                //mapping the terms from the interface to the database tablename and columns\n                if (keyWord.length() > 1) {\n                    keyWord = keyWord.trim();\n                    if (columInfo.compareTo(\"ALL\") == 0) {\n                        columInfo = (\"ALL.ALL\");\n                    } else if (columInfo.compareTo(\"Keyword\") == 0) {\n                        columInfo = (\"Keywords.Keyword\");\n                    } else if (columInfo.compareTo(\"Title\") == 0) {\n                        columInfo = (\"Metadata.Title\");\n                    } else if (columInfo.compareTo(\"metaID\") == 0) {\n                        columInfo = (\"Metadata.MetadataID\");\n                    } else if (columInfo.compareTo(\"Description\") == 0) {\n                        columInfo = (\"Metadata.Description\");\n                    } else if (columInfo.compareTo(\"Contributor\") == 0) {\n                        columInfo = (\"Contributors.vCard\");\n                    } else if (columInfo.compareTo(\"CopyrightHolder\") == 0) {\n                        columInfo = (\"CopyrightHolders.vCard\");\n                    } else //added by Zhen 6/12/08 for Tag cloud search.\n                    if (columInfo.compareTo(\"Tags\") == 0) {\n                        columInfo = (\"Tags.tag\");\n                    }\n                    //switch to lower case\n                    keyWord = keyWord.toLowerCase();\n                    StringBuffer bf = new StringBuffer();\n                    char[] origQuery = keyWord.toCharArray();\n                    int paranthesisCount = 0;\n                    int pos = 0;\n                    for (int t = 0; t < origQuery.length; t++) {\n                        if (origQuery[t] == '(' || origQuery[t] == ')') {\n                            if (//if \")(\" happens, change to \") and (\"\n                            origQuery[t] == '(') {\n                                if (bf.length() >= 2 && bf.charAt(bf.length() - 2) == ')') {\n                                    bf.append(\"and \" + origQuery[t] + \" \");\n                                    paranthesisCount++;\n                                } else {\n                                    bf.append(\" \" + origQuery[t] + \" \");\n                                    paranthesisCount++;\n                                }\n                            } else if (//if \"( )\" happens, remove the segment\n                            origQuery[t] == ')') {\n                                pos = bf.length() - 1;\n                                while (//need to get to the last character\n                                bf.charAt(pos) == ' ' && pos > 0) {\n                                    pos--;\n                                }\n                                if (bf.charAt(pos) == '(') {\n                                    bf.delete(bf.length() - 3, bf.length() - 1);\n                                    paranthesisCount--;\n                                } else {\n                                    bf.append(\" \" + origQuery[t] + \" \");\n                                    paranthesisCount--;\n                                }\n                            } else\n                                bf.append(\" \" + origQuery[t] + \" \");\n                        } else if (//if \"...\", copy the whole string\n                        origQuery[t] == '\"') {\n                            bf.append(\" \\\" \");\n                            t++;\n                            while (i < origQuery.length && origQuery[t] != '\"') {\n                                bf.append(origQuery[t]);\n                                t++;\n                            }\n                            if (t == origQuery.length) {\n                                validate = false;\n                            }\n                            bf.append(\" \\\" \");\n                        } else if (origQuery[t] == '\\'') {\n                            bf.append(\"\\'\\'\");\n                        } else if (origQuery[t] == ' ' && bf.charAt(bf.length() - 1) == ' ') {\n                        } else\n                            bf.append(origQuery[t]);\n                    }\n                    if (paranthesisCount != 0) {\n                        validate = false;\n                    }\n                    if (validate) {\n                        pam = new ParameterNode(columInfo, bf.toString(), relation);\n                        param.addParameters(pam);\n                    } else {\n                        i = 10;\n                    }\n                } else {\n                    break;\n                }\n            }\n            String[] imagingArray = request.getParameterValues(\"imaging\");\n            if ((imagingArray != null) && (imagingArray[0].compareTo(\"all\")) != 0) {\n                param.setImaging(imagingArray);\n            }\n            String[] diseaseprocessArray = request.getParameterValues(\"diseaseProcess\");\n            if (diseaseprocessArray != null) {\n                if (diseaseprocessArray[0].compareTo(\"all\") != 0) {\n                    param.setDisease(diseaseprocessArray);\n                }\n            }\n            String[] filterStringArray = request.getParameterValues(\"filters\");\n            if ((filterStringArray != null) && (filterStringArray[0].compareTo(\"all\") != 0 && filterStringArray.length < 8)) {\n                param.setFilterArray(filterStringArray);\n            }\n            sourceArray = request.getParameterValues(\"source\");\n            if ((sourceArray != null) && (sourceArray[0].compareTo(\"all\") != 0)) {\n                param.setSourceCollection(sourceArray);\n            }\n            String[] primary = { \"Health Profession Education\", \"Higher Education\" };\n            String[] primaryArray = request.getParameterValues(\"primary\");\n            if ((primaryArray != null)) {\n                if (primaryArray[0].startsWith(\"Health\")) {\n                    param.setPrimaryArray(primary);\n                } else\n                    param.setPrimaryArray(primaryArray);\n            }\n        }\n        try {\n            resultBean = sd.AdvSearch(param);\n            for (int i = 0; i < param.size(); i++) {\n                ParameterNode tempNode = param.getParameters(i);\n                if (i == 0) {\n                    keywords = tempNode.getKeyWord();\n                } else {\n                    keywords = keywords + \" \" + tempNode.getRelation() + \" \" + tempNode.getKeyWord();\n                }\n            }\n            resultBean.setKeywords(keywords);\n            request.getSession().setAttribute(\"searchResults\", resultBean);\n            //NOTE: PAGE MUST BE THE LAST PARAMETER!\n            String queryString = request.getQueryString();\n            request.getSession().setAttribute(\"pams\", queryString);\n            if (queryString == null || queryString.length() == 0) {\n                queryString = \"page=1\";\n            } else {\n                queryString = queryString + \"&page=1\";\n            }\n            String redirectURL = \"searchResults?\" + queryString;\n            response.sendRedirect(redirectURL);\n        } catch (SQLException ex) {\n            //throw new SQLException(ex.toString());\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/AdvSearchActionTest.java",
		"test_prompt": "// AdvSearchActionTest.java\npackage org.heal.servlet.search;\n\nimport org.heal.module.search.AdvSearchDAO;\nimport org.heal.module.search.ParameterBean;\nimport org.heal.module.search.ParameterNode;\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdvSearchAction}.\n* It contains ten unit test cases for the {@link AdvSearchAction#actionRequiresLogin()} method.\n*/\nclass AdvSearchActionTest {"
	},
	{
		"original_code": "// SearchResultsAction.java\npackage org.heal.servlet.search;\n\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport org.heal.util.ParameterMap;\nimport org.heal.util.ResultsPager;\nimport org.heal.servlet.Action;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\n\npublic class SearchResultsAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        SearchResultBean searchResults;\n        searchResults = (SearchResultBean) request.getSession().getAttribute(\"searchResults\");\n        String searchType = request.getParameter(\"searchtype\");\n        String queryString = request.getQueryString();\n        String pagenb = request.getParameter(\"page\");\n        if (queryString == null) {\n            queryString = \"\";\n        }\n        // If there are no search results, redirect to the appropriate search action.\n        // This is here so that, for example, if a user bookmarked a search results page\n        // rather than arriving here through a search, the expected page would be generated\n        if (searchResults == null) {\n            String searchURL = null;\n            if (\"simple\".equalsIgnoreCase(searchType)) {\n                //substring(\"action=display&showpage=Searchresults&\".length());;\n                searchURL = \"search?\" + queryString;\n            } else {\n                searchURL = \"advsearch?\" + queryString;\n            }\n            response.sendRedirect(searchURL);\n            return;\n        }\n        // page specifies the page we are looking at, defaultly page 1\n        int displayPage = getParameterAsInteger(request, \"page\", 1);\n        // display specifies how many items are being displayed per page, defaultly 25\n        int displayIncrement = getParameterAsInteger(request, \"display\", 25);\n        //**** BEGIN code to calculate displayStart and displayStop\n        int displayStart = (displayPage - 1) * displayIncrement;\n        int displayStop = 0;\n        ShortMetadataResultBean[] allMetadata = null;\n        if (searchResults != null) {\n            allMetadata = searchResults.getShortRecords();\n        }\n        if (allMetadata != null) {\n            displayStop = displayStart + displayIncrement;\n            if (displayStop > allMetadata.length) {\n                displayStop = allMetadata.length;\n            }\n        }\n        //**** END code to calculate displayStart and displayStop\n        request.setAttribute(\"displayStart\", \"\" + displayStart);\n        request.setAttribute(\"displayStop\", \"\" + displayStop);\n        ParameterMap parameters = new ParameterMap(request.getParameterMap());\n        // If they're changing the display size, we must reset the page\n        parameters.remove(\"page\");\n        // Disregarding what \"display\" value may be in the current parameters\n        // map, we put in \"10\" and construct a new query string to represent\n        // the original query string with a \"display\" of \"10\"\n        parameters.put(\"display\", \"10\");\n        parameters.put(\"page\", pagenb);\n        request.setAttribute(\"displayString10\", \"searchResults?\" + parameters.toString());\n        // Disregarding what \"display\" value may be in the current parameters\n        // map, we put in \"25\" and construct a new query string to represent\n        // the original query string with a \"display\" of \"25\"\n        parameters.put(\"display\", \"25\");\n        parameters.put(\"page\", pagenb);\n        request.setAttribute(\"displayString25\", \"searchResults?\" + parameters.toString());\n        // Disregarding what \"display\" value may be in the current parameters\n        // map, we put in \"50\" and construct a new query string to represent\n        // the original query string with a \"display\" of \"50\"\n        parameters.put(\"display\", \"50\");\n        parameters.put(\"page\", pagenb);\n        request.setAttribute(\"displayString50\", \"searchResults?\" + parameters.toString());\n        // The \"searchURL\" is the original URL with only the search-specific\n        // parameters in the query string with the addition of the \"display\" parameter.\n        // This is used in creating the links to different pages of search results.\n        parameters = new ParameterMap(request.getParameterMap());\n        parameters.remove(\"page\");\n        request.setAttribute(\"searchURL\", \"searchResults?\" + parameters.toString());\n        ParameterMap parameterv = new ParameterMap(request.getParameterMap());\n        // If they're changing the display format, we must reset the page\n        parameterv.remove(\"page\");\n        // Disregarding what \"display\" format may be in the current parameters\n        // map, we put in \"1\" and construct a new query string to represent\n        // the original query string with a \"viewtype\" of \"1\"\n        parameterv.put(\"viewtype\", \"1\");\n        parameterv.put(\"page\", pagenb);\n        request.setAttribute(\"view1\", \"searchResults?\" + parameterv.toString());\n        // Disregarding what \"display\" format may be in the current parameters\n        // map, we put in \"2\" and construct a new query string to represent\n        // the original query string with a \"viewtype\" of \"2\"\n        parameterv.put(\"viewtype\", \"2\");\n        parameterv.put(\"page\", pagenb);\n        request.setAttribute(\"view2\", \"searchResults?\" + parameterv.toString());\n        // Disregarding what \"display\" value may be in the current parameters\n        // map, we put in \"3\" and construct a new query string to represent\n        // the original query string with a \"viewtype\" of \"3\"\n        parameterv.put(\"viewtype\", \"3\");\n        parameterv.put(\"page\", pagenb);\n        request.setAttribute(\"view3\", \"searchResults?\" + parameterv.toString());\n        // The \"searchURL\" is the original URL with only the search-specific\n        // parameters in the query string with the addition of the \"display\" parameter.\n        // This is used in creating the links to different pages of search results.\n        parameterv = new ParameterMap(request.getParameterMap());\n        parameterv.remove(\"page\");\n        request.setAttribute(\"searchURL\", \"searchResults?\" + parameterv.toString());\n        ParameterMap parametert = new ParameterMap(request.getParameterMap());\n        // If they're sorting the display result, we must reset the page\n        parametert.remove(\"page\");\n        // Disregarding what \"sort\" value may be in the current parameters\n        // map, we put in \"sortFormat\" and construct a new query string to represent\n        // the original query string with a \"sort\" by \"Format\"\n        parametert.put(\"sortby\", \"Title\");\n        parametert.put(\"page\", pagenb);\n        request.setAttribute(\"sortTitle\", \"sortResults?\" + parametert.toString());\n        parametert.put(\"sortby\", \"Format\");\n        parametert.put(\"page\", pagenb);\n        request.setAttribute(\"sortFormat\", \"sortResults?\" + parametert.toString());\n        // Disregarding what \"sort\" value may be in the current parameters\n        // map, we put in \"sortScollect\" and construct a new query string to represent\n        // the original query string with a \"sort\" by \"Source Collection\"\n        parametert.put(\"sortby\", \"SourceCollection\");\n        parametert.put(\"page\", pagenb);\n        request.setAttribute(\"sortScollect\", \"sortResults?\" + parametert.toString());\n        // Disregarding what \"sort\" value may be in the current parameters\n        // map, we put in \"sortSize\" and construct a new query string to represent\n        // the original query string with a \"sort\" by \"File Size\"\n        parametert.put(\"sortby\", \"FileSize\");\n        parametert.put(\"page\", pagenb);\n        request.setAttribute(\"sortSize\", \"sortResults?\" + parametert.toString());\n        // The \"searchURL\" is the original URL with only the search-specific\n        // parameters in the query string with the addition of the \"display\" parameter.\n        // This is used in creating the links to different pages of search results.\n        parametert = new ParameterMap(request.getParameterMap());\n        parametert.remove(\"page\");\n        request.setAttribute(\"searchURL\", \"searchResults?\" + parametert.toString());\n        request.setAttribute(\"origURL\", \"searchResults?\" + queryString);\n        if (allMetadata != null) {\n            ResultsPager pager = new org.heal.util.ResultsPager(allMetadata.length, displayIncrement, displayPage);\n            request.setAttribute(\"pager\", pager);\n        }\n        String metadataId;\n        ShortMetadataBean currentMeta;\n        MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        InterfaceUtilitiesBean interfaceUtilities = (InterfaceUtilitiesBean) servlet.getServletContext().getAttribute(\"interfaceUtilities\");\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        for (int i = displayStart; i < displayStop; i++) {\n            metadataId = allMetadata[i].getMetadataId();\n            currentMeta = allMetadata[i].getShortMetadata();\n            if (currentMeta == null) {\n                try {\n                    currentMeta = metadataServices.getShortMetadata(metadataId);\n                } catch (SQLException e) {\n                    System.err.println(e);\n                }\n                String format = currentMeta.getFormat();\n                if (format == null) {\n                    format = \"unknown\";\n                }\n                ThumbnailBean thumbnail = interfaceUtilities.getThumbnail(currentMeta.getThumbnail(), format, \"../\");\n                //}\n                currentMeta.setThumbnail(thumbnail);\n                currentMeta.setLocation(healFileLocator.getContentURL(currentMeta.getLocation()));\n                currentMeta.setDescription(interfaceUtilities.getAbbreviatedString(currentMeta.getDescription(), 100));\n                currentMeta.setFileSize(NumberFormat.getInstance().format(Long.parseLong(currentMeta.getFileSize())));\n                allMetadata[i].setShortMetadata(currentMeta);\n            }\n        }\n        // If the original query string is missing a parameter we add\n        // the parameter's default value before passing on the query\n        String queryStringWithDefaults;\n        ParameterMap parameter = new ParameterMap(request.getParameterMap());\n        if (!parameter.containsKey(\"display\")) {\n            // The default \"display\" is \"25\"\n            parameter.put(\"display\", \"25\");\n        }\n        if (!parameter.containsKey(\"page\")) {\n            // The default \"page\" is \"1\"\n            parameter.put(\"page\", \"1\");\n        }\n        if (!parameter.containsKey(\"viewtype\")) {\n            // The default \"view\" is \"1\"\n            parameter.put(\"viewtype\", \"1\");\n        }\n        if (!parameter.containsKey(\"sortby\")) {\n            // The default \"sort\" is \"Title\"\n            parameter.put(\"sortby\", \"Title\");\n        }\n        queryStringWithDefaults = parameter.toString();\n        String forwardURL = null;\n        forwardURL = \"/search/searchresults.jsp?\" + queryStringWithDefaults;\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(forwardURL);\n        rd.forward(request, response);\n        return;\n    }\n\n    private int getParameterAsInteger(final HttpServletRequest request, final String paramName, final int defaultValue) {\n        int ret = defaultValue;\n        String parameter = request.getParameter(paramName);\n        if (parameter != null && parameter.length() != 0) {\n            try {\n                ret = Integer.parseInt(parameter);\n            }// does nothing, so the defaultValue will be returned\n             catch (NumberFormatException e) {\n            }\n        }\n        return ret;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/SearchResultsActionTest.java",
		"test_prompt": "// SearchResultsActionTest.java\npackage org.heal.servlet.search;\n\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport org.heal.util.ParameterMap;\nimport org.heal.util.ResultsPager;\nimport org.heal.servlet.Action;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultsAction}.\n* It contains ten unit test cases for the {@link SearchResultsAction#actionRequiresLogin()} method.\n*/\nclass SearchResultsActionTest {"
	},
	{
		"original_code": "// SimpleSearchAction.java\npackage org.heal.servlet.search;\n\nimport org.heal.module.search.ParameterBean;\nimport org.heal.module.search.ParameterNode;\nimport org.heal.module.search.SearchResultBean;\n//import org.heal.module.search.ConceptMappingBean;\nimport org.heal.module.search.SimpleSearchDAO;\n//import org.heal.module.search.ConceptMappingDAO;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class SimpleSearchAction implements Action {\n\n    public SimpleSearchAction() {\n    }\n\n    /**\n     * @param servlet\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        SimpleSearchDAO sd = (SimpleSearchDAO) servlet.getServletContext().getAttribute(\"SimpleSearchDAO\");\n        // ConceptMappingDAO cd = (ConceptMappingDAO) servlet.getServletContext().getAttribute(\"ConceptMappingDAO\");\n        request.getSession().setAttribute(\"prekeywords\", null);\n        String consumer = request.getParameter(\"consumer\");\n        String keywordString = request.getParameter(\"keywords\");\n        String peir = request.getParameter(\"peir\");\n        String searchType = request.getParameter(\"searchtype\");\n        String keywords = \"\";\n        ParameterBean param = new ParameterBean(keywordString);\n        if (peir == null) {\n            param.setUsageRights(null);\n            ;\n        } else {\n            param.setUsageRights(\"PEIR\");\n            ;\n        }\n        request.getSession().setAttribute(\"searchResults\", null);\n        // request.getSession().setAttribute(\"conceptMapping\", null);\n        SearchResultBean resultBean = new SearchResultBean();\n        // ConceptMappingBean cmb = new ConceptMappingBean();\n        try {\n            if (keywordString != null) {\n                resultBean = sd.simpleSearch(param, consumer);\n                //  cmb = cd.ConceptMapping(keywordString);\n                for (int i = 0; i < param.size(); i++) {\n                    ParameterNode tempNode = param.getParameters(i);\n                    if (i == 0) {\n                        keywords = tempNode.getKeyWord();\n                    } else {\n                        keywords = keywords + \" \" + tempNode.getRelation() + \" \" + tempNode.getKeyWord();\n                    }\n                }\n                resultBean.setKeywords(keywords);\n                request.getSession().setAttribute(\"searchResults\", resultBean);\n                // request.getSession().setAttribute(\"conceptMapping\", cmb);\n            }\n            if (resultBean == null)\n                System.err.println(\"rb is null\");\n            //NOTE: PAGE MUST BE THE LAST PARAMETER!\n            String queryString = request.getQueryString();\n            if (queryString == null || queryString.length() == 0) {\n                queryString = \"page=1\";\n            } else {\n                queryString = queryString + \"&page=1\";\n            }\n            String redirectURL = \"searchResults?\" + queryString;\n            response.sendRedirect(redirectURL);\n        } catch (SQLException ex) {\n            //throw new SQLException(ex.toString());\n        }\n    }\n\n    /**\n     * @return\n     */\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/SimpleSearchActionTest.java",
		"test_prompt": "// SimpleSearchActionTest.java\npackage org.heal.servlet.search;\n\nimport org.heal.module.search.ParameterBean;\nimport org.heal.module.search.ParameterNode;\nimport org.heal.module.search.SearchResultBean;\n//import org.heal.module.search.ConceptMappingBean;\nimport org.heal.module.search.SimpleSearchDAO;\n//import org.heal.module.search.ConceptMappingDAO;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSearchAction}.\n* It contains ten unit test cases for the {@link SimpleSearchAction#actionRequiresLogin()} method.\n*/\nclass SimpleSearchActionTest {"
	},
	{
		"original_code": "// SortResultsAction.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.servlet.Action;\nimport org.heal.module.search.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class SortResultsAction implements Action {\n\n    public SortResultsAction() {\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String metaids = null;\n        ReSearchDAO sd = (ReSearchDAO) servlet.getServletContext().getAttribute(\"ReSearchDAO\");\n        List metaIDs = (List) request.getSession().getAttribute(\"metaids\");\n        String queryString = request.getQueryString();\n        String kwds = request.getParameter(\"keywords\");\n        String redirectURL = null;\n        //System.out.print(\"metaIDs\"+metaIDs);\n        if (metaIDs != null) {\n            metaids = sd.makeInString(metaIDs);\n            request.getSession().setAttribute(\"sortString\", metaids);\n            //System.out.print(metaids);\n        } else {\n            metaids = (String) request.getSession().getAttribute(\"sortString\");\n            //  System.out.print(metaids);\n        }\n        String sortterm = request.getParameter(\"sortby\");\n        SearchResultBean resultBean = new SearchResultBean();\n        try {\n            //  if(sortterm.equals(\"Relevance\"))\n            //  {\n            //    redirectURL = \"http://157.142.98.192/healnew/search/relevance.html\";\n            //    response.sendRedirect(redirectURL);\n            //  }\n            //  else\n            //  {\n            //filter hidden\n            resultBean = sd.sortResult(sortterm, metaids);\n            resultBean.setKeywords(kwds);\n            request.getSession().setAttribute(\"searchResults\", resultBean);\n            if (resultBean == null)\n                System.err.println(\"rb is null\");\n            if (queryString == null || queryString.length() == 0) {\n                queryString = \"page=1\";\n            }\n            // else\n            // {\n            //   queryString = queryString + \"&page=1\";\n            //  }\n            redirectURL = \"searchResults?\" + queryString;\n            response.sendRedirect(redirectURL);\n            // }\n        } catch (SQLException ex) {\n            //throw new SQLException(ex.toString());\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/SortResultsActionTest.java",
		"test_prompt": "// SortResultsActionTest.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.servlet.Action;\nimport org.heal.module.search.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SortResultsAction}.\n* It contains ten unit test cases for the {@link SortResultsAction#actionRequiresLogin()} method.\n*/\nclass SortResultsActionTest {"
	},
	{
		"original_code": "// VarSearchAction.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport org.heal.servlet.Action;\nimport org.heal.module.search.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class VarSearchAction implements Action {\n\n    public VarSearchAction() {\n    }\n\n    /**\n     * @param servlet\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        SimpleSearchDAO sd = (SimpleSearchDAO) servlet.getServletContext().getAttribute(\"SimpleSearchDAO\");\n        String prek = request.getParameter(\"prekeywords\");\n        String[] keywordArray = request.getParameterValues(\"keywords\");\n        ParameterBean param = new ParameterBean();\n        ParameterNode pam = new ParameterNode();\n        String keywords = \"\";\n        boolean stype = true;\n        if (keywordArray == null) {\n            keywordArray[0] = \"%\";\n            //System.out.print(keywordString);\n        }\n        String relation = null;\n        //dummy variable\n        String columInfo = \"ALL.ALL\";\n        param.setHidden(false);\n        //mapping the terms from the interface to the database tablename and columns\n        String key = null;\n        for (int i = 0; i < keywordArray.length; i++) {\n            key = keywordArray[i];\n            //switch to lower case\n            key = key.toLowerCase();\n            key = key.replaceAll(\"\\'\", \"\\'\\'\");\n            if (i == 0) {\n                relation = \"AND\";\n            } else {\n                relation = \"OR\";\n            }\n            pam = new ParameterNode(columInfo, key, relation, stype);\n            param.addParameters(pam);\n        }\n        for (int i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            if (i == 0) {\n                keywords = tempNode.getKeyWord();\n            } else {\n                keywords = keywords + \" \" + tempNode.getRelation() + \" \" + tempNode.getKeyWord();\n            }\n        }\n        request.getSession().setAttribute(\"variants\", keywords);\n        request.getSession().setAttribute(\"searchResults\", null);\n        SearchResultBean resultBean = new SearchResultBean();\n        try {\n            if (keywordArray != null) {\n                resultBean = sd.simpleSearch(param, \"check\");\n                resultBean.setKeywords(prek);\n                System.out.print(\"*****\" + prek);\n                request.getSession().setAttribute(\"searchResults\", resultBean);\n            }\n            if (resultBean == null)\n                System.err.println(\"rb is null\");\n            //NOTE: PAGE MUST BE THE LAST PARAMETER!\n            String queryString = request.getQueryString();\n            if (queryString == null || queryString.length() == 0) {\n                queryString = \"page=1\";\n            } else {\n                queryString = queryString + \"&page=1\";\n            }\n            String redirectURL = \"searchResults?\" + queryString;\n            response.sendRedirect(redirectURL);\n        } catch (SQLException ex) {\n            //throw new SQLException(ex.toString());\n        }\n    }\n\n    /**\n     * @return\n     */\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/VarSearchActionTest.java",
		"test_prompt": "// VarSearchActionTest.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport org.heal.servlet.Action;\nimport org.heal.module.search.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VarSearchAction}.\n* It contains ten unit test cases for the {@link VarSearchAction#actionRequiresLogin()} method.\n*/\nclass VarSearchActionTest {"
	},
	{
		"original_code": "// ResearchAction.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.module.search.*;\nimport org.heal.servlet.Action;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class ResearchAction implements Action {\n\n    public ResearchAction() {\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        List metaIDs = null;\n        String metaids = null;\n        SearchResultBean resultBean = new SearchResultBean();\n        ReSearchDAO sd = (ReSearchDAO) servlet.getServletContext().getAttribute(\"ReSearchDAO\");\n        String checker = request.getParameter(\"check\");\n        String keywordString = request.getParameter(\"keywords\");\n        String searchtype = request.getParameter(\"selecttype\");\n        // String pagenb = request.getParameter(\"page\");\n        if (checker != null) {\n            metaIDs = (List) request.getSession().getAttribute(\"metaids\");\n            // System.out.print(\"step2:\"+metaIDs);\n            metaids = sd.makeInString(metaIDs);\n            /* Tracking previous search words\n      String prewords = request.getParameter(\"prekeywords\");\n      \n      String prekeywords =(String)request.getSession().getAttribute(\"prekeywords\");\n      if(prekeywords != null) \n      {     \n          prekeywords = prekeywords+\" AND \"+prewords;       \n      }\n      else \n      {\n        prekeywords =prewords;\n      }\n      request.getSession().setAttribute(\"prekeywords\",prekeywords);  \n      */\n        } else {\n            metaids = \"no\";\n            //  request.getSession().setAttribute(\"prekeywords\",null);\n        }\n        if (keywordString == null) {\n            keywordString = \"%\";\n        } else if (keywordString != null && keywordString.length() == 0) {\n            keywordString = \"%\";\n        } else {\n            //control apostrophes search in database\n            char ch = 39;\n            String nch = \"''\";\n            String och = null;\n            och = Character.toString(ch);\n            keywordString = keywordString.toLowerCase();\n            keywordString = keywordString.replaceAll(och, nch);\n            keywordString = keywordString.replace('\"', '%');\n            keywordString = keywordString.replaceAll(\" and \", \" \");\n            keywordString = keywordString.replaceAll(\" or \", \" \");\n        }\n        request.getSession().setAttribute(\"searchResults\", null);\n        String[] filterStringArray = request.getParameterValues(\"filters\");\n        if ((filterStringArray != null) && (filterStringArray[0].equals(\"all\")))\n            filterStringArray = null;\n        try {\n            if (keywordString != null) {\n                //filter hidden\n                resultBean = sd.editSearch(metaids, keywordString, filterStringArray, searchtype, false);\n                // System.out.print(\"\\nID\"+metaids);\n                List keys = new ArrayList();\n                String keywords = \"\";\n                StringTokenizer tokenizer = new StringTokenizer(keywordString, \" \");\n                while (tokenizer.hasMoreTokens()) {\n                    keys.add(tokenizer.nextToken());\n                }\n                for (int i = 0; i < keys.size(); i++) {\n                    if (i == 0) {\n                        keywords = (String) keys.get(0);\n                    } else {\n                        if (searchtype.equals(\"All\")) {\n                            keywords = keywords + \" AND \" + (String) keys.get(i);\n                        }\n                        if (searchtype.equals(\"Any\")) {\n                            keywords = keywords + \" OR \" + (String) keys.get(i);\n                        }\n                        if (searchtype.equals(\"Exact\")) {\n                            keywords = keywords + \" \" + (String) keys.get(i);\n                        }\n                    }\n                }\n                resultBean.setKeywords(keywords);\n                request.getSession().setAttribute(\"searchResults\", resultBean);\n            }\n            if (resultBean == null)\n                System.err.println(\"rb is null\");\n            //NOTE: PAGE MUST BE THE LAST PARAMETER!\n            String queryString = request.getQueryString();\n            if (queryString == null || queryString.length() == 0) {\n                queryString = \"page=1\";\n            } else {\n                queryString = queryString + \"&page=1\";\n            }\n            String redirectURL = \"searchResults?\" + queryString;\n            response.sendRedirect(redirectURL);\n        } catch (SQLException ex) {\n            //throw new SQLException(ex.toString());\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/ResearchActionTest.java",
		"test_prompt": "// ResearchActionTest.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.module.search.*;\nimport org.heal.servlet.Action;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResearchAction}.\n* It contains ten unit test cases for the {@link ResearchAction#actionRequiresLogin()} method.\n*/\nclass ResearchActionTest {"
	},
	{
		"original_code": "// RefineSearchAction.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.user.UserBean;\nimport org.heal.util.*;\nimport com.ora.jsp.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\nimport javax.sql.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class RefineSearchAction implements Action {\n\n    public RefineSearchAction() {\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String redirectURL = null;\n        redirectURL = request.getParameter(\"pam\");\n        // System.out.println(\"URL:\"+redirectURL);\n        response.sendRedirect(redirectURL);\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/search/RefineSearchActionTest.java",
		"test_prompt": "// RefineSearchActionTest.java\npackage org.heal.servlet.search;\n\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.user.UserBean;\nimport org.heal.util.*;\nimport com.ora.jsp.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.sql.*;\nimport javax.sql.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RefineSearchAction}.\n* It contains ten unit test cases for the {@link RefineSearchAction#actionRequiresLogin()} method.\n*/\nclass RefineSearchActionTest {"
	},
	{
		"original_code": "// BrowseAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.browse.BrowseDAO;\nimport org.heal.module.browse.BrowseResultsBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport org.heal.util.ParameterMap;\nimport org.heal.util.ResultsPager;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\n\n/**\n * This {@link Action} handles the browse request\n *\n * @author Jason Varghese\n * @modify Brad Schaefer\n */\npublic class BrowseAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        try {\n            BrowseDAO browseServices = (BrowseDAO) servlet.getServletContext().getAttribute(\"browseDAO\");\n            String pid = request.getParameter(\"pid\");\n            Vector categories;\n            Vector trail;\n            Vector results;\n            BrowseResultsBean browseResultsBean;\n            browseResultsBean = (BrowseResultsBean) request.getSession().getAttribute(\"results\");\n            MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n            if (pid == null || pid.length() < 1) {\n                pid = \"0\";\n            }\n            if ((browseResultsBean != null) && (browseResultsBean.getId().equals(pid))) {\n                trail = browseResultsBean.getTrail();\n                categories = browseResultsBean.getSubCategories();\n                results = browseResultsBean.getResultsId();\n            } else {\n                trail = browseServices.getTrail(pid);\n                categories = browseServices.getChildrenCategories(pid);\n                results = browseServices.doBrowse(pid);\n                if (trail == null) {\n                    trail = new Vector();\n                }\n                request.getSession().removeAttribute(\"results\");\n                browseResultsBean = new BrowseResultsBean();\n                browseResultsBean.setTrail(trail);\n                browseResultsBean.setId(pid);\n                browseResultsBean.setSubCategories(categories);\n                browseResultsBean.setResultsId(results);\n                request.getSession().setAttribute(\"results\", browseResultsBean);\n            }\n            final int currentSection = getParameterAsInteger(request, \"currentSection\", 0);\n            // display specifies how many items are being displayed per page, defaultly 25\n            final int displayIncrement = getParameterAsInteger(request, \"display\", 25);\n            final int previousSection = currentSection - 1;\n            int nextSection = currentSection + 1;\n            final int lowerbound = currentSection * displayIncrement;\n            int upperbound = nextSection * displayIncrement;\n            if (upperbound > results.size()) {\n                upperbound = results.size();\n                nextSection = -1;\n            }\n            Vector smbs = null;\n            if ((results != null) && (results.size() > 0)) {\n                smbs = new Vector();\n                InterfaceUtilitiesBean interfaceUtilities = (InterfaceUtilitiesBean) servlet.getServletContext().getAttribute(\"interfaceUtilities\");\n                FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n                for (int b = lowerbound; b < upperbound; b++) {\n                    final String id = (String) results.get(b);\n                    if (id != null) {\n                        final ShortMetadataBean smb = metadataServices.getShortMetadata(id);\n                        String temp = smb.getDescription();\n                        if (temp != null && temp.length() > 0) {\n                            final int limit = (100 > temp.length() ? temp.length() : 100);\n                            smb.setDescription(temp.substring(0, limit));\n                        }\n                        ThumbnailBean tbean = interfaceUtilities.getThumbnail(smb.getThumbnail(), smb.getFormat(), \"../\");\n                        smb.setThumbnail(tbean);\n                        smb.setLocation(healFileLocator.getContentURL(smb.getLocation()));\n                        smbs.add(smb);\n                    }\n                }\n            }\n            // page specifies the page we are looking at, defaultly page 1\n            final int displayPage = getParameterAsInteger(request, \"page\", 1);\n            final String pagenb = String.valueOf(displayPage);\n            ResultsPager pager = new ResultsPager(results.size(), displayIncrement, displayPage);\n            request.setAttribute(\"pager\", pager);\n            //**** BEGIN code to calculate displayStart and displayStop\n            int displayStart = (displayPage - 1) * displayIncrement;\n            int displayStop = 0;\n            if (results != null) {\n                displayStop = displayStart + displayIncrement;\n                if (displayStop > results.size()) {\n                    displayStop = results.size();\n                }\n            }\n            //**** END code to calculate displayStart and displayStop\n            request.setAttribute(\"displayStart\", String.valueOf(displayStart));\n            request.setAttribute(\"displayStop\", String.valueOf(displayStop));\n            {\n                ParameterMap parameters = new ParameterMap(request.getParameterMap());\n                // If they're changing the display size, we must reset the page\n                parameters.remove(\"page\");\n                // Disregarding what \"display\" value may be in the current parameters\n                // map, we put in \"25\" and construct a new query string to represent\n                // the original query string with a \"display\" of \"25\"\n                parameters.put(\"display\", \"10\");\n                parameters.put(\"page\", pagenb);\n                request.setAttribute(\"displayString10\", \"browse?\" + parameters.toString());\n                // Disregarding what \"display\" value may be in the current parameters\n                // map, we put in \"25\" and construct a new query string to represent\n                // the original query string with a \"display\" of \"25\"\n                parameters.put(\"display\", \"25\");\n                parameters.put(\"page\", pagenb);\n                request.setAttribute(\"displayString25\", \"browse?\" + parameters.toString());\n                // Disregarding what \"display\" value may be in the current parameters\n                // map, we put in \"100\" and construct a new query string to represent\n                // the original query string with a \"display\" of \"100\"\n                parameters.put(\"display\", \"50\");\n                parameters.put(\"page\", pagenb);\n                request.setAttribute(\"displayString50\", \"browse?\" + parameters.toString());\n            }\n            String origURL = \"../healapp/browse?\" + request.getQueryString();\n            request.setAttribute(\"origURL\", origURL);\n            request.setAttribute(\"startNumber\", String.valueOf(lowerbound + 1));\n            request.setAttribute(\"smbs\", smbs);\n            request.setAttribute(\"trail\", trail);\n            request.setAttribute(\"categories\", categories);\n            request.setAttribute(\"pid\", pid);\n            if (previousSection >= 0) {\n                request.setAttribute(\"previousSection\", Integer.toString(previousSection));\n            }\n            if (currentSection >= 0) {\n                request.setAttribute(\"currentSection\", Integer.toString(currentSection));\n            }\n            if (nextSection >= 0) {\n                request.setAttribute(\"nextSection\", Integer.toString(nextSection));\n            }\n            RequestDispatcher rd;\n            rd = request.getRequestDispatcher(\"/browse/browse2.jsp\");\n            rd.forward(request, response);\n        } catch (SQLException ex) {\n        }\n    }\n\n    private int getParameterAsInteger(final HttpServletRequest request, final String paramName, final int defaultValue) {\n        int ret = defaultValue;\n        String parameter = request.getParameter(paramName);\n        if (parameter != null && parameter.length() != 0) {\n            try {\n                ret = Integer.parseInt(parameter);\n            } catch (NumberFormatException e) {\n            }\n            // does nothing, so the defaultValue will be returned\n        }\n        return ret;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/BrowseActionTest.java",
		"test_prompt": "// BrowseActionTest.java\npackage org.heal.servlet;\n\nimport org.heal.module.browse.BrowseDAO;\nimport org.heal.module.browse.BrowseResultsBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport org.heal.util.ParameterMap;\nimport org.heal.util.ResultsPager;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BrowseAction}.\n* It contains ten unit test cases for the {@link BrowseAction#actionRequiresLogin()} method.\n*/\nclass BrowseActionTest {"
	},
	{
		"original_code": "// MetametadataIdentifierRecordModifier.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Saves changes to a {@link MetametadataIdentifierBean}.\n */\npublic class MetametadataIdentifierRecordModifier implements Action, MetadataModifier {\n\n    private static final Action NEXT_ACTION = new EditMetadataAction();\n\n    public void updateMetadata(CompleteMetadataBean cmb, ServletRequest request) {\n        final String mmIdentifierId = request.getParameter(\"metametadataIdentifierId\");\n        final String catalogue = request.getParameter(\"catalogue\");\n        final String entry = request.getParameter(\"entry\");\n        final String metadataSchema = request.getParameter(\"metadataSchema\");\n        MetametadataIdentifierBean mib = null;\n        int lowestMetametadataIdentifierId = 0;\n        for (Object o : cmb.getMetametadataIdentifiers()) {\n            MetametadataIdentifierBean temp = (MetametadataIdentifierBean) o;\n            String idStr = temp.getMetametadataIdentifierId();\n            int id = Integer.parseInt(idStr);\n            if (idStr.equals(mmIdentifierId)) {\n                mib = temp;\n                break;\n            }\n            // We must find the lowest metametadata identifier id for cases\n            // where this is a new metametadata identifier object, and we must\n            // generate a unique id for it (which we define to be\n            // negative numbers for metametadata identifiers not in the\n            // database yet).\n            if (id < lowestMetametadataIdentifierId) {\n                lowestMetametadataIdentifierId = id;\n            }\n        }\n        if (null == mib) {\n            // No existing metametadata identifier was found, so we must\n            // create one with a unique id and add it to the CompleteMetadataBean\n            mib = new MetametadataIdentifierBean();\n            mib.setMetametadataIdentifierId(String.valueOf(lowestMetametadataIdentifierId - 1));\n            cmb.getMetametadataIdentifiers().add(mib);\n        }\n        mib.setCatalog(catalogue);\n        mib.setEntry(entry);\n        mib.setMetadataSchema(metadataSchema);\n    }\n\n    public Action getNextAction(ServletRequest request) {\n        return NEXT_ACTION;\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        MetametadataIdentifierBean mmIdentifierToEdit = new MetametadataIdentifierBean();\n        for (Object o : cmb.getMetametadataIdentifiers()) {\n            MetametadataIdentifierBean temp = (MetametadataIdentifierBean) o;\n            if (selectedId.equals(temp.getMetametadataIdentifierId())) {\n                mmIdentifierToEdit = temp;\n                break;\n            }\n        }\n        request.setAttribute(\"MetametadataIdentifierBean\", mmIdentifierToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editMetametadataIdentifier.jsp\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/MetametadataIdentifierRecordModifierTest.java",
		"test_prompt": "// MetametadataIdentifierRecordModifierTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetametadataIdentifierRecordModifier}.\n* It contains ten unit test cases for the {@link MetametadataIdentifierRecordModifier#actionRequiresLogin()} method.\n*/\nclass MetametadataIdentifierRecordModifierTest {"
	},
	{
		"original_code": "// EditContextURLAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Context URL.  If\n * there isn't an existing Context URL which can be found to edit,\n * we assume that a new Context URL should be edited.\n */\npublic class EditContextURLAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        ContextURLBean cubToEdit = new ContextURLBean();\n        for (Iterator iter = cmb.getContextURLs().iterator(); iter.hasNext(); ) {\n            ContextURLBean testCub = (ContextURLBean) iter.next();\n            if (testCub.getContextURLId().equals(selectedId)) {\n                cubToEdit = testCub;\n                break;\n            }\n        }\n        request.setAttribute(\"ContextURLBean\", cubToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editContextURL.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/EditContextURLActionTest.java",
		"test_prompt": "// EditContextURLActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditContextURLAction}.\n* It contains ten unit test cases for the {@link EditContextURLAction#actionRequiresLogin()} method.\n*/\nclass EditContextURLActionTest {"
	},
	{
		"original_code": "// ModifyMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * <p>An {@link Action} that saves the metadata from a form into\n * the session's {@link CompleteMetadataBean} by mapping {@link MetadataModifier}s\n * to forms.  The {@link MetadataModifier} which matches the form determines\n * the next {@link Action} to execute.</p>\n *\n * <p>The mapping is currently defined as:</p>\n *\n * <ul><li>'metadata' : {@link MetadataRecordModifier}\n * <li>'contextURL' : {@link ContextURLRecordModifier}\n * <li>'contributor' : {@link ContributorRecordModifier}\n * <li>'copyrightHolder' : {@link CopyrightHolderRecordModifier}\n * <li>'controlledVocabulary' : {@link ControlledVocabularyRecordModifier}\n * <li>'requirement' : {@link RequirementRecordModifier}\n * </ul>\n */\npublic class ModifyMetadataAction implements Action {\n\n    private final Map modifierMap;\n\n    public ModifyMetadataAction() {\n        // Initializes the action map\n        Map modifierMap = new HashMap();\n        modifierMap.put(\"metadata\", new MetadataRecordModifier());\n        modifierMap.put(\"contextURL\", new ContextURLRecordModifier());\n        modifierMap.put(\"contributor\", new ContributorRecordModifier());\n        modifierMap.put(\"copyrightHolder\", new CopyrightHolderRecordModifier());\n        modifierMap.put(\"controlledVocabulary\", new ControlledVocabularyRecordModifier());\n        modifierMap.put(\"requirement\", new RequirementRecordModifier());\n        modifierMap.put(\"relation\", new RelationRecordModifier());\n        modifierMap.put(\"metametadataIdentifier\", new MetametadataIdentifierRecordModifier());\n        modifierMap.put(\"metametadataContributor\", new MetametadataContributorRecordModifier());\n        // This guarantees that the action map will not be modified after initialization\n        this.modifierMap = Collections.unmodifiableMap(modifierMap);\n    }\n\n    /**\n     * <p>This perform method uses the <code>\"type\"</code> parameter to save the\n     * metadata modifications from the <code>request</code> in the\n     * {@link CompleteMetadataBean} that is in the session.  If the type or\n     * <code>CompleteMetadataBean</code> doesn't exist, the <code>response</code> is\n     * redirected to an error page.</o>\n     *\n     * <p>When a valid type and a <code>CompleteMetadataBean</code> is available\n     * in the session, this method uses the appropriate {@link MetadataModifier}\n     * to save the motifications to the metadata and to perform the subsequent\n     * {@link Action}.</p>\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String modifierKey = request.getParameter(\"type\");\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        if (null == cmb || !modifierMap.containsKey(modifierKey)) {\n            // Not enough information in the form and/or session to process this request\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final MetadataModifier modifier = (MetadataModifier) modifierMap.get(modifierKey);\n        modifier.updateMetadata(cmb, request);\n        Action nextAction = modifier.getNextAction(request);\n        nextAction.perform(servlet, request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyMetadataActionTest.java",
		"test_prompt": "// ModifyMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyMetadataAction}.\n* It contains ten unit test cases for the {@link ModifyMetadataAction#actionRequiresLogin()} method.\n*/\nclass ModifyMetadataActionTest {"
	},
	{
		"original_code": "// EditRequirementAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.RequirementBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Requirement.  If\n * there isn't an existing Requirement which can be found to edit,\n * we assume that a new Requirement should be edited.\n */\npublic class EditRequirementAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        RequirementBean requirementToEdit = new RequirementBean();\n        for (Iterator iter = cmb.getRequirements().iterator(); iter.hasNext(); ) {\n            RequirementBean rb = (RequirementBean) iter.next();\n            if (selectedId.equals(rb.getRequirementId())) {\n                requirementToEdit = rb;\n                break;\n            }\n        }\n        request.setAttribute(\"RequirementBean\", requirementToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editRequirement.jsp\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/EditRequirementActionTest.java",
		"test_prompt": "// EditRequirementActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.RequirementBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditRequirementAction}.\n* It contains ten unit test cases for the {@link EditRequirementAction#actionRequiresLogin()} method.\n*/\nclass EditRequirementActionTest {"
	},
	{
		"original_code": "// SaveMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Iterator;\n\n/**\n * An {@link org.heal.servlet.Action Action} used to save metadata\n * records.\n */\npublic class SaveMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean metadata = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == metadata) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        // Makes a best effort to prevent the session metadata object from\n        // being changed and then having a stale edit metadata form submitted,\n        // which would save bad data\n        final String metadataId = metadata.getMetadataId();\n        final String formMetadataId = request.getParameter(\"metadataId\");\n        if (!(null == metadataId && 0 == formMetadataId.length()) && !formMetadataId.equals(metadataId)) {\n            request.setAttribute(\"reason\", \"Session metadataId doesn't match metadataId submitted with form.\");\n            RequestDispatcher rd = request.getRequestDispatcher(\"/error/accessDenied.jsp\");\n            rd.forward(request, response);\n            return;\n        }\n        final MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        scrubMetadata(metadata);\n        try {\n            metadataServices.saveEditMetadataForm(metadata);\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        if (null == metadataId) {\n            // This is a new record, so we add it to the approval queue\n            final QueueDAO queueManager = (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n            queueManager.enqueue(QueueDAO.TYPE_APPROVAL, metadata.getMetadataId());\n        }\n        request.getSession().setAttribute(\"metadata\", null);\n        response.sendRedirect(\"showMetadata?metadataId=\" + metadata.getMetadataId());\n    }\n\n    /**\n     * Since we have been using negative numbers to give unique id's to\n     * complicated metadata information, this method will turn all those\n     * negative ids back to <code>null</code> values so that the metadata\n     * gets saved correctly.\n     *\n     * @param cmb The {@link CompleteMetadataBean} to scrub.\n     */\n    private void scrubMetadata(CompleteMetadataBean cmb) {\n        // scrubs Context URLs\n        for (Iterator iter = cmb.getContextURLs().iterator(); iter.hasNext(); ) {\n            final ContextURLBean cub = (ContextURLBean) iter.next();\n            final String cubId = cub.getContextURLId();\n            if (null != cubId && 0 > Integer.parseInt(cubId)) {\n                cub.setContextURLId(null);\n            }\n        }\n        // scrubs Contributors\n        for (Iterator iter = cmb.getContributorList().iterator(); iter.hasNext(); ) {\n            final ContributorBean cb = (ContributorBean) iter.next();\n            final String cbId = cb.getContributorId();\n            if (null != cbId && 0 > Integer.parseInt(cbId)) {\n                cb.setContributorId(null);\n            }\n        }\n        // scrubs Controlled Vocab\n        for (Iterator iterOne = cmb.getTaxonPaths().iterator(); iterOne.hasNext(); ) {\n            final TaxonPathBean tpb = (TaxonPathBean) iterOne.next();\n            final String tpbId = tpb.getTaxonPathId();\n            if (null != tpbId && 0 > Integer.parseInt(tpbId)) {\n                tpb.setTaxonPathId(null);\n            }\n            for (Iterator iterTwo = tpb.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                final TaxonBean tb = (TaxonBean) iterTwo.next();\n                final String tbId = tb.getTaxonId();\n                if (null != tbId && 0 > Integer.parseInt(tbId)) {\n                    tb.setTaxonId(null);\n                }\n            }\n        }\n        // scrubs Copyright holders\n        for (Iterator iter = cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n            final CopyrightHolderBean chb = (CopyrightHolderBean) iter.next();\n            final String chbId = chb.getCopyrightHolderId();\n            if (null != chbId && 0 > Integer.parseInt(chbId)) {\n                chb.setCopyrightHolderId(null);\n            }\n        }\n        // scrubs metametadata identifiers\n        for (Object o : cmb.getMetametadataIdentifiers()) {\n            final MetametadataIdentifierBean mib = (MetametadataIdentifierBean) o;\n            final String mibId = mib.getMetametadataIdentifierId();\n            if (null != mibId && 0 > Integer.parseInt(mibId)) {\n                mib.setMetametadataIdentifierId(null);\n            }\n        }\n        // scrubs metametadata contributors\n        for (Object o : cmb.getMetametadataContributors()) {\n            final MetametadataContributorBean mcb = (MetametadataContributorBean) o;\n            final String mcbId = mcb.getMetametadataContributorId();\n            if (null != mcbId && 0 > Integer.parseInt(mcbId)) {\n                mcb.setMetametadataContributorId(null);\n            }\n        }\n        // scrubs requirements\n        for (Iterator iter = cmb.getRequirements().iterator(); iter.hasNext(); ) {\n            final RequirementBean rb = (RequirementBean) iter.next();\n            final String rbId = rb.getRequirementId();\n            if (null != rbId && 0 > Integer.parseInt(rbId)) {\n                rb.setRequirementId(null);\n            }\n        }\n        // scrubs relations\n        for (Iterator iter = cmb.getRelations().iterator(); iter.hasNext(); ) {\n            final RelationBean rb = (RelationBean) iter.next();\n            final String rbId = rb.getRelationId();\n            if (null != rbId && 0 > Integer.parseInt(rbId)) {\n                rb.setRelationId(null);\n            }\n        }\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/SaveMetadataActionTest.java",
		"test_prompt": "// SaveMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SaveMetadataAction}.\n* It contains ten unit test cases for the {@link SaveMetadataAction#actionRequiresLogin()} method.\n*/\nclass SaveMetadataActionTest {"
	},
	{
		"original_code": "// CreateMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.sql.SQLException;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * An {@link Action} which creates a new metadata record to edit,\n * puts it into the session, and then directs the user to the editing\n * page.\n */\npublic class CreateMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final HttpSession session = request.getSession();\n        CompleteMetadataBean cmb = (CompleteMetadataBean) session.getAttribute(\"metadata\");\n        if (null != cmb) {\n            response.sendRedirect(\"../catalog/concurrentMetadataEditError.jsp\");\n            return;\n        }\n        final String metadataId = request.getParameter(\"basedOnMetadataId\");\n        if (null == metadataId) {\n            cmb = new CompleteMetadataBean();\n        } else {\n            final MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n            try {\n                cmb = metadataServices.getCompleteMetadata(metadataId);\n            } catch (SQLException e) {\n                throw new ServletException(e);\n            }\n            clearIds(cmb);\n            cmb.setLocation(null);\n            cmb.setCatalogDate(null);\n            cmb.setApproveDate(null);\n            if (null != cmb.getThumbnail()) {\n                cmb.setThumbnail(null);\n            }\n            cmb.setFileSize(null);\n            cmb.setFileHeight(null);\n            cmb.setFileWidth(null);\n        }\n        cmb.setContributeDate(new Date());\n        session.setAttribute(\"metadata\", cmb);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/healapp/editMetadata\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * Since this {@link Action} creates <em>new</em> metadata records, we\n     * must clear the ids from an existing {@link CompleteMetadataBean} that\n     * this new record is based on.\n     *\n     * @param cmb\n     */\n    private static void clearIds(CompleteMetadataBean cmb) throws ServletException {\n        cmb.setMetadataId(null);\n        cmb.setGlobalId(null);\n        clearIdsFromList(cmb.getContextURLs());\n        clearIdsFromList(cmb.getContributorList());\n        clearIdsFromList(cmb.getCopyrightHolders());\n        clearIdsFromList(cmb.getCopyrights());\n        clearIdsFromList(cmb.getDiseaseDiagnoses());\n        clearIdsFromList(cmb.getFormats());\n        clearIdsFromList(cmb.getKeywords());\n        clearIdsFromList(cmb.getRelations());\n        clearIdsFromList(cmb.getRequirements());\n        clearIdsFromList(cmb.getTargetUserGroups());\n        // Taxons/TaxonPaths need to be handled a bit differently since\n        // they have an unusual association going on\n        String nextTaxonId = \"-1\";\n        String nextTaxonPathId = \"-1\";\n        for (Iterator iterOne = cmb.getTaxonPaths().iterator(); iterOne.hasNext(); ) {\n            final TaxonPathBean taxonPath = (TaxonPathBean) iterOne.next();\n            taxonPath.setMetadataId(null);\n            taxonPath.setTaxonPathId(nextTaxonPathId);\n            for (Iterator iterTwo = taxonPath.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                final TaxonBean taxon = (TaxonBean) iterTwo.next();\n                taxon.setTaxonId(nextTaxonId);\n                taxon.setTaxonPathId(null);\n                nextTaxonId = String.valueOf(Integer.parseInt(nextTaxonId) - 1);\n            }\n            nextTaxonPathId = String.valueOf(Integer.parseInt(nextTaxonPathId) - 1);\n        }\n    }\n\n    private static void clearIdsFromList(List objects) throws ServletException {\n        Map ids = new HashMap();\n        for (Iterator iter = objects.iterator(); iter.hasNext(); ) {\n            Object ob = iter.next();\n            Method[] methods = ob.getClass().getMethods();\n            for (int i = 0; i < methods.length; ++i) {\n                final String methodName = methods[i].getName();\n                Object[] args = new Object[1];\n                if (\"setMetadataId\".equals(methodName)) {\n                    args[0] = null;\n                } else if (methodName.matches(\"^set.+Id\")) {\n                    String id;\n                    if (!ids.containsKey(methodName)) {\n                        id = \"-1\";\n                    } else {\n                        id = String.valueOf(Integer.parseInt((String) ids.get(methodName)) - 1);\n                    }\n                    args[0] = id;\n                    ids.put(methodName, id);\n                } else {\n                    continue;\n                }\n                Class[] parameters = methods[i].getParameterTypes();\n                if (1 != parameters.length || !parameters[0].equals(String.class)) {\n                    // Constructs method signature for error message\n                    StringBuffer argString = new StringBuffer(\"(\");\n                    for (int j = 0; j < parameters.length; ++j) {\n                        argString.append(parameters[j].getName());\n                        if (j < parameters.length - 1) {\n                            argString.append(\", \");\n                        }\n                    }\n                    argString.append(\")\");\n                    throw new ServletException(\"Unexpected setXXXId method found: \" + methodName + argString.toString());\n                }\n                try {\n                    methods[i].invoke(ob, args);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/CreateMetadataActionTest.java",
		"test_prompt": "// CreateMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.sql.SQLException;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CreateMetadataAction}.\n* It contains ten unit test cases for the {@link CreateMetadataAction#actionRequiresLogin()} method.\n*/\nclass CreateMetadataActionTest {"
	},
	{
		"original_code": "// ModifyCatalogQueueEntryAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.FileLocator;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.sql.SQLException;\n\n/**\n * An {@link org.heal.servlet.Action Action} which is called in order to edit a metadata item which is in\n * the catalog queue.\n *\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @version 1.0\n */\npublic class ModifyCatalogQueueEntryAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        final String catalogQueueEntryId = request.getParameter(\"catalogQueueEntryId\");\n        final String status = request.getParameter(\"status\");\n        if (!AuthenticationTools.isCataloger(request) || null == catalogQueueEntryId || null == status) {\n            // The user does not have the access to view this page\n            // or the Catalog Queue entry id or status is missing,\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String metadataId = request.getParameter(\"metadataId\");\n        final QueueDAO queueManager = (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        try {\n            final String statusTest = status.toLowerCase();\n            if (\"waiting\".equals(statusTest) || \"incomplete\".equals(statusTest)) {\n                // If the status is 'waiting', or incomplete, we just save the catalog queue entry\n                // Creates an QueuedRecordBean based on the form data\n                final QueuedRecordBean catalogEntry = new QueuedRecordBean();\n                catalogEntry.setQueuedRecordId(catalogQueueEntryId);\n                catalogEntry.setComments(request.getParameter(\"comment\"));\n                catalogEntry.getShortMetadata().setMetadataId(metadataId);\n                catalogEntry.setStatus(status);\n                catalogEntry.setType(QueueDAO.TYPE_CATALOG);\n                queueManager.saveQueuedRecord(catalogEntry);\n            } else if (\"cataloged\".equals(statusTest)) {\n                // If the status is 'cataloged' we mark it as such in the database,\n                // and copy the file to the content directory\n                MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n                FileLocator fileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n                ShortMetadataBean metadata = metadataServices.getShortMetadata(metadataId);\n                queueManager.markRecordCataloged(metadataId);\n                queueManager.dequeue(catalogQueueEntryId);\n                String sourceFile = fileLocator.getUploadFilePath(metadata.getLocation());\n                String destinationFile = fileLocator.getContentFilePath(metadata.getLocation());\n                if (!new File(destinationFile).exists()) {\n                    copyFile(sourceFile, destinationFile);\n                }\n            }\n        } catch (SQLException e) {\n            // TODO logging?\n        }\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        response.sendRedirect(\"showCatalogQueue\");\n    }\n\n    /**\n     * Copies a file from a sourceLocation to a destinationLocation.\n     *\n     * @param sourceLocation\n     * @param destinationLocation\n     */\n    private static void copyFile(String sourceLocation, String destinationLocation) {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            // Create channel on the source\n            srcChannel = new FileInputStream(sourceLocation).getChannel();\n            // Create channel on the destination\n            dstChannel = new FileOutputStream(destinationLocation).getChannel();\n            // Copy file contents from source to destination\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // Close the channels\n            if (null != srcChannel) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e) {\n                }\n            }\n            if (null != dstChannel) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/ModifyCatalogQueueEntryActionTest.java",
		"test_prompt": "// ModifyCatalogQueueEntryActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.FileLocator;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyCatalogQueueEntryAction}.\n* It contains ten unit test cases for the {@link ModifyCatalogQueueEntryAction#actionRequiresLogin()} method.\n*/\nclass ModifyCatalogQueueEntryActionTest {"
	},
	{
		"original_code": "// RelationRecordModifier.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Saves changes to a {@link RelationBean} and acts as\n * an {@link Action} which is called to edit a Relation.  If\n * there isn't an existing Relation which can be found to edit,\n * we assume that a new Relation should be edited.\n */\npublic class RelationRecordModifier implements Action, MetadataModifier {\n\n    private static Action NEXT_ACTION = new EditMetadataAction();\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        RelationBean rbToEdit = findRelationBean(cmb.getRelations(), selectedId);\n        if (null == rbToEdit) {\n            rbToEdit = new RelationBean();\n        }\n        request.setAttribute(\"RelationBean\", rbToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editRelation.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    public void updateMetadata(CompleteMetadataBean cmb, ServletRequest request) {\n        final String relationId = request.getParameter(\"relationId\");\n        final String resource = request.getParameter(\"resource\");\n        final String kind = request.getParameter(\"kind\");\n        final String description = request.getParameter(\"description\");\n        final String catalogue = request.getParameter(\"catalogue\");\n        final String entry = request.getParameter(\"entry\");\n        RelationBean rb = findRelationBean(cmb.getRelations(), relationId);\n        if (null == rb) {\n            int lowestRelationId = 0;\n            for (Iterator iter = cmb.getRelations().iterator(); iter.hasNext(); ) {\n                final RelationBean temp = (RelationBean) iter.next();\n                final int tempId = Integer.parseInt(temp.getRelationId());\n                if (tempId < lowestRelationId) {\n                    lowestRelationId = tempId;\n                }\n            }\n            rb = new RelationBean();\n            rb.setRelationId(String.valueOf(lowestRelationId - 1));\n            cmb.addRelation(rb);\n        }\n        rb.setResource(resource);\n        rb.setKind(kind);\n        rb.setDescription(description);\n        rb.setCatalogue(catalogue);\n        rb.setEntry(entry);\n    }\n\n    public Action getNextAction(ServletRequest request) {\n        return NEXT_ACTION;\n    }\n\n    private RelationBean findRelationBean(final List relations, final String relationId) {\n        RelationBean ret = null;\n        for (Iterator iter = relations.iterator(); iter.hasNext(); ) {\n            RelationBean temp = (RelationBean) iter.next();\n            if ((null == relationId && null == temp.getRelationId()) || (null != relationId && relationId.equals(temp.getRelationId()))) {\n                ret = temp;\n            }\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/RelationRecordModifierTest.java",
		"test_prompt": "// RelationRecordModifierTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RelationRecordModifier}.\n* It contains ten unit test cases for the {@link RelationRecordModifier#actionRequiresLogin()} method.\n*/\nclass RelationRecordModifierTest {"
	},
	{
		"original_code": "// CancelEditMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\n\n/**\n * A simple {@link Action} which clears the session variable used\n * for editing metadata.\n */\npublic class CancelEditMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        HttpSession session = request.getSession(false);\n        if (null != session) {\n            session.removeAttribute(\"metadata\");\n        }\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editCancelled.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>false</code>\n     */\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/CancelEditMetadataActionTest.java",
		"test_prompt": "// CancelEditMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CancelEditMetadataAction}.\n* It contains ten unit test cases for the {@link CancelEditMetadataAction#actionRequiresLogin()} method.\n*/\nclass CancelEditMetadataActionTest {"
	},
	{
		"original_code": "// EditControlledVocabularyAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Controlled Vocabulary item.  If\n * there isn't an existing Controlled Vocabulary item which can be found to edit,\n * we assume that a new Controlled Vocabulary entry should be edited.\n */\npublic class EditControlledVocabularyAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        TaxonBean taxonToEdit = new TaxonBean();\n        TaxonPathBean taxonPathToEdit = new TaxonPathBean();\n        if (null != selectedId && 0 < selectedId.length()) {\n            for (Iterator iterOne = cmb.getTaxonPaths().iterator(); iterOne.hasNext(); ) {\n                final TaxonPathBean tempTaxonPath = (TaxonPathBean) iterOne.next();\n                for (Iterator iterTwo = tempTaxonPath.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                    final TaxonBean tempTaxon = (TaxonBean) iterTwo.next();\n                    if (tempTaxon.getTaxonId().equals(selectedId)) {\n                        taxonToEdit = tempTaxon;\n                        taxonPathToEdit = tempTaxonPath;\n                    }\n                }\n            }\n        }\n        request.setAttribute(\"TaxonBean\", taxonToEdit);\n        request.setAttribute(\"TaxonPathBean\", taxonPathToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editControlledVocabulary.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/EditControlledVocabularyActionTest.java",
		"test_prompt": "// EditControlledVocabularyActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditControlledVocabularyAction}.\n* It contains ten unit test cases for the {@link EditControlledVocabularyAction#actionRequiresLogin()} method.\n*/\nclass EditControlledVocabularyActionTest {"
	},
	{
		"original_code": "// EditMetadataAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * An {@link org.heal.servlet.Action Action} used to edit metadata\n * records.\n *\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @version 1.0\n */\npublic class EditMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String metadataId = request.getParameter(\"metadataId\");\n        CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        if (null == cmb) {\n            if (null != metadataId) {\n                // If there's no CompleteMetadataBean in the session, we try to retrieve one from\n                // the database based on the metadataId parameter\n                final MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n                try {\n                    cmb = metadataServices.getCompleteMetadata(metadataId);\n                    request.getSession().setAttribute(\"metadata\", cmb);\n                } catch (SQLException e) {\n                    throw new ServletException(e);\n                    // TODO Logging?\n                }\n            } else {\n                request.setAttribute(\"reason\", \"No metadata record available to edit.\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/error/accessDenied.jsp\");\n                rd.forward(request, response);\n                return;\n            }\n        } else {\n            if (null != metadataId) {\n                response.sendRedirect(\"../catalog/concurrentMetadataEditError.jsp\");\n                return;\n            }\n        }\n        if (null != cmb) {\n            // We must add target user groups to the request as a Map so that\n            // the JSP EL can easily determine whether checkboxes should be checked\n            Map targetUserGroups = new HashMap();\n            for (Iterator iter = cmb.getTargetUserGroups().iterator(); iter.hasNext(); ) {\n                TargetUserGroupBean tug = (TargetUserGroupBean) iter.next();\n                targetUserGroups.put(tug.getTargetUserGroup().toLowerCase(), new Object());\n            }\n            request.setAttribute(\"targetUserGroups\", targetUserGroups);\n            // We add names for contributors so that they can be\n            // printed out nicely in the jsp\n            VCardBean vCard = new VCardBean();\n            List contributors = cmb.getContributorList();\n            for (Iterator iter = contributors.iterator(); iter.hasNext(); ) {\n                ContributorBean cb = (ContributorBean) iter.next();\n                vCard.setVCard(cb.getVCard());\n                if (vCard.isValidVCard()) {\n                    if (null != vCard.getFormattedName()) {\n                        cb.setTitle(vCard.getFormattedName());\n                    } else {\n                        cb.setTitle(vCard.getFirstName() + \" \" + vCard.getLastName());\n                    }\n                } else {\n                    cb.setTitle(cb.getVCard());\n                }\n            }\n            // We add names for copyright holders so that they can be\n            // printed out nicely in the jsp\n            for (Iterator iter = cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n                CopyrightHolderBean chb = (CopyrightHolderBean) iter.next();\n                vCard.setVCard(chb.getVCard());\n                if (vCard.isValidVCard()) {\n                    if (null != vCard.getFormattedName()) {\n                        chb.setTitle(vCard.getFormattedName());\n                    } else {\n                        chb.setTitle(vCard.getFirstName() + \" \" + chb.getLastName());\n                    }\n                } else {\n                    chb.setTitle(chb.getVCard());\n                }\n            }\n        }\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editMetadata.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/EditMetadataActionTest.java",
		"test_prompt": "// EditMetadataActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditMetadataAction}.\n* It contains ten unit test cases for the {@link EditMetadataAction#actionRequiresLogin()} method.\n*/\nclass EditMetadataActionTest {"
	},
	{
		"original_code": "// MetametadataContributorRecordModifier.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.util.DateTools;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\n\n/**\n * Saves changes to a {@link MetametadataContributorBean}.\n */\npublic class MetametadataContributorRecordModifier implements Action, MetadataModifier {\n\n    private static final Action NEXT_ACTION = new EditMetadataAction();\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        MetametadataContributorBean mcbToEdit = new MetametadataContributorBean();\n        for (Object o : cmb.getMetametadataContributors()) {\n            MetametadataContributorBean temp = (MetametadataContributorBean) o;\n            if (selectedId.equals(temp.getMetametadataContributorId())) {\n                mcbToEdit = temp;\n                break;\n            }\n        }\n        request.setAttribute(\"MetametadataContributorBean\", mcbToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editMetametadataContributor.jsp\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    public void updateMetadata(CompleteMetadataBean cmb, ServletRequest request) {\n        final String mmContributorId = request.getParameter(\"metametadataContributorId\");\n        final String role = request.getParameter(\"role\");\n        final String contributeDateStr = request.getParameter(\"contributeDate\");\n        final String contributeDateDescription = request.getParameter(\"contributeDateDescription\");\n        final String vCard = request.getParameter(\"vCard\");\n        MetametadataContributorBean mcb = null;\n        int lowestMetametadataContributorId = 0;\n        for (Object o : cmb.getMetametadataContributors()) {\n            MetametadataContributorBean temp = (MetametadataContributorBean) o;\n            String idStr = temp.getMetametadataContributorId();\n            int id = Integer.parseInt(idStr);\n            if (idStr.equals(mmContributorId)) {\n                mcb = temp;\n                break;\n            }\n            // We must find the lowest metametadata contributor id for cases\n            // where this is a new metametadata contributor object, and we must\n            // generate a unique id for it (which we define to be\n            // negative numbers for metametadata contributors not in the\n            // database yet).\n            if (id < lowestMetametadataContributorId) {\n                lowestMetametadataContributorId = id;\n            }\n        }\n        if (null == mcb) {\n            // No existing metametadata contributor was found, so we must\n            // create one with a unique id and add it to the CompleteMetadataBean\n            mcb = new MetametadataContributorBean();\n            mcb.setMetametadataContributorId(String.valueOf(lowestMetametadataContributorId - 1));\n            cmb.getMetametadataContributors().add(mcb);\n        }\n        mcb.setDate(DateTools.parse(contributeDateStr));\n        mcb.setDateDescription(contributeDateDescription);\n        mcb.setRole(role);\n        mcb.setvCard(vCard);\n    }\n\n    public Action getNextAction(ServletRequest request) {\n        return NEXT_ACTION;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/MetametadataContributorRecordModifierTest.java",
		"test_prompt": "// MetametadataContributorRecordModifierTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.util.DateTools;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetametadataContributorRecordModifier}.\n* It contains ten unit test cases for the {@link MetametadataContributorRecordModifier#actionRequiresLogin()} method.\n*/\nclass MetametadataContributorRecordModifierTest {"
	},
	{
		"original_code": "// SaveControlledVocabularyMultipleAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.CommonDAO;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Comments here!\n */\npublic class SaveControlledVocabularyMultipleAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String formSource = request.getParameter(\"source\");\n        final String formId = request.getParameter(\"id\");\n        final String formEntry = request.getParameter(\"entry\");\n        final String formMetadataIds = request.getParameter(\"metadataIds\");\n        List<String> metadataIds = new ArrayList<String>();\n        List<String> errors = new ArrayList<String>();\n        if (isEmpty(formSource)) {\n            errors.add(\"source (empty)\");\n        }\n        if (isEmpty(formId) && !\"Consumer Health/Patient Education\".equals(formSource)) {\n            errors.add(\"id (empty)\");\n        }\n        if (\"Mesh\".equals(formSource) && isEmpty(formEntry)) {\n            errors.add(\"entry (empty)\");\n        }\n        if (isEmpty(formMetadataIds)) {\n            errors.add(\"metadataIds (empty)\");\n        } else {\n            try {\n                for (String metadataId : formMetadataIds.split(\"\\\\n\")) {\n                    if (0 != metadataId.trim().length() && !\"\\n\".equals(metadataId.trim())) {\n                        Integer.parseInt(metadataId.trim());\n                        metadataIds.add(metadataId.trim());\n                    }\n                }\n            } catch (NumberFormatException e) {\n                errors.add(\"metadataIds (not numbers)\");\n            }\n        }\n        if (0 != errors.size()) {\n            request.setAttribute(\"errors\", errors);\n            request.setAttribute(\"source\", formSource);\n            request.setAttribute(\"id\", formId);\n            request.setAttribute(\"entry\", formEntry);\n            request.setAttribute(\"metadataIds\", formMetadataIds);\n            RequestDispatcher rd;\n            rd = request.getRequestDispatcher(\"/catalog/addControlledVocabularyMultiple.jsp\");\n            rd.forward(request, response);\n            return;\n        }\n        CommonDAO cd = (CommonDAO) servlet.getServletContext().getAttribute(\"CommonDAO\");\n        try {\n            for (String metadataId : metadataIds) {\n                saveControlledVocab(cd, metadataId, formSource, formEntry, formId);\n            }\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/success.jsp\");\n        rd.forward(request, response);\n    }\n\n    private void saveControlledVocab(CommonDAO cd, String metadataId, String source, String entry, String id) throws SQLException {\n        TaxonPathBean tpb = new TaxonPathBean();\n        tpb.setMetadataId(metadataId);\n        tpb.setSource(source);\n        TaxonBean tb = new TaxonBean();\n        tb.setEntry(entry);\n        tb.setId(id);\n        tpb.addTaxon(tb);\n        cd.saveTaxonPath(tpb);\n    }\n\n    private boolean isEmpty(String test) {\n        return (null == test || 0 == test.trim().length());\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/SaveControlledVocabularyMultipleActionTest.java",
		"test_prompt": "// SaveControlledVocabularyMultipleActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.CommonDAO;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SaveControlledVocabularyMultipleAction}.\n* It contains ten unit test cases for the {@link SaveControlledVocabularyMultipleAction#actionRequiresLogin()} method.\n*/\nclass SaveControlledVocabularyMultipleActionTest {"
	},
	{
		"original_code": "// EditContributorAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContributorBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Contributor.  If\n * there isn't an existing Contributor which can be found to edit,\n * we assume that a new Contributor should be edited.\n */\npublic class EditContributorAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        ContributorBean cbToEdit = new ContributorBean();\n        for (Iterator iter = cmb.getContributorList().iterator(); iter.hasNext(); ) {\n            ContributorBean tempCb = (ContributorBean) iter.next();\n            if (tempCb.getContributorId().equals(selectedId)) {\n                cbToEdit = tempCb;\n                break;\n            }\n        }\n        request.setAttribute(\"ContributorBean\", cbToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editContributor.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/EditContributorActionTest.java",
		"test_prompt": "// EditContributorActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContributorBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditContributorAction}.\n* It contains ten unit test cases for the {@link EditContributorAction#actionRequiresLogin()} method.\n*/\nclass EditContributorActionTest {"
	},
	{
		"original_code": "// ShowCatalogQueueAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * An {@link org.heal.servlet.Action} which fetches the information needed to\n * display the catalog queue.\n *\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class ShowCatalogQueueAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        if (!AuthenticationTools.isCataloger(request)) {\n            // The user does not have the access to view this page\n            // so we go no further, and redirect them to an access denied page\n            // TODO instead of hardcoding page locations, this should be in config files somewhere\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final QueueDAO queueManager = (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        final List queue = queueManager.getCatalogQueue();\n        request.setAttribute(\"catalogQueue\", queue);\n        // TODO instead of hardcoding page locations, this should be in config files somewhere\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/viewqueue.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/ShowCatalogQueueActionTest.java",
		"test_prompt": "// ShowCatalogQueueActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.servlet.Action;\nimport org.heal.util.AuthenticationTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowCatalogQueueAction}.\n* It contains ten unit test cases for the {@link ShowCatalogQueueAction#actionRequiresLogin()} method.\n*/\nclass ShowCatalogQueueActionTest {"
	},
	{
		"original_code": "// EditCopyrightHolderAction.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * An {@link Action} which is called to edit a Copyright Holder.  If\n * there isn't an existing Copyright Holder which can be found to edit,\n * we assume that a new Copyright Holder should be edited.\n */\npublic class EditCopyrightHolderAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // We skip the usual authentication-checking stuff since this\n        // already should've been done by ModifyMetadataAction\n        final CompleteMetadataBean cmb = (CompleteMetadataBean) request.getSession().getAttribute(\"metadata\");\n        final String selectedId = request.getParameter(\"selectedId\");\n        // This shouldn't be necessary, but it won't hurt to check\n        if (null == cmb || null == selectedId) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        CopyrightHolderBean chbToEdit = new CopyrightHolderBean();\n        for (Iterator iter = cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n            CopyrightHolderBean tempChb = (CopyrightHolderBean) iter.next();\n            if (tempChb.getCopyrightHolderId().equals(selectedId)) {\n                chbToEdit = tempChb;\n                break;\n            }\n        }\n        request.setAttribute(\"CopyrightHolderBean\", chbToEdit);\n        RequestDispatcher rd = request.getRequestDispatcher(\"/catalog/editCopyrightHolder.jsp\");\n        rd.forward(request, response);\n    }\n\n    /**\n     * @return <code>true</code>\n     */\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/cataloger/EditCopyrightHolderActionTest.java",
		"test_prompt": "// EditCopyrightHolderActionTest.java\npackage org.heal.servlet.cataloger;\n\nimport org.heal.servlet.Action;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EditCopyrightHolderAction}.\n* It contains ten unit test cases for the {@link EditCopyrightHolderAction#actionRequiresLogin()} method.\n*/\nclass EditCopyrightHolderActionTest {"
	},
	{
		"original_code": "// LogoutAction.java\npackage org.heal.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class LogoutAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        request.getSession().invalidate();\n        response.sendRedirect(\"../user/logout_response.jsp\");\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/LogoutActionTest.java",
		"test_prompt": "// LogoutActionTest.java\npackage org.heal.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LogoutAction}.\n* It contains ten unit test cases for the {@link LogoutAction#actionRequiresLogin()} method.\n*/\nclass LogoutActionTest {"
	},
	{
		"original_code": "// ModifyEmailAction.java\npackage org.heal.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.notice.NotificationServicesBean;\nimport javax.mail.MessagingException;\nimport org.heal.util.FileLocator;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport javax.servlet.RequestDispatcher;\n\npublic class ModifyEmailAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String email = request.getParameter(\"email\");\n        String newEmail = request.getParameter(\"newemail\");\n        String cfmEmail = request.getParameter(\"emailConfirm\");\n        UserBean user = new UserBean();\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        Vector errorMessage = new Vector();\n        if (email == null || email.length() == 0) {\n            errorMessage.addElement(\"Current E-mail address missing\");\n        }\n        if (newEmail == null || newEmail.length() == 0) {\n            errorMessage.addElement(\"New E-mail address missing\");\n        }\n        try {\n            if (userRegistry.userExists(newEmail)) {\n                errorMessage.addElement(\"User \" + newEmail + \" already exists, please try another email address.\");\n            } else if (userRegistry.userExists(email) == false) {\n                errorMessage.addElement(\"Invalid current E-mail address\");\n            }\n        } catch (SQLException ex) {\n        }\n        if (cfmEmail == null || cfmEmail.length() == 0) {\n            errorMessage.addElement(\"E-mail confirmation missing\");\n        }\n        if (!cfmEmail.equals(newEmail)) {\n            errorMessage.addElement(\"Email confirmation does not match\");\n        }\n        if (errorMessage.size() > 0) {\n            request.setAttribute(\"errorMessage\", errorMessage);\n            RequestDispatcher rd;\n            rd = request.getRequestDispatcher(\"/user/modifyemail.jsp\");\n            rd.forward(request, response);\n        } else {\n            userRegistry.updateEmail(email, newEmail);\n            try {\n                user = userRegistry.getUserFromEmail(newEmail);\n            } catch (SQLException ex) {\n            }\n            String userId = user.getUserId();\n            NotificationServicesBean nsb = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n            FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n            try {\n                nsb.sendUsernameValidationEmail(user, healFileLocator.getServerBaseURL() + \"/healapp/emailValidation?emailId=\" + userId + \"&email=\" + user.getEmail());\n            } catch (MessagingException m) {\n                m.printStackTrace();\n            }\n            response.sendRedirect(\"../user/register_response.jsp?email=\" + newEmail);\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/ModifyEmailActionTest.java",
		"test_prompt": "// ModifyEmailActionTest.java\npackage org.heal.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.heal.module.user.UserRegistryBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.notice.NotificationServicesBean;\nimport javax.mail.MessagingException;\nimport org.heal.util.FileLocator;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport javax.servlet.RequestDispatcher;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifyEmailAction}.\n* It contains ten unit test cases for the {@link ModifyEmailAction#actionRequiresLogin()} method.\n*/\nclass ModifyEmailActionTest {"
	},
	{
		"original_code": "// ApproveUserReviewAction.java\npackage org.heal.servlet.userreview;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport org.heal.servlet.*;\nimport org.heal.util.AuthenticationTools;\n\n// approves user reviews\npublic class ApproveUserReviewAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // only approvers, admins or catalogers can access this page.\n        if (AuthenticationTools.isApprover(request) == false && AuthenticationTools.isAdministrator(request) == false && AuthenticationTools.isCataloger(request) == false) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        String metaDataId;\n        UserReviewBean userReviewEntry = null;\n        UserReviewDAO userReviewRegistry = (UserReviewDAO) servlet.getServletContext().getAttribute(\"UserReviewDAO\");\n        metaDataId = request.getParameter(\"metadataId\");\n        String[] approvedArray = request.getParameterValues(\"approved\");\n        try {\n            // to approve a list of reviews for a resource, all existing approved reviews are set to NOT approved...\n            userReviewRegistry.clearUserReviewApproval(metaDataId);\n            // ...then new approved reviews are updated using this loop.\n            if (approvedArray != null && approvedArray.length != 0) {\n                for (int i = 0; i < approvedArray.length; i++) {\n                    userReviewEntry = new UserReviewBean();\n                    userReviewEntry.setApproved(true);\n                    userReviewEntry.setReviewId(Integer.parseInt(approvedArray[i]));\n                    userReviewRegistry.approveUserReview(userReviewEntry);\n                }\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        response.sendRedirect(\"../userreview/userreviewapproval_response.jsp?metadataId=\" + metaDataId);\n    }\n\n    // login is required to view this page.\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/userreview/ApproveUserReviewActionTest.java",
		"test_prompt": "// ApproveUserReviewActionTest.java\npackage org.heal.servlet.userreview;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport org.heal.servlet.*;\nimport org.heal.util.AuthenticationTools;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ApproveUserReviewAction}.\n* It contains ten unit test cases for the {@link ApproveUserReviewAction#actionRequiresLogin()} method.\n*/\nclass ApproveUserReviewActionTest {"
	},
	{
		"original_code": "// WriteUserReviewAction.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n// used to bring up the user review form.\npublic class WriteUserReviewAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        RequestDispatcher rd;\n        String formURL = \"/userreview/userreviewform.jsp?\" + request.getQueryString();\n        rd = request.getRequestDispatcher(formURL);\n        rd.forward(request, response);\n    }\n\n    // login is required to view this page.\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/userreview/WriteUserReviewActionTest.java",
		"test_prompt": "// WriteUserReviewActionTest.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WriteUserReviewAction}.\n* It contains ten unit test cases for the {@link WriteUserReviewAction#actionRequiresLogin()} method.\n*/\nclass WriteUserReviewActionTest {"
	},
	{
		"original_code": "// ShowAllUserReviewAction.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.FileLocator;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\n\n// user review manager, lists all user reviews that need approval.\npublic class ShowAllUserReviewAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // only approvers, admins or catalogers can access this page.\n        if (AuthenticationTools.isApprover(request) == false && AuthenticationTools.isAdministrator(request) == false && AuthenticationTools.isCataloger(request) == false) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final UserReviewDAO userReviewRegistry = (UserReviewDAO) servlet.getServletContext().getAttribute(\"UserReviewDAO\");\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        ArrayList userReviewArray = new ArrayList();\n        try {\n            // need to pass the file locator for path to resource thumbnails and images.\n            userReviewArray = userReviewRegistry.getAllUserReview(healFileLocator);\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        String origURL = \"../healapp/showMetadata?\" + request.getQueryString();\n        request.setAttribute(\"origURL\", origURL);\n        request.setAttribute(\"userReviewArray\", userReviewArray);\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(\"/userreview/userreviewmanager.jsp\");\n        rd.forward(request, response);\n    }\n\n    // login is required to view this page.\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/userreview/ShowAllUserReviewActionTest.java",
		"test_prompt": "// ShowAllUserReviewActionTest.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport org.heal.util.AuthenticationTools;\nimport org.heal.util.FileLocator;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowAllUserReviewAction}.\n* It contains ten unit test cases for the {@link ShowAllUserReviewAction#actionRequiresLogin()} method.\n*/\nclass ShowAllUserReviewActionTest {"
	},
	{
		"original_code": "// ShowUserReviewAction.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport org.heal.util.AuthenticationTools;\n\n// lists all the reviews (approved and pending) for a particular resource.\npublic class ShowUserReviewAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        // only approvers, admins or catalogers can access this page.\n        if (AuthenticationTools.isApprover(request) == false && AuthenticationTools.isAdministrator(request) == false && AuthenticationTools.isCataloger(request) == false) {\n            response.sendRedirect(\"/error/accessDenied.jsp\");\n            return;\n        }\n        final String metadataId = request.getParameter(\"metadataId\");\n        final UserReviewDAO userReviewRegistry = (UserReviewDAO) servlet.getServletContext().getAttribute(\"UserReviewDAO\");\n        ArrayList userReviewArray = new ArrayList();\n        int userRatingAVG = 0;\n        try {\n            // get all the user review data.\n            userReviewArray = userReviewRegistry.getUserReview(metadataId, \"all\", \"reviewDate\");\n            // calculate the average star rating.\n            userRatingAVG = userReviewRegistry.getUserRatingAVG(metadataId);\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        String referrer = request.getHeader(\"referer\");\n        request.setAttribute(\"origURL\", referrer);\n        request.setAttribute(\"userReviewArray\", userReviewArray);\n        request.setAttribute(\"userRatingAVG\", userRatingAVG);\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(\"/userreview/indivuserreview.jsp\");\n        rd.forward(request, response);\n    }\n\n    // login is required to view this page.\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/userreview/ShowUserReviewActionTest.java",
		"test_prompt": "// ShowUserReviewActionTest.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport org.heal.util.AuthenticationTools;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowUserReviewAction}.\n* It contains ten unit test cases for the {@link ShowUserReviewAction#actionRequiresLogin()} method.\n*/\nclass ShowUserReviewActionTest {"
	},
	{
		"original_code": "// ShowTop10Action.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport org.heal.util.FileLocator;\n\n// shows the top 10 most highly rated resources.\npublic class ShowTop10Action implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        final UserReviewDAO userReviewRegistry = (UserReviewDAO) servlet.getServletContext().getAttribute(\"UserReviewDAO\");\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        ArrayList userReviewArray = new ArrayList();\n        try {\n            // need to pass the file locator for path to resource thumbnails and images.\n            userReviewArray = userReviewRegistry.getTop10(healFileLocator);\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        String origURL = \"../healapp/showMetadata?\" + request.getQueryString();\n        request.setAttribute(\"origURL\", origURL);\n        request.setAttribute(\"userReviewArray\", userReviewArray);\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(\"/userreview/top10.jsp\");\n        rd.forward(request, response);\n    }\n\n    // login is not required to view this page.\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/userreview/ShowTop10ActionTest.java",
		"test_prompt": "// ShowTop10ActionTest.java\npackage org.heal.servlet.userreview;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport org.heal.util.FileLocator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowTop10Action}.\n* It contains ten unit test cases for the {@link ShowTop10Action#actionRequiresLogin()} method.\n*/\nclass ShowTop10ActionTest {"
	},
	{
		"original_code": "// SubmitUserReviewAction.java\npackage org.heal.servlet.userreview;\n\nimport javax.mail.internet.AddressException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport javax.mail.MessagingException;\nimport javax.mail.internet.InternetAddress;\nimport org.heal.servlet.*;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.util.FileLocator;\n\n// submits a user review\npublic class SubmitUserReviewAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String metaDataId;\n        String userId;\n        String comments;\n        int userRating = 0;\n        boolean result = false;\n        UserReviewBean userReviewEntry = new UserReviewBean();\n        UserReviewDAO userReviewRegistry = (UserReviewDAO) servlet.getServletContext().getAttribute(\"UserReviewDAO\");\n        NotificationServicesBean notificationServices = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        String managerurl = healFileLocator.getServerBaseURL();\n        // gets all the review data from the form.\n        metaDataId = request.getParameter(\"metadataId\");\n        userId = request.getParameter(\"userId\");\n        userRating = Integer.parseInt(request.getParameter(\"userRating\"));\n        comments = request.getParameter(\"comments\").trim();\n        Boolean anonymous = false;\n        String anonValue = request.getParameter(\"anonymous\");\n        if (anonValue != null) {\n            anonymous = true;\n        }\n        // puts all the reivew data into the user review bean.\n        userReviewEntry.setMetaDataId(metaDataId);\n        userReviewEntry.setUserId(userId);\n        userReviewEntry.setUserRating(userRating);\n        userReviewEntry.setComments(comments);\n        userReviewEntry.setAnonymous(anonymous);\n        try {\n            // saves the bean into database.\n            userReviewRegistry.saveUserReview(userReviewEntry);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        // sends email notice to Sharon Dennis whenever a resource has been reviewed.\n        try {\n            InternetAddress approver = new InternetAddress(\"sdennis@lib.med.utah.edu\");\n            InternetAddress[] to = { approver };\n            String text = \"HEAL resource with metadata ID #\" + metaDataId + \" has been reviewed.\" + System.getProperty(\"line.separator\") + \"Please go here to approve user reviews: \" + managerurl + \"/userreview/manager.html\";\n            String subject = \"HEAL Resource Reviewed\";\n            result = notificationServices.sendEmail(to, text, subject);\n            System.out.println(\"email result: \" + result);\n        } catch (AddressException ex) {\n            System.err.println(\"Address Ex: \" + ex.toString());\n        } catch (MessagingException ex) {\n            System.err.println(\"Messaging Ex: \" + ex.toString());\n        }\n        response.sendRedirect(\"../userreview/userreview_response.jsp?metadataId=\" + metaDataId);\n    }\n\n    // login is required to view this page.\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/userreview/SubmitUserReviewActionTest.java",
		"test_prompt": "// SubmitUserReviewActionTest.java\npackage org.heal.servlet.userreview;\n\nimport javax.mail.internet.AddressException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport javax.mail.MessagingException;\nimport javax.mail.internet.InternetAddress;\nimport org.heal.servlet.*;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.util.FileLocator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SubmitUserReviewAction}.\n* It contains ten unit test cases for the {@link SubmitUserReviewAction#actionRequiresLogin()} method.\n*/\nclass SubmitUserReviewActionTest {"
	},
	{
		"original_code": "// AuthenticateAction.java\npackage org.heal.servlet;\n\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.net.URLEncoder;\n\npublic class AuthenticateAction implements Action {\n\n    private final static String ENCODING = \"UTF-8\";\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        request.getSession().removeAttribute(\"validUser\");\n        String userName = request.getParameter(\"userName\");\n        String password = request.getParameter(\"password\");\n        String origURL = request.getParameter(\"origURL\");\n        boolean usernameIsEmail = false;\n        if (userName != null && userName.indexOf('@') > 0)\n            usernameIsEmail = true;\n        if (userName.length() == 0 || password.length() == 0) {\n            String query = \"../user/login.jsp?errorMsg=\" + URLEncoder.encode(\"You must enter a Username and Password.\", ENCODING);\n            if (origURL != null && origURL.length() > 0) {\n                query = query + \"&origURL=\" + URLEncoder.encode(origURL, ENCODING);\n            }\n            response.sendRedirect(query);\n            return;\n        }\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        UserBean user;\n        String query = \"\";\n        try {\n            if (null == (user = userRegistry.verifyLogin(userName, password, usernameIsEmail))) {\n                query = \"../user/login.jsp?errorMsg=\" + URLEncoder.encode(\"The Username and Password you entered is not valid.\", ENCODING);\n                if (origURL != null && origURL.length() > 0) {\n                    query = query + \"&origURL=\" + URLEncoder.encode(origURL, ENCODING);\n                }\n                response.sendRedirect(query);\n                return;\n            } else {\n                request.getSession().setAttribute(\"validUser\", user);\n                boolean modifiedLogin = user.isLoginModified();\n                if (!modifiedLogin) {\n                    query = \"../healapp/showRegistrationInfo?type=modify\";\n                    if (origURL != null && origURL.length() > 0)\n                        query = query + \"&origURL=\" + URLEncoder.encode(origURL, ENCODING);\n                    response.sendRedirect(query);\n                    return;\n                }\n                if (!usernameIsEmail) {\n                    request.getSession().invalidate();\n                    query = \"../user/login.jsp?errorMsg=\" + URLEncoder.encode(\"The username name you entered is invalid. <br> Your username is now your email address.\") + \"&origURL=\" + URLEncoder.encode(origURL, ENCODING);\n                    response.sendRedirect(query);\n                    return;\n                }\n                boolean emailValidated = user.isEmailValidated();\n                if (!emailValidated) {\n                    request.getSession().invalidate();\n                    query = \"../user/login.jsp?errorMsg=\" + URLEncoder.encode(\"The email address you entered has not been validated. <br> Please click on the link sent to your email inbox.\") + \"&origURL=\" + URLEncoder.encode(origURL, ENCODING);\n                    response.sendRedirect(query);\n                    return;\n                }\n                /*\n\t\t\t\t  Redirect to the main page or to the original URL, if\n\t\t\t\t  invoked as a result of a access attempt to a protected\n\t\t\t\t  page.\n\t\t\t\t*/\n                if (origURL != null && origURL.length() > 0) {\n                    response.sendRedirect(origURL);\n                } else {\n                    response.sendRedirect(\"../index.jsp\");\n                }\n            }\n        } catch (SQLException ex) {\n            throw new ServletException(ex);\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/AuthenticateActionTest.java",
		"test_prompt": "// AuthenticateActionTest.java\npackage org.heal.servlet;\n\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.net.URLEncoder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticateAction}.\n* It contains ten unit test cases for the {@link AuthenticateAction#actionRequiresLogin()} method.\n*/\nclass AuthenticateActionTest {"
	},
	{
		"original_code": "// DetailedViewAccessAction.java\npackage org.heal.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.heal.module.user.UserBean;\n\n/**\n * Comments here!\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class DetailedViewAccessAction extends DelimitedFileWriterAction {\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n\n    /**\n     * @return The name of the file to write the delimited data to.  This file\n     *      need not include path information -- it will show up in the /private/logs/\n     *      folder as specified in {@link org.heal.servlet.DelimitedFileWriterAction}.\n     */\n    public String getLogFilename() {\n        return \"detailedViewAccess.txt\";\n    }\n\n    /**\n     * @return A <code>String</code> representation of the page to forward\n     *      to upon a successful form submission.\n     */\n    public String getSuccessPage() {\n        return null;\n    }\n\n    public List getData(HttpServletRequest request) {\n        List ret = new ArrayList();\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        if (user != null) {\n            ret.add(user.getUserId());\n        }\n        ret.add(request.getParameter(\"metadataId\"));\n        ret.add(request.getSession().getId());\n        ret.add(\"\" + new java.util.Date());\n        //ret.add(getFormParameter(request, \"lastName\"));\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/DetailedViewAccessActionTest.java",
		"test_prompt": "// DetailedViewAccessActionTest.java\npackage org.heal.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.List;\nimport java.util.ArrayList;\nimport org.heal.module.user.UserBean;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DetailedViewAccessAction}.\n* It contains ten unit test cases for the {@link DetailedViewAccessAction#actionRequiresLogin()} method.\n*/\nclass DetailedViewAccessActionTest {"
	},
	{
		"original_code": "// ShowMetadataAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport org.heal.servlet.userreview.*;\nimport org.heal.servlet.tagcloud.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Comparator;\n\npublic class ShowMetadataAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        final MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        final InterfaceUtilitiesBean interfaceUtilities = (InterfaceUtilitiesBean) servlet.getServletContext().getAttribute(\"interfaceUtilities\");\n        final FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        CompleteMetadataBean completeMetadata;\n        final String metadataId = request.getParameter(\"metadataId\");\n        final DetailedViewAccessAction dtvaa = new DetailedViewAccessAction();\n        dtvaa.perform(servlet, request, response);\n        //added by Zhen 2/24/08\n        final UserReviewDAO userReviewRegistry = (UserReviewDAO) servlet.getServletContext().getAttribute(\"UserReviewDAO\");\n        //UserReviewBean userReviewEntry;\n        ArrayList userReviewArray = new ArrayList();\n        int userRatingAVG = 0;\n        //added by Zhen 5/21/08\n        final TagCloudDAO tagRegistry = (TagCloudDAO) servlet.getServletContext().getAttribute(\"TagCloudDAO\");\n        ArrayList tagArray = new ArrayList();\n        try {\n            userReviewArray = userReviewRegistry.getUserReview(metadataId, \"approved\", \"reviewDate\");\n            userRatingAVG = userReviewRegistry.getUserRatingAVG(metadataId);\n            tagArray = tagRegistry.getTags(metadataId);\n            completeMetadata = metadataServices.getCompleteMetadata(metadataId);\n            String format = completeMetadata.getFormat();\n            if (format == null) {\n                format = \"unknown\";\n                FormatBean ddb = new FormatBean();\n                ddb.setFormat(format);\n                ArrayList formats = new ArrayList();\n                formats.add(ddb);\n                completeMetadata.setFormats(formats);\n            }\n            ThumbnailBean thumbnail = interfaceUtilities.getThumbnail(completeMetadata.getThumbnail(), format, \"../\");\n            completeMetadata.setThumbnail(thumbnail);\n            if (completeMetadata.isCataloged()) {\n                completeMetadata.setLocation(healFileLocator.getContentURL(completeMetadata.getLocation()));\n            } else {\n                completeMetadata.setLocation(healFileLocator.getUploadURL(completeMetadata.getLocation()));\n            }\n            completeMetadata.setFileSize(NumberFormat.getInstance().format(Long.parseLong(completeMetadata.getFileSize())));\n            // Seperates requirements into List<String>s that are easy to\n            // display in the interface\n            final List<String> osRequirements = new ArrayList<String>();\n            final List<String> browserRequirements = new ArrayList<String>();\n            final Iterator iter = completeMetadata.getRequirements().iterator();\n            while (iter.hasNext()) {\n                RequirementBean requirement = (RequirementBean) iter.next();\n                final String type = requirement.getRequirementType();\n                final String name = requirement.getRequirementName();\n                if (\"Operating System\".equalsIgnoreCase(type)) {\n                    if (!\"None\".equalsIgnoreCase(name)) {\n                        osRequirements.add(name);\n                    }\n                } else if (\"Web Browser\".equalsIgnoreCase(type)) {\n                    if (!\"Any\".equalsIgnoreCase(name)) {\n                        browserRequirements.add(name);\n                    }\n                }\n            }\n            request.setAttribute(\"osRequirements\", osRequirements);\n            request.setAttribute(\"browserRequirements\", browserRequirements);\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        // Target User Groups are put into alphabetical order\n        Collections.sort(completeMetadata.getTargetUserGroups(), new Comparator() {\n\n            public int compare(Object o, Object o1) {\n                TargetUserGroupBean tug1 = (TargetUserGroupBean) o;\n                TargetUserGroupBean tug2 = (TargetUserGroupBean) o1;\n                return tug1.getTargetUserGroup().compareTo(tug2.getTargetUserGroup());\n            }\n        });\n        String origURL = \"../healapp/showMetadata?\" + request.getQueryString();\n        request.setAttribute(\"origURL\", origURL);\n        request.setAttribute(\"completeMetadata\", completeMetadata);\n        request.setAttribute(\"userReviewArray\", userReviewArray);\n        request.setAttribute(\"userRatingAVG\", userRatingAVG);\n        request.setAttribute(\"tagArray\", tagArray);\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(\"/metadata/detail.jsp\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/ShowMetadataActionTest.java",
		"test_prompt": "// ShowMetadataActionTest.java\npackage org.heal.servlet;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport org.heal.servlet.userreview.*;\nimport org.heal.servlet.tagcloud.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowMetadataAction}.\n* It contains ten unit test cases for the {@link ShowMetadataAction#actionRequiresLogin()} method.\n*/\nclass ShowMetadataActionTest {"
	},
	{
		"original_code": "// WSSimpleSearchAction.java\npackage org.heal.servlet;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.search.MerlotWS.SimpleMerlotSearch;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\n/**\n * An {@link Action} that handles a request to call MERLOT's SOAP based search methods.\n */\npublic class WSSimpleSearchAction implements Action {\n\n    /**\n     * @param servlet\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String keywords = new String();\n        keywords = request.getParameter(\"keywords\");\n        ShortMetadataBean currentMeta = null;\n        InterfaceUtilitiesBean interfaceUtilities = (InterfaceUtilitiesBean) servlet.getServletContext().getAttribute(\"interfaceUtilities\");\n        SimpleSearchDAO sd = (SimpleSearchDAO) servlet.getServletContext().getAttribute(\"SimpleSearchDAO\");\n        MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        SearchResultBean srb = null;\n        SimpleMerlotSearch sms = new SimpleMerlotSearch();\n        String library = new String();\n        library = request.getParameter(\"library\");\n        String library2 = new String();\n        library2 = request.getParameter(\"library2\");\n        SearchResultBean hsrb = null;\n        if (\"Merlot\".equals(library)) {\n            srb = sms.doSimpleMerlotSearch(keywords, 1, 25);\n            srb = prepareForInterface(srb, interfaceUtilities);\n        }\n        if (\"HEAL\".equals(library2)) {\n            ParameterBean pb = new ParameterBean(keywords);\n            try {\n                hsrb = sd.simpleSearch(pb, \"check\");\n                if (hsrb.getShortRecords() != null) {\n                    int hSearchLength = hsrb.getShortRecords().length;\n                    if (hSearchLength > 25)\n                        hSearchLength = 25;\n                    String metadataId = null;\n                    ShortMetadataBean hShortMetadata = null;\n                    ShortMetadataResultBean[] hShortMetadataResultBean = null;\n                    hShortMetadataResultBean = hsrb.getShortRecords();\n                    for (int b = 0; b < hSearchLength; b++) {\n                        hShortMetadata = hShortMetadataResultBean[b].getShortMetadata();\n                        metadataId = hShortMetadataResultBean[b].getMetadataId();\n                        currentMeta = metadataServices.getShortMetadata(metadataId);\n                        hShortMetadataResultBean[b].setShortMetadata(currentMeta);\n                    }\n                    ShortMetadataResultBean[] smr = new ShortMetadataResultBean[hSearchLength];\n                    for (int c = 0; c < hSearchLength; c++) {\n                        smr[c] = hShortMetadataResultBean[c];\n                    }\n                    hsrb.setShortRecords(smr);\n                    hsrb = prepareForInterface(hsrb, interfaceUtilities);\n                } else {\n                    hsrb = null;\n                }\n            } catch (SQLException se) {\n                se.printStackTrace();\n            }\n        }\n        SearchResultBean rb = new SearchResultBean();\n        rb = mixResults(srb, hsrb);\n        int healCount = 0;\n        int merlotCount = 0;\n        if (hsrb != null)\n            healCount = hsrb.getShortRecords().length;\n        if (srb != null)\n            merlotCount = srb.getShortRecords().length;\n        request.getSession().setAttribute(\"healCount\", healCount);\n        request.getSession().setAttribute(\"merlotCount\", merlotCount);\n        request.getSession().setAttribute(\"searchResults\", rb);\n        String queryString = request.getQueryString();\n        if (queryString == null || queryString.length() == 0) {\n            queryString = \"page=1\";\n        } else {\n            queryString = queryString + \"&page=1\";\n        }\n        String redirectURL = \"wsSearchResults?\" + queryString;\n        response.sendRedirect(redirectURL);\n    }\n\n    public SearchResultBean prepareForInterface(SearchResultBean srb, InterfaceUtilitiesBean interfaceUtilities) {\n        if (srb == null)\n            return null;\n        ShortMetadataResultBean[] smrb = null;\n        ShortMetadataBean currentMeta = null;\n        smrb = srb.getShortRecords();\n        int searchLength = srb.getShortRecords().length;\n        for (int a = 0; a < searchLength; a++) {\n            currentMeta = smrb[a].getShortMetadata();\n            String format = currentMeta.getFormat();\n            if (format == null || format.length() == 0) {\n                format = \"unknown\";\n            }\n            ThumbnailBean thumbnail = interfaceUtilities.getThumbnail(currentMeta.getThumbnail(), format, \"../\");\n            currentMeta.setThumbnail(thumbnail);\n            if (currentMeta.getDescription() == null || currentMeta.getDescription().length() == 0)\n                currentMeta.setDescription(\"No Description Available\");\n            currentMeta.setDescription(interfaceUtilities.getAbbreviatedString(currentMeta.getDescription(), 100));\n            // in the HEAL metadata filesize is required.\n            if (null != currentMeta.getFileSize() && currentMeta.getFileSize().length() != 0)\n                currentMeta.setFileSize(NumberFormat.getInstance().format(Long.parseLong(currentMeta.getFileSize())));\n            else\n                currentMeta.setFileSize(\"0\");\n        }\n        return srb;\n    }\n\n    public SearchResultBean mixResults(SearchResultBean srb, SearchResultBean hsrb) {\n        if (srb == null & hsrb == null) {\n            return new SearchResultBean();\n        } else if (srb == null)\n            return hsrb;\n        else if (hsrb == null)\n            return srb;\n        SearchResultBean rb = new SearchResultBean();\n        ShortMetadataResultBean[] hShortMetadataResultBean = null;\n        hShortMetadataResultBean = hsrb.getShortRecords();\n        ShortMetadataResultBean[] shortMetadataResultBean = null;\n        shortMetadataResultBean = srb.getShortRecords();\n        ShortMetadataResultBean[] smrb = new ShortMetadataResultBean[hShortMetadataResultBean.length + shortMetadataResultBean.length];\n        int beanLen = 0;\n        int sBeanLen = 0;\n        if (hShortMetadataResultBean.length > shortMetadataResultBean.length) {\n            beanLen = hShortMetadataResultBean.length;\n            sBeanLen = shortMetadataResultBean.length;\n        } else {\n            beanLen = shortMetadataResultBean.length;\n            sBeanLen = hShortMetadataResultBean.length;\n        }\n        int h = 0;\n        int m = 0;\n        int r = 0;\n        for (int a = 0; a < beanLen; a++) {\n            if ((hShortMetadataResultBean.length == sBeanLen && a < sBeanLen) || (hShortMetadataResultBean.length > sBeanLen) && hShortMetadataResultBean[h] != null) {\n                smrb[r++] = hShortMetadataResultBean[h++];\n            }\n            if ((shortMetadataResultBean.length == sBeanLen && a < sBeanLen) || (shortMetadataResultBean.length > sBeanLen) && shortMetadataResultBean[m] != null) {\n                smrb[r++] = shortMetadataResultBean[m++];\n            }\n            rb.setShortRecords(smrb);\n        }\n        return rb;\n    }\n\n    /**\n     * @return\n     */\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/WSSimpleSearchActionTest0.java",
		"test_prompt": "// WSSimpleSearchActionTest0.java\npackage org.heal.servlet;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.search.MerlotWS.SimpleMerlotSearch;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WSSimpleSearchAction}.\n* It contains ten unit test cases for the {@link WSSimpleSearchAction#prepareForInterface(SearchResultBean, InterfaceUtilitiesBean)} method.\n*/\nclass WSSimpleSearchActionTest0 {"
	},
	{
		"original_code": "// WSSimpleSearchAction.java\npackage org.heal.servlet;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.search.MerlotWS.SimpleMerlotSearch;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\n/**\n * An {@link Action} that handles a request to call MERLOT's SOAP based search methods.\n */\npublic class WSSimpleSearchAction implements Action {\n\n    /**\n     * @param servlet\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String keywords = new String();\n        keywords = request.getParameter(\"keywords\");\n        ShortMetadataBean currentMeta = null;\n        InterfaceUtilitiesBean interfaceUtilities = (InterfaceUtilitiesBean) servlet.getServletContext().getAttribute(\"interfaceUtilities\");\n        SimpleSearchDAO sd = (SimpleSearchDAO) servlet.getServletContext().getAttribute(\"SimpleSearchDAO\");\n        MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        SearchResultBean srb = null;\n        SimpleMerlotSearch sms = new SimpleMerlotSearch();\n        String library = new String();\n        library = request.getParameter(\"library\");\n        String library2 = new String();\n        library2 = request.getParameter(\"library2\");\n        SearchResultBean hsrb = null;\n        if (\"Merlot\".equals(library)) {\n            srb = sms.doSimpleMerlotSearch(keywords, 1, 25);\n            srb = prepareForInterface(srb, interfaceUtilities);\n        }\n        if (\"HEAL\".equals(library2)) {\n            ParameterBean pb = new ParameterBean(keywords);\n            try {\n                hsrb = sd.simpleSearch(pb, \"check\");\n                if (hsrb.getShortRecords() != null) {\n                    int hSearchLength = hsrb.getShortRecords().length;\n                    if (hSearchLength > 25)\n                        hSearchLength = 25;\n                    String metadataId = null;\n                    ShortMetadataBean hShortMetadata = null;\n                    ShortMetadataResultBean[] hShortMetadataResultBean = null;\n                    hShortMetadataResultBean = hsrb.getShortRecords();\n                    for (int b = 0; b < hSearchLength; b++) {\n                        hShortMetadata = hShortMetadataResultBean[b].getShortMetadata();\n                        metadataId = hShortMetadataResultBean[b].getMetadataId();\n                        currentMeta = metadataServices.getShortMetadata(metadataId);\n                        hShortMetadataResultBean[b].setShortMetadata(currentMeta);\n                    }\n                    ShortMetadataResultBean[] smr = new ShortMetadataResultBean[hSearchLength];\n                    for (int c = 0; c < hSearchLength; c++) {\n                        smr[c] = hShortMetadataResultBean[c];\n                    }\n                    hsrb.setShortRecords(smr);\n                    hsrb = prepareForInterface(hsrb, interfaceUtilities);\n                } else {\n                    hsrb = null;\n                }\n            } catch (SQLException se) {\n                se.printStackTrace();\n            }\n        }\n        SearchResultBean rb = new SearchResultBean();\n        rb = mixResults(srb, hsrb);\n        int healCount = 0;\n        int merlotCount = 0;\n        if (hsrb != null)\n            healCount = hsrb.getShortRecords().length;\n        if (srb != null)\n            merlotCount = srb.getShortRecords().length;\n        request.getSession().setAttribute(\"healCount\", healCount);\n        request.getSession().setAttribute(\"merlotCount\", merlotCount);\n        request.getSession().setAttribute(\"searchResults\", rb);\n        String queryString = request.getQueryString();\n        if (queryString == null || queryString.length() == 0) {\n            queryString = \"page=1\";\n        } else {\n            queryString = queryString + \"&page=1\";\n        }\n        String redirectURL = \"wsSearchResults?\" + queryString;\n        response.sendRedirect(redirectURL);\n    }\n\n    public SearchResultBean prepareForInterface(SearchResultBean srb, InterfaceUtilitiesBean interfaceUtilities) {\n        if (srb == null)\n            return null;\n        ShortMetadataResultBean[] smrb = null;\n        ShortMetadataBean currentMeta = null;\n        smrb = srb.getShortRecords();\n        int searchLength = srb.getShortRecords().length;\n        for (int a = 0; a < searchLength; a++) {\n            currentMeta = smrb[a].getShortMetadata();\n            String format = currentMeta.getFormat();\n            if (format == null || format.length() == 0) {\n                format = \"unknown\";\n            }\n            ThumbnailBean thumbnail = interfaceUtilities.getThumbnail(currentMeta.getThumbnail(), format, \"../\");\n            currentMeta.setThumbnail(thumbnail);\n            if (currentMeta.getDescription() == null || currentMeta.getDescription().length() == 0)\n                currentMeta.setDescription(\"No Description Available\");\n            currentMeta.setDescription(interfaceUtilities.getAbbreviatedString(currentMeta.getDescription(), 100));\n            // in the HEAL metadata filesize is required.\n            if (null != currentMeta.getFileSize() && currentMeta.getFileSize().length() != 0)\n                currentMeta.setFileSize(NumberFormat.getInstance().format(Long.parseLong(currentMeta.getFileSize())));\n            else\n                currentMeta.setFileSize(\"0\");\n        }\n        return srb;\n    }\n\n    public SearchResultBean mixResults(SearchResultBean srb, SearchResultBean hsrb) {\n        if (srb == null & hsrb == null) {\n            return new SearchResultBean();\n        } else if (srb == null)\n            return hsrb;\n        else if (hsrb == null)\n            return srb;\n        SearchResultBean rb = new SearchResultBean();\n        ShortMetadataResultBean[] hShortMetadataResultBean = null;\n        hShortMetadataResultBean = hsrb.getShortRecords();\n        ShortMetadataResultBean[] shortMetadataResultBean = null;\n        shortMetadataResultBean = srb.getShortRecords();\n        ShortMetadataResultBean[] smrb = new ShortMetadataResultBean[hShortMetadataResultBean.length + shortMetadataResultBean.length];\n        int beanLen = 0;\n        int sBeanLen = 0;\n        if (hShortMetadataResultBean.length > shortMetadataResultBean.length) {\n            beanLen = hShortMetadataResultBean.length;\n            sBeanLen = shortMetadataResultBean.length;\n        } else {\n            beanLen = shortMetadataResultBean.length;\n            sBeanLen = hShortMetadataResultBean.length;\n        }\n        int h = 0;\n        int m = 0;\n        int r = 0;\n        for (int a = 0; a < beanLen; a++) {\n            if ((hShortMetadataResultBean.length == sBeanLen && a < sBeanLen) || (hShortMetadataResultBean.length > sBeanLen) && hShortMetadataResultBean[h] != null) {\n                smrb[r++] = hShortMetadataResultBean[h++];\n            }\n            if ((shortMetadataResultBean.length == sBeanLen && a < sBeanLen) || (shortMetadataResultBean.length > sBeanLen) && shortMetadataResultBean[m] != null) {\n                smrb[r++] = shortMetadataResultBean[m++];\n            }\n            rb.setShortRecords(smrb);\n        }\n        return rb;\n    }\n\n    /**\n     * @return\n     */\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/WSSimpleSearchActionTest1.java",
		"test_prompt": "// WSSimpleSearchActionTest1.java\npackage org.heal.servlet;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.search.MerlotWS.SimpleMerlotSearch;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WSSimpleSearchAction}.\n* It contains ten unit test cases for the {@link WSSimpleSearchAction#mixResults(SearchResultBean, SearchResultBean)} method.\n*/\nclass WSSimpleSearchActionTest1 {"
	},
	{
		"original_code": "// WSSimpleSearchAction.java\npackage org.heal.servlet;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.search.MerlotWS.SimpleMerlotSearch;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\n/**\n * An {@link Action} that handles a request to call MERLOT's SOAP based search methods.\n */\npublic class WSSimpleSearchAction implements Action {\n\n    /**\n     * @param servlet\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String keywords = new String();\n        keywords = request.getParameter(\"keywords\");\n        ShortMetadataBean currentMeta = null;\n        InterfaceUtilitiesBean interfaceUtilities = (InterfaceUtilitiesBean) servlet.getServletContext().getAttribute(\"interfaceUtilities\");\n        SimpleSearchDAO sd = (SimpleSearchDAO) servlet.getServletContext().getAttribute(\"SimpleSearchDAO\");\n        MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        SearchResultBean srb = null;\n        SimpleMerlotSearch sms = new SimpleMerlotSearch();\n        String library = new String();\n        library = request.getParameter(\"library\");\n        String library2 = new String();\n        library2 = request.getParameter(\"library2\");\n        SearchResultBean hsrb = null;\n        if (\"Merlot\".equals(library)) {\n            srb = sms.doSimpleMerlotSearch(keywords, 1, 25);\n            srb = prepareForInterface(srb, interfaceUtilities);\n        }\n        if (\"HEAL\".equals(library2)) {\n            ParameterBean pb = new ParameterBean(keywords);\n            try {\n                hsrb = sd.simpleSearch(pb, \"check\");\n                if (hsrb.getShortRecords() != null) {\n                    int hSearchLength = hsrb.getShortRecords().length;\n                    if (hSearchLength > 25)\n                        hSearchLength = 25;\n                    String metadataId = null;\n                    ShortMetadataBean hShortMetadata = null;\n                    ShortMetadataResultBean[] hShortMetadataResultBean = null;\n                    hShortMetadataResultBean = hsrb.getShortRecords();\n                    for (int b = 0; b < hSearchLength; b++) {\n                        hShortMetadata = hShortMetadataResultBean[b].getShortMetadata();\n                        metadataId = hShortMetadataResultBean[b].getMetadataId();\n                        currentMeta = metadataServices.getShortMetadata(metadataId);\n                        hShortMetadataResultBean[b].setShortMetadata(currentMeta);\n                    }\n                    ShortMetadataResultBean[] smr = new ShortMetadataResultBean[hSearchLength];\n                    for (int c = 0; c < hSearchLength; c++) {\n                        smr[c] = hShortMetadataResultBean[c];\n                    }\n                    hsrb.setShortRecords(smr);\n                    hsrb = prepareForInterface(hsrb, interfaceUtilities);\n                } else {\n                    hsrb = null;\n                }\n            } catch (SQLException se) {\n                se.printStackTrace();\n            }\n        }\n        SearchResultBean rb = new SearchResultBean();\n        rb = mixResults(srb, hsrb);\n        int healCount = 0;\n        int merlotCount = 0;\n        if (hsrb != null)\n            healCount = hsrb.getShortRecords().length;\n        if (srb != null)\n            merlotCount = srb.getShortRecords().length;\n        request.getSession().setAttribute(\"healCount\", healCount);\n        request.getSession().setAttribute(\"merlotCount\", merlotCount);\n        request.getSession().setAttribute(\"searchResults\", rb);\n        String queryString = request.getQueryString();\n        if (queryString == null || queryString.length() == 0) {\n            queryString = \"page=1\";\n        } else {\n            queryString = queryString + \"&page=1\";\n        }\n        String redirectURL = \"wsSearchResults?\" + queryString;\n        response.sendRedirect(redirectURL);\n    }\n\n    public SearchResultBean prepareForInterface(SearchResultBean srb, InterfaceUtilitiesBean interfaceUtilities) {\n        if (srb == null)\n            return null;\n        ShortMetadataResultBean[] smrb = null;\n        ShortMetadataBean currentMeta = null;\n        smrb = srb.getShortRecords();\n        int searchLength = srb.getShortRecords().length;\n        for (int a = 0; a < searchLength; a++) {\n            currentMeta = smrb[a].getShortMetadata();\n            String format = currentMeta.getFormat();\n            if (format == null || format.length() == 0) {\n                format = \"unknown\";\n            }\n            ThumbnailBean thumbnail = interfaceUtilities.getThumbnail(currentMeta.getThumbnail(), format, \"../\");\n            currentMeta.setThumbnail(thumbnail);\n            if (currentMeta.getDescription() == null || currentMeta.getDescription().length() == 0)\n                currentMeta.setDescription(\"No Description Available\");\n            currentMeta.setDescription(interfaceUtilities.getAbbreviatedString(currentMeta.getDescription(), 100));\n            // in the HEAL metadata filesize is required.\n            if (null != currentMeta.getFileSize() && currentMeta.getFileSize().length() != 0)\n                currentMeta.setFileSize(NumberFormat.getInstance().format(Long.parseLong(currentMeta.getFileSize())));\n            else\n                currentMeta.setFileSize(\"0\");\n        }\n        return srb;\n    }\n\n    public SearchResultBean mixResults(SearchResultBean srb, SearchResultBean hsrb) {\n        if (srb == null & hsrb == null) {\n            return new SearchResultBean();\n        } else if (srb == null)\n            return hsrb;\n        else if (hsrb == null)\n            return srb;\n        SearchResultBean rb = new SearchResultBean();\n        ShortMetadataResultBean[] hShortMetadataResultBean = null;\n        hShortMetadataResultBean = hsrb.getShortRecords();\n        ShortMetadataResultBean[] shortMetadataResultBean = null;\n        shortMetadataResultBean = srb.getShortRecords();\n        ShortMetadataResultBean[] smrb = new ShortMetadataResultBean[hShortMetadataResultBean.length + shortMetadataResultBean.length];\n        int beanLen = 0;\n        int sBeanLen = 0;\n        if (hShortMetadataResultBean.length > shortMetadataResultBean.length) {\n            beanLen = hShortMetadataResultBean.length;\n            sBeanLen = shortMetadataResultBean.length;\n        } else {\n            beanLen = shortMetadataResultBean.length;\n            sBeanLen = hShortMetadataResultBean.length;\n        }\n        int h = 0;\n        int m = 0;\n        int r = 0;\n        for (int a = 0; a < beanLen; a++) {\n            if ((hShortMetadataResultBean.length == sBeanLen && a < sBeanLen) || (hShortMetadataResultBean.length > sBeanLen) && hShortMetadataResultBean[h] != null) {\n                smrb[r++] = hShortMetadataResultBean[h++];\n            }\n            if ((shortMetadataResultBean.length == sBeanLen && a < sBeanLen) || (shortMetadataResultBean.length > sBeanLen) && shortMetadataResultBean[m] != null) {\n                smrb[r++] = shortMetadataResultBean[m++];\n            }\n            rb.setShortRecords(smrb);\n        }\n        return rb;\n    }\n\n    /**\n     * @return\n     */\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/WSSimpleSearchActionTest2.java",
		"test_prompt": "// WSSimpleSearchActionTest2.java\npackage org.heal.servlet;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport org.heal.module.metadata.*;\nimport org.heal.module.search.*;\nimport org.heal.module.search.MerlotWS.SimpleMerlotSearch;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WSSimpleSearchAction}.\n* It contains ten unit test cases for the {@link WSSimpleSearchAction#actionRequiresLogin()} method.\n*/\nclass WSSimpleSearchActionTest2 {"
	},
	{
		"original_code": "// RemoveFromDownloadAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class RemoveFromDownloadAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        DownloadQueueBean downloadQueue = (DownloadQueueBean) request.getSession().getAttribute(\"downloadQueue\");\n        boolean removeAll = (request.getParameter(\"all\") != null);\n        String[] contentIds = request.getParameterValues(\"downloadIds\");\n        if (removeAll) {\n            downloadQueue.removeAllFromQueue();\n        } else if (contentIds != null) {\n            for (int i = 0; i < contentIds.length; i++) {\n                downloadQueue.removeFromQueue(contentIds[i]);\n            }\n        }\n        String origURL = request.getParameter(\"origURL\");\n        if (origURL == null || origURL.length() < 1) {\n            origURL = \"viewDownloadFolder\";\n        }\n        System.err.println(origURL);\n        response.sendRedirect(origURL);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    public boolean isAuthenticatedAction() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/RemoveFromDownloadActionTest0.java",
		"test_prompt": "// RemoveFromDownloadActionTest0.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RemoveFromDownloadAction}.\n* It contains ten unit test cases for the {@link RemoveFromDownloadAction#actionRequiresLogin()} method.\n*/\nclass RemoveFromDownloadActionTest0 {"
	},
	{
		"original_code": "// RemoveFromDownloadAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class RemoveFromDownloadAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        DownloadQueueBean downloadQueue = (DownloadQueueBean) request.getSession().getAttribute(\"downloadQueue\");\n        boolean removeAll = (request.getParameter(\"all\") != null);\n        String[] contentIds = request.getParameterValues(\"downloadIds\");\n        if (removeAll) {\n            downloadQueue.removeAllFromQueue();\n        } else if (contentIds != null) {\n            for (int i = 0; i < contentIds.length; i++) {\n                downloadQueue.removeFromQueue(contentIds[i]);\n            }\n        }\n        String origURL = request.getParameter(\"origURL\");\n        if (origURL == null || origURL.length() < 1) {\n            origURL = \"viewDownloadFolder\";\n        }\n        System.err.println(origURL);\n        response.sendRedirect(origURL);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    public boolean isAuthenticatedAction() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/RemoveFromDownloadActionTest1.java",
		"test_prompt": "// RemoveFromDownloadActionTest1.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RemoveFromDownloadAction}.\n* It contains ten unit test cases for the {@link RemoveFromDownloadAction#isAuthenticatedAction()} method.\n*/\nclass RemoveFromDownloadActionTest1 {"
	},
	{
		"original_code": "// ViewDownloadFolderAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.download.DownloadDAO;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class ViewDownloadFolderAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        DownloadQueueBean downloadQueue = (DownloadQueueBean) request.getSession().getAttribute(\"downloadQueue\");\n        if (downloadQueue == null) {\n            downloadQueue = new DownloadQueueBean();\n            request.getSession().setAttribute(\"downloadQueue\", downloadQueue);\n        }\n        MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        //MetadataServicesBean metadataServices = (MetadataServicesBean) servlet.getServletContext().getAttribute(\"metadataServices\");\n        InterfaceUtilitiesBean interfaceUtilities = (InterfaceUtilitiesBean) servlet.getServletContext().getAttribute(\"interfaceUtilities\");\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        Collection contentIds;\n        Iterator idIterator = null;\n        String metadataId = null;\n        contentIds = downloadQueue.getContentIds();\n        idIterator = contentIds.iterator();\n        ShortMetadataBean[] currentMeta = null;\n        int i = 0;\n        //ShortMetadataBean currentMeta;\n        if (contentIds.size() > 0)\n            currentMeta = new ShortMetadataBean[contentIds.size()];\n        while (idIterator.hasNext()) {\n            metadataId = (String) idIterator.next();\n            //System.err.println(metadataId);\n            try {\n                currentMeta[i] = metadataServices.getShortMetadata(metadataId);\n                //System.err.println(\"n\" + currentMeta[i].getMetadataId());\n                String format = currentMeta[i].getFormat();\n                if (format == null) {\n                    format = \"unknown\";\n                    currentMeta[i].setFormat(format);\n                }\n                ThumbnailBean thumbnail = interfaceUtilities.getThumbnail(currentMeta[i].getThumbnail(), format, \"../\");\n                currentMeta[i].setThumbnail(thumbnail);\n                currentMeta[i].setLocation(healFileLocator.getContentURL(currentMeta[i].getLocation()));\n                currentMeta[i].setDescription(interfaceUtilities.getAbbreviatedString(currentMeta[i].getDescription(), 100));\n                currentMeta[i].setFileSize(NumberFormat.getInstance().format(Long.parseLong(currentMeta[i].getFileSize())));\n            } catch (SQLException e) {\n                System.err.println(e);\n            }\n            i++;\n        }\n        //+\"?\"+request.getQueryString();\n        String origURL = \"../healapp/viewDownloadFolder\";\n        request.setAttribute(\"origURL\", origURL);\n        request.setAttribute(\"currentMeta\", currentMeta);\n        String forwardURL = \"/download/viewqueue.jsp\";\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(forwardURL);\n        rd.forward(request, response);\n        return;\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/ViewDownloadFolderActionTest.java",
		"test_prompt": "// ViewDownloadFolderActionTest.java\npackage org.heal.servlet;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.download.DownloadDAO;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport org.heal.util.InterfaceUtilitiesBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ViewDownloadFolderAction}.\n* It contains ten unit test cases for the {@link ViewDownloadFolderAction#actionRequiresLogin()} method.\n*/\nclass ViewDownloadFolderActionTest {"
	},
	{
		"original_code": "// SubmitTagsAction.java\npackage org.heal.servlet.tagcloud;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.StringTokenizer;\nimport org.heal.servlet.*;\n\npublic class SubmitTagsAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String taglist;\n        String metadataId;\n        String userId;\n        String nextToken, nextToken2;\n        TagBean tagEntry = new TagBean();\n        TagCloudDAO tagCloudRegistry = (TagCloudDAO) servlet.getServletContext().getAttribute(\"TagCloudDAO\");\n        taglist = request.getParameter(\"taglist\");\n        metadataId = request.getParameter(\"metadataId\");\n        userId = request.getParameter(\"userId\");\n        // separate the tag list into individual tokens.\n        StringTokenizer tags = new StringTokenizer(taglist, \",\");\n        while (tags.hasMoreTokens()) {\n            nextToken = tags.nextToken().trim();\n            StringTokenizer tags2 = new StringTokenizer(nextToken, \";\");\n            while (tags2.hasMoreTokens()) {\n                nextToken2 = tags2.nextToken().trim();\n                if (nextToken2.length() != 0) {\n                    tagEntry.setTag(nextToken2);\n                    tagEntry.setMetadataId(metadataId);\n                    tagEntry.setUserId(userId);\n                    try {\n                        // saves the bean into database.\n                        tagCloudRegistry.saveTagEntry(tagEntry);\n                    } catch (SQLException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        response.sendRedirect(\"../tagcloud/tagsubmit_response.jsp?metadataId=\" + metadataId);\n    }\n\n    // login is required to view this page.\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/tagcloud/SubmitTagsActionTest.java",
		"test_prompt": "// SubmitTagsActionTest.java\npackage org.heal.servlet.tagcloud;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.StringTokenizer;\nimport org.heal.servlet.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SubmitTagsAction}.\n* It contains ten unit test cases for the {@link SubmitTagsAction#actionRequiresLogin()} method.\n*/\nclass SubmitTagsActionTest {"
	},
	{
		"original_code": "// InputTagsFormAction.java\npackage org.heal.servlet.tagcloud;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n// used to bring up the user review form.\npublic class InputTagsFormAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        RequestDispatcher rd;\n        String formURL = \"/tagcloud/tagform.jsp?\" + request.getQueryString();\n        rd = request.getRequestDispatcher(formURL);\n        rd.forward(request, response);\n    }\n\n    // login is required to view this page.\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/tagcloud/InputTagsFormActionTest.java",
		"test_prompt": "// InputTagsFormActionTest.java\npackage org.heal.servlet.tagcloud;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InputTagsFormAction}.\n* It contains ten unit test cases for the {@link InputTagsFormAction#actionRequiresLogin()} method.\n*/\nclass InputTagsFormActionTest {"
	},
	{
		"original_code": "// ShowTopTagsAction.java\npackage org.heal.servlet.tagcloud;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\n\n// shows the top 10 most highly rated resources.\npublic class ShowTopTagsAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        final TagCloudDAO tagCloudRegistry = (TagCloudDAO) servlet.getServletContext().getAttribute(\"TagCloudDAO\");\n        ArrayList tagArray = new ArrayList();\n        try {\n            tagArray = tagCloudRegistry.getTopTags();\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        String origURL = \"../healapp/showMetadata?\" + request.getQueryString();\n        request.setAttribute(\"origURL\", origURL);\n        request.setAttribute(\"tagArray\", tagArray);\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(\"/tagcloud/toptags.jsp\");\n        rd.forward(request, response);\n    }\n\n    // login is not required to view this page.\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/tagcloud/ShowTopTagsActionTest.java",
		"test_prompt": "// ShowTopTagsActionTest.java\npackage org.heal.servlet.tagcloud;\n\nimport org.heal.servlet.*;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowTopTagsAction}.\n* It contains ten unit test cases for the {@link ShowTopTagsAction#actionRequiresLogin()} method.\n*/\nclass ShowTopTagsActionTest {"
	},
	{
		"original_code": "// ShowRegistrationInfoAction.java\npackage org.heal.servlet;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class ShowRegistrationInfoAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String type = new String();\n        type = request.getParameter(\"type\");\n        RequestDispatcher rd;\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        //request.setAttribute(\"validUser\", user);\n        setUserAttributes(request, user);\n        //System.out.println(\"type=\"+type);\n        if (\"modify\".equals(type) || (!user.isLoginModified()))\n            rd = request.getRequestDispatcher(\"/user/modifyLogin.jsp\");\n        else\n            rd = request.getRequestDispatcher(\"/user/update.jsp\");\n        rd.forward(request, response);\n        return;\n    }\n\n    public void setUserAttributes(HttpServletRequest request, UserBean user) {\n        ArrayList ilb = new ArrayList();\n        ArrayList instructionalLevel = null;\n        ArrayList professionalRole = null;\n        instructionalLevel = user.getInstructionalLevel();\n        Iterator it = instructionalLevel.iterator();\n        while (it.hasNext()) {\n            InstructionalLevelBean instructionalLevelBean = (InstructionalLevelBean) it.next();\n            ilb.add(instructionalLevelBean.getInstructionalLevel());\n        }\n        ArrayList prb = new ArrayList();\n        professionalRole = user.getProfessionalRole();\n        it = professionalRole.iterator();\n        while (it.hasNext()) {\n            ProfessionalRoleBean professionalRoleBean = (ProfessionalRoleBean) it.next();\n            String pr = professionalRoleBean.getProfessionalRole();\n            if ((!\"Faculty Member/Instructor/Lecturer\".equalsIgnoreCase(pr)) && (!\"Course Director\".equalsIgnoreCase(pr)) && (!\"Residency Program Director\".equalsIgnoreCase(pr)) && (!\"Instructional Developer\".equalsIgnoreCase(pr)) && (!\"Dean or Other Administrator\".equalsIgnoreCase(pr)) && (!\"Student or Resident\".equalsIgnoreCase(pr)) && (!\"Librarian\".equalsIgnoreCase(pr))) {\n                request.setAttribute(\"professionalRoleOtherText\", professionalRoleBean.getProfessionalRole());\n                prb.add(\"Other\");\n            } else\n                prb.add(professionalRoleBean.getProfessionalRole());\n        }\n        request.setAttribute(\"validUser\", user);\n        request.setAttribute(\"prb\", prb);\n        request.setAttribute(\"ilb\", ilb);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/ShowRegistrationInfoActionTest.java",
		"test_prompt": "// ShowRegistrationInfoActionTest.java\npackage org.heal.servlet;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowRegistrationInfoAction}.\n* It contains ten unit test cases for the {@link ShowRegistrationInfoAction#actionRequiresLogin()} method.\n*/\nclass ShowRegistrationInfoActionTest {"
	},
	{
		"original_code": "// EmailFeedbackAction.java\npackage org.heal.servlet;\n\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * An {@link Action} which emails form data\n */\npublic class EmailFeedbackAction implements Action {\n\n    public static final String DEFAULT_FROM = new String(\"info@healcentral.org\");\n\n    public static final String DEFAULT_SUBJECT = new String(\"HEALCENTRAL.ORG mailer\");\n\n    public static final String DEFAULT_BODY = new String();\n\n    public static final String LINE_SEPARATOR = System.getProperty(\"line.separator\");\n\n    private final String smtpServer;\n\n    private final String xmlFilename;\n\n    public EmailFeedbackAction(String smtpServer, String xmlFilename) {\n        this.smtpServer = smtpServer;\n        this.xmlFilename = xmlFilename;\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        saveXml(request.getParameterMap());\n        sendEmail(request.getParameterMap());\n        RequestDispatcher rd = request.getRequestDispatcher(\"/feedback/mail_logged_response.html\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n\n    /**\n     * Sends an email according to the parameters indicated\n     *\n     * @param parameters A <code>Map</code> representing the variables\n     * submitted to the servlet.\n     *\n     * @return <code>true</code> if an email was sent, otherwise <code>false</code>.\n     */\n    private boolean sendEmail(final Map parameters) {\n        Map formVariables = new HashMap(parameters);\n        String to = join((String[]) formVariables.get(\"to\"), LINE_SEPARATOR);\n        String from = join((String[]) formVariables.get(\"from\"), LINE_SEPARATOR);\n        String subject = join((String[]) formVariables.get(\"subject\"), LINE_SEPARATOR);\n        String body = join((String[]) formVariables.get(\"body\"), LINE_SEPARATOR);\n        formVariables.remove(\"to\");\n        formVariables.remove(\"from\");\n        formVariables.remove(\"subject\");\n        formVariables.remove(\"body\");\n        if (null == to) {\n            // This field is required\n            return false;\n        }\n        if (null == from) {\n            from = DEFAULT_FROM;\n        }\n        if (null == subject) {\n            subject = DEFAULT_SUBJECT;\n        }\n        if (null == body) {\n            body = DEFAULT_BODY;\n        }\n        StringBuffer extra = new StringBuffer();\n        for (Object temp : formVariables.entrySet()) {\n            Map.Entry entry = (Map.Entry) temp;\n            extra.append(entry.getKey()).append(\" = \").append(join((String[]) entry.getValue(), LINE_SEPARATOR)).append(LINE_SEPARATOR);\n        }\n        try {\n            Properties props = System.getProperties();\n            props.put(\"mail.smtp.host\", smtpServer);\n            Session session = Session.getDefaultInstance(props, null);\n            // Constructs the email from the form variables\n            StringBuffer msg = new StringBuffer();\n            msg.append(body);\n            if (extra.length() > 0) {\n                msg.append(\"\\n\");\n                msg.append(\"-------\\n\");\n                msg.append(extra.toString());\n            }\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(subject);\n            message.setText(msg.toString());\n            Transport.send(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Saves the form data to an xml file.\n     *\n     * @param formVariables\n     *\n     * @throws IOException\n     */\n    private synchronized void saveXml(Map formVariables) throws IOException {\n        boolean fileExists = false;\n        File file = new File(xmlFilename);\n        if (file.exists()) {\n            fileExists = true;\n        }\n        RandomAccessFile xmlFile = new RandomAccessFile(xmlFilename, \"rw\");\n        xmlFile.seek(xmlFile.length());\n        if (!fileExists) {\n            xmlFile.writeBytes(\"<?xml version=\\\"1.0\\\"?>\" + LINE_SEPARATOR);\n            xmlFile.writeBytes(\"<!DOCTYPE records\" + LINE_SEPARATOR);\n            xmlFile.writeBytes(\"[\" + LINE_SEPARATOR);\n            xmlFile.writeBytes(\"<!ELEMENT records (record)+>\" + LINE_SEPARATOR);\n            xmlFile.writeBytes(\"<!ELEMENT record (\");\n            StringBuffer fieldNameList = new StringBuffer();\n            StringBuffer elementList = new StringBuffer();\n            for (Object key : formVariables.keySet()) {\n                String fieldName = (String) key;\n                if (fieldNameList.length() > 0) {\n                    fieldNameList.append(\",\" + fieldName);\n                } else {\n                    fieldNameList.append(fieldName);\n                }\n                elementList.append(\"<!ELEMENT \" + fieldName + \" (#PCDATA)>\" + LINE_SEPARATOR);\n            }\n            xmlFile.writeBytes(fieldNameList.toString() + \")>\" + LINE_SEPARATOR);\n            xmlFile.writeBytes(elementList.toString());\n            xmlFile.writeBytes(\"]>\" + LINE_SEPARATOR);\n            xmlFile.writeBytes(\"<records>\" + LINE_SEPARATOR);\n        } else {\n            xmlFile.seek(xmlFile.length() - (long) \"records\".length() - (long) LINE_SEPARATOR.length() - 3L);\n        }\n        xmlFile.writeBytes(\"<record>\" + LINE_SEPARATOR);\n        for (Object entry : formVariables.entrySet()) {\n            final String fieldName = (String) ((Map.Entry) entry).getKey();\n            final String fieldValue = join((String[]) ((Map.Entry) entry).getValue(), LINE_SEPARATOR);\n            xmlFile.writeBytes(\"<\" + fieldName + \">\" + fieldValue + \"</\" + fieldName + \">\" + LINE_SEPARATOR);\n        }\n        xmlFile.writeBytes(\"</record>\" + LINE_SEPARATOR);\n        xmlFile.writeBytes(\"</records>\" + LINE_SEPARATOR);\n        xmlFile.close();\n    }\n\n    private static final String join(String[] arr, String delim) {\n        if (null == arr) {\n            return null;\n        }\n        StringBuffer buffer = new StringBuffer();\n        final int lastElement = arr.length - 1;\n        for (int i = 0; i < arr.length; ++i) {\n            buffer.append(arr[i]);\n            if (i < lastElement) {\n                buffer.append(delim);\n            }\n        }\n        return buffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/EmailFeedbackActionTest.java",
		"test_prompt": "// EmailFeedbackActionTest.java\npackage org.heal.servlet;\n\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EmailFeedbackAction}.\n* It contains ten unit test cases for the {@link EmailFeedbackAction#actionRequiresLogin()} method.\n*/\nclass EmailFeedbackActionTest {"
	},
	{
		"original_code": "// RegistrationAction.java\npackage org.heal.servlet;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\n\npublic class RegistrationAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String action = request.getParameter(\"action\");\n        Vector errorMessages = new Vector();\n        UserRegistryBean userRegistry = (UserRegistryBean) servlet.getServletContext().getAttribute(\"userRegistry\");\n        RequestDispatcher rd;\n        UserBean user = (UserBean) request.getSession().getAttribute(\"validUser\");\n        String firstName, lastName, middleInitial, professionalTitle, professionalSpecialty, areaOfExpertise, professionalRoleOther, professionalRoleOtherText, userName = \"\", phoneNumber, email, aminor, institutionName, mailingListS = \"\", address1, address2, postalCode, city, state, country, emailConfirm = \"\", password = \"\", passwordConfirm;\n        String[] instructionalLevel = null, professionalRole = null;\n        UserBean userEntry = new UserBean();\n        if (\"create\".equals(action)) {\n            user = new UserBean();\n            try {\n                if ((userName = request.getParameter(\"email\")) == null || userName.length() == 0) {\n                    errorMessages.addElement(\"E-mail address missing\");\n                } else if (userRegistry.userExists(userName)) {\n                    errorMessages.addElement(\"User \" + userName + \" already exists, please try another email address.\");\n                }\n                user.setUserName(userName);\n                if ((password = request.getParameter(\"password\")) == null || password.length() == 0) {\n                    errorMessages.addElement(\"Password missing\");\n                }\n                if ((passwordConfirm = request.getParameter(\"passwordconfirm\")) == null || passwordConfirm.length() == 0) {\n                    errorMessages.addElement(\"Password confirmation missing\");\n                }\n            } catch (SQLException ex) {\n                // do something\n            }\n        }\n        if (action.equals(\"update\") || action.equals(\"modify\")) {\n            userName = user.getUserName();\n            if (userName == null || userName.length() == 0) {\n                errorMessages.addElement(\"Unable to determine the username, please logout.\");\n            }\n            password = request.getParameter(\"password\");\n            passwordConfirm = request.getParameter(\"passwordconfirm\");\n            if (password == null || password.length() == 0) {\n                //we didn't receive a password setting from the form...\n                if (passwordConfirm != null && passwordConfirm.length() > 0) {\n                    //but we did get one for password confirm, so there is a mismatch\n                    errorMessages.addElement(\"Password and password confirmation do not match.\");\n                } else {\n                    //both were empty, so we set the password to that in the bean\n                    //if (action.equals(\"create\"))\n                    password = user.getPassword();\n                }\n            } else {\n                //password entry in the form wasn't empty\n                if (passwordConfirm == null || passwordConfirm.length() == 0) {\n                    errorMessages.addElement(\"Password confirmation was empty.\");\n                } else if (!passwordConfirm.equals(password)) {\n                    errorMessages.addElement(\"Password and password confirmation do not match.\");\n                }\n            }\n        }\n        emailConfirm = request.getParameter(\"emailConfirm\");\n        if (userName != null && userName.length() != 0) {\n            if ((!action.equals(\"update\")) && (!StringFormat.isValidEmailAddr(request.getParameter(\"email\")))) {\n                errorMessages.addElement(\"Invalid E-mail address\");\n            }\n            if (!emailConfirm.equals(request.getParameter(\"email\"))) {\n                errorMessages.addElement(\"Email confirmation does not match\");\n            }\n        }\n        if ((professionalRole = request.getParameterValues(\"professionalRole\")) == null || professionalRole.length == 0 || professionalRole[0].length() == 0) {\n            errorMessages.addElement(\"Professional Role missing\");\n        }\n        professionalRoleOther = request.getParameter(\"professionalRoleOther\");\n        professionalRoleOtherText = request.getParameter(\"professionalRoleOtherText\").trim();\n        if (professionalRole != null) {\n            for (int a = 0; a < professionalRole.length; a++) {\n                if (\"Other\".equals(professionalRole[a])) {\n                    if (professionalRoleOtherText == null || professionalRoleOtherText.length() == 0) {\n                        errorMessages.addElement(\"Enter value for Professional Role: Other\");\n                    }\n                }\n            }\n        }\n        if ((areaOfExpertise = request.getParameter(\"areaOfExpertise\")) == null || areaOfExpertise.length() == 0) {\n            errorMessages.addElement(\"Area of Expertise missing\");\n        }\n        if (action.equals(\"update\") || action.equals(\"create\")) {\n            if ((firstName = request.getParameter(\"firstName\").trim()) == null || firstName.length() == 0) {\n                errorMessages.addElement(\"First Name missing\");\n            }\n            if ((lastName = request.getParameter(\"lastName\").trim()) == null || lastName.length() == 0) {\n                errorMessages.addElement(\"Last Name missing\");\n            }\n            if ((mailingListS = request.getParameter(\"isMailingList\")) == null || mailingListS.length() == 0) {\n                errorMessages.addElement(\"Please indicate if you want to be on the mailing list\");\n            }\n            if ((institutionName = request.getParameter(\"institutionName\").trim()) == null || institutionName.length() == 0) {\n                errorMessages.addElement(\"Institution Name missing\");\n            }\n            if ((city = request.getParameter(\"city\").trim()) == null || city.length() == 0) {\n                errorMessages.addElement(\"City missing\");\n            }\n            if ((state = request.getParameter(\"state\").trim()) == null || state.length() == 0) {\n                errorMessages.addElement(\"State missing\");\n            }\n            if ((country = request.getParameter(\"country\").trim()) == null || country.length() == 0) {\n                errorMessages.addElement(\"Country missing\");\n            }\n        }\n        if ((action.equals(\"create\")) && (errorMessages.size() > 0)) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            request.setAttribute(\"validUser\", userEntry);\n            ArrayList ilb = new ArrayList();\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        //InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.add(instructionalLevel[a]);\n                        //userEntry.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        //ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        prb.add(professionalRole[a]);\n                        //userEntry.addProfessionalRole(prb);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            rd = request.getRequestDispatcher(\"/user/register.jsp\");\n            rd.forward(request, response);\n            return;\n        } else if ((action.equals(\"update\")) && (errorMessages.size() > 0)) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            //UserBean userEntry = new UserBean();\n            userEntry.setFirstName(request.getParameter(\"firstName\"));\n            userEntry.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            userEntry.setLastName(request.getParameter(\"lastName\"));\n            ArrayList ilb = new ArrayList();\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        //InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.add(instructionalLevel[a]);\n                        //userEntry.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        //ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        prb.add(professionalRole[a]);\n                        //userEntry.addProfessionalRole(prb);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            userEntry.setEmail(request.getParameter(\"email\"));\n            userEntry.setInstitutionName(request.getParameter(\"institutionName\"));\n            userEntry.setAddress1(request.getParameter(\"address1\"));\n            userEntry.setAddress2(request.getParameter(\"address2\"));\n            userEntry.setState(request.getParameter(\"state\"));\n            userEntry.setCity(request.getParameter(\"city\"));\n            userEntry.setZipCode(request.getParameter(\"zipCode\"));\n            userEntry.setCountry(request.getParameter(\"country\"));\n            request.setAttribute(\"validUser\", userEntry);\n            rd = request.getRequestDispatcher(\"/user/update.jsp\");\n            rd.forward(request, response);\n        } else if ((action.equals(\"modify\")) && (errorMessages.size() > 0)) {\n            request.setAttribute(\"errorMessages\", errorMessages);\n            //UserBean userEntry = new UserBean();\n            userEntry.setFirstName(request.getParameter(\"firstName\"));\n            userEntry.setMiddleInitial(request.getParameter(\"middleInitial\"));\n            userEntry.setLastName(request.getParameter(\"lastName\"));\n            //System.err.println(\"hereee\");\n            ArrayList ilb = new ArrayList();\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        //InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.add(instructionalLevel[a]);\n                        //userEntry.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            ArrayList prb = new ArrayList();\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        //ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        prb.add(professionalRole[a]);\n                        //userEntry.addProfessionalRole(prb);\n                    }\n                }\n            }\n            request.setAttribute(\"professionalRoleOtherText\", professionalRoleOtherText);\n            request.setAttribute(\"prb\", prb);\n            request.setAttribute(\"ilb\", ilb);\n            userEntry.setProfessionalSpecialty(areaOfExpertise);\n            userEntry.setEmail(request.getParameter(\"email\"));\n            //userEntry.setEmail(user.getEmail());\n            userEntry.setInstitutionName(request.getParameter(\"institutionName\"));\n            userEntry.setAddress1(request.getParameter(\"address1\"));\n            userEntry.setAddress2(request.getParameter(\"address2\"));\n            userEntry.setState(request.getParameter(\"state\"));\n            userEntry.setCity(request.getParameter(\"city\"));\n            userEntry.setZipCode(request.getParameter(\"zipCode\"));\n            userEntry.setCountry(request.getParameter(\"country\"));\n            request.setAttribute(\"validUser\", userEntry);\n            rd = request.getRequestDispatcher(\"/user/modifyLogin.jsp\");\n            rd.forward(request, response);\n        } else {\n            if (action.equals(\"update\") || action.equals(\"create\")) {\n                user.setFirstName(request.getParameter(\"firstName\").trim());\n                user.setMiddleInitial(request.getParameter(\"middleInitial\"));\n                user.setLastName(request.getParameter(\"lastName\").trim());\n                user.setInstitutionName(request.getParameter(\"institutionName\").trim());\n                user.setAddress1(request.getParameter(\"address1\"));\n                user.setAddress2(request.getParameter(\"address2\"));\n                user.setState(request.getParameter(\"state\").trim());\n                user.setCity(request.getParameter(\"city\").trim());\n                user.setZipCode(request.getParameter(\"zipCode\"));\n                //user.setLoginModified(true);\n                user.setCountry(request.getParameter(\"country\").trim());\n                //System.err.println(\"status=\"+user.isEmailValidated());\n                boolean minor = false;\n                boolean mailingList = true;\n                String minorS = (request.getParameter(\"aminor\"));\n                if (\"yes\".equals(minorS))\n                    minor = true;\n                if (\"no\".equals(mailingListS))\n                    mailingList = false;\n                user.setMinor(minor);\n                user.setMailingList(mailingList);\n            }\n            user.setLoginModified(true);\n            instructionalLevel = request.getParameterValues(\"instructionalLevel\");\n            user.setInstructionalLevel(new ArrayList());\n            if ((instructionalLevel != null && instructionalLevel.length > 0)) {\n                for (int a = 0; a < instructionalLevel.length; a++) {\n                    if (instructionalLevel[a].length() > 0) {\n                        InstructionalLevelBean ilb = new InstructionalLevelBean();\n                        ilb.setInstructionalLevel(instructionalLevel[a]);\n                        user.addInstructionalLevel(ilb);\n                    }\n                }\n            }\n            if ((professionalRole != null && professionalRole.length > 0)) {\n                user.setProfessionalRole(new ArrayList());\n                for (int a = 0; a < professionalRole.length; a++) {\n                    if (professionalRole[a].length() > 0) {\n                        ProfessionalRoleBean prb = new ProfessionalRoleBean();\n                        if (\"Other\".equalsIgnoreCase(professionalRole[a]))\n                            prb.setProfessionalRole(professionalRoleOtherText);\n                        else\n                            prb.setProfessionalRole(professionalRole[a]);\n                        user.addProfessionalRole(prb);\n                    }\n                }\n            }\n            user.setProfessionalSpecialty(areaOfExpertise);\n            if (action.equals(\"create\"))\n                user.setEmail(request.getParameter(\"email\"));\n            user.setPassword(password);\n            String userId = \"\";\n            String userId2 = \"\";\n            try {\n                userId2 = userRegistry.saveRegistration(user);\n            } catch (SQLException e) {\n                System.err.println(e.toString());\n            }\n            userId = user.getUserId();\n            if (userId == null || userId.length() == 0) {\n                userId = userId2;\n            }\n            if (action.equals(\"modify\") || action.equals(\"create\")) {\n                NotificationServicesBean nsb = (NotificationServicesBean) servlet.getServletContext().getAttribute(\"notificationServices\");\n                FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n                try {\n                    nsb.sendUsernameValidationEmail(user, healFileLocator.getServerBaseURL() + \"/healapp/emailValidation?emailId=\" + userId + \"&email=\" + user.getEmail());\n                } catch (MessagingException m) {\n                    m.printStackTrace();\n                }\n            }\n            request.getSession().setAttribute(\"validUser\", user);\n            String from = request.getParameter(\"action\");\n            String origURL = request.getParameter(\"origURL\");\n            //<%-- Redirect to the notice page--%>\n            String redirect = \"../index.jsp\";\n            if (\"modify\".equals(from)) {\n                if ((origURL != null) && (origURL.length() > 0))\n                    redirect = origURL;\n            }\n            if (\"modify\".equals(from)) {\n                response.sendRedirect(redirect);\n                if (\"update\".equals(from))\n                    response.sendRedirect(\"../user/update_response.jsp \");\n            } else {\n                response.sendRedirect(\"../user/register_response.jsp\");\n            }\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n    //response.sendRedirect(redirectURL);\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/RegistrationActionTest.java",
		"test_prompt": "// RegistrationActionTest.java\npackage org.heal.servlet;\n\nimport com.ora.jsp.util.StringFormat;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport javax.mail.MessagingException;\nimport org.heal.module.notice.NotificationServicesBean;\nimport org.heal.module.user.InstructionalLevelBean;\nimport org.heal.module.user.ProfessionalRoleBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport org.heal.util.FileLocator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistrationAction}.\n* It contains ten unit test cases for the {@link RegistrationAction#actionRequiresLogin()} method.\n*/\nclass RegistrationActionTest {"
	},
	{
		"original_code": "// ShowUploadFormAction.java\npackage org.heal.servlet.upload;\n\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Map;\n\npublic class ShowUploadFormAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String continueSubmission = request.getParameter(\"continueSubmission\");\n        Map storedParameters = (Map) request.getSession().getAttribute(\"requestParameters\");\n        if (\"samePub\".equals(continueSubmission) && storedParameters != null) {\n            SimpleUploadAction.setupAttributes(request, storedParameters);\n        } else {\n            request.setAttribute(\"creationDate\", DateTools.format(new Date()));\n        }\n        request.getSession().removeAttribute(\"requestParameters\");\n        RequestDispatcher rd = request.getRequestDispatcher(\"/upload2/uploadform.jsp\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/upload/ShowUploadFormActionTest.java",
		"test_prompt": "// ShowUploadFormActionTest.java\npackage org.heal.servlet.upload;\n\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShowUploadFormAction}.\n* It contains ten unit test cases for the {@link ShowUploadFormAction#actionRequiresLogin()} method.\n*/\nclass ShowUploadFormActionTest {"
	},
	{
		"original_code": "// PreviewUploadAction.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.MultipartRequest;\nimport com.oreilly.servlet.multipart.FileRenamePolicy;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.upload.UploadServicesBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Vector;\nimport org.heal.servlet.upload.AlphanumericFileRenamePolicy;\n\npublic class PreviewUploadAction implements Action {\n\n    private static final FileRenamePolicy fileRenamePolicy = new AlphanumericFileRenamePolicy();\n\n    private static final Map<String, String> mediaTypes;\n\n    // Initializes the mediaTypes map\n    static {\n        Map<String, String> temp = new HashMap<String, String>();\n        temp.put(\"pdf\", \"application/pdf\");\n        temp.put(\"ppt\", \"application/vnd.ms-powerpoint\");\n        temp.put(\"pot\", \"application/vnd.ms-powerpoint\");\n        temp.put(\"swf\", \"application/x-shockwave-flash\");\n        temp.put(\"smil\", \"application/smil\");\n        temp.put(\"zip\", \"application/zip\");\n        temp.put(\"doc\", \"application/msword\");\n        temp.put(\"wpd\", \"application/vnd.wordperfect\");\n        temp.put(\"vsd\", \"application/visio\");\n        temp.put(\"xls\", \"application/vnd.ms-excel\");\n        temp.put(\"xlm\", \"application/vnd.ms-excel\");\n        temp.put(\"mpp\", \"application/vnd.ms-project\");\n        temp.put(\"xml\", \"application/xml\");\n        temp.put(\"exe\", \"application/octet-stream\");\n        temp.put(\"js\", \"application/x-javascript\");\n        temp.put(\"wav\", \"audio/x-wav\");\n        temp.put(\"mpg\", \"audio/mpeg\");\n        temp.put(\"rm\", \"audio/x-pn-realaudio\");\n        temp.put(\"ra\", \"audio/x-pn-realaudio\");\n        temp.put(\"ram\", \"audio/x-pn-realaudio\");\n        temp.put(\"rpm\", \"audio/x-pn-realaudio-plugin\");\n        temp.put(\"qt\", \"audio/qt\");\n        temp.put(\"au\", \"audio/basic\");\n        temp.put(\"aif\", \"audio/x-aiff\");\n        temp.put(\"jpg\", \"Image/jpeg\");\n        temp.put(\"gif\", \"Image/gif\");\n        temp.put(\"png\", \"Image/png\");\n        temp.put(\"igs\", \"model/iges\");\n        temp.put(\"iges\", \"model/iges\");\n        temp.put(\"vrml\", \"model/vrml\");\n        temp.put(\"htm\", \"text/html\");\n        temp.put(\"html\", \"text/html\");\n        temp.put(\"sgm\", \"text/sgml\");\n        temp.put(\"sgml\", \"text/sgml\");\n        temp.put(\"txt\", \"text/plain\");\n        temp.put(\"rtf\", \"text/rtf\");\n        temp.put(\"xml\", \"text/xml\");\n        temp.put(\"mpeg\", \"video/mpeg\");\n        temp.put(\"mpg\", \"video/mpeg\");\n        temp.put(\"qt\", \"video/quicktime\");\n        temp.put(\"mov\", \"video/quicktime\");\n        mediaTypes = Collections.unmodifiableMap(temp);\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        RequestDispatcher rd;\n        CompleteMetadataBean completeMetadata = new CompleteMetadataBean();\n        Vector errorMessages = new Vector();\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        UserBean validUser = (UserBean) request.getSession().getAttribute(\"validUser\");\n        MultipartRequest multiPartReq = processUploadRequest(request, validUser, completeMetadata, healFileLocator, errorMessages);\n        if (errorMessages.size() > 0) {\n            //setup attributes\n            setupAttributes(request, multiPartReq);\n            request.setAttribute(\"errorMessages\", errorMessages);\n            String forwardURL = \"../upload2/uploadform.jsp\";\n            rd = request.getRequestDispatcher(forwardURL);\n            rd.forward(request, response);\n            return;\n        } else {\n            UploadServicesBean uploadServices = (UploadServicesBean) servlet.getServletContext().getAttribute(\"uploadServices\");\n            //MetadataDAO metadataServices = (MetadataDAO)servlet.getServletContext().getAttribute(\"MetadataDAO\");\n            //final QueueDAO queueManager = (QueueDAO)servlet.getServletContext().getAttribute(\"QueueDAO\");\n            // final CommonDAO commonServices = (CommonDAO)servlet.getServletContext().getAttribute(\"CommonDAO\");\n            String format = completeMetadata.getFormat();\n            String location = completeMetadata.getLocation();\n            String converted = healFileLocator.convertLocationToFilePath(location);\n            String path = healFileLocator.getUploadFilePath() + File.separator + converted;\n            if ((format.toLowerCase()).startsWith(\"Image\".toLowerCase())) {\n                uploadServices.processImage(completeMetadata, path);\n            } else if (\"Video\".equalsIgnoreCase(format) || \"Animation\".equalsIgnoreCase(format)) {\n                uploadServices.processVideo(completeMetadata, path);\n            } else if (\"Audio\".equalsIgnoreCase(format)) {\n                uploadServices.processAudio(completeMetadata, path);\n            }\n            final String vCard = \"begin:vcard\\n\" + \"n:Health Education Assets Library (HEAL)\\n\" + \"url:http://www.healcentral.org\\n\" + \"email;type=internet:info@healcentral.org \\n\" + \"fn:Health Education Assets Library (HEAL)\\n\" + \"end:vcard\";\n            MetametadataContributorBean mcb = new MetametadataContributorBean();\n            mcb.setDate(new Date());\n            mcb.setRole(\"Creator\");\n            mcb.setvCard(vCard);\n            mcb.setDateDescription(\"Contributed to HEAL\");\n            completeMetadata.getMetametadataContributors().add(mcb);\n            request.getSession().setAttribute(\"completeMetadata\", completeMetadata);\n            request.getSession().setAttribute(\"requestParameters\", multiPartReq);\n            response.sendRedirect(\"../upload2/preview.jsp\");\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    /**\n     * Handles all processing of an upload request.  Parses out the upload\n     * parameters and file and stores the information in the provided\n     * CompleteMetadataBean.  Any errors that occur will result in\n     * messages being added to the errorMessages vector.\n     * The validUser parameter is required in order to determine where to\n     * place the uploaded file.  The healFileLocator parameter is also\n     * required for this reason.\n     * If the errorMessages vector is empty then the complete metadata\n     * bean parameter will be fully filled out and ready for storage\n     * in the database.  If an errorMessage does show up, then there\n     * was an error in processing and the uploaded file will be deleted\n     * before this method returns.  The CompleteMetadataBean will still\n     * contain as many parameters as the method was able to process, thus\n     * allowing the error form to retain those settings as a convenience\n     * to the user.\n     * This method returns a HashMap containing all of the parameters and\n     * values read from the request.  See the readRequestParameters method\n     * for a description of the format of this map.\n     */\n    public static MultipartRequest processUploadRequest(HttpServletRequest request, UserBean validUser, CompleteMetadataBean cmb, FileLocator healFileLocator, Vector errorMessages) {\n        String location;\n        try {\n            String userUploadDir = healFileLocator.getUploadFilePath() + \"\\\\\" + validUser.getUserId();\n            File directory = new File(userUploadDir);\n            if (!directory.exists()) {\n                directory.mkdir();\n            }\n            MultipartRequest multipartReq = new MultipartRequest(request, userUploadDir, (int) healFileLocator.getMaxUploadSize(), fileRenamePolicy);\n            String fn = multipartReq.getParameter(\"locationfile\");\n            if (fn.equals(\"File\")) {\n                location = multipartReq.getFilesystemName(\"fileName\");\n                System.err.println(\"Location = \" + location);\n                if (location == null) {\n                    errorMessages.addElement(\"Unable to process uploaded file.\");\n                } else {\n                    location = validUser.getUserId() + \"/\" + location;\n                }\n            } else {\n                location = multipartReq.getParameter(\"fileName\");\n            }\n            if (multipartReq.getParameter(\"contributorInfo\") == null || multipartReq.getParameter(\"contributorInfo\").length() == 0) {\n                errorMessages.addElement(\"Please include contributor information.\");\n            }\n            if (multipartReq.getParameter(\"title\") == null || multipartReq.getParameter(\"title\").length() == 0) {\n                errorMessages.addElement(\"Please enter a title.\");\n            }\n            if (multipartReq.getParameter(\"description\") == null || multipartReq.getParameter(\"description\").length() == 0) {\n                errorMessages.addElement(\"Please enter a general description.\");\n            }\n            if (multipartReq.getParameter(\"license\") == null || multipartReq.getParameter(\"license\").length() == 0) {\n                errorMessages.addElement(\"Please select usage rights setting.\");\n            }\n            if (multipartReq.getParameter(\"copyrightHolder\") == null || multipartReq.getParameter(\"copyrightHolder\").length() == 0) {\n                errorMessages.addElement(\"Please include copyright holder information.\");\n            }\n            Date testDate = DateTools.parse(multipartReq.getParameter(\"creationDate\"));\n            if (null == testDate) {\n                errorMessages.addElement(\"Please provide a date in the format YYYY-MM-DD.\");\n            } else {\n                // This is MS SQL Server-specific\n                Calendar testCalendar = Calendar.getInstance();\n                testCalendar.setTime(testDate);\n                final int year = testCalendar.get(Calendar.YEAR);\n                if (year < 1753 || year > 9999) {\n                    errorMessages.addElement(\"The year '\" + year + \"' in '\" + multipartReq.getParameter(\"creationDate\") + \"' is invalid.  Please provide a year within the range 1753 - 9999.\");\n                }\n            }\n            if (null == multipartReq.getParameter(\"revision\")) {\n                errorMessages.addElement(\"Please select whether or not this is a revision\");\n            }\n            //add info to the complete metadata bean...\n            storeParameters(multipartReq, validUser, location, healFileLocator, cmb);\n            return multipartReq;\n        } catch (IOException lEx) {\n            errorMessages.addElement(\"An error occured while reading the submitted file.\");\n            lEx.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * Handles all processing of an upload request.  Parses out the upload\n     * parameters and file and stores the information in the provided\n     * CompleteMetadataBean.  Any errors that occur will result in\n     * messages being added to the errorMessages vector.\n     * The validUser parameter is required in order to determine where to\n     * place the uploaded file.  The healFileLocator parameter is also\n     * required for this reason.\n     * If the errorMessages vector is empty then the complete metadata\n     * bean parameter will be fully filled out and ready for storage\n     * in the database.  If an errorMessage does show up, then there\n     * was an error in processing and the uploaded file will be deleted\n     * before this method returns.  The CompleteMetadataBean will still\n     * contain as many parameters as the method was able to process, thus\n     * allowing the error form to retain those settings as a convenience\n     * to the user.\n     * This method returns a HashMap containing all of the parameters and\n     * values read from the request.  See the readRequestParameters method\n     * for a description of the format of this map.\n     */\n    /**\n     * Reads the information contained within the parametersMap\n     * and stores that information in the CompleteMetadataBean.\n     * The values in the parametersMap are ArrayLists keyed off\n     * of strings defined in the upload form.  These values,\n     * along with the user, location, and file locator are\n     * used to completely fill out the complete metadata so\n     * that it is ready to be stored in the database.\n     * Since this is a new upload, the cmb.metadata.hidden\n     * value is set to true (we don't mark things as unhidden\n     * until the item is cataloged).\n     */\n    private static void storeParameters(MultipartRequest multipartReq, UserBean validUser, String location, FileLocator fileLocator, CompleteMetadataBean cmb) {\n        cmb.setLocation(location);\n        cmb.setTitle(multipartReq.getParameter(\"title\"));\n        cmb.setContributeUserId(validUser.getUserId());\n        cmb.setCreationDate(DateTools.parse(multipartReq.getParameter(\"creationDate\")));\n        java.util.Date currentTime = new java.util.Date();\n        cmb.setContributeDate(currentTime);\n        cmb.setAnnotated(multipartReq.getParameter(\"annotated\"));\n        cmb.setInappropriate(multipartReq.getParameter(\"inappropriate\"));\n        cmb.setPublicationName(multipartReq.getParameter(\"publicationName\"));\n        cmb.setPublicationId(multipartReq.getParameter(\"publicationId\"));\n        cmb.setSourceCollection(\"Peer Review Pending\");\n        cmb.setSubmissionAgreement(multipartReq.getParameter(\"submissionAgreement\"));\n        cmb.setDescription(multipartReq.getParameter(\"description\"));\n        cmb.setLearningResourceType(multipartReq.getParameter(\"learningResourceType\"));\n        cmb.setSpecimenType(multipartReq.getParameter(\"specimenType\"));\n        cmb.setRadiographType(multipartReq.getParameter(\"radiographType\"));\n        cmb.setOrientation(multipartReq.getParameter(\"orientation\"));\n        cmb.setMagnification(multipartReq.getParameter(\"magnification\"));\n        cmb.setClinicalHistory(multipartReq.getParameter(\"clinicalHistory\"));\n        //we start out hidden until cataloged\n        cmb.setPrivate(true);\n        if (location != null) {\n            storeFileInfo(location, fileLocator, cmb);\n        }\n        String resource = multipartReq.getParameter(\"relatedItem\");\n        String kind = multipartReq.getParameter(\"relationType\");\n        String description = multipartReq.getParameter(\"relationDescription\");\n        if (resource != null) {\n            RelationBean relation = new RelationBean();\n            relation.setResource(resource);\n            relation.setKind(kind);\n            relation.setDescription(description);\n            cmb.addRelation(relation);\n        }\n        String[] list;\n        String value;\n        list = multipartReq.getParameterValues(\"copyrightHolder\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                CopyrightHolderBean ddb = new CopyrightHolderBean();\n                //XXX we aren't really storing a VCARD here\n                ddb.setVCard(value);\n                cmb.addCopyrightHolder(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"contributorInfo\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                VCardBean vCard = new VCardBean();\n                value = list[iter];\n                ContributorBean cb = new ContributorBean();\n                String[] nestedValues = value.split(\"\\\\|\");\n                if (nestedValues.length == 7) {\n                    cb.setRole(trimString(nestedValues[0]));\n                    final String lastName = trimString(nestedValues[1]);\n                    cb.setLastName(lastName);\n                    vCard.setLastName(lastName);\n                    final String firstName = trimString(nestedValues[2]);\n                    cb.setFirstName(firstName);\n                    vCard.setFirstName(firstName);\n                    vCard.setMiddleName(trimString(nestedValues[3]));\n                    vCard.setTitle(trimString(nestedValues[4]));\n                    final String org = trimString(nestedValues[5]);\n                    cb.setOrganization(org);\n                    vCard.setOrganization(org);\n                    final String email = trimString(nestedValues[6]);\n                    cb.setEmail(email);\n                    vCard.setEmail(email);\n                } else if (nestedValues.length == 8) {\n                    cb.setRole(trimString(nestedValues[0]));\n                    final String lastName = trimString(nestedValues[1]);\n                    cb.setLastName(lastName);\n                    vCard.setLastName(lastName);\n                    final String firstName = trimString(nestedValues[2]);\n                    cb.setFirstName(firstName);\n                    vCard.setFirstName(firstName);\n                    vCard.setMiddleName(trimString(nestedValues[3]));\n                    vCard.setTitle(trimString(nestedValues[4]));\n                    final String org = trimString(nestedValues[5]);\n                    cb.setOrganization(org);\n                    vCard.setOrganization(org);\n                    final String email = trimString(nestedValues[6]);\n                    cb.setEmail(email);\n                    vCard.setEmail(email);\n                    vCard.setPhone(trimString(nestedValues[7]));\n                } else {\n                    System.err.println(\"SimpleUploadAction: cannot parse contributor \\\"\" + value + \"\\\"\");\n                    continue;\n                }\n                String vCardString = vCard.getVCard();\n                if (null != vCardString) {\n                    cb.setVCard(vCardString);\n                } else {\n                    //XXX we aren't really storing a VCARD here\n                    cb.setVCard(value);\n                }\n                cmb.addContributor(cb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"license\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                CopyrightTextBean ddb = new CopyrightTextBean();\n                ddb.setCopyrightText(value);\n                CopyrightBean cb = new CopyrightBean();\n                cb.setCopyrightText(ddb);\n                cmb.addCopyright(cb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"context\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                ContextURLBean ddb = new ContextURLBean();\n                ddb.setContextURL(value);\n                cmb.addContextURL(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"targetUserGroup\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                TargetUserGroupBean tugb = new TargetUserGroupBean();\n                tugb.setTargetUserGroup(value);\n                cmb.addTargetUserGroup(tugb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"browserReq\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                RequirementBean ddb = new RequirementBean();\n                ddb.setRequirementType(RequirementBean.BROWSER);\n                ddb.setRequirementName(value);\n                cmb.addRequirement(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"operatingReq\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                RequirementBean ddb = new RequirementBean();\n                ddb.setRequirementType(RequirementBean.OS);\n                ddb.setRequirementName(value);\n                cmb.addRequirement(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"keywords\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                KeywordBean ddb = new KeywordBean();\n                ddb.setKeyword(value);\n                cmb.addKeyword(ddb);\n            }\n        }\n        value = location;\n        value = getMediaType(value);\n        FormatBean ddb = new FormatBean();\n        ddb.setFormat(value);\n        cmb.addFormat(ddb);\n    }\n\n    /**\n     * A helper method used to store all the file information\n     * in the provided metadata.  The location and fileLocator\n     * are used to gain a handle on the File, at which point the\n     * size, name, extension, and location are set in the\n     * metadata bean.\n     */\n    private static void storeFileInfo(String location, FileLocator fileLocator, MetadataBean metadata) {\n        if (location.startsWith(\"http\")) {\n            metadata.setFileName(location);\n        } else {\n            File content = new File(fileLocator.getUploadFilePath(), location);\n            System.err.println(fileLocator.getUploadFilePath());\n            System.err.println(location);\n            if (content.exists() && content.isFile()) {\n                metadata.setLocation(location);\n                String name = content.getName();\n                metadata.setFileName(name);\n                metadata.setFileSize(String.valueOf(content.length()));\n            }\n        }\n    }\n\n    /**\n     * Takes information from the parametersMap and, using\n     * the request.setAttribute method, places it in the request\n     * such that the upload form can easily look it up and display\n     * it to the user.  This method is meant to be used in the case\n     * that an error occured during the upload processing (such\n     * as a missing parameter) and we need the user to resubmit\n     * their request.  This method sets the attributes so that\n     * the previously set fields in the form can be filled in\n     * and the user doesn't have to completely refill the form.\n     * Because we are using an encoding type of multipart/form-data\n     * to upload the form and file, the request's parameters are\n     * not set (we have to read these manually), then we need to\n     * set them before we forward the request to another page\n     * that wants to use them.\n     * If an attribute is not supposed to have multiple settings\n     * such as the title or description, the attribute that is\n     * set is a String, if the attribute does have multiple\n     * settings, such as keywords or organ, then the attribute\n     * that is set is a String array (String[]).\n     * The parameters that are set are: (* denotes multiple)\n     * mediaType\n     * browserReq*\n     * operatingReq*\n     * title\n     * description\n     * annotated\n     * context*\n     * specimenType\n     * radiographType\n     * mriType\n     * orientation\n     * magnification\n     * diseaseProcess\n     * diseaseDiagnosis\n     * clinicalHistory\n     * learnContext\n     * inappropriate\n     * keywords*\n     * organ*\n     * copyrightHolder\n     * copyrightMessage\n     * relatedItem\n     * relationType\n     * relationDescription\n     */\n    public static void setupAttributes(HttpServletRequest request, MultipartRequest multiPartReq) {\n        setStringAttribute(request, \"mediaType\", multiPartReq);\n        setArrayAttribute(request, \"browserReq\", multiPartReq);\n        setArrayAttribute(request, \"operatingReq\", multiPartReq);\n        setStringAttribute(request, \"title\", multiPartReq);\n        setStringAttribute(request, \"description\", multiPartReq);\n        setStringAttribute(request, \"annotated\", multiPartReq);\n        setArrayAttribute(request, \"context\", multiPartReq);\n        setStringAttribute(request, \"specimenType\", multiPartReq);\n        setStringAttribute(request, \"radiographType\", multiPartReq);\n        setStringAttribute(request, \"mriType\", multiPartReq);\n        setStringAttribute(request, \"orientation\", multiPartReq);\n        setStringAttribute(request, \"magnification\", multiPartReq);\n        setStringAttribute(request, \"diseaseProcess\", multiPartReq);\n        setStringAttribute(request, \"diseaseDiagnosis\", multiPartReq);\n        setStringAttribute(request, \"clinicalHistory\", multiPartReq);\n        setStringAttribute(request, \"learnContext\", multiPartReq);\n        setStringAttribute(request, \"inappropriate\", multiPartReq);\n        setArrayAttribute(request, \"keywords\", multiPartReq);\n        setStringAttribute(request, \"copyrightHolder\", multiPartReq);\n        setArrayAttribute(request, \"contributorInfo\", multiPartReq);\n        setStringAttribute(request, \"copyrightMessage\", multiPartReq);\n        setStringAttribute(request, \"relatedItem\", multiPartReq);\n        setStringAttribute(request, \"relationType\", multiPartReq);\n        setStringAttribute(request, \"relationDescription\", multiPartReq);\n        setStringAttribute(request, \"q_1\", multiPartReq);\n        setStringAttribute(request, \"q_2\", multiPartReq);\n        setStringAttribute(request, \"q_3\", multiPartReq);\n        setStringAttribute(request, \"targetUserGroup\", multiPartReq);\n        setStringAttribute(request, \"publicationName\", multiPartReq);\n        setStringAttribute(request, \"creationDate\", multiPartReq);\n        setStringAttribute(request, \"learningResourceType\", multiPartReq);\n        setStringAttribute(request, \"locationfile\", multiPartReq);\n        setStringAttribute(request, \"fileName\", multiPartReq);\n    }\n\n    /**\n     * Looks up the attribute in the parametersMap, takes that setting\n     * (if it isn't null) and sets an attribute in the request\n     * with the given name and the discovered values.  The value\n     * of the attribute is a String[] of all of the values found\n     * in the parametersMap that correspond to the given attributeName\n     */\n    private static void setArrayAttribute(HttpServletRequest request, String attributeName, MultipartRequest multiPartReq) {\n        String[] stringArray = multiPartReq.getParameterValues(attributeName);\n        if (stringArray != null) {\n            request.setAttribute(attributeName, stringArray);\n        }\n    }\n\n    /**\n     * Looks up the attribute in the parametersMap, takes that setting\n     * (if it isn't null) and sets an attribute in the request\n     * with the given name and the discovered value.\n     */\n    private static void setStringAttribute(HttpServletRequest request, String attributeName, MultipartRequest multipartReq) {\n        String aString = multipartReq.getParameter(attributeName);\n        if (aString != null) {\n            request.setAttribute(attributeName, aString);\n        }\n    }\n\n    /**\n     * Given a complete metadata beans and two hashmaps, looks up the\n     * requirements associated with the metadata and separates the\n     * requirements into those related to the user's web browser and\n     * those related to the user's operating system.  Each entry is\n     * added to the hash map as the key, with SELECTED as the value.\n     * This is intended for use in jsp pages where a select input is\n     * being generated.\n     */\n    public static void separateRequirements(CompleteMetadataBean cmb, HashMap browserMap, HashMap operatingMap) {\n        ArrayList requirements = cmb.getRequirements();\n        if (requirements != null) {\n            Iterator iter = requirements.iterator();\n            while (iter.hasNext()) {\n                RequirementBean requirement = (RequirementBean) iter.next();\n                String type = requirement.getRequirementType();\n                String name = requirement.getRequirementName();\n                if (name != null) {\n                    if (RequirementBean.BROWSER.equalsIgnoreCase(type)) {\n                        browserMap.put(name, \"SELECTED\");\n                    } else if (RequirementBean.OS.equalsIgnoreCase(type)) {\n                        operatingMap.put(name, \"SELECTED\");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Determines the media file type based on the file extension (from filename)\n     * If filename startsWith \"http://\" media file Type is web page\n     */\n    private static String getMediaType(String fileName) {\n        int index;\n        String fileExtension = null;\n        if ((index = fileName.lastIndexOf(\".\")) != -1) {\n            fileExtension = fileName.substring(index + 1);\n        }\n        String mediaType = mediaTypes.get(fileExtension);\n        if (mediaType == null) {\n            mediaType = \"unknown\";\n        }\n        if ((\"unknown\".equals(mediaTypes)) && (fileName.startsWith(\"http\"))) {\n            mediaType = \"text/htm\";\n        }\n        return mediaType;\n    }\n\n    /**\n     * Trims any extra whitespace from the beginning and end of a value -- if\n     * that results in an empty string, this method returns <code>null</code>.\n     *\n     * @param value A non-null String.\n     * @return A trimmed String or null if the string is empty.\n     */\n    private final static String trimString(String value) {\n        String ret = value.trim();\n        return (ret.length() > 0 ? ret : null);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/upload/PreviewUploadActionTest0.java",
		"test_prompt": "// PreviewUploadActionTest0.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.MultipartRequest;\nimport com.oreilly.servlet.multipart.FileRenamePolicy;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.upload.UploadServicesBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Vector;\nimport org.heal.servlet.upload.AlphanumericFileRenamePolicy;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreviewUploadAction}.\n* It contains ten unit test cases for the {@link PreviewUploadAction#actionRequiresLogin()} method.\n*/\nclass PreviewUploadActionTest0 {"
	},
	{
		"original_code": "// PreviewUploadAction.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.MultipartRequest;\nimport com.oreilly.servlet.multipart.FileRenamePolicy;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.upload.UploadServicesBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Vector;\nimport org.heal.servlet.upload.AlphanumericFileRenamePolicy;\n\npublic class PreviewUploadAction implements Action {\n\n    private static final FileRenamePolicy fileRenamePolicy = new AlphanumericFileRenamePolicy();\n\n    private static final Map<String, String> mediaTypes;\n\n    // Initializes the mediaTypes map\n    static {\n        Map<String, String> temp = new HashMap<String, String>();\n        temp.put(\"pdf\", \"application/pdf\");\n        temp.put(\"ppt\", \"application/vnd.ms-powerpoint\");\n        temp.put(\"pot\", \"application/vnd.ms-powerpoint\");\n        temp.put(\"swf\", \"application/x-shockwave-flash\");\n        temp.put(\"smil\", \"application/smil\");\n        temp.put(\"zip\", \"application/zip\");\n        temp.put(\"doc\", \"application/msword\");\n        temp.put(\"wpd\", \"application/vnd.wordperfect\");\n        temp.put(\"vsd\", \"application/visio\");\n        temp.put(\"xls\", \"application/vnd.ms-excel\");\n        temp.put(\"xlm\", \"application/vnd.ms-excel\");\n        temp.put(\"mpp\", \"application/vnd.ms-project\");\n        temp.put(\"xml\", \"application/xml\");\n        temp.put(\"exe\", \"application/octet-stream\");\n        temp.put(\"js\", \"application/x-javascript\");\n        temp.put(\"wav\", \"audio/x-wav\");\n        temp.put(\"mpg\", \"audio/mpeg\");\n        temp.put(\"rm\", \"audio/x-pn-realaudio\");\n        temp.put(\"ra\", \"audio/x-pn-realaudio\");\n        temp.put(\"ram\", \"audio/x-pn-realaudio\");\n        temp.put(\"rpm\", \"audio/x-pn-realaudio-plugin\");\n        temp.put(\"qt\", \"audio/qt\");\n        temp.put(\"au\", \"audio/basic\");\n        temp.put(\"aif\", \"audio/x-aiff\");\n        temp.put(\"jpg\", \"Image/jpeg\");\n        temp.put(\"gif\", \"Image/gif\");\n        temp.put(\"png\", \"Image/png\");\n        temp.put(\"igs\", \"model/iges\");\n        temp.put(\"iges\", \"model/iges\");\n        temp.put(\"vrml\", \"model/vrml\");\n        temp.put(\"htm\", \"text/html\");\n        temp.put(\"html\", \"text/html\");\n        temp.put(\"sgm\", \"text/sgml\");\n        temp.put(\"sgml\", \"text/sgml\");\n        temp.put(\"txt\", \"text/plain\");\n        temp.put(\"rtf\", \"text/rtf\");\n        temp.put(\"xml\", \"text/xml\");\n        temp.put(\"mpeg\", \"video/mpeg\");\n        temp.put(\"mpg\", \"video/mpeg\");\n        temp.put(\"qt\", \"video/quicktime\");\n        temp.put(\"mov\", \"video/quicktime\");\n        mediaTypes = Collections.unmodifiableMap(temp);\n    }\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        RequestDispatcher rd;\n        CompleteMetadataBean completeMetadata = new CompleteMetadataBean();\n        Vector errorMessages = new Vector();\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        UserBean validUser = (UserBean) request.getSession().getAttribute(\"validUser\");\n        MultipartRequest multiPartReq = processUploadRequest(request, validUser, completeMetadata, healFileLocator, errorMessages);\n        if (errorMessages.size() > 0) {\n            //setup attributes\n            setupAttributes(request, multiPartReq);\n            request.setAttribute(\"errorMessages\", errorMessages);\n            String forwardURL = \"../upload2/uploadform.jsp\";\n            rd = request.getRequestDispatcher(forwardURL);\n            rd.forward(request, response);\n            return;\n        } else {\n            UploadServicesBean uploadServices = (UploadServicesBean) servlet.getServletContext().getAttribute(\"uploadServices\");\n            //MetadataDAO metadataServices = (MetadataDAO)servlet.getServletContext().getAttribute(\"MetadataDAO\");\n            //final QueueDAO queueManager = (QueueDAO)servlet.getServletContext().getAttribute(\"QueueDAO\");\n            // final CommonDAO commonServices = (CommonDAO)servlet.getServletContext().getAttribute(\"CommonDAO\");\n            String format = completeMetadata.getFormat();\n            String location = completeMetadata.getLocation();\n            String converted = healFileLocator.convertLocationToFilePath(location);\n            String path = healFileLocator.getUploadFilePath() + File.separator + converted;\n            if ((format.toLowerCase()).startsWith(\"Image\".toLowerCase())) {\n                uploadServices.processImage(completeMetadata, path);\n            } else if (\"Video\".equalsIgnoreCase(format) || \"Animation\".equalsIgnoreCase(format)) {\n                uploadServices.processVideo(completeMetadata, path);\n            } else if (\"Audio\".equalsIgnoreCase(format)) {\n                uploadServices.processAudio(completeMetadata, path);\n            }\n            final String vCard = \"begin:vcard\\n\" + \"n:Health Education Assets Library (HEAL)\\n\" + \"url:http://www.healcentral.org\\n\" + \"email;type=internet:info@healcentral.org \\n\" + \"fn:Health Education Assets Library (HEAL)\\n\" + \"end:vcard\";\n            MetametadataContributorBean mcb = new MetametadataContributorBean();\n            mcb.setDate(new Date());\n            mcb.setRole(\"Creator\");\n            mcb.setvCard(vCard);\n            mcb.setDateDescription(\"Contributed to HEAL\");\n            completeMetadata.getMetametadataContributors().add(mcb);\n            request.getSession().setAttribute(\"completeMetadata\", completeMetadata);\n            request.getSession().setAttribute(\"requestParameters\", multiPartReq);\n            response.sendRedirect(\"../upload2/preview.jsp\");\n        }\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    /**\n     * Handles all processing of an upload request.  Parses out the upload\n     * parameters and file and stores the information in the provided\n     * CompleteMetadataBean.  Any errors that occur will result in\n     * messages being added to the errorMessages vector.\n     * The validUser parameter is required in order to determine where to\n     * place the uploaded file.  The healFileLocator parameter is also\n     * required for this reason.\n     * If the errorMessages vector is empty then the complete metadata\n     * bean parameter will be fully filled out and ready for storage\n     * in the database.  If an errorMessage does show up, then there\n     * was an error in processing and the uploaded file will be deleted\n     * before this method returns.  The CompleteMetadataBean will still\n     * contain as many parameters as the method was able to process, thus\n     * allowing the error form to retain those settings as a convenience\n     * to the user.\n     * This method returns a HashMap containing all of the parameters and\n     * values read from the request.  See the readRequestParameters method\n     * for a description of the format of this map.\n     */\n    public static MultipartRequest processUploadRequest(HttpServletRequest request, UserBean validUser, CompleteMetadataBean cmb, FileLocator healFileLocator, Vector errorMessages) {\n        String location;\n        try {\n            String userUploadDir = healFileLocator.getUploadFilePath() + \"\\\\\" + validUser.getUserId();\n            File directory = new File(userUploadDir);\n            if (!directory.exists()) {\n                directory.mkdir();\n            }\n            MultipartRequest multipartReq = new MultipartRequest(request, userUploadDir, (int) healFileLocator.getMaxUploadSize(), fileRenamePolicy);\n            String fn = multipartReq.getParameter(\"locationfile\");\n            if (fn.equals(\"File\")) {\n                location = multipartReq.getFilesystemName(\"fileName\");\n                System.err.println(\"Location = \" + location);\n                if (location == null) {\n                    errorMessages.addElement(\"Unable to process uploaded file.\");\n                } else {\n                    location = validUser.getUserId() + \"/\" + location;\n                }\n            } else {\n                location = multipartReq.getParameter(\"fileName\");\n            }\n            if (multipartReq.getParameter(\"contributorInfo\") == null || multipartReq.getParameter(\"contributorInfo\").length() == 0) {\n                errorMessages.addElement(\"Please include contributor information.\");\n            }\n            if (multipartReq.getParameter(\"title\") == null || multipartReq.getParameter(\"title\").length() == 0) {\n                errorMessages.addElement(\"Please enter a title.\");\n            }\n            if (multipartReq.getParameter(\"description\") == null || multipartReq.getParameter(\"description\").length() == 0) {\n                errorMessages.addElement(\"Please enter a general description.\");\n            }\n            if (multipartReq.getParameter(\"license\") == null || multipartReq.getParameter(\"license\").length() == 0) {\n                errorMessages.addElement(\"Please select usage rights setting.\");\n            }\n            if (multipartReq.getParameter(\"copyrightHolder\") == null || multipartReq.getParameter(\"copyrightHolder\").length() == 0) {\n                errorMessages.addElement(\"Please include copyright holder information.\");\n            }\n            Date testDate = DateTools.parse(multipartReq.getParameter(\"creationDate\"));\n            if (null == testDate) {\n                errorMessages.addElement(\"Please provide a date in the format YYYY-MM-DD.\");\n            } else {\n                // This is MS SQL Server-specific\n                Calendar testCalendar = Calendar.getInstance();\n                testCalendar.setTime(testDate);\n                final int year = testCalendar.get(Calendar.YEAR);\n                if (year < 1753 || year > 9999) {\n                    errorMessages.addElement(\"The year '\" + year + \"' in '\" + multipartReq.getParameter(\"creationDate\") + \"' is invalid.  Please provide a year within the range 1753 - 9999.\");\n                }\n            }\n            if (null == multipartReq.getParameter(\"revision\")) {\n                errorMessages.addElement(\"Please select whether or not this is a revision\");\n            }\n            //add info to the complete metadata bean...\n            storeParameters(multipartReq, validUser, location, healFileLocator, cmb);\n            return multipartReq;\n        } catch (IOException lEx) {\n            errorMessages.addElement(\"An error occured while reading the submitted file.\");\n            lEx.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * Handles all processing of an upload request.  Parses out the upload\n     * parameters and file and stores the information in the provided\n     * CompleteMetadataBean.  Any errors that occur will result in\n     * messages being added to the errorMessages vector.\n     * The validUser parameter is required in order to determine where to\n     * place the uploaded file.  The healFileLocator parameter is also\n     * required for this reason.\n     * If the errorMessages vector is empty then the complete metadata\n     * bean parameter will be fully filled out and ready for storage\n     * in the database.  If an errorMessage does show up, then there\n     * was an error in processing and the uploaded file will be deleted\n     * before this method returns.  The CompleteMetadataBean will still\n     * contain as many parameters as the method was able to process, thus\n     * allowing the error form to retain those settings as a convenience\n     * to the user.\n     * This method returns a HashMap containing all of the parameters and\n     * values read from the request.  See the readRequestParameters method\n     * for a description of the format of this map.\n     */\n    /**\n     * Reads the information contained within the parametersMap\n     * and stores that information in the CompleteMetadataBean.\n     * The values in the parametersMap are ArrayLists keyed off\n     * of strings defined in the upload form.  These values,\n     * along with the user, location, and file locator are\n     * used to completely fill out the complete metadata so\n     * that it is ready to be stored in the database.\n     * Since this is a new upload, the cmb.metadata.hidden\n     * value is set to true (we don't mark things as unhidden\n     * until the item is cataloged).\n     */\n    private static void storeParameters(MultipartRequest multipartReq, UserBean validUser, String location, FileLocator fileLocator, CompleteMetadataBean cmb) {\n        cmb.setLocation(location);\n        cmb.setTitle(multipartReq.getParameter(\"title\"));\n        cmb.setContributeUserId(validUser.getUserId());\n        cmb.setCreationDate(DateTools.parse(multipartReq.getParameter(\"creationDate\")));\n        java.util.Date currentTime = new java.util.Date();\n        cmb.setContributeDate(currentTime);\n        cmb.setAnnotated(multipartReq.getParameter(\"annotated\"));\n        cmb.setInappropriate(multipartReq.getParameter(\"inappropriate\"));\n        cmb.setPublicationName(multipartReq.getParameter(\"publicationName\"));\n        cmb.setPublicationId(multipartReq.getParameter(\"publicationId\"));\n        cmb.setSourceCollection(\"Peer Review Pending\");\n        cmb.setSubmissionAgreement(multipartReq.getParameter(\"submissionAgreement\"));\n        cmb.setDescription(multipartReq.getParameter(\"description\"));\n        cmb.setLearningResourceType(multipartReq.getParameter(\"learningResourceType\"));\n        cmb.setSpecimenType(multipartReq.getParameter(\"specimenType\"));\n        cmb.setRadiographType(multipartReq.getParameter(\"radiographType\"));\n        cmb.setOrientation(multipartReq.getParameter(\"orientation\"));\n        cmb.setMagnification(multipartReq.getParameter(\"magnification\"));\n        cmb.setClinicalHistory(multipartReq.getParameter(\"clinicalHistory\"));\n        //we start out hidden until cataloged\n        cmb.setPrivate(true);\n        if (location != null) {\n            storeFileInfo(location, fileLocator, cmb);\n        }\n        String resource = multipartReq.getParameter(\"relatedItem\");\n        String kind = multipartReq.getParameter(\"relationType\");\n        String description = multipartReq.getParameter(\"relationDescription\");\n        if (resource != null) {\n            RelationBean relation = new RelationBean();\n            relation.setResource(resource);\n            relation.setKind(kind);\n            relation.setDescription(description);\n            cmb.addRelation(relation);\n        }\n        String[] list;\n        String value;\n        list = multipartReq.getParameterValues(\"copyrightHolder\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                CopyrightHolderBean ddb = new CopyrightHolderBean();\n                //XXX we aren't really storing a VCARD here\n                ddb.setVCard(value);\n                cmb.addCopyrightHolder(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"contributorInfo\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                VCardBean vCard = new VCardBean();\n                value = list[iter];\n                ContributorBean cb = new ContributorBean();\n                String[] nestedValues = value.split(\"\\\\|\");\n                if (nestedValues.length == 7) {\n                    cb.setRole(trimString(nestedValues[0]));\n                    final String lastName = trimString(nestedValues[1]);\n                    cb.setLastName(lastName);\n                    vCard.setLastName(lastName);\n                    final String firstName = trimString(nestedValues[2]);\n                    cb.setFirstName(firstName);\n                    vCard.setFirstName(firstName);\n                    vCard.setMiddleName(trimString(nestedValues[3]));\n                    vCard.setTitle(trimString(nestedValues[4]));\n                    final String org = trimString(nestedValues[5]);\n                    cb.setOrganization(org);\n                    vCard.setOrganization(org);\n                    final String email = trimString(nestedValues[6]);\n                    cb.setEmail(email);\n                    vCard.setEmail(email);\n                } else if (nestedValues.length == 8) {\n                    cb.setRole(trimString(nestedValues[0]));\n                    final String lastName = trimString(nestedValues[1]);\n                    cb.setLastName(lastName);\n                    vCard.setLastName(lastName);\n                    final String firstName = trimString(nestedValues[2]);\n                    cb.setFirstName(firstName);\n                    vCard.setFirstName(firstName);\n                    vCard.setMiddleName(trimString(nestedValues[3]));\n                    vCard.setTitle(trimString(nestedValues[4]));\n                    final String org = trimString(nestedValues[5]);\n                    cb.setOrganization(org);\n                    vCard.setOrganization(org);\n                    final String email = trimString(nestedValues[6]);\n                    cb.setEmail(email);\n                    vCard.setEmail(email);\n                    vCard.setPhone(trimString(nestedValues[7]));\n                } else {\n                    System.err.println(\"SimpleUploadAction: cannot parse contributor \\\"\" + value + \"\\\"\");\n                    continue;\n                }\n                String vCardString = vCard.getVCard();\n                if (null != vCardString) {\n                    cb.setVCard(vCardString);\n                } else {\n                    //XXX we aren't really storing a VCARD here\n                    cb.setVCard(value);\n                }\n                cmb.addContributor(cb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"license\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                CopyrightTextBean ddb = new CopyrightTextBean();\n                ddb.setCopyrightText(value);\n                CopyrightBean cb = new CopyrightBean();\n                cb.setCopyrightText(ddb);\n                cmb.addCopyright(cb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"context\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                ContextURLBean ddb = new ContextURLBean();\n                ddb.setContextURL(value);\n                cmb.addContextURL(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"targetUserGroup\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                TargetUserGroupBean tugb = new TargetUserGroupBean();\n                tugb.setTargetUserGroup(value);\n                cmb.addTargetUserGroup(tugb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"browserReq\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                RequirementBean ddb = new RequirementBean();\n                ddb.setRequirementType(RequirementBean.BROWSER);\n                ddb.setRequirementName(value);\n                cmb.addRequirement(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"operatingReq\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                RequirementBean ddb = new RequirementBean();\n                ddb.setRequirementType(RequirementBean.OS);\n                ddb.setRequirementName(value);\n                cmb.addRequirement(ddb);\n            }\n        }\n        list = multipartReq.getParameterValues(\"keywords\");\n        if (list != null) {\n            int a = list.length;\n            for (int iter = 0; iter < a; iter++) {\n                value = list[iter];\n                KeywordBean ddb = new KeywordBean();\n                ddb.setKeyword(value);\n                cmb.addKeyword(ddb);\n            }\n        }\n        value = location;\n        value = getMediaType(value);\n        FormatBean ddb = new FormatBean();\n        ddb.setFormat(value);\n        cmb.addFormat(ddb);\n    }\n\n    /**\n     * A helper method used to store all the file information\n     * in the provided metadata.  The location and fileLocator\n     * are used to gain a handle on the File, at which point the\n     * size, name, extension, and location are set in the\n     * metadata bean.\n     */\n    private static void storeFileInfo(String location, FileLocator fileLocator, MetadataBean metadata) {\n        if (location.startsWith(\"http\")) {\n            metadata.setFileName(location);\n        } else {\n            File content = new File(fileLocator.getUploadFilePath(), location);\n            System.err.println(fileLocator.getUploadFilePath());\n            System.err.println(location);\n            if (content.exists() && content.isFile()) {\n                metadata.setLocation(location);\n                String name = content.getName();\n                metadata.setFileName(name);\n                metadata.setFileSize(String.valueOf(content.length()));\n            }\n        }\n    }\n\n    /**\n     * Takes information from the parametersMap and, using\n     * the request.setAttribute method, places it in the request\n     * such that the upload form can easily look it up and display\n     * it to the user.  This method is meant to be used in the case\n     * that an error occured during the upload processing (such\n     * as a missing parameter) and we need the user to resubmit\n     * their request.  This method sets the attributes so that\n     * the previously set fields in the form can be filled in\n     * and the user doesn't have to completely refill the form.\n     * Because we are using an encoding type of multipart/form-data\n     * to upload the form and file, the request's parameters are\n     * not set (we have to read these manually), then we need to\n     * set them before we forward the request to another page\n     * that wants to use them.\n     * If an attribute is not supposed to have multiple settings\n     * such as the title or description, the attribute that is\n     * set is a String, if the attribute does have multiple\n     * settings, such as keywords or organ, then the attribute\n     * that is set is a String array (String[]).\n     * The parameters that are set are: (* denotes multiple)\n     * mediaType\n     * browserReq*\n     * operatingReq*\n     * title\n     * description\n     * annotated\n     * context*\n     * specimenType\n     * radiographType\n     * mriType\n     * orientation\n     * magnification\n     * diseaseProcess\n     * diseaseDiagnosis\n     * clinicalHistory\n     * learnContext\n     * inappropriate\n     * keywords*\n     * organ*\n     * copyrightHolder\n     * copyrightMessage\n     * relatedItem\n     * relationType\n     * relationDescription\n     */\n    public static void setupAttributes(HttpServletRequest request, MultipartRequest multiPartReq) {\n        setStringAttribute(request, \"mediaType\", multiPartReq);\n        setArrayAttribute(request, \"browserReq\", multiPartReq);\n        setArrayAttribute(request, \"operatingReq\", multiPartReq);\n        setStringAttribute(request, \"title\", multiPartReq);\n        setStringAttribute(request, \"description\", multiPartReq);\n        setStringAttribute(request, \"annotated\", multiPartReq);\n        setArrayAttribute(request, \"context\", multiPartReq);\n        setStringAttribute(request, \"specimenType\", multiPartReq);\n        setStringAttribute(request, \"radiographType\", multiPartReq);\n        setStringAttribute(request, \"mriType\", multiPartReq);\n        setStringAttribute(request, \"orientation\", multiPartReq);\n        setStringAttribute(request, \"magnification\", multiPartReq);\n        setStringAttribute(request, \"diseaseProcess\", multiPartReq);\n        setStringAttribute(request, \"diseaseDiagnosis\", multiPartReq);\n        setStringAttribute(request, \"clinicalHistory\", multiPartReq);\n        setStringAttribute(request, \"learnContext\", multiPartReq);\n        setStringAttribute(request, \"inappropriate\", multiPartReq);\n        setArrayAttribute(request, \"keywords\", multiPartReq);\n        setStringAttribute(request, \"copyrightHolder\", multiPartReq);\n        setArrayAttribute(request, \"contributorInfo\", multiPartReq);\n        setStringAttribute(request, \"copyrightMessage\", multiPartReq);\n        setStringAttribute(request, \"relatedItem\", multiPartReq);\n        setStringAttribute(request, \"relationType\", multiPartReq);\n        setStringAttribute(request, \"relationDescription\", multiPartReq);\n        setStringAttribute(request, \"q_1\", multiPartReq);\n        setStringAttribute(request, \"q_2\", multiPartReq);\n        setStringAttribute(request, \"q_3\", multiPartReq);\n        setStringAttribute(request, \"targetUserGroup\", multiPartReq);\n        setStringAttribute(request, \"publicationName\", multiPartReq);\n        setStringAttribute(request, \"creationDate\", multiPartReq);\n        setStringAttribute(request, \"learningResourceType\", multiPartReq);\n        setStringAttribute(request, \"locationfile\", multiPartReq);\n        setStringAttribute(request, \"fileName\", multiPartReq);\n    }\n\n    /**\n     * Looks up the attribute in the parametersMap, takes that setting\n     * (if it isn't null) and sets an attribute in the request\n     * with the given name and the discovered values.  The value\n     * of the attribute is a String[] of all of the values found\n     * in the parametersMap that correspond to the given attributeName\n     */\n    private static void setArrayAttribute(HttpServletRequest request, String attributeName, MultipartRequest multiPartReq) {\n        String[] stringArray = multiPartReq.getParameterValues(attributeName);\n        if (stringArray != null) {\n            request.setAttribute(attributeName, stringArray);\n        }\n    }\n\n    /**\n     * Looks up the attribute in the parametersMap, takes that setting\n     * (if it isn't null) and sets an attribute in the request\n     * with the given name and the discovered value.\n     */\n    private static void setStringAttribute(HttpServletRequest request, String attributeName, MultipartRequest multipartReq) {\n        String aString = multipartReq.getParameter(attributeName);\n        if (aString != null) {\n            request.setAttribute(attributeName, aString);\n        }\n    }\n\n    /**\n     * Given a complete metadata beans and two hashmaps, looks up the\n     * requirements associated with the metadata and separates the\n     * requirements into those related to the user's web browser and\n     * those related to the user's operating system.  Each entry is\n     * added to the hash map as the key, with SELECTED as the value.\n     * This is intended for use in jsp pages where a select input is\n     * being generated.\n     */\n    public static void separateRequirements(CompleteMetadataBean cmb, HashMap browserMap, HashMap operatingMap) {\n        ArrayList requirements = cmb.getRequirements();\n        if (requirements != null) {\n            Iterator iter = requirements.iterator();\n            while (iter.hasNext()) {\n                RequirementBean requirement = (RequirementBean) iter.next();\n                String type = requirement.getRequirementType();\n                String name = requirement.getRequirementName();\n                if (name != null) {\n                    if (RequirementBean.BROWSER.equalsIgnoreCase(type)) {\n                        browserMap.put(name, \"SELECTED\");\n                    } else if (RequirementBean.OS.equalsIgnoreCase(type)) {\n                        operatingMap.put(name, \"SELECTED\");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Determines the media file type based on the file extension (from filename)\n     * If filename startsWith \"http://\" media file Type is web page\n     */\n    private static String getMediaType(String fileName) {\n        int index;\n        String fileExtension = null;\n        if ((index = fileName.lastIndexOf(\".\")) != -1) {\n            fileExtension = fileName.substring(index + 1);\n        }\n        String mediaType = mediaTypes.get(fileExtension);\n        if (mediaType == null) {\n            mediaType = \"unknown\";\n        }\n        if ((\"unknown\".equals(mediaTypes)) && (fileName.startsWith(\"http\"))) {\n            mediaType = \"text/htm\";\n        }\n        return mediaType;\n    }\n\n    /**\n     * Trims any extra whitespace from the beginning and end of a value -- if\n     * that results in an empty string, this method returns <code>null</code>.\n     *\n     * @param value A non-null String.\n     * @return A trimmed String or null if the string is empty.\n     */\n    private final static String trimString(String value) {\n        String ret = value.trim();\n        return (ret.length() > 0 ? ret : null);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/upload/PreviewUploadActionTest1.java",
		"test_prompt": "// PreviewUploadActionTest1.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.MultipartRequest;\nimport com.oreilly.servlet.multipart.FileRenamePolicy;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.upload.UploadServicesBean;\nimport org.heal.module.user.UserBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport org.heal.util.VCardBean;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Vector;\nimport org.heal.servlet.upload.AlphanumericFileRenamePolicy;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreviewUploadAction}.\n* It contains ten unit test cases for the {@link PreviewUploadAction#processUploadRequest(HttpServletRequest, UserBean, CompleteMetadataBean, FileLocator, Vector)} method.\n*/\nclass PreviewUploadActionTest1 {"
	},
	{
		"original_code": "// AlphanumericFileRenamePolicy.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.multipart.DefaultFileRenamePolicy;\nimport java.io.File;\n\n/**\n * A FileRenamePolicy that strips non-alphanumeric characters.\n */\npublic class AlphanumericFileRenamePolicy extends DefaultFileRenamePolicy {\n\n    /**\n     * Eliminates non-alphanumeric characters from filenames.  Exceptions\n     * include <code>' '</code>, <code>'.'</code> and <code>'_'</code>\n     *\n     * @param original Original file reference.\n     * @return File reference stripped of non-alphanumeric characters.\n     */\n    public File rename(File original) {\n        File ret = new File(stripSpecialCharacters(original.getPath()));\n        return super.rename(ret);\n    }\n\n    String stripSpecialCharacters(String filename) {\n        // Removes all non-alphanumeric characters (except for '.' and ' ')\n        return filename.substring(0, filename.lastIndexOf(File.separator) + 1) + filename.substring(filename.lastIndexOf(File.separator) + 1).replaceAll(\"[^\\\\w\\\\. ]\", \"\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/upload/AlphanumericFileRenamePolicyTest.java",
		"test_prompt": "// AlphanumericFileRenamePolicyTest.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.multipart.DefaultFileRenamePolicy;\nimport java.io.File;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AlphanumericFileRenamePolicy}.\n* It contains ten unit test cases for the {@link AlphanumericFileRenamePolicy#rename(File)} method.\n*/\nclass AlphanumericFileRenamePolicyTest {"
	},
	{
		"original_code": "// SimpleUploadAction.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.MultipartRequest;\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.upload.UploadServicesBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.FileLocator;\nimport org.heal.util.CommonDAO;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SimpleUploadAction implements Action {\n\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        RequestDispatcher rd;\n        CompleteMetadataBean completeMetadata = (CompleteMetadataBean) request.getSession().getAttribute(\"completeMetadata\");\n        MultipartRequest multiPartReq = (MultipartRequest) request.getSession().getAttribute(\"requestParameters\");\n        Map parameters = new HashMap();\n        for (Enumeration enumeration = multiPartReq.getParameterNames(); enumeration.hasMoreElements(); ) {\n            final String parameterName = (String) enumeration.nextElement();\n            final String[] parameterValues = multiPartReq.getParameterValues(parameterName);\n            parameters.put(parameterName, parameterValues);\n        }\n        FileLocator healFileLocator = (FileLocator) servlet.getServletContext().getAttribute(\"healFileLocator\");\n        UploadServicesBean uploadServices = (UploadServicesBean) servlet.getServletContext().getAttribute(\"uploadServices\");\n        MetadataDAO metadataServices = (MetadataDAO) servlet.getServletContext().getAttribute(\"MetadataDAO\");\n        final QueueDAO queueManager = (QueueDAO) servlet.getServletContext().getAttribute(\"QueueDAO\");\n        final CommonDAO commonServices = (CommonDAO) servlet.getServletContext().getAttribute(\"CommonDAO\");\n        String format = completeMetadata.getFormat();\n        String location = completeMetadata.getLocation();\n        String converted = healFileLocator.convertLocationToFilePath(location);\n        String path = healFileLocator.getUploadFilePath() + File.separator + converted;\n        if ((format.toLowerCase()).startsWith(\"Image\".toLowerCase())) {\n            uploadServices.processImage(completeMetadata, path);\n        } else if (\"Video\".equalsIgnoreCase(format) || \"Animation\".equalsIgnoreCase(format)) {\n            uploadServices.processVideo(completeMetadata, path);\n        } else if (\"Audio\".equalsIgnoreCase(format)) {\n            uploadServices.processAudio(completeMetadata, path);\n        }\n        try {\n            metadataServices.saveCompleteMetadata(completeMetadata);\n            // since we need a metadata id for this part...\n            MetametadataIdentifierBean mib = new MetametadataIdentifierBean();\n            mib.setCatalog(\"http://www.healcentral.org/\");\n            mib.setEntry(completeMetadata.getMetadataId());\n            mib.setMetadataId(completeMetadata.getMetadataId());\n            completeMetadata.getMetametadataIdentifiers().add(mib);\n            metadataServices.saveMetametadataIdentifier(mib);\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n        QueuedRecordBean temp = new QueuedRecordBean();\n        temp.setType(QueueDAO.TYPE_APPROVAL);\n        if (\"yes\".equalsIgnoreCase(multiPartReq.getParameter(\"revision\"))) {\n            temp.setComments(\"submitted as a revision\");\n        }\n        temp.setShortMetadata(completeMetadata);\n        queueManager.saveQueuedRecord(temp);\n        parameters.put(\"publicationId\", new String[] { completeMetadata.getPublicationId() });\n        request.getSession().setAttribute(\"requestParameters\", parameters);\n        request.setAttribute(\"submissionId\", completeMetadata.getPublicationId());\n        rd = request.getRequestDispatcher(\"../upload2/uploadformSuccess.jsp\");\n        rd.forward(request, response);\n    }\n\n    public boolean actionRequiresLogin() {\n        return true;\n    }\n\n    /**\n     * Takes information from the parametersMap and, using\n     * the request.setAttribute method, places it in the request\n     * such that the upload form can easily look it up and display\n     * it to the user.  This method is meant to be used in the case\n     * that an error occured during the upload processing (such\n     * as a missing parameter) and we need the user to resubmit\n     * their request.  This method sets the attributes so that\n     * the previously set fields in the form can be filled in\n     * and the user doesn't have to completely refill the form.\n     * Because we are using an encoding type of multipart/form-data\n     * to upload the form and file, the request's parameters are\n     * not set (we have to read these manually), then we need to\n     * set them before we forward the request to another page\n     * that wants to use them.\n     * If an attribute is not supposed to have multiple settings\n     * such as the title or description, the attribute that is\n     * set is a String, if the attribute does have multiple\n     * settings, such as keywords or organ, then the attribute\n     * that is set is a String array (String[]).\n     * The parameters that are set are: (* denotes multiple)\n     * mediaType\n     * browserReq*\n     * operatingReq*\n     * title\n     * description\n     * annotated\n     * context*\n     * specimenType\n     * radiographType\n     * mriType\n     * orientation\n     * magnification\n     * diseaseProcess\n     * diseaseDiagnosis\n     * clinicalHistory\n     * learnContext\n     * inappropriate\n     * keywords*\n     * organ*\n     * copyrightHolder\n     * copyrightMessage\n     * relatedItem\n     * relationType\n     * relationDescription\n     */\n    public static void setupAttributes(HttpServletRequest request, Map parameters) {\n        setStringAttribute(request, \"title\", parameters);\n        setStringAttribute(request, \"description\", parameters);\n        setStringAttribute(request, \"annotated\", parameters);\n        setArrayAttribute(request, \"context\", parameters);\n        setStringAttribute(request, \"specimenType\", parameters);\n        setStringAttribute(request, \"radiographType\", parameters);\n        setStringAttribute(request, \"mriType\", parameters);\n        setStringAttribute(request, \"orientation\", parameters);\n        setStringAttribute(request, \"magnification\", parameters);\n        setStringAttribute(request, \"diseaseProcess\", parameters);\n        setStringAttribute(request, \"diseaseDiagnosis\", parameters);\n        setStringAttribute(request, \"clinicalHistory\", parameters);\n        setStringAttribute(request, \"learnContext\", parameters);\n        setStringAttribute(request, \"inappropriate\", parameters);\n        setArrayAttribute(request, \"keywords\", parameters);\n        setStringAttribute(request, \"copyrightHolder\", parameters);\n        setArrayAttribute(request, \"contributorInfo\", parameters);\n        setStringAttribute(request, \"copyrightMessage\", parameters);\n        setStringAttribute(request, \"relatedItem\", parameters);\n        setStringAttribute(request, \"relationType\", parameters);\n        setStringAttribute(request, \"relationDescription\", parameters);\n        setStringAttribute(request, \"q_1\", parameters);\n        setStringAttribute(request, \"q_2\", parameters);\n        setStringAttribute(request, \"q_3\", parameters);\n        setArrayListAttribute(request, \"targetUserGroup\", parameters);\n        setStringAttribute(request, \"publicationName\", parameters);\n        setStringAttribute(request, \"creationDate\", parameters);\n        setStringAttribute(request, \"learningResourceType\", parameters);\n        setStringAttribute(request, \"revision\", parameters);\n        setStringAttribute(request, \"publicationId\", parameters);\n        setStringAttribute(request, \"locationfile\", parameters);\n        setStringAttribute(request, \"fileName\", parameters);\n    }\n\n    /**\n     * Looks up the attribute in the parametersMap, takes that setting\n     * (if it isn't null) and sets an attribute in the request\n     * with the given name and the discovered values.  The value\n     * of the attribute is a String[] of all of the values found\n     * in the parametersMap that correspond to the given attributeName\n     */\n    private static void setArrayListAttribute(HttpServletRequest request, String attributeName, Map parameters) {\n        String[] stringArray = (String[]) parameters.get(attributeName);\n        if (stringArray == null) {\n            return;\n        }\n        ArrayList aList = new ArrayList();\n        for (int a = 0; a < stringArray.length; a++) {\n            aList.add(stringArray[a]);\n        }\n        request.setAttribute(attributeName, aList);\n    }\n\n    /**\n     * Looks up the attribute in the parametersMap, takes that setting\n     * (if it isn't null) and sets an attribute in the request\n     * with the given name and the discovered value.\n     */\n    private static void setStringAttribute(HttpServletRequest request, String attributeName, Map parameters) {\n        String[] temp = (String[]) parameters.get(attributeName);\n        if (null != temp && temp.length > 0) {\n            request.setAttribute(attributeName, temp[0]);\n        }\n    }\n\n    /**\n     * Looks up the attribute in the parametersMap, takes that setting\n     * (if it isn't null) and sets an attribute in the request\n     * with the given name and the discovered values.  The value\n     * of the attribute is a String[] of all of the values found\n     * in the parametersMap that correspond to the given attributeName\n     */\n    private static void setArrayAttribute(HttpServletRequest request, String attributeName, Map parameters) {\n        String[] stringArray = (String[]) parameters.get(attributeName);\n        request.setAttribute(attributeName, stringArray);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/upload/SimpleUploadActionTest.java",
		"test_prompt": "// SimpleUploadActionTest.java\npackage org.heal.servlet.upload;\n\nimport com.oreilly.servlet.MultipartRequest;\nimport org.heal.module.catalog.QueueDAO;\nimport org.heal.module.catalog.QueuedRecordBean;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.upload.UploadServicesBean;\nimport org.heal.servlet.Action;\nimport org.heal.util.FileLocator;\nimport org.heal.util.CommonDAO;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleUploadAction}.\n* It contains ten unit test cases for the {@link SimpleUploadAction#actionRequiresLogin()} method.\n*/\nclass SimpleUploadActionTest {"
	},
	{
		"original_code": "// WSSearchResultsAction.java\npackage org.heal.servlet;\n\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.ParameterMap;\nimport org.heal.util.ResultsPager;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * An {@link Action} that handles the results of MERLOT's SOAP based search services.\n */\npublic class WSSearchResultsAction implements Action {\n\n    /**\n     * @param servlet\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void perform(HttpServlet servlet, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        SearchResultBean searchResults;\n        searchResults = (SearchResultBean) request.getSession().getAttribute(\"searchResults\");\n        String queryString = request.getQueryString();\n        if (queryString == null) {\n            queryString = \"\";\n        }\n        // If there are no search results, redirect to the appropriate search action.\n        // This is here so that, for example, if a user bookmarked a search results page\n        // rather than arriving here through a search, the expected page would be generated\n        if (searchResults == null) {\n            String searchURL = \"../search/fedsearch.jsp\";\n            response.sendRedirect(searchURL);\n            return;\n        }\n        // page specifies the page we are looking at, defaultly page 1\n        int displayPage = getParameterAsInteger(request, \"page\", 1);\n        // display specifies how many items are being displayed per page, defaultly 10\n        int displayIncrement = getParameterAsInteger(request, \"display\", 10);\n        //**** BEGIN code to calculate displayStart and displayStop\n        int displayStart = (displayPage - 1) * displayIncrement;\n        int displayStop = 0;\n        ShortMetadataResultBean[] allMetadata = null;\n        if (searchResults != null) {\n            allMetadata = searchResults.getShortRecords();\n        }\n        if (allMetadata != null) {\n            displayStop = displayStart + displayIncrement;\n            if (displayStop > allMetadata.length) {\n                displayStop = allMetadata.length;\n            }\n        }\n        //**** END code to calculate displayStart and displayStop\n        request.setAttribute(\"displayStart\", \"\" + displayStart);\n        request.setAttribute(\"displayStop\", \"\" + displayStop);\n        {\n            ParameterMap parameters = new ParameterMap(request.getParameterMap());\n            // If they're changing the display size, we must reset the page\n            parameters.remove(\"page\");\n            // Disregarding what \"display\" value may be in the current parameters\n            // map, we put in \"5\" and construct a new query string to represent\n            // the original query string with a \"display\" of \"5\"\n            parameters.put(\"display\", \"5\");\n            request.setAttribute(\"displayString5\", \"wsSearchResults?\" + parameters.toString());\n            // Disregarding what \"display\" value may be in the current parameters\n            // map, we put in \"10\" and construct a new query string to represent\n            // the original query string with a \"display\" of \"10\"\n            parameters.put(\"display\", \"10\");\n            request.setAttribute(\"displayString10\", \"wsSearchResults?\" + parameters.toString());\n            // Disregarding what \"display\" value may be in the current parameters\n            // map, we put in \"25\" and construct a new query string to represent\n            // the original query string with a \"display\" of \"25\"\n            parameters.put(\"display\", \"25\");\n            request.setAttribute(\"displayString25\", \"wsSearchResults?\" + parameters.toString());\n            // Disregarding what \"display\" value may be in the current parameters\n            // map, we put in \"25\" and construct a new query string to represent\n            // the original query string with a \"display\" of \"25\"\n            parameters.put(\"display\", \"50\");\n            request.setAttribute(\"displayString50\", \"wsSearchResults?\" + parameters.toString());\n            // The \"searchURL\" is the original URL with only the search-specific\n            // parameters in the query string with the addition of the \"display\" parameter.\n            // This is used in creating the links to different pages of search results.\n            parameters = new ParameterMap(request.getParameterMap());\n            parameters.remove(\"page\");\n            request.setAttribute(\"searchURL\", \"wsSearchResults?\" + parameters.toString());\n        }\n        request.setAttribute(\"origURL\", \"wsSearchResults?\" + queryString);\n        String pagenb = request.getParameter(\"page\");\n        ParameterMap parameterv = new ParameterMap(request.getParameterMap());\n        // If they're changing the display format, we must reset the page\n        parameterv.remove(\"page\");\n        // Disregarding what \"display\" format may be in the current parameters\n        // map, we put in \"1\" and construct a new query string to represent\n        // the original query string with a \"viewtype\" of \"1\"\n        parameterv.put(\"viewtype\", \"1\");\n        parameterv.put(\"page\", pagenb);\n        request.setAttribute(\"view1\", \"wsSearchResults?\" + parameterv.toString());\n        // Disregarding what \"display\" format may be in the current parameters\n        // map, we put in \"2\" and construct a new query string to represent\n        // the original query string with a \"viewtype\" of \"2\"\n        parameterv.put(\"viewtype\", \"2\");\n        parameterv.put(\"page\", pagenb);\n        request.setAttribute(\"view2\", \"wsSearchResults?\" + parameterv.toString());\n        // Disregarding what \"display\" value may be in the current parameters\n        // map, we put in \"3\" and construct a new query string to represent\n        // the original query string with a \"viewtype\" of \"3\"\n        parameterv.put(\"viewtype\", \"3\");\n        parameterv.put(\"page\", pagenb);\n        request.setAttribute(\"view3\", \"wsSearchResults?\" + parameterv.toString());\n        // The \"searchURL\" is the original URL with only the search-specific\n        // parameters in the query string with the addition of the \"display\" parameter.\n        // This is used in creating the links to different pages of search results.\n        parameterv = new ParameterMap(request.getParameterMap());\n        parameterv.remove(\"page\");\n        request.setAttribute(\"searchURL\", \"wsSearchResults?\" + parameterv.toString());\n        if (allMetadata != null) {\n            ResultsPager pager = new org.heal.util.ResultsPager(allMetadata.length, displayIncrement, displayPage);\n            request.setAttribute(\"pager\", pager);\n        }\n        String keywords = new String();\n        keywords = request.getParameter(\"keywords\");\n        // If the original query string is missing a parameter we add\n        // the parameter's default value before passing on the query\n        String queryStringWithDefaults;\n        {\n            ParameterMap parameters = new ParameterMap(request.getParameterMap());\n            if (!parameters.containsKey(\"display\")) {\n                // The default \"display\" is \"10\"\n                parameters.put(\"display\", \"10\");\n            }\n            if (!parameters.containsKey(\"page\")) {\n                // The default \"page\" is \"1\"\n                parameters.put(\"page\", \"1\");\n            }\n            queryStringWithDefaults = parameters.toString();\n        }\n        String forwardURL = \"/search/WSsearchresults.jsp?\" + queryStringWithDefaults;\n        RequestDispatcher rd;\n        rd = request.getRequestDispatcher(forwardURL);\n        rd.forward(request, response);\n        return;\n    }\n\n    private int getParameterAsInteger(final HttpServletRequest request, final String paramName, final int defaultValue) {\n        int ret = defaultValue;\n        String parameter = request.getParameter(paramName);\n        if (parameter != null && parameter.length() != 0) {\n            try {\n                ret = Integer.parseInt(parameter);\n            }// does nothing, so the defaultValue will be returned\n             catch (NumberFormatException e) {\n            }\n        }\n        return ret;\n    }\n\n    public boolean actionRequiresLogin() {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/servlet/WSSearchResultsActionTest.java",
		"test_prompt": "// WSSearchResultsActionTest.java\npackage org.heal.servlet;\n\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.heal.util.ParameterMap;\nimport org.heal.util.ResultsPager;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WSSearchResultsAction}.\n* It contains ten unit test cases for the {@link WSSearchResultsAction#actionRequiresLogin()} method.\n*/\nclass WSSearchResultsActionTest {"
	},
	{
		"original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT = new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT = new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret = null;\n        if (null != dateString) {\n            boolean match = false;\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret = formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret = null;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret = formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String, or <code>false</code> otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match = false;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or <code>false</code>\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match = false;\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match = true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/DateToolsTest0.java",
		"test_prompt": "// DateToolsTest0.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#format(Date)} method.\n*/\nclass DateToolsTest0 {"
	},
	{
		"original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT = new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT = new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret = null;\n        if (null != dateString) {\n            boolean match = false;\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret = formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret = null;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret = formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String, or <code>false</code> otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match = false;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or <code>false</code>\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match = false;\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match = true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/DateToolsTest1.java",
		"test_prompt": "// DateToolsTest1.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#format(Date, String)} method.\n*/\nclass DateToolsTest1 {"
	},
	{
		"original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT = new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT = new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret = null;\n        if (null != dateString) {\n            boolean match = false;\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret = formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret = null;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret = formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String, or <code>false</code> otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match = false;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or <code>false</code>\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match = false;\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match = true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/DateToolsTest2.java",
		"test_prompt": "// DateToolsTest2.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#parse(String)} method.\n*/\nclass DateToolsTest2 {"
	},
	{
		"original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT = new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT = new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret = null;\n        if (null != dateString) {\n            boolean match = false;\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret = formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret = null;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret = formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String, or <code>false</code> otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match = false;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or <code>false</code>\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match = false;\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match = true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/DateToolsTest3.java",
		"test_prompt": "// DateToolsTest3.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#parse(String, String)} method.\n*/\nclass DateToolsTest3 {"
	},
	{
		"original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT = new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT = new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret = null;\n        if (null != dateString) {\n            boolean match = false;\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret = formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret = null;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret = formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String, or <code>false</code> otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match = false;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or <code>false</code>\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match = false;\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match = true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/DateToolsTest4.java",
		"test_prompt": "// DateToolsTest4.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#isValidDate(String)} method.\n*/\nclass DateToolsTest4 {"
	},
	{
		"original_code": "// DateTools.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A general utility class for dealing with dates.\n */\npublic class DateTools {\n\n    public static final String DEFAULT_DATE_FORMAT = new String(\"yyyy-MM-dd\");\n\n    public static final String LONG_DATE_FORMAT = new String(\"yyyy-MM-dd HH:mm:ss\");\n\n    private static final String[] POSSIBLE_DATE_FORMATS = new String[] { DEFAULT_DATE_FORMAT, LONG_DATE_FORMAT, \"MM/dd/yyyy\", \"MM-dd-yyyy\", \"yyyy\" };\n\n    private DateTools() {\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @return A String representation of the date parameter in\n     * \t\tthe {@link #DEFAULT_DATE_FORMAT default format}.\n     */\n    public static String format(Date date) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param date A {@link Date} to format.\n     * @param format A format (corresponding to {@link SimpleDateFormat}'s syntax)\n     * \t\tto convert the date to.\n     * @return A String representation of the date parameter in the\n     * \t\tspecified format, or null if the given date is null.\n     */\n    public static String format(Date date, String format) {\n        if (null == date) {\n            return null;\n        }\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        return formatter.format(date);\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed.\n     */\n    public static Date parse(String dateString) {\n        Date ret = null;\n        if (null != dateString) {\n            boolean match = false;\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    ret = formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String to parse into a {@link Date} object.\n     * @param format A format to use to parse the date parameter with.\n     * @return A {@link Date} representation of the String when possible,\n     * \t\tor <code>null</code> if the date cannot be parsed with the\n     * \t\tgiven format.\n     */\n    public static Date parse(String dateString, String format) {\n        Date ret = null;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat(format);\n            formatter.setLenient(false);\n            try {\n                ret = formatter.parse(dateString);\n            } catch (ParseException e) {\n                // do nothing\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String, or <code>false</code> otherwise.\n     * @see #parse(String dateString)\n     */\n    public static boolean isValidDate(String dateString) {\n        boolean match = false;\n        if (null != dateString) {\n            SimpleDateFormat formatter = new SimpleDateFormat();\n            formatter.setLenient(false);\n            for (int i = 0; i < POSSIBLE_DATE_FORMATS.length && !match; ++i) {\n                formatter.applyPattern(POSSIBLE_DATE_FORMATS[i]);\n                try {\n                    formatter.parse(dateString);\n                    match = true;\n                } catch (ParseException e) {\n                    // do nothing\n                }\n            }\n        }\n        return match;\n    }\n\n    /**\n     * @param dateString A String that may or may not represent a\n     * \t\t{@link Date} that can be parsed with the given format.\n     * @param format A format to use to check if the String can\n     * \t\tbe parsed into a {@link Date}.\n     * @return <code>true</code> if a {@link Date} can be parsed from\n     * \t\tthe String in the given format, or <code>false</code>\n     * \t\totherwise.\n     * @see #parse(String dateString, String format)\n     */\n    public static boolean isValidDate(String dateString, String format) {\n        boolean match = false;\n        SimpleDateFormat formatter = new SimpleDateFormat(format);\n        formatter.setLenient(false);\n        try {\n            formatter.parse(dateString);\n            match = true;\n        } catch (ParseException e) {\n            // do nothing\n        }\n        return match;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/DateToolsTest5.java",
		"test_prompt": "// DateToolsTest5.java\npackage org.heal.util;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DateTools}.\n* It contains ten unit test cases for the {@link DateTools#isValidDate(String, String)} method.\n*/\nclass DateToolsTest5 {"
	},
	{
		"original_code": "// AuthenticationTools.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * A convenience class which holds some common methods used for authentication.\n */\npublic final class AuthenticationTools {\n\n    /**\n     * A private constructor to prevent an instance of this class to be created.\n     */\n    private AuthenticationTools() {\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     *         is a valid cataloger, <code>false</code> otherwise.\n     */\n    public static boolean isCataloger(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isCataloger());\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     * is a valid approver, <code>false</code> otherwise.\n     */\n    public static boolean isApprover(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isApprover());\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     * is a valid administrator, <code>false</code> otherwise.\n     */\n    public static boolean isAdministrator(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isAdministrator());\n    }\n\n    /**\n     * @param request The <code>HttpServletRequest</code> that this method attempts\n     * \t\tto get the {@link UserBean} from.\n     * @return The {@link UserBean} attribute from the <code>HttpServletRequest</code>\n     * \t\tor <code>null</code> if none exists.\n     */\n    private static UserBean getUser(HttpServletRequest request) {\n        return (UserBean) request.getSession().getAttribute(\"validUser\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/AuthenticationToolsTest0.java",
		"test_prompt": "// AuthenticationToolsTest0.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport javax.servlet.http.HttpServletRequest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticationTools}.\n* It contains ten unit test cases for the {@link AuthenticationTools#isCataloger(HttpServletRequest)} method.\n*/\nclass AuthenticationToolsTest0 {"
	},
	{
		"original_code": "// AuthenticationTools.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * A convenience class which holds some common methods used for authentication.\n */\npublic final class AuthenticationTools {\n\n    /**\n     * A private constructor to prevent an instance of this class to be created.\n     */\n    private AuthenticationTools() {\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     *         is a valid cataloger, <code>false</code> otherwise.\n     */\n    public static boolean isCataloger(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isCataloger());\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     * is a valid approver, <code>false</code> otherwise.\n     */\n    public static boolean isApprover(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isApprover());\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     * is a valid administrator, <code>false</code> otherwise.\n     */\n    public static boolean isAdministrator(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isAdministrator());\n    }\n\n    /**\n     * @param request The <code>HttpServletRequest</code> that this method attempts\n     * \t\tto get the {@link UserBean} from.\n     * @return The {@link UserBean} attribute from the <code>HttpServletRequest</code>\n     * \t\tor <code>null</code> if none exists.\n     */\n    private static UserBean getUser(HttpServletRequest request) {\n        return (UserBean) request.getSession().getAttribute(\"validUser\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/AuthenticationToolsTest1.java",
		"test_prompt": "// AuthenticationToolsTest1.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport javax.servlet.http.HttpServletRequest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticationTools}.\n* It contains ten unit test cases for the {@link AuthenticationTools#isApprover(HttpServletRequest)} method.\n*/\nclass AuthenticationToolsTest1 {"
	},
	{
		"original_code": "// AuthenticationTools.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * A convenience class which holds some common methods used for authentication.\n */\npublic final class AuthenticationTools {\n\n    /**\n     * A private constructor to prevent an instance of this class to be created.\n     */\n    private AuthenticationTools() {\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     *         is a valid cataloger, <code>false</code> otherwise.\n     */\n    public static boolean isCataloger(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isCataloger());\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     * is a valid approver, <code>false</code> otherwise.\n     */\n    public static boolean isApprover(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isApprover());\n    }\n\n    /**\n     * @return <code>true</code> if the user given in the <code>HttpServletRequest</code>\n     * is a valid administrator, <code>false</code> otherwise.\n     */\n    public static boolean isAdministrator(HttpServletRequest request) {\n        UserBean user = getUser(request);\n        return (null != user && user.isAdministrator());\n    }\n\n    /**\n     * @param request The <code>HttpServletRequest</code> that this method attempts\n     * \t\tto get the {@link UserBean} from.\n     * @return The {@link UserBean} attribute from the <code>HttpServletRequest</code>\n     * \t\tor <code>null</code> if none exists.\n     */\n    private static UserBean getUser(HttpServletRequest request) {\n        return (UserBean) request.getSession().getAttribute(\"validUser\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/AuthenticationToolsTest2.java",
		"test_prompt": "// AuthenticationToolsTest2.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport javax.servlet.http.HttpServletRequest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AuthenticationTools}.\n* It contains ten unit test cases for the {@link AuthenticationTools#isAdministrator(HttpServletRequest)} method.\n*/\nclass AuthenticationToolsTest2 {"
	},
	{
		"original_code": "// CommonDAO.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class CommonDAO implements Serializable {\n\n    public CommonDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private static final String THUMBNAILINSERTSQL = \"INSERT INTO Thumbnails (MetadataId, Location, FileWidth, FileHeight) VALUES(?, ?, ?, ?)\";\n\n    private static final String THUMBNAILUPDATESQL = \"UPDATE Thumbnails SET MetadataId = ?, Location= ?, FileWidth= ?, FileHeight = ? WHERE ThumbnailID = ?\";\n\n    private static final String COPYRIGHTINSERTSQL = \"INSERT INTO Copyrights (MetadataID, CopyrightTextID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTUPDATESQL = \"UPDATE Copyrights SET MetadataID = ?, CopyrightTextID = ? WHERE CopyrightID = ?\";\n\n    private static final String COPYRIGHTTEXTINSERTSQL = \"INSERT INTO CopyrightTexts (CopyrightText, Cost, CopyrightAndOtherRestriction) VALUES(?, ?, ?)\";\n\n    private static final String COPYRIGHTTEXTUPDATESQL = \"UPDATE CopyrightTexts SET CopyrightText = ?, Cost = ?, CopyrightAndOtherRestriction = ? WHERE CopyrightTextID = ?\";\n\n    private static final String COPYRIGHTTEXTLOOKUPIDSQL = \"SELECT CopyrightTextID FROM CopyrightTexts WHERE CopyrightText = ?\";\n\n    private static final String DISEASEDIAGNOSISINSERTSQL = \"INSERT INTO DiseaseDiagnoses (MetadataID, DiseaseDiagnosis) VALUES(?, ?)\";\n\n    private static final String DISEASEDIAGNOSISUPDATESQL = \"UPDATE DiseaseDiagnoses SET MetadataID = ?, DiseaseDiagnosis = ? WHERE DiseaseDiagnosisID = ?\";\n\n    private static final String COPYRIGHTHOLDERINSERTSQL = \"INSERT INTO CopyrightHolders (MetadataID, vCardID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTHOLDERUPDATESQL = \"UPDATE CopyrightHolders SET MetadataID = ?, vCardID = ? WHERE CopyrightHolderID = ?\";\n\n    private static final String KEYWORDINSERTSQL = \"INSERT INTO Keywords (MetadataID, Keyword) VALUES(?, ?)\";\n\n    private static final String KEYWORDUPDATESQL = \"UPDATE Keywords SET MetadataID = ?, Keyword = ? WHERE KeywordID = ?\";\n\n    private static final String FORMATINSERTSQL = \"INSERT INTO Formats (MetadataID, Format) VALUES(?, ?)\";\n\n    private static final String FORMATUPDATESQL = \"UPDATE Formats SET MetadataID = ?, Format = ? WHERE FormatID = ?\";\n\n    private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source, Purpose, Description, Keyword) VALUES(?, ?, ?, ?, ?)\";\n\n    //  private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source) VALUES(?, ?)\";\n    private static final String TAXONINSERTSQL = \"INSERT INTO Taxons (TaxonPathID, ID, Entry) VALUES(?, ?, ?)\";\n\n    private static final String TAXONUPDATESQL = \"UPDATE Taxons SET TaxonPathID = ?, ID = ?, Entry = ? WHERE TaxonID = ?\";\n\n    private static final String CONTEXTURLINSERTSQL = \"INSERT INTO ContextURLs (MetadataID, ContextURL, ContextURLDescription) VALUES(?, ?, ?)\";\n\n    private static final String CONTEXTURLUPDATESQL = \"UPDATE ContextURLs SET MetadataID = ?, ContextURL = ?, ContextURLDescription = ? WHERE ContextURLID = ?\";\n\n    private static final String REQUIREMENTINSERTSQL = \"INSERT INTO Requirements (MetadataID, RequirementType, RequirementName, OtherPlatformRequirements, Duration, Description) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String REQUIREMENTUPDATESQL = \"UPDATE Requirements SET MetadataID = ?, RequirementType = ?, RequirementName = ?, OtherPlatformRequirements = ?, Duration = ?, Description = ? WHERE RequirementID = ?\";\n\n    private static final String CONTRIBUTORINSERTSQL = \"INSERT INTO Contributors (MetadataID, Role, vCardID, ContributeDate, ContributeDateDescription, Version, Status) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String CONTRIBUTORUPDATESQL = \"UPDATE Contributors SET MetadataID = ?, Role = ?, vCardID = ?, ContributeDate = ?, ContributeDateDescription = ?, Version = ?, Status = ? WHERE ContributorID = ?\";\n\n    private static final String RELATIONINSERTSQL = \"INSERT INTO Relations (MetadataID, Resource, Kind, Description, Catalogue, Entry) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String RELATIONUPDATESQL = \"UPDATE Relations SET MetadataID = ?, Resource = ?, Kind = ?, Description = ?, Catalogue = ?, Entry = ? WHERE RelationID = ?\";\n\n    private static final String TARGETUSERGROUPINSERTSQL = \"INSERT INTO TargetUserGroups (MetadataId, TargetUserGroup) VALUES (?, ?)\";\n\n    private static final String DELETEDITEMSINSERTSQL = \"INSERT INTO DeletedItems (GlobalID, FileName, Title, Location, ContributeUserID, ContributeDate, DeleteDate, Comments) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"UPDATE Metadata SET \").append(propertyName).append(\" = ? WHERE \");\n        sql.append(\"MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(propertyValue);\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataStringProperty(String propertyName, String propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new StringValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataTimestampProperty(String propertyName, Timestamp propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new TimestampValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Returns a Vector of Rows with all of the requested columns from the\n     * requested table that have the specified metadataId in their\n     * MetadataID column, or null if no matches are found.\n     */\n    public Vector getMetadataProperties(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        if (metadataId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT \").append(columnNames).append(\" FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        return rows;\n    }\n\n    public TimestampValue getTimestampValue(Date date) {\n        TimestampValue ret;\n        if (null != date) {\n            ret = new TimestampValue(new Timestamp(date.getTime()));\n        } else {\n            ret = new TimestampValue(null);\n        }\n        return ret;\n    }\n\n    public IntValue getIntValue(String intString) {\n        int parsedInt = 0;\n        try {\n            parsedInt = Integer.parseInt(intString);\n        } catch (NumberFormatException ex) {\n            //XXX logging?\n        }\n        return new IntValue(parsedInt);\n    }\n\n    public LongValue getLongValue(String longString) {\n        long parsedLong = 0;\n        try {\n            parsedLong = Long.parseLong(longString);\n        } catch (NumberFormatException e) {\n        }\n        return new LongValue(parsedLong);\n    }\n\n    /**\n     * Gets all rows from a given table.  The return value is a Vector\n     * of com.ora.jsp.sql.Row object or null if an error occurs.\n     */\n    public Vector getAllRows(String tableName) throws SQLException {\n        if (tableName == null) {\n            return null;\n        }\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(\"SELECT * FROM \" + tableName);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId, Connection conn) throws SQLException {\n        // Get the metadata info from the database\n        Row metadataRow = getMetadataProperty(metadataId, \"Metadata.*, Publications.Name AS PubName, Publications.PublicationDate AS PubDate\", \"Metadata LEFT OUTER JOIN Publications ON Metadata.PublicationId = Publications.PublicationId\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        MetadataBean metadataInfo = new MetadataBean();\n        try {\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setContributeDate(DateTools.parse(metadataRow.getString(\"ContributeDate\")));\n            metadataInfo.setAnnotated(metadataRow.getString(\"Annotated\"));\n            metadataInfo.setInappropriate(metadataRow.getString(\"Inappropriate\"));\n            metadataInfo.setArchived(metadataRow.getString(\"Archived\"));\n            metadataInfo.setPrivate(metadataRow.getString(\"Private\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setSpecimenType(metadataRow.getString(\"SpecimenType\"));\n            metadataInfo.setRadiographType(metadataRow.getString(\"RadiographType\"));\n            metadataInfo.setOrientation(metadataRow.getString(\"Orientation\"));\n            metadataInfo.setMagnification(metadataRow.getString(\"Magnification\"));\n            metadataInfo.setClinicalHistory(metadataRow.getString(\"ClinicalHistory\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setDuration(metadataRow.getString(\"Duration\"));\n            metadataInfo.setApproveDate(DateTools.parse(metadataRow.getString(\"ApproveDate\")));\n            metadataInfo.setCatalogDate(DateTools.parse(metadataRow.getString(\"CatalogDate\")));\n            metadataInfo.setRejectDate(DateTools.parse(metadataRow.getString(\"RejectDate\")));\n            metadataInfo.setCreationDate(DateTools.parse(metadataRow.getString(\"CreationDate\")));\n            metadataInfo.setPublicationName(metadataRow.getString(\"PubName\"));\n            metadataInfo.setPublicationDate(DateTools.parse(metadataRow.getString(\"PubDate\")));\n            // For some reason a null integer gets returned from getString as \"0\"\n            // so this ensures the publicationId is populated as null correctly\n            final String publicationId = metadataRow.getString(\"PublicationId\");\n            metadataInfo.setPublicationId(\"0\".equals(publicationId) ? null : publicationId);\n            metadataInfo.setLanguageType(metadataRow.getString(\"LanguageType\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * metadata or null if the metadata is not found.\n     */\n    public Row getMetadataProperty(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        Vector results = getMetadataProperties(metadataId, columnNames, tableName, conn);\n        if (results != null) {\n            return (Row) results.firstElement();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Removes all taxons and taxon paths associated with the given metadataId.\n     */\n    public void removeTaxonPaths(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Taxons WHERE TaxonPathID in (SELECT TaxonPathID FROM TaxonPaths WHERE MetadataID = ?)\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        sql.append(\"DELETE FROM TaxonPaths WHERE MetadataID = ?\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all copyright entries with the given metadataId\n     * from the Copyrights table.\n     */\n    public void removeCopyrights(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Copyrights WHERE MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        //clean up the copyright texts\n        sql.append(\"DELETE FROM CopyrightTexts WHERE CopyrightTextID NOT IN (SELECT CopyrightTextID FROM Copyrights)\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values = new Vector();\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all entries in a table that have a given metadataId.\n     */\n    public void removeMetadataFromTable(String metadataId, String tableName, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Deletes the metadata entry from the metadata table.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadata(String metadataId) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            removeMetadataFromTable(metadataId, \"Metadata\", conn);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return success;\n    }\n\n    public String getMetadataPropertyAsString(String metadataId, String columnName, String tableName, Connection conn) throws SQLException {\n        Row row = getMetadataProperty(metadataId, columnName, tableName, conn);\n        if (row != null) {\n            try {\n                return row.getString(columnName);\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = getMetadata(metadataId, conn);\n        addToDeletedItems(metadata, comment, conn);\n        success = deleteMetadataReferences(metadataId, conn);\n        removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Takes information from the metadata bean and stores it in the\n     * deleted items table, with the addition of the provided comment.\n     */\n    public void addToDeletedItems(MetadataBean metadata, String comment, Connection conn) throws SQLException {\n        if (metadata == null) {\n            throw new SQLException(\"Invalid metadata provided.\");\n        }\n        Timestamp deleteDate = new Timestamp(System.currentTimeMillis());\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(DELETEDITEMSINSERTSQL);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getGlobalId()));\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(getIntValue(metadata.getContributeUserId()));\n        values.addElement(getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new TimestampValue(deleteDate));\n        values.addElement(new StringValue(comment));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all references to the given metadataId, EXCEPT for the main\n     * entry in the Metadata table.  All other references are removed from\n     * the other tables (Formats, Keywords, Requirements, etc).\n     * Also deleted are all taxons associated with taxonpaths associated with\n     * this metadata reference.  Also, all copyrights associated with the\n     * metadata are deleted.  If the copyright to be deleted contains the only\n     * reference to the associated copyright text, then the copyright text\n     * is also deleted.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadataReferences(String metadataId, Connection conn) throws SQLException {\n        //first do the easy removals...\n        removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        removeMetadataFromTable(metadataId, \"Formats\", conn);\n        removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        removeMetadataFromTable(metadataId, \"Relations\", conn);\n        removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n        removeTaxonPaths(metadataId, conn);\n        removeCopyrights(metadataId, conn);\n        return true;\n    }\n\n    /**\n     * Returns a ThumbnailBean associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public ThumbnailBean getThumbnail(String metadataId, Connection conn) throws SQLException {\n        ThumbnailBean result = null;\n        if (metadataId != null) {\n            Vector rows = getMetadataProperties(metadataId, \"*\", \"Thumbnails\", conn);\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new ThumbnailBean();\n                    result.setThumbnailId(row.getString(\"ThumbnailID\"));\n                    result.setMetadataId(metadataId);\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"FileWidth\"));\n                    result.setFileHeight(row.getString(\"FileHeight\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a SourceCollection Bean associated with the\n     * given source collection name.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public SourceCollectionBean getSCollectionBean(String name, Connection conn) throws SQLException {\n        SourceCollectionBean result = null;\n        if (name != null) {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT * FROM SourceCollection WHERE name = ?\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(name));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new SourceCollectionBean();\n                    result.setSourceId(row.getString(\"SourceCollectionID\"));\n                    result.setSourceName(\"Name\");\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"Width\"));\n                    result.setFileHeight(row.getString(\"Height\"));\n                    result.setLink(row.getString(\"Link\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Inserts the information about the specified thumbnail,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveThumbnail(ThumbnailBean thumbnail, Connection conn) throws SQLException {\n        if (thumbnail == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String thumbnailId = thumbnail.getThumbnailId();\n        Vector values = new Vector();\n        if (thumbnailId == null) {\n            // Use INSERT statement\n            sql.append(THUMBNAILINSERTSQL);\n        } else {\n            sql.append(THUMBNAILUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values.addElement(new StringValue(thumbnail.getMetadataId()));\n        values.addElement(new StringValue(thumbnail.getLocation()));\n        values.addElement(new StringValue(thumbnail.getFileWidth()));\n        values.addElement(new StringValue(thumbnail.getFileHeight()));\n        if (thumbnailId != null) {\n            values.addElement(new StringValue(thumbnailId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified diseaseDiagnosis,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveDiseaseDiagnosis(DiseaseDiagnosisBean diseaseDiagnosis, Connection conn) throws SQLException {\n        if (diseaseDiagnosis == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String diseaseDiagnosisId = diseaseDiagnosis.getDiseaseDiagnosisId();\n        if (diseaseDiagnosisId == null) {\n            // Use INSERT statement\n            sql.append(DISEASEDIAGNOSISINSERTSQL);\n        } else {\n            sql.append(DISEASEDIAGNOSISUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(diseaseDiagnosis.getMetadataId()));\n        values.addElement(new StringValue(diseaseDiagnosis.getDiseaseDiagnosis()));\n        if (diseaseDiagnosisId != null) {\n            values.addElement(new StringValue(diseaseDiagnosisId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified copyright,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyright(CopyrightBean copyright, Connection conn) throws SQLException {\n        if (copyright == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String copyrightId = copyright.getCopyrightId();\n        if (copyrightId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyright.getMetadataId()));\n        String copyrightTextId = saveCopyrightText(copyright.getCopyrightText(), conn);\n        values.addElement(new StringValue(copyrightTextId));\n        if (copyrightId != null) {\n            values.addElement(new StringValue(copyright.getCopyrightId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Stores a CopyrightTextBean in the database.  If the provided\n     * CopyrightTextBean has a copyrightTextId that is non-null, an update\n     * will be attempted.  Otherwise, an insert will be performed.\n     * The copyrightTextId will be returned.  This will either be obtained\n     * from the provided bean, or by doing another database lookup after\n     * the insert (looking for a match on the copyrightText).\n     */\n    public String saveCopyrightText(CopyrightTextBean copyrightText, Connection conn) throws SQLException {\n        if (copyrightText == null) {\n            return null;\n        }\n        String copyrightTextId = null;\n        copyrightTextId = copyrightText.getCopyrightTextId();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        Vector values = new Vector();\n        StringValue textValue = new StringValue(copyrightText.getCopyrightText());\n        values.addElement(textValue);\n        values.addElement(new StringValue(copyrightText.getCost()));\n        values.addElement(new StringValue(copyrightText.getCopyrightAndOtherRestriction()));\n        if (copyrightTextId != null) {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTUPDATESQL);\n            values.addElement(new StringValue(copyrightText.getCopyrightTextId()));\n        } else {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTINSERTSQL);\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        if (copyrightTextId == null) {\n            try {\n                sqlCommandBean.setSqlValue(COPYRIGHTTEXTLOOKUPIDSQL);\n                values.clear();\n                values.addElement(textValue);\n                Vector rows;\n                rows = sqlCommandBean.executeQuery();\n                Row aRow = (Row) rows.firstElement();\n                copyrightTextId = aRow.getString(\"CopyrightTextID\");\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return copyrightTextId;\n    }\n\n    /**\n     * Inserts the information about the specified copyrightHolder,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyrightHolder(CopyrightHolderBean copyrightHolder, Connection conn) throws SQLException {\n        if (copyrightHolder == null) {\n            return;\n        }\n        String vCardID = saveVCard(copyrightHolder.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String copyrightHolderId = copyrightHolder.getCopyrightHolderId();\n        if (copyrightHolderId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTHOLDERINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTHOLDERUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyrightHolder.getMetadataId()));\n        values.addElement(new StringValue(vCardID));\n        if (copyrightHolderId != null) {\n            values.addElement(new StringValue(copyrightHolderId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * @param vCard non-null vcard String\n     * @param conn\n     *\n     * @return\n     *\n     * @throws SQLException\n     */\n    public String saveVCard(String vCard, Connection conn) throws SQLException {\n        vCard = vCard.trim();\n        String vCardID = getVCardIDByVCard(vCard, conn);\n        if (vCardID == null) {\n            // No current vCard found, so we have to insert one\n            SQLCommandBean sqlInsertCommand = new SQLCommandBean();\n            sqlInsertCommand.setConnection(conn);\n            sqlInsertCommand.setSqlValue(\"INSERT INTO vCards (vCard) VALUES (?)\");\n            Vector insertValues = new Vector();\n            insertValues.add(new StringValue(vCard));\n            sqlInsertCommand.setValues(insertValues);\n            sqlInsertCommand.executeUpdate();\n            vCardID = getVCardIDByVCard(vCard, conn);\n        }\n        return vCardID;\n    }\n\n    /**\n     * Returns a vCardID or null if no VCard matching the vCard parameter\n     * is found.\n     *\n     * @param vCard The String of the vCard to be found\n     * @param conn The connection to the database.\n     *\n     * @return <code>null</code>If no vCard is found, otherwise returns a\n     *         <code>String</code> containing the vCardID\n     */\n    private String getVCardIDByVCard(String vCard, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommand = new SQLCommandBean();\n        sqlCommand.setConnection(conn);\n        sqlCommand.setSqlValue(\"SELECT vCardID FROM vCards WHERE vCard LIKE ?\");\n        Vector values = new Vector();\n        values.add(new StringValue(vCard));\n        sqlCommand.setValues(values);\n        Vector results;\n        try {\n            results = sqlCommand.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.getMessage());\n        }\n        if (results != null && results.size() > 0) {\n            Row row = (Row) results.get(0);\n            try {\n                return row.getString(\"vCardID\");\n            } catch (NoSuchColumnException e) {\n                throw new SQLException(e.getMessage());\n            }\n        } else\n            return null;\n    }\n\n    public void saveTaxonPath(TaxonPathBean taxonPath) throws SQLException {\n        if (null == taxonPath) {\n            return;\n        }\n        Connection conn = dataSource.getConnection();\n        try {\n            saveTaxonPath(taxonPath, conn);\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Inserts the information about the specified taxon path,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxonPath(TaxonPathBean taxonPath, Connection conn) throws SQLException {\n        if (taxonPath == null) {\n            return;\n        }\n        String taxonPathId = taxonPath.getTaxonPathId();\n        final String source = taxonPath.getSource();\n        final String purpose = taxonPath.getPurpose();\n        final String description = taxonPath.getDescription();\n        final String keyword = taxonPath.getKeyword();\n        final String metadataId = taxonPath.getMetadataId();\n        // Checks if a taxon path like this already exists in the db\n        if (null == taxonPathId) {\n            taxonPathId = getTaxonPathId(metadataId, source, conn);\n        }\n        if (taxonPathId == null) {\n            // Use INSERT statement\n            final String sql = TAXONPATHINSERTSQL;\n            final SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql);\n            // Sets a temporary source so that we can grab the taxon path id with a unique value\n            final String tempSource = metadataId + System.currentTimeMillis();\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            values.addElement(new StringValue(tempSource));\n            values.addElement(new StringValue(purpose));\n            values.addElement(new StringValue(description));\n            values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            // Gets the taxon path id using the unique temporary source value\n            sqlCommandBean.setSqlValue(\"SELECT TaxonPathID FROM \" + \"TaxonPaths WHERE Source = ?\");\n            values.clear();\n            values.addElement(new StringValue(tempSource));\n            //  values.addElement(new StringValue(purpose));\n            // values.addElement(new StringValue(description));\n            //  values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    Row aRow = (Row) rows.firstElement();\n                    // taxonPathId is used below to set the taxon path bean's taxon path id\n                    taxonPathId = aRow.getString(\"TaxonPathID\");\n                    // fixes the temporary source\n                    sqlCommandBean.setSqlValue(\"UPDATE TaxonPaths SET \" + \"Source = ?, Purpose = ?, Description = ?, Keyword = ? \" + \"WHERE TaxonPathID = ?\");\n                    values.clear();\n                    values.addElement(new StringValue(source));\n                    values.addElement(new StringValue(purpose));\n                    values.addElement(new StringValue(description));\n                    values.addElement(new StringValue(keyword));\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    sqlCommandBean.executeUpdate();\n                }\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            } catch (UnsupportedTypeException ex2) {\n                throw new SQLException(ex2.toString());\n            }\n        }\n        taxonPath.setTaxonPathId(taxonPathId);\n        // There should be a taxon path id now\n        if (taxonPathId != null && taxonPath.getTaxons() != null) {\n            Iterator taxonIterator = taxonPath.getTaxons().iterator();\n            while (taxonIterator.hasNext()) {\n                TaxonBean taxon = (TaxonBean) taxonIterator.next();\n                taxon.setTaxonPathId(taxonPathId);\n                saveTaxon(taxon, conn);\n            }\n        } else {\n            throw new RuntimeException(\"Unable to save TaxonPath\");\n        }\n    }\n\n    private String getTaxonPathId(final String metadataId, final String source, final Connection conn) throws SQLException {\n        final String sql = \"SELECT TaxonPathId FROM TaxonPaths WHERE MetadataID = ? AND Source = ?\";\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.setString(2, source);\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified taxon,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxon(TaxonBean taxon, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        String taxonId = taxon.getTaxonId();\n        String taxonPathId = taxon.getTaxonPathId();\n        String id = taxon.getId();\n        String entry = taxon.getEntry();\n        // Checks to see if a Taxon matching this  bean already exists\n        // in the database\n        String existingTaxon = getTaxonId(taxon, conn);\n        if (null != existingTaxon) {\n            taxon.setTaxonId(existingTaxon);\n            return;\n        }\n        if (taxonId == null) {\n            // Use INSERT statement\n            sql.append(TAXONINSERTSQL);\n        } else {\n            sql.append(TAXONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(taxonPathId));\n        values.addElement(new StringValue(id));\n        values.addElement(new StringValue(entry));\n        if (taxonId != null) {\n            values.addElement(new StringValue(taxonId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    private String getTaxonId(TaxonBean taxon, Connection conn) throws SQLException {\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String sql = \"SELECT TaxonID FROM Taxons WHERE Id = ? AND Entry = ? AND TaxonPathID = ?\";\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, taxon.getId());\n            ps.setString(2, taxon.getEntry());\n            ps.setString(3, taxon.getTaxonPathId());\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified contextURL,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContextURL(ContextURLBean contextURL, Connection conn) throws SQLException {\n        if (contextURL == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String contextURLId = contextURL.getContextURLId();\n        if (contextURLId == null) {\n            // Use INSERT statement\n            sql.append(CONTEXTURLINSERTSQL);\n        } else {\n            sql.append(CONTEXTURLUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contextURL.getMetadataId()));\n        values.addElement(new StringValue(contextURL.getContextURL()));\n        values.addElement(new StringValue(contextURL.getContextURLDescription()));\n        if (contextURLId != null) {\n            values.addElement(new StringValue(contextURLId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified contributor,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContributor(ContributorBean contributor, Connection conn) throws SQLException {\n        if (contributor == null) {\n            return;\n        }\n        String vCardID = saveVCard(contributor.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String contributorId = contributor.getContributorId();\n        if (contributorId == null) {\n            // Use INSERT statement\n            sql.append(CONTRIBUTORINSERTSQL);\n        } else {\n            sql.append(CONTRIBUTORUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contributor.getMetadataId()));\n        values.addElement(new StringValue(contributor.getRole()));\n        values.addElement(new StringValue(vCardID));\n        java.sql.Date contributeDate = null;\n        if (null != contributor.getDate()) {\n            contributeDate = new java.sql.Date(contributor.getDate().getTime());\n        }\n        values.addElement(new DateValue(contributeDate));\n        values.addElement(new StringValue(contributor.getDateDescription()));\n        values.addElement(new StringValue(contributor.getVersion()));\n        values.addElement(new StringValue(contributor.getStatus()));\n        if (contributorId != null) {\n            values.addElement(new StringValue(contributor.getContributorId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified requirement,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRequirement(RequirementBean requirement, Connection conn) throws SQLException {\n        if (requirement == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String requirementId = requirement.getRequirementId();\n        if (requirementId == null) {\n            // Use INSERT statement\n            sql.append(REQUIREMENTINSERTSQL);\n        } else {\n            sql.append(REQUIREMENTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(requirement.getMetadataId()));\n        values.addElement(new StringValue(requirement.getRequirementType()));\n        values.addElement(new StringValue(requirement.getRequirementName()));\n        values.addElement(new StringValue(requirement.getOtherPlatform()));\n        values.addElement(new StringValue(requirement.getDuration()));\n        values.addElement(new StringValue(requirement.getDescription()));\n        if (requirementId != null) {\n            values.addElement(new StringValue(requirement.getRequirementId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified relation,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRelation(RelationBean relation, Connection conn) throws SQLException {\n        if (relation == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String relationId = relation.getRelationId();\n        if (relationId == null) {\n            // Use INSERT statement\n            sql.append(RELATIONINSERTSQL);\n        } else {\n            sql.append(RELATIONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(relation.getMetadataId()));\n        values.addElement(new StringValue(relation.getResource()));\n        values.addElement(new StringValue(relation.getKind()));\n        values.addElement(new StringValue(relation.getDescription()));\n        values.addElement(new StringValue(relation.getCatalogue()));\n        values.addElement(new StringValue(relation.getEntry()));\n        if (relationId != null) {\n            values.addElement(new StringValue(relation.getRelationId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveKeyword(KeywordBean keyword, Connection conn) throws SQLException {\n        if (keyword == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String keywordId = keyword.getKeywordId();\n        if (keywordId == null) {\n            // Use INSERT statement\n            sql.append(KEYWORDINSERTSQL);\n        } else {\n            sql.append(KEYWORDUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(keyword.getMetadataId()));\n        values.addElement(new StringValue(keyword.getKeyword()));\n        if (keywordId != null) {\n            values.addElement(new StringValue(keywordId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTargetUserGroup(TargetUserGroupBean tug, Connection conn) throws SQLException {\n        if (tug == null) {\n            return;\n        }\n        List<TargetUserGroupBean> existingTugs = new ArrayList<TargetUserGroupBean>();\n        Vector rows = null;\n        if (null != tug.getMetadataId()) {\n            rows = getMetadataProperties(tug.getMetadataId(), \"TargetUserGroup\", \"TargetUserGroups\", conn);\n        }\n        if (null != rows) {\n            try {\n                for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                    Row row = (Row) iter.next();\n                    String tugDescription = row.getString(\"TargetUserGroup\");\n                    TargetUserGroupBean temp = new TargetUserGroupBean();\n                    temp.setMetadataId(tug.getMetadataId());\n                    temp.setTargetUserGroup(tugDescription);\n                    existingTugs.add(temp);\n                }\n            } catch (NoSuchColumnException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (null != tug.getTargetUserGroup()) {\n            for (TargetUserGroupBean existingTug : existingTugs) {\n                if (tug.getTargetUserGroup().equals(existingTug.getTargetUserGroup())) {\n                    // We don't need to save this TUG, because it already exists\n                    return;\n                }\n            }\n        }\n        String sql = TARGETUSERGROUPINSERTSQL;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(tug.getMetadataId()));\n        values.addElement(new StringValue(tug.getTargetUserGroup()));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public void deleteTargetUserGroupsByMetadataId(final String metadataId, final Connection conn) throws SQLException {\n        if (null == metadataId)\n            return;\n        final String sql = \"DELETE FROM TargetUserGroups WHERE MetadataId = ?\";\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified format,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveFormat(FormatBean format, Connection conn) throws SQLException {\n        if (format == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String formatId = format.getFormatId();\n        if (formatId == null) {\n            // Use INSERT statement\n            sql.append(FORMATINSERTSQL);\n        } else {\n            sql.append(FORMATUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(format.getMetadataId()));\n        values.addElement(new StringValue(format.getFormat()));\n        if (formatId != null) {\n            values.addElement(new StringValue(formatId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public List getMetametadataIdentifiers(String metadataId, Connection conn) {\n        List<MetametadataIdentifierBean> ret = new ArrayList<MetametadataIdentifierBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT MetametadataIdentifierID, Catalogue, Entry, MetadataSchema FROM MetametadataIdentifiers WHERE MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataIdentifierBean mib = new MetametadataIdentifierBean();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n                mib.setMetadataId(metadataId);\n                mib.setCatalog(rs.getString(2));\n                mib.setEntry(rs.getString(3));\n                mib.setMetadataSchema(rs.getString(4));\n                ret.add(mib);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return ret;\n    }\n\n    public List getMetametadataContributors(String metadataId, Connection conn) throws SQLException {\n        List<MetametadataContributorBean> ret = new ArrayList<MetametadataContributorBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT A.MetametadataContributorID, A.Role, A.ContributeDate, A.ContributeDateDescription, B.vCard FROM MetametadataContributors A INNER JOIN vCards B ON A.vCardID = B.vCardID WHERE A.MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataContributorBean mcb = new MetametadataContributorBean();\n                mcb.setMetametadataContributorId(rs.getString(1));\n                mcb.setRole(rs.getString(2));\n                mcb.setDate(rs.getDate(3));\n                mcb.setDateDescription(rs.getString(4));\n                mcb.setvCard(rs.getString(5));\n                mcb.setMetadataId(metadataId);\n                ret.add(mcb);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/CommonDAOTest0.java",
		"test_prompt": "// CommonDAOTest0.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CommonDAO}.\n* It contains ten unit test cases for the {@link CommonDAO#deleteMetadata(String)} method.\n*/\nclass CommonDAOTest0 {"
	},
	{
		"original_code": "// CommonDAO.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class CommonDAO implements Serializable {\n\n    public CommonDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private static final String THUMBNAILINSERTSQL = \"INSERT INTO Thumbnails (MetadataId, Location, FileWidth, FileHeight) VALUES(?, ?, ?, ?)\";\n\n    private static final String THUMBNAILUPDATESQL = \"UPDATE Thumbnails SET MetadataId = ?, Location= ?, FileWidth= ?, FileHeight = ? WHERE ThumbnailID = ?\";\n\n    private static final String COPYRIGHTINSERTSQL = \"INSERT INTO Copyrights (MetadataID, CopyrightTextID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTUPDATESQL = \"UPDATE Copyrights SET MetadataID = ?, CopyrightTextID = ? WHERE CopyrightID = ?\";\n\n    private static final String COPYRIGHTTEXTINSERTSQL = \"INSERT INTO CopyrightTexts (CopyrightText, Cost, CopyrightAndOtherRestriction) VALUES(?, ?, ?)\";\n\n    private static final String COPYRIGHTTEXTUPDATESQL = \"UPDATE CopyrightTexts SET CopyrightText = ?, Cost = ?, CopyrightAndOtherRestriction = ? WHERE CopyrightTextID = ?\";\n\n    private static final String COPYRIGHTTEXTLOOKUPIDSQL = \"SELECT CopyrightTextID FROM CopyrightTexts WHERE CopyrightText = ?\";\n\n    private static final String DISEASEDIAGNOSISINSERTSQL = \"INSERT INTO DiseaseDiagnoses (MetadataID, DiseaseDiagnosis) VALUES(?, ?)\";\n\n    private static final String DISEASEDIAGNOSISUPDATESQL = \"UPDATE DiseaseDiagnoses SET MetadataID = ?, DiseaseDiagnosis = ? WHERE DiseaseDiagnosisID = ?\";\n\n    private static final String COPYRIGHTHOLDERINSERTSQL = \"INSERT INTO CopyrightHolders (MetadataID, vCardID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTHOLDERUPDATESQL = \"UPDATE CopyrightHolders SET MetadataID = ?, vCardID = ? WHERE CopyrightHolderID = ?\";\n\n    private static final String KEYWORDINSERTSQL = \"INSERT INTO Keywords (MetadataID, Keyword) VALUES(?, ?)\";\n\n    private static final String KEYWORDUPDATESQL = \"UPDATE Keywords SET MetadataID = ?, Keyword = ? WHERE KeywordID = ?\";\n\n    private static final String FORMATINSERTSQL = \"INSERT INTO Formats (MetadataID, Format) VALUES(?, ?)\";\n\n    private static final String FORMATUPDATESQL = \"UPDATE Formats SET MetadataID = ?, Format = ? WHERE FormatID = ?\";\n\n    private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source, Purpose, Description, Keyword) VALUES(?, ?, ?, ?, ?)\";\n\n    //  private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source) VALUES(?, ?)\";\n    private static final String TAXONINSERTSQL = \"INSERT INTO Taxons (TaxonPathID, ID, Entry) VALUES(?, ?, ?)\";\n\n    private static final String TAXONUPDATESQL = \"UPDATE Taxons SET TaxonPathID = ?, ID = ?, Entry = ? WHERE TaxonID = ?\";\n\n    private static final String CONTEXTURLINSERTSQL = \"INSERT INTO ContextURLs (MetadataID, ContextURL, ContextURLDescription) VALUES(?, ?, ?)\";\n\n    private static final String CONTEXTURLUPDATESQL = \"UPDATE ContextURLs SET MetadataID = ?, ContextURL = ?, ContextURLDescription = ? WHERE ContextURLID = ?\";\n\n    private static final String REQUIREMENTINSERTSQL = \"INSERT INTO Requirements (MetadataID, RequirementType, RequirementName, OtherPlatformRequirements, Duration, Description) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String REQUIREMENTUPDATESQL = \"UPDATE Requirements SET MetadataID = ?, RequirementType = ?, RequirementName = ?, OtherPlatformRequirements = ?, Duration = ?, Description = ? WHERE RequirementID = ?\";\n\n    private static final String CONTRIBUTORINSERTSQL = \"INSERT INTO Contributors (MetadataID, Role, vCardID, ContributeDate, ContributeDateDescription, Version, Status) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String CONTRIBUTORUPDATESQL = \"UPDATE Contributors SET MetadataID = ?, Role = ?, vCardID = ?, ContributeDate = ?, ContributeDateDescription = ?, Version = ?, Status = ? WHERE ContributorID = ?\";\n\n    private static final String RELATIONINSERTSQL = \"INSERT INTO Relations (MetadataID, Resource, Kind, Description, Catalogue, Entry) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String RELATIONUPDATESQL = \"UPDATE Relations SET MetadataID = ?, Resource = ?, Kind = ?, Description = ?, Catalogue = ?, Entry = ? WHERE RelationID = ?\";\n\n    private static final String TARGETUSERGROUPINSERTSQL = \"INSERT INTO TargetUserGroups (MetadataId, TargetUserGroup) VALUES (?, ?)\";\n\n    private static final String DELETEDITEMSINSERTSQL = \"INSERT INTO DeletedItems (GlobalID, FileName, Title, Location, ContributeUserID, ContributeDate, DeleteDate, Comments) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"UPDATE Metadata SET \").append(propertyName).append(\" = ? WHERE \");\n        sql.append(\"MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(propertyValue);\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataStringProperty(String propertyName, String propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new StringValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataTimestampProperty(String propertyName, Timestamp propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new TimestampValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Returns a Vector of Rows with all of the requested columns from the\n     * requested table that have the specified metadataId in their\n     * MetadataID column, or null if no matches are found.\n     */\n    public Vector getMetadataProperties(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        if (metadataId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT \").append(columnNames).append(\" FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        return rows;\n    }\n\n    public TimestampValue getTimestampValue(Date date) {\n        TimestampValue ret;\n        if (null != date) {\n            ret = new TimestampValue(new Timestamp(date.getTime()));\n        } else {\n            ret = new TimestampValue(null);\n        }\n        return ret;\n    }\n\n    public IntValue getIntValue(String intString) {\n        int parsedInt = 0;\n        try {\n            parsedInt = Integer.parseInt(intString);\n        } catch (NumberFormatException ex) {\n            //XXX logging?\n        }\n        return new IntValue(parsedInt);\n    }\n\n    public LongValue getLongValue(String longString) {\n        long parsedLong = 0;\n        try {\n            parsedLong = Long.parseLong(longString);\n        } catch (NumberFormatException e) {\n        }\n        return new LongValue(parsedLong);\n    }\n\n    /**\n     * Gets all rows from a given table.  The return value is a Vector\n     * of com.ora.jsp.sql.Row object or null if an error occurs.\n     */\n    public Vector getAllRows(String tableName) throws SQLException {\n        if (tableName == null) {\n            return null;\n        }\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(\"SELECT * FROM \" + tableName);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId, Connection conn) throws SQLException {\n        // Get the metadata info from the database\n        Row metadataRow = getMetadataProperty(metadataId, \"Metadata.*, Publications.Name AS PubName, Publications.PublicationDate AS PubDate\", \"Metadata LEFT OUTER JOIN Publications ON Metadata.PublicationId = Publications.PublicationId\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        MetadataBean metadataInfo = new MetadataBean();\n        try {\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setContributeDate(DateTools.parse(metadataRow.getString(\"ContributeDate\")));\n            metadataInfo.setAnnotated(metadataRow.getString(\"Annotated\"));\n            metadataInfo.setInappropriate(metadataRow.getString(\"Inappropriate\"));\n            metadataInfo.setArchived(metadataRow.getString(\"Archived\"));\n            metadataInfo.setPrivate(metadataRow.getString(\"Private\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setSpecimenType(metadataRow.getString(\"SpecimenType\"));\n            metadataInfo.setRadiographType(metadataRow.getString(\"RadiographType\"));\n            metadataInfo.setOrientation(metadataRow.getString(\"Orientation\"));\n            metadataInfo.setMagnification(metadataRow.getString(\"Magnification\"));\n            metadataInfo.setClinicalHistory(metadataRow.getString(\"ClinicalHistory\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setDuration(metadataRow.getString(\"Duration\"));\n            metadataInfo.setApproveDate(DateTools.parse(metadataRow.getString(\"ApproveDate\")));\n            metadataInfo.setCatalogDate(DateTools.parse(metadataRow.getString(\"CatalogDate\")));\n            metadataInfo.setRejectDate(DateTools.parse(metadataRow.getString(\"RejectDate\")));\n            metadataInfo.setCreationDate(DateTools.parse(metadataRow.getString(\"CreationDate\")));\n            metadataInfo.setPublicationName(metadataRow.getString(\"PubName\"));\n            metadataInfo.setPublicationDate(DateTools.parse(metadataRow.getString(\"PubDate\")));\n            // For some reason a null integer gets returned from getString as \"0\"\n            // so this ensures the publicationId is populated as null correctly\n            final String publicationId = metadataRow.getString(\"PublicationId\");\n            metadataInfo.setPublicationId(\"0\".equals(publicationId) ? null : publicationId);\n            metadataInfo.setLanguageType(metadataRow.getString(\"LanguageType\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * metadata or null if the metadata is not found.\n     */\n    public Row getMetadataProperty(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        Vector results = getMetadataProperties(metadataId, columnNames, tableName, conn);\n        if (results != null) {\n            return (Row) results.firstElement();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Removes all taxons and taxon paths associated with the given metadataId.\n     */\n    public void removeTaxonPaths(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Taxons WHERE TaxonPathID in (SELECT TaxonPathID FROM TaxonPaths WHERE MetadataID = ?)\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        sql.append(\"DELETE FROM TaxonPaths WHERE MetadataID = ?\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all copyright entries with the given metadataId\n     * from the Copyrights table.\n     */\n    public void removeCopyrights(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Copyrights WHERE MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        //clean up the copyright texts\n        sql.append(\"DELETE FROM CopyrightTexts WHERE CopyrightTextID NOT IN (SELECT CopyrightTextID FROM Copyrights)\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values = new Vector();\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all entries in a table that have a given metadataId.\n     */\n    public void removeMetadataFromTable(String metadataId, String tableName, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Deletes the metadata entry from the metadata table.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadata(String metadataId) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            removeMetadataFromTable(metadataId, \"Metadata\", conn);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return success;\n    }\n\n    public String getMetadataPropertyAsString(String metadataId, String columnName, String tableName, Connection conn) throws SQLException {\n        Row row = getMetadataProperty(metadataId, columnName, tableName, conn);\n        if (row != null) {\n            try {\n                return row.getString(columnName);\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = getMetadata(metadataId, conn);\n        addToDeletedItems(metadata, comment, conn);\n        success = deleteMetadataReferences(metadataId, conn);\n        removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Takes information from the metadata bean and stores it in the\n     * deleted items table, with the addition of the provided comment.\n     */\n    public void addToDeletedItems(MetadataBean metadata, String comment, Connection conn) throws SQLException {\n        if (metadata == null) {\n            throw new SQLException(\"Invalid metadata provided.\");\n        }\n        Timestamp deleteDate = new Timestamp(System.currentTimeMillis());\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(DELETEDITEMSINSERTSQL);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getGlobalId()));\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(getIntValue(metadata.getContributeUserId()));\n        values.addElement(getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new TimestampValue(deleteDate));\n        values.addElement(new StringValue(comment));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all references to the given metadataId, EXCEPT for the main\n     * entry in the Metadata table.  All other references are removed from\n     * the other tables (Formats, Keywords, Requirements, etc).\n     * Also deleted are all taxons associated with taxonpaths associated with\n     * this metadata reference.  Also, all copyrights associated with the\n     * metadata are deleted.  If the copyright to be deleted contains the only\n     * reference to the associated copyright text, then the copyright text\n     * is also deleted.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadataReferences(String metadataId, Connection conn) throws SQLException {\n        //first do the easy removals...\n        removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        removeMetadataFromTable(metadataId, \"Formats\", conn);\n        removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        removeMetadataFromTable(metadataId, \"Relations\", conn);\n        removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n        removeTaxonPaths(metadataId, conn);\n        removeCopyrights(metadataId, conn);\n        return true;\n    }\n\n    /**\n     * Returns a ThumbnailBean associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public ThumbnailBean getThumbnail(String metadataId, Connection conn) throws SQLException {\n        ThumbnailBean result = null;\n        if (metadataId != null) {\n            Vector rows = getMetadataProperties(metadataId, \"*\", \"Thumbnails\", conn);\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new ThumbnailBean();\n                    result.setThumbnailId(row.getString(\"ThumbnailID\"));\n                    result.setMetadataId(metadataId);\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"FileWidth\"));\n                    result.setFileHeight(row.getString(\"FileHeight\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a SourceCollection Bean associated with the\n     * given source collection name.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public SourceCollectionBean getSCollectionBean(String name, Connection conn) throws SQLException {\n        SourceCollectionBean result = null;\n        if (name != null) {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT * FROM SourceCollection WHERE name = ?\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(name));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new SourceCollectionBean();\n                    result.setSourceId(row.getString(\"SourceCollectionID\"));\n                    result.setSourceName(\"Name\");\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"Width\"));\n                    result.setFileHeight(row.getString(\"Height\"));\n                    result.setLink(row.getString(\"Link\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Inserts the information about the specified thumbnail,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveThumbnail(ThumbnailBean thumbnail, Connection conn) throws SQLException {\n        if (thumbnail == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String thumbnailId = thumbnail.getThumbnailId();\n        Vector values = new Vector();\n        if (thumbnailId == null) {\n            // Use INSERT statement\n            sql.append(THUMBNAILINSERTSQL);\n        } else {\n            sql.append(THUMBNAILUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values.addElement(new StringValue(thumbnail.getMetadataId()));\n        values.addElement(new StringValue(thumbnail.getLocation()));\n        values.addElement(new StringValue(thumbnail.getFileWidth()));\n        values.addElement(new StringValue(thumbnail.getFileHeight()));\n        if (thumbnailId != null) {\n            values.addElement(new StringValue(thumbnailId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified diseaseDiagnosis,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveDiseaseDiagnosis(DiseaseDiagnosisBean diseaseDiagnosis, Connection conn) throws SQLException {\n        if (diseaseDiagnosis == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String diseaseDiagnosisId = diseaseDiagnosis.getDiseaseDiagnosisId();\n        if (diseaseDiagnosisId == null) {\n            // Use INSERT statement\n            sql.append(DISEASEDIAGNOSISINSERTSQL);\n        } else {\n            sql.append(DISEASEDIAGNOSISUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(diseaseDiagnosis.getMetadataId()));\n        values.addElement(new StringValue(diseaseDiagnosis.getDiseaseDiagnosis()));\n        if (diseaseDiagnosisId != null) {\n            values.addElement(new StringValue(diseaseDiagnosisId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified copyright,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyright(CopyrightBean copyright, Connection conn) throws SQLException {\n        if (copyright == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String copyrightId = copyright.getCopyrightId();\n        if (copyrightId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyright.getMetadataId()));\n        String copyrightTextId = saveCopyrightText(copyright.getCopyrightText(), conn);\n        values.addElement(new StringValue(copyrightTextId));\n        if (copyrightId != null) {\n            values.addElement(new StringValue(copyright.getCopyrightId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Stores a CopyrightTextBean in the database.  If the provided\n     * CopyrightTextBean has a copyrightTextId that is non-null, an update\n     * will be attempted.  Otherwise, an insert will be performed.\n     * The copyrightTextId will be returned.  This will either be obtained\n     * from the provided bean, or by doing another database lookup after\n     * the insert (looking for a match on the copyrightText).\n     */\n    public String saveCopyrightText(CopyrightTextBean copyrightText, Connection conn) throws SQLException {\n        if (copyrightText == null) {\n            return null;\n        }\n        String copyrightTextId = null;\n        copyrightTextId = copyrightText.getCopyrightTextId();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        Vector values = new Vector();\n        StringValue textValue = new StringValue(copyrightText.getCopyrightText());\n        values.addElement(textValue);\n        values.addElement(new StringValue(copyrightText.getCost()));\n        values.addElement(new StringValue(copyrightText.getCopyrightAndOtherRestriction()));\n        if (copyrightTextId != null) {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTUPDATESQL);\n            values.addElement(new StringValue(copyrightText.getCopyrightTextId()));\n        } else {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTINSERTSQL);\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        if (copyrightTextId == null) {\n            try {\n                sqlCommandBean.setSqlValue(COPYRIGHTTEXTLOOKUPIDSQL);\n                values.clear();\n                values.addElement(textValue);\n                Vector rows;\n                rows = sqlCommandBean.executeQuery();\n                Row aRow = (Row) rows.firstElement();\n                copyrightTextId = aRow.getString(\"CopyrightTextID\");\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return copyrightTextId;\n    }\n\n    /**\n     * Inserts the information about the specified copyrightHolder,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyrightHolder(CopyrightHolderBean copyrightHolder, Connection conn) throws SQLException {\n        if (copyrightHolder == null) {\n            return;\n        }\n        String vCardID = saveVCard(copyrightHolder.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String copyrightHolderId = copyrightHolder.getCopyrightHolderId();\n        if (copyrightHolderId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTHOLDERINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTHOLDERUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyrightHolder.getMetadataId()));\n        values.addElement(new StringValue(vCardID));\n        if (copyrightHolderId != null) {\n            values.addElement(new StringValue(copyrightHolderId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * @param vCard non-null vcard String\n     * @param conn\n     *\n     * @return\n     *\n     * @throws SQLException\n     */\n    public String saveVCard(String vCard, Connection conn) throws SQLException {\n        vCard = vCard.trim();\n        String vCardID = getVCardIDByVCard(vCard, conn);\n        if (vCardID == null) {\n            // No current vCard found, so we have to insert one\n            SQLCommandBean sqlInsertCommand = new SQLCommandBean();\n            sqlInsertCommand.setConnection(conn);\n            sqlInsertCommand.setSqlValue(\"INSERT INTO vCards (vCard) VALUES (?)\");\n            Vector insertValues = new Vector();\n            insertValues.add(new StringValue(vCard));\n            sqlInsertCommand.setValues(insertValues);\n            sqlInsertCommand.executeUpdate();\n            vCardID = getVCardIDByVCard(vCard, conn);\n        }\n        return vCardID;\n    }\n\n    /**\n     * Returns a vCardID or null if no VCard matching the vCard parameter\n     * is found.\n     *\n     * @param vCard The String of the vCard to be found\n     * @param conn The connection to the database.\n     *\n     * @return <code>null</code>If no vCard is found, otherwise returns a\n     *         <code>String</code> containing the vCardID\n     */\n    private String getVCardIDByVCard(String vCard, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommand = new SQLCommandBean();\n        sqlCommand.setConnection(conn);\n        sqlCommand.setSqlValue(\"SELECT vCardID FROM vCards WHERE vCard LIKE ?\");\n        Vector values = new Vector();\n        values.add(new StringValue(vCard));\n        sqlCommand.setValues(values);\n        Vector results;\n        try {\n            results = sqlCommand.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.getMessage());\n        }\n        if (results != null && results.size() > 0) {\n            Row row = (Row) results.get(0);\n            try {\n                return row.getString(\"vCardID\");\n            } catch (NoSuchColumnException e) {\n                throw new SQLException(e.getMessage());\n            }\n        } else\n            return null;\n    }\n\n    public void saveTaxonPath(TaxonPathBean taxonPath) throws SQLException {\n        if (null == taxonPath) {\n            return;\n        }\n        Connection conn = dataSource.getConnection();\n        try {\n            saveTaxonPath(taxonPath, conn);\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Inserts the information about the specified taxon path,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxonPath(TaxonPathBean taxonPath, Connection conn) throws SQLException {\n        if (taxonPath == null) {\n            return;\n        }\n        String taxonPathId = taxonPath.getTaxonPathId();\n        final String source = taxonPath.getSource();\n        final String purpose = taxonPath.getPurpose();\n        final String description = taxonPath.getDescription();\n        final String keyword = taxonPath.getKeyword();\n        final String metadataId = taxonPath.getMetadataId();\n        // Checks if a taxon path like this already exists in the db\n        if (null == taxonPathId) {\n            taxonPathId = getTaxonPathId(metadataId, source, conn);\n        }\n        if (taxonPathId == null) {\n            // Use INSERT statement\n            final String sql = TAXONPATHINSERTSQL;\n            final SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql);\n            // Sets a temporary source so that we can grab the taxon path id with a unique value\n            final String tempSource = metadataId + System.currentTimeMillis();\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            values.addElement(new StringValue(tempSource));\n            values.addElement(new StringValue(purpose));\n            values.addElement(new StringValue(description));\n            values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            // Gets the taxon path id using the unique temporary source value\n            sqlCommandBean.setSqlValue(\"SELECT TaxonPathID FROM \" + \"TaxonPaths WHERE Source = ?\");\n            values.clear();\n            values.addElement(new StringValue(tempSource));\n            //  values.addElement(new StringValue(purpose));\n            // values.addElement(new StringValue(description));\n            //  values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    Row aRow = (Row) rows.firstElement();\n                    // taxonPathId is used below to set the taxon path bean's taxon path id\n                    taxonPathId = aRow.getString(\"TaxonPathID\");\n                    // fixes the temporary source\n                    sqlCommandBean.setSqlValue(\"UPDATE TaxonPaths SET \" + \"Source = ?, Purpose = ?, Description = ?, Keyword = ? \" + \"WHERE TaxonPathID = ?\");\n                    values.clear();\n                    values.addElement(new StringValue(source));\n                    values.addElement(new StringValue(purpose));\n                    values.addElement(new StringValue(description));\n                    values.addElement(new StringValue(keyword));\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    sqlCommandBean.executeUpdate();\n                }\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            } catch (UnsupportedTypeException ex2) {\n                throw new SQLException(ex2.toString());\n            }\n        }\n        taxonPath.setTaxonPathId(taxonPathId);\n        // There should be a taxon path id now\n        if (taxonPathId != null && taxonPath.getTaxons() != null) {\n            Iterator taxonIterator = taxonPath.getTaxons().iterator();\n            while (taxonIterator.hasNext()) {\n                TaxonBean taxon = (TaxonBean) taxonIterator.next();\n                taxon.setTaxonPathId(taxonPathId);\n                saveTaxon(taxon, conn);\n            }\n        } else {\n            throw new RuntimeException(\"Unable to save TaxonPath\");\n        }\n    }\n\n    private String getTaxonPathId(final String metadataId, final String source, final Connection conn) throws SQLException {\n        final String sql = \"SELECT TaxonPathId FROM TaxonPaths WHERE MetadataID = ? AND Source = ?\";\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.setString(2, source);\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified taxon,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxon(TaxonBean taxon, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        String taxonId = taxon.getTaxonId();\n        String taxonPathId = taxon.getTaxonPathId();\n        String id = taxon.getId();\n        String entry = taxon.getEntry();\n        // Checks to see if a Taxon matching this  bean already exists\n        // in the database\n        String existingTaxon = getTaxonId(taxon, conn);\n        if (null != existingTaxon) {\n            taxon.setTaxonId(existingTaxon);\n            return;\n        }\n        if (taxonId == null) {\n            // Use INSERT statement\n            sql.append(TAXONINSERTSQL);\n        } else {\n            sql.append(TAXONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(taxonPathId));\n        values.addElement(new StringValue(id));\n        values.addElement(new StringValue(entry));\n        if (taxonId != null) {\n            values.addElement(new StringValue(taxonId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    private String getTaxonId(TaxonBean taxon, Connection conn) throws SQLException {\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String sql = \"SELECT TaxonID FROM Taxons WHERE Id = ? AND Entry = ? AND TaxonPathID = ?\";\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, taxon.getId());\n            ps.setString(2, taxon.getEntry());\n            ps.setString(3, taxon.getTaxonPathId());\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified contextURL,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContextURL(ContextURLBean contextURL, Connection conn) throws SQLException {\n        if (contextURL == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String contextURLId = contextURL.getContextURLId();\n        if (contextURLId == null) {\n            // Use INSERT statement\n            sql.append(CONTEXTURLINSERTSQL);\n        } else {\n            sql.append(CONTEXTURLUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contextURL.getMetadataId()));\n        values.addElement(new StringValue(contextURL.getContextURL()));\n        values.addElement(new StringValue(contextURL.getContextURLDescription()));\n        if (contextURLId != null) {\n            values.addElement(new StringValue(contextURLId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified contributor,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContributor(ContributorBean contributor, Connection conn) throws SQLException {\n        if (contributor == null) {\n            return;\n        }\n        String vCardID = saveVCard(contributor.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String contributorId = contributor.getContributorId();\n        if (contributorId == null) {\n            // Use INSERT statement\n            sql.append(CONTRIBUTORINSERTSQL);\n        } else {\n            sql.append(CONTRIBUTORUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contributor.getMetadataId()));\n        values.addElement(new StringValue(contributor.getRole()));\n        values.addElement(new StringValue(vCardID));\n        java.sql.Date contributeDate = null;\n        if (null != contributor.getDate()) {\n            contributeDate = new java.sql.Date(contributor.getDate().getTime());\n        }\n        values.addElement(new DateValue(contributeDate));\n        values.addElement(new StringValue(contributor.getDateDescription()));\n        values.addElement(new StringValue(contributor.getVersion()));\n        values.addElement(new StringValue(contributor.getStatus()));\n        if (contributorId != null) {\n            values.addElement(new StringValue(contributor.getContributorId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified requirement,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRequirement(RequirementBean requirement, Connection conn) throws SQLException {\n        if (requirement == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String requirementId = requirement.getRequirementId();\n        if (requirementId == null) {\n            // Use INSERT statement\n            sql.append(REQUIREMENTINSERTSQL);\n        } else {\n            sql.append(REQUIREMENTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(requirement.getMetadataId()));\n        values.addElement(new StringValue(requirement.getRequirementType()));\n        values.addElement(new StringValue(requirement.getRequirementName()));\n        values.addElement(new StringValue(requirement.getOtherPlatform()));\n        values.addElement(new StringValue(requirement.getDuration()));\n        values.addElement(new StringValue(requirement.getDescription()));\n        if (requirementId != null) {\n            values.addElement(new StringValue(requirement.getRequirementId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified relation,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRelation(RelationBean relation, Connection conn) throws SQLException {\n        if (relation == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String relationId = relation.getRelationId();\n        if (relationId == null) {\n            // Use INSERT statement\n            sql.append(RELATIONINSERTSQL);\n        } else {\n            sql.append(RELATIONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(relation.getMetadataId()));\n        values.addElement(new StringValue(relation.getResource()));\n        values.addElement(new StringValue(relation.getKind()));\n        values.addElement(new StringValue(relation.getDescription()));\n        values.addElement(new StringValue(relation.getCatalogue()));\n        values.addElement(new StringValue(relation.getEntry()));\n        if (relationId != null) {\n            values.addElement(new StringValue(relation.getRelationId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveKeyword(KeywordBean keyword, Connection conn) throws SQLException {\n        if (keyword == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String keywordId = keyword.getKeywordId();\n        if (keywordId == null) {\n            // Use INSERT statement\n            sql.append(KEYWORDINSERTSQL);\n        } else {\n            sql.append(KEYWORDUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(keyword.getMetadataId()));\n        values.addElement(new StringValue(keyword.getKeyword()));\n        if (keywordId != null) {\n            values.addElement(new StringValue(keywordId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTargetUserGroup(TargetUserGroupBean tug, Connection conn) throws SQLException {\n        if (tug == null) {\n            return;\n        }\n        List<TargetUserGroupBean> existingTugs = new ArrayList<TargetUserGroupBean>();\n        Vector rows = null;\n        if (null != tug.getMetadataId()) {\n            rows = getMetadataProperties(tug.getMetadataId(), \"TargetUserGroup\", \"TargetUserGroups\", conn);\n        }\n        if (null != rows) {\n            try {\n                for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                    Row row = (Row) iter.next();\n                    String tugDescription = row.getString(\"TargetUserGroup\");\n                    TargetUserGroupBean temp = new TargetUserGroupBean();\n                    temp.setMetadataId(tug.getMetadataId());\n                    temp.setTargetUserGroup(tugDescription);\n                    existingTugs.add(temp);\n                }\n            } catch (NoSuchColumnException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (null != tug.getTargetUserGroup()) {\n            for (TargetUserGroupBean existingTug : existingTugs) {\n                if (tug.getTargetUserGroup().equals(existingTug.getTargetUserGroup())) {\n                    // We don't need to save this TUG, because it already exists\n                    return;\n                }\n            }\n        }\n        String sql = TARGETUSERGROUPINSERTSQL;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(tug.getMetadataId()));\n        values.addElement(new StringValue(tug.getTargetUserGroup()));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public void deleteTargetUserGroupsByMetadataId(final String metadataId, final Connection conn) throws SQLException {\n        if (null == metadataId)\n            return;\n        final String sql = \"DELETE FROM TargetUserGroups WHERE MetadataId = ?\";\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified format,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveFormat(FormatBean format, Connection conn) throws SQLException {\n        if (format == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String formatId = format.getFormatId();\n        if (formatId == null) {\n            // Use INSERT statement\n            sql.append(FORMATINSERTSQL);\n        } else {\n            sql.append(FORMATUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(format.getMetadataId()));\n        values.addElement(new StringValue(format.getFormat()));\n        if (formatId != null) {\n            values.addElement(new StringValue(formatId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public List getMetametadataIdentifiers(String metadataId, Connection conn) {\n        List<MetametadataIdentifierBean> ret = new ArrayList<MetametadataIdentifierBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT MetametadataIdentifierID, Catalogue, Entry, MetadataSchema FROM MetametadataIdentifiers WHERE MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataIdentifierBean mib = new MetametadataIdentifierBean();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n                mib.setMetadataId(metadataId);\n                mib.setCatalog(rs.getString(2));\n                mib.setEntry(rs.getString(3));\n                mib.setMetadataSchema(rs.getString(4));\n                ret.add(mib);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return ret;\n    }\n\n    public List getMetametadataContributors(String metadataId, Connection conn) throws SQLException {\n        List<MetametadataContributorBean> ret = new ArrayList<MetametadataContributorBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT A.MetametadataContributorID, A.Role, A.ContributeDate, A.ContributeDateDescription, B.vCard FROM MetametadataContributors A INNER JOIN vCards B ON A.vCardID = B.vCardID WHERE A.MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataContributorBean mcb = new MetametadataContributorBean();\n                mcb.setMetametadataContributorId(rs.getString(1));\n                mcb.setRole(rs.getString(2));\n                mcb.setDate(rs.getDate(3));\n                mcb.setDateDescription(rs.getString(4));\n                mcb.setvCard(rs.getString(5));\n                mcb.setMetadataId(metadataId);\n                ret.add(mcb);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/CommonDAOTest1.java",
		"test_prompt": "// CommonDAOTest1.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CommonDAO}.\n* It contains ten unit test cases for the {@link CommonDAO#moveToDeletedItems(String, String, Connection)} method.\n*/\nclass CommonDAOTest1 {"
	},
	{
		"original_code": "// CommonDAO.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class CommonDAO implements Serializable {\n\n    public CommonDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private static final String THUMBNAILINSERTSQL = \"INSERT INTO Thumbnails (MetadataId, Location, FileWidth, FileHeight) VALUES(?, ?, ?, ?)\";\n\n    private static final String THUMBNAILUPDATESQL = \"UPDATE Thumbnails SET MetadataId = ?, Location= ?, FileWidth= ?, FileHeight = ? WHERE ThumbnailID = ?\";\n\n    private static final String COPYRIGHTINSERTSQL = \"INSERT INTO Copyrights (MetadataID, CopyrightTextID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTUPDATESQL = \"UPDATE Copyrights SET MetadataID = ?, CopyrightTextID = ? WHERE CopyrightID = ?\";\n\n    private static final String COPYRIGHTTEXTINSERTSQL = \"INSERT INTO CopyrightTexts (CopyrightText, Cost, CopyrightAndOtherRestriction) VALUES(?, ?, ?)\";\n\n    private static final String COPYRIGHTTEXTUPDATESQL = \"UPDATE CopyrightTexts SET CopyrightText = ?, Cost = ?, CopyrightAndOtherRestriction = ? WHERE CopyrightTextID = ?\";\n\n    private static final String COPYRIGHTTEXTLOOKUPIDSQL = \"SELECT CopyrightTextID FROM CopyrightTexts WHERE CopyrightText = ?\";\n\n    private static final String DISEASEDIAGNOSISINSERTSQL = \"INSERT INTO DiseaseDiagnoses (MetadataID, DiseaseDiagnosis) VALUES(?, ?)\";\n\n    private static final String DISEASEDIAGNOSISUPDATESQL = \"UPDATE DiseaseDiagnoses SET MetadataID = ?, DiseaseDiagnosis = ? WHERE DiseaseDiagnosisID = ?\";\n\n    private static final String COPYRIGHTHOLDERINSERTSQL = \"INSERT INTO CopyrightHolders (MetadataID, vCardID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTHOLDERUPDATESQL = \"UPDATE CopyrightHolders SET MetadataID = ?, vCardID = ? WHERE CopyrightHolderID = ?\";\n\n    private static final String KEYWORDINSERTSQL = \"INSERT INTO Keywords (MetadataID, Keyword) VALUES(?, ?)\";\n\n    private static final String KEYWORDUPDATESQL = \"UPDATE Keywords SET MetadataID = ?, Keyword = ? WHERE KeywordID = ?\";\n\n    private static final String FORMATINSERTSQL = \"INSERT INTO Formats (MetadataID, Format) VALUES(?, ?)\";\n\n    private static final String FORMATUPDATESQL = \"UPDATE Formats SET MetadataID = ?, Format = ? WHERE FormatID = ?\";\n\n    private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source, Purpose, Description, Keyword) VALUES(?, ?, ?, ?, ?)\";\n\n    //  private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source) VALUES(?, ?)\";\n    private static final String TAXONINSERTSQL = \"INSERT INTO Taxons (TaxonPathID, ID, Entry) VALUES(?, ?, ?)\";\n\n    private static final String TAXONUPDATESQL = \"UPDATE Taxons SET TaxonPathID = ?, ID = ?, Entry = ? WHERE TaxonID = ?\";\n\n    private static final String CONTEXTURLINSERTSQL = \"INSERT INTO ContextURLs (MetadataID, ContextURL, ContextURLDescription) VALUES(?, ?, ?)\";\n\n    private static final String CONTEXTURLUPDATESQL = \"UPDATE ContextURLs SET MetadataID = ?, ContextURL = ?, ContextURLDescription = ? WHERE ContextURLID = ?\";\n\n    private static final String REQUIREMENTINSERTSQL = \"INSERT INTO Requirements (MetadataID, RequirementType, RequirementName, OtherPlatformRequirements, Duration, Description) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String REQUIREMENTUPDATESQL = \"UPDATE Requirements SET MetadataID = ?, RequirementType = ?, RequirementName = ?, OtherPlatformRequirements = ?, Duration = ?, Description = ? WHERE RequirementID = ?\";\n\n    private static final String CONTRIBUTORINSERTSQL = \"INSERT INTO Contributors (MetadataID, Role, vCardID, ContributeDate, ContributeDateDescription, Version, Status) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String CONTRIBUTORUPDATESQL = \"UPDATE Contributors SET MetadataID = ?, Role = ?, vCardID = ?, ContributeDate = ?, ContributeDateDescription = ?, Version = ?, Status = ? WHERE ContributorID = ?\";\n\n    private static final String RELATIONINSERTSQL = \"INSERT INTO Relations (MetadataID, Resource, Kind, Description, Catalogue, Entry) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String RELATIONUPDATESQL = \"UPDATE Relations SET MetadataID = ?, Resource = ?, Kind = ?, Description = ?, Catalogue = ?, Entry = ? WHERE RelationID = ?\";\n\n    private static final String TARGETUSERGROUPINSERTSQL = \"INSERT INTO TargetUserGroups (MetadataId, TargetUserGroup) VALUES (?, ?)\";\n\n    private static final String DELETEDITEMSINSERTSQL = \"INSERT INTO DeletedItems (GlobalID, FileName, Title, Location, ContributeUserID, ContributeDate, DeleteDate, Comments) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"UPDATE Metadata SET \").append(propertyName).append(\" = ? WHERE \");\n        sql.append(\"MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(propertyValue);\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataStringProperty(String propertyName, String propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new StringValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataTimestampProperty(String propertyName, Timestamp propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new TimestampValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Returns a Vector of Rows with all of the requested columns from the\n     * requested table that have the specified metadataId in their\n     * MetadataID column, or null if no matches are found.\n     */\n    public Vector getMetadataProperties(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        if (metadataId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT \").append(columnNames).append(\" FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        return rows;\n    }\n\n    public TimestampValue getTimestampValue(Date date) {\n        TimestampValue ret;\n        if (null != date) {\n            ret = new TimestampValue(new Timestamp(date.getTime()));\n        } else {\n            ret = new TimestampValue(null);\n        }\n        return ret;\n    }\n\n    public IntValue getIntValue(String intString) {\n        int parsedInt = 0;\n        try {\n            parsedInt = Integer.parseInt(intString);\n        } catch (NumberFormatException ex) {\n            //XXX logging?\n        }\n        return new IntValue(parsedInt);\n    }\n\n    public LongValue getLongValue(String longString) {\n        long parsedLong = 0;\n        try {\n            parsedLong = Long.parseLong(longString);\n        } catch (NumberFormatException e) {\n        }\n        return new LongValue(parsedLong);\n    }\n\n    /**\n     * Gets all rows from a given table.  The return value is a Vector\n     * of com.ora.jsp.sql.Row object or null if an error occurs.\n     */\n    public Vector getAllRows(String tableName) throws SQLException {\n        if (tableName == null) {\n            return null;\n        }\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(\"SELECT * FROM \" + tableName);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId, Connection conn) throws SQLException {\n        // Get the metadata info from the database\n        Row metadataRow = getMetadataProperty(metadataId, \"Metadata.*, Publications.Name AS PubName, Publications.PublicationDate AS PubDate\", \"Metadata LEFT OUTER JOIN Publications ON Metadata.PublicationId = Publications.PublicationId\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        MetadataBean metadataInfo = new MetadataBean();\n        try {\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setContributeDate(DateTools.parse(metadataRow.getString(\"ContributeDate\")));\n            metadataInfo.setAnnotated(metadataRow.getString(\"Annotated\"));\n            metadataInfo.setInappropriate(metadataRow.getString(\"Inappropriate\"));\n            metadataInfo.setArchived(metadataRow.getString(\"Archived\"));\n            metadataInfo.setPrivate(metadataRow.getString(\"Private\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setSpecimenType(metadataRow.getString(\"SpecimenType\"));\n            metadataInfo.setRadiographType(metadataRow.getString(\"RadiographType\"));\n            metadataInfo.setOrientation(metadataRow.getString(\"Orientation\"));\n            metadataInfo.setMagnification(metadataRow.getString(\"Magnification\"));\n            metadataInfo.setClinicalHistory(metadataRow.getString(\"ClinicalHistory\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setDuration(metadataRow.getString(\"Duration\"));\n            metadataInfo.setApproveDate(DateTools.parse(metadataRow.getString(\"ApproveDate\")));\n            metadataInfo.setCatalogDate(DateTools.parse(metadataRow.getString(\"CatalogDate\")));\n            metadataInfo.setRejectDate(DateTools.parse(metadataRow.getString(\"RejectDate\")));\n            metadataInfo.setCreationDate(DateTools.parse(metadataRow.getString(\"CreationDate\")));\n            metadataInfo.setPublicationName(metadataRow.getString(\"PubName\"));\n            metadataInfo.setPublicationDate(DateTools.parse(metadataRow.getString(\"PubDate\")));\n            // For some reason a null integer gets returned from getString as \"0\"\n            // so this ensures the publicationId is populated as null correctly\n            final String publicationId = metadataRow.getString(\"PublicationId\");\n            metadataInfo.setPublicationId(\"0\".equals(publicationId) ? null : publicationId);\n            metadataInfo.setLanguageType(metadataRow.getString(\"LanguageType\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * metadata or null if the metadata is not found.\n     */\n    public Row getMetadataProperty(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        Vector results = getMetadataProperties(metadataId, columnNames, tableName, conn);\n        if (results != null) {\n            return (Row) results.firstElement();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Removes all taxons and taxon paths associated with the given metadataId.\n     */\n    public void removeTaxonPaths(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Taxons WHERE TaxonPathID in (SELECT TaxonPathID FROM TaxonPaths WHERE MetadataID = ?)\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        sql.append(\"DELETE FROM TaxonPaths WHERE MetadataID = ?\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all copyright entries with the given metadataId\n     * from the Copyrights table.\n     */\n    public void removeCopyrights(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Copyrights WHERE MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        //clean up the copyright texts\n        sql.append(\"DELETE FROM CopyrightTexts WHERE CopyrightTextID NOT IN (SELECT CopyrightTextID FROM Copyrights)\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values = new Vector();\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all entries in a table that have a given metadataId.\n     */\n    public void removeMetadataFromTable(String metadataId, String tableName, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Deletes the metadata entry from the metadata table.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadata(String metadataId) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            removeMetadataFromTable(metadataId, \"Metadata\", conn);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return success;\n    }\n\n    public String getMetadataPropertyAsString(String metadataId, String columnName, String tableName, Connection conn) throws SQLException {\n        Row row = getMetadataProperty(metadataId, columnName, tableName, conn);\n        if (row != null) {\n            try {\n                return row.getString(columnName);\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = getMetadata(metadataId, conn);\n        addToDeletedItems(metadata, comment, conn);\n        success = deleteMetadataReferences(metadataId, conn);\n        removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Takes information from the metadata bean and stores it in the\n     * deleted items table, with the addition of the provided comment.\n     */\n    public void addToDeletedItems(MetadataBean metadata, String comment, Connection conn) throws SQLException {\n        if (metadata == null) {\n            throw new SQLException(\"Invalid metadata provided.\");\n        }\n        Timestamp deleteDate = new Timestamp(System.currentTimeMillis());\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(DELETEDITEMSINSERTSQL);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getGlobalId()));\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(getIntValue(metadata.getContributeUserId()));\n        values.addElement(getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new TimestampValue(deleteDate));\n        values.addElement(new StringValue(comment));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all references to the given metadataId, EXCEPT for the main\n     * entry in the Metadata table.  All other references are removed from\n     * the other tables (Formats, Keywords, Requirements, etc).\n     * Also deleted are all taxons associated with taxonpaths associated with\n     * this metadata reference.  Also, all copyrights associated with the\n     * metadata are deleted.  If the copyright to be deleted contains the only\n     * reference to the associated copyright text, then the copyright text\n     * is also deleted.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadataReferences(String metadataId, Connection conn) throws SQLException {\n        //first do the easy removals...\n        removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        removeMetadataFromTable(metadataId, \"Formats\", conn);\n        removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        removeMetadataFromTable(metadataId, \"Relations\", conn);\n        removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n        removeTaxonPaths(metadataId, conn);\n        removeCopyrights(metadataId, conn);\n        return true;\n    }\n\n    /**\n     * Returns a ThumbnailBean associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public ThumbnailBean getThumbnail(String metadataId, Connection conn) throws SQLException {\n        ThumbnailBean result = null;\n        if (metadataId != null) {\n            Vector rows = getMetadataProperties(metadataId, \"*\", \"Thumbnails\", conn);\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new ThumbnailBean();\n                    result.setThumbnailId(row.getString(\"ThumbnailID\"));\n                    result.setMetadataId(metadataId);\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"FileWidth\"));\n                    result.setFileHeight(row.getString(\"FileHeight\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a SourceCollection Bean associated with the\n     * given source collection name.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public SourceCollectionBean getSCollectionBean(String name, Connection conn) throws SQLException {\n        SourceCollectionBean result = null;\n        if (name != null) {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT * FROM SourceCollection WHERE name = ?\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(name));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new SourceCollectionBean();\n                    result.setSourceId(row.getString(\"SourceCollectionID\"));\n                    result.setSourceName(\"Name\");\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"Width\"));\n                    result.setFileHeight(row.getString(\"Height\"));\n                    result.setLink(row.getString(\"Link\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Inserts the information about the specified thumbnail,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveThumbnail(ThumbnailBean thumbnail, Connection conn) throws SQLException {\n        if (thumbnail == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String thumbnailId = thumbnail.getThumbnailId();\n        Vector values = new Vector();\n        if (thumbnailId == null) {\n            // Use INSERT statement\n            sql.append(THUMBNAILINSERTSQL);\n        } else {\n            sql.append(THUMBNAILUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values.addElement(new StringValue(thumbnail.getMetadataId()));\n        values.addElement(new StringValue(thumbnail.getLocation()));\n        values.addElement(new StringValue(thumbnail.getFileWidth()));\n        values.addElement(new StringValue(thumbnail.getFileHeight()));\n        if (thumbnailId != null) {\n            values.addElement(new StringValue(thumbnailId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified diseaseDiagnosis,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveDiseaseDiagnosis(DiseaseDiagnosisBean diseaseDiagnosis, Connection conn) throws SQLException {\n        if (diseaseDiagnosis == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String diseaseDiagnosisId = diseaseDiagnosis.getDiseaseDiagnosisId();\n        if (diseaseDiagnosisId == null) {\n            // Use INSERT statement\n            sql.append(DISEASEDIAGNOSISINSERTSQL);\n        } else {\n            sql.append(DISEASEDIAGNOSISUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(diseaseDiagnosis.getMetadataId()));\n        values.addElement(new StringValue(diseaseDiagnosis.getDiseaseDiagnosis()));\n        if (diseaseDiagnosisId != null) {\n            values.addElement(new StringValue(diseaseDiagnosisId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified copyright,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyright(CopyrightBean copyright, Connection conn) throws SQLException {\n        if (copyright == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String copyrightId = copyright.getCopyrightId();\n        if (copyrightId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyright.getMetadataId()));\n        String copyrightTextId = saveCopyrightText(copyright.getCopyrightText(), conn);\n        values.addElement(new StringValue(copyrightTextId));\n        if (copyrightId != null) {\n            values.addElement(new StringValue(copyright.getCopyrightId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Stores a CopyrightTextBean in the database.  If the provided\n     * CopyrightTextBean has a copyrightTextId that is non-null, an update\n     * will be attempted.  Otherwise, an insert will be performed.\n     * The copyrightTextId will be returned.  This will either be obtained\n     * from the provided bean, or by doing another database lookup after\n     * the insert (looking for a match on the copyrightText).\n     */\n    public String saveCopyrightText(CopyrightTextBean copyrightText, Connection conn) throws SQLException {\n        if (copyrightText == null) {\n            return null;\n        }\n        String copyrightTextId = null;\n        copyrightTextId = copyrightText.getCopyrightTextId();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        Vector values = new Vector();\n        StringValue textValue = new StringValue(copyrightText.getCopyrightText());\n        values.addElement(textValue);\n        values.addElement(new StringValue(copyrightText.getCost()));\n        values.addElement(new StringValue(copyrightText.getCopyrightAndOtherRestriction()));\n        if (copyrightTextId != null) {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTUPDATESQL);\n            values.addElement(new StringValue(copyrightText.getCopyrightTextId()));\n        } else {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTINSERTSQL);\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        if (copyrightTextId == null) {\n            try {\n                sqlCommandBean.setSqlValue(COPYRIGHTTEXTLOOKUPIDSQL);\n                values.clear();\n                values.addElement(textValue);\n                Vector rows;\n                rows = sqlCommandBean.executeQuery();\n                Row aRow = (Row) rows.firstElement();\n                copyrightTextId = aRow.getString(\"CopyrightTextID\");\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return copyrightTextId;\n    }\n\n    /**\n     * Inserts the information about the specified copyrightHolder,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyrightHolder(CopyrightHolderBean copyrightHolder, Connection conn) throws SQLException {\n        if (copyrightHolder == null) {\n            return;\n        }\n        String vCardID = saveVCard(copyrightHolder.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String copyrightHolderId = copyrightHolder.getCopyrightHolderId();\n        if (copyrightHolderId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTHOLDERINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTHOLDERUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyrightHolder.getMetadataId()));\n        values.addElement(new StringValue(vCardID));\n        if (copyrightHolderId != null) {\n            values.addElement(new StringValue(copyrightHolderId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * @param vCard non-null vcard String\n     * @param conn\n     *\n     * @return\n     *\n     * @throws SQLException\n     */\n    public String saveVCard(String vCard, Connection conn) throws SQLException {\n        vCard = vCard.trim();\n        String vCardID = getVCardIDByVCard(vCard, conn);\n        if (vCardID == null) {\n            // No current vCard found, so we have to insert one\n            SQLCommandBean sqlInsertCommand = new SQLCommandBean();\n            sqlInsertCommand.setConnection(conn);\n            sqlInsertCommand.setSqlValue(\"INSERT INTO vCards (vCard) VALUES (?)\");\n            Vector insertValues = new Vector();\n            insertValues.add(new StringValue(vCard));\n            sqlInsertCommand.setValues(insertValues);\n            sqlInsertCommand.executeUpdate();\n            vCardID = getVCardIDByVCard(vCard, conn);\n        }\n        return vCardID;\n    }\n\n    /**\n     * Returns a vCardID or null if no VCard matching the vCard parameter\n     * is found.\n     *\n     * @param vCard The String of the vCard to be found\n     * @param conn The connection to the database.\n     *\n     * @return <code>null</code>If no vCard is found, otherwise returns a\n     *         <code>String</code> containing the vCardID\n     */\n    private String getVCardIDByVCard(String vCard, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommand = new SQLCommandBean();\n        sqlCommand.setConnection(conn);\n        sqlCommand.setSqlValue(\"SELECT vCardID FROM vCards WHERE vCard LIKE ?\");\n        Vector values = new Vector();\n        values.add(new StringValue(vCard));\n        sqlCommand.setValues(values);\n        Vector results;\n        try {\n            results = sqlCommand.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.getMessage());\n        }\n        if (results != null && results.size() > 0) {\n            Row row = (Row) results.get(0);\n            try {\n                return row.getString(\"vCardID\");\n            } catch (NoSuchColumnException e) {\n                throw new SQLException(e.getMessage());\n            }\n        } else\n            return null;\n    }\n\n    public void saveTaxonPath(TaxonPathBean taxonPath) throws SQLException {\n        if (null == taxonPath) {\n            return;\n        }\n        Connection conn = dataSource.getConnection();\n        try {\n            saveTaxonPath(taxonPath, conn);\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Inserts the information about the specified taxon path,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxonPath(TaxonPathBean taxonPath, Connection conn) throws SQLException {\n        if (taxonPath == null) {\n            return;\n        }\n        String taxonPathId = taxonPath.getTaxonPathId();\n        final String source = taxonPath.getSource();\n        final String purpose = taxonPath.getPurpose();\n        final String description = taxonPath.getDescription();\n        final String keyword = taxonPath.getKeyword();\n        final String metadataId = taxonPath.getMetadataId();\n        // Checks if a taxon path like this already exists in the db\n        if (null == taxonPathId) {\n            taxonPathId = getTaxonPathId(metadataId, source, conn);\n        }\n        if (taxonPathId == null) {\n            // Use INSERT statement\n            final String sql = TAXONPATHINSERTSQL;\n            final SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql);\n            // Sets a temporary source so that we can grab the taxon path id with a unique value\n            final String tempSource = metadataId + System.currentTimeMillis();\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            values.addElement(new StringValue(tempSource));\n            values.addElement(new StringValue(purpose));\n            values.addElement(new StringValue(description));\n            values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            // Gets the taxon path id using the unique temporary source value\n            sqlCommandBean.setSqlValue(\"SELECT TaxonPathID FROM \" + \"TaxonPaths WHERE Source = ?\");\n            values.clear();\n            values.addElement(new StringValue(tempSource));\n            //  values.addElement(new StringValue(purpose));\n            // values.addElement(new StringValue(description));\n            //  values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    Row aRow = (Row) rows.firstElement();\n                    // taxonPathId is used below to set the taxon path bean's taxon path id\n                    taxonPathId = aRow.getString(\"TaxonPathID\");\n                    // fixes the temporary source\n                    sqlCommandBean.setSqlValue(\"UPDATE TaxonPaths SET \" + \"Source = ?, Purpose = ?, Description = ?, Keyword = ? \" + \"WHERE TaxonPathID = ?\");\n                    values.clear();\n                    values.addElement(new StringValue(source));\n                    values.addElement(new StringValue(purpose));\n                    values.addElement(new StringValue(description));\n                    values.addElement(new StringValue(keyword));\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    sqlCommandBean.executeUpdate();\n                }\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            } catch (UnsupportedTypeException ex2) {\n                throw new SQLException(ex2.toString());\n            }\n        }\n        taxonPath.setTaxonPathId(taxonPathId);\n        // There should be a taxon path id now\n        if (taxonPathId != null && taxonPath.getTaxons() != null) {\n            Iterator taxonIterator = taxonPath.getTaxons().iterator();\n            while (taxonIterator.hasNext()) {\n                TaxonBean taxon = (TaxonBean) taxonIterator.next();\n                taxon.setTaxonPathId(taxonPathId);\n                saveTaxon(taxon, conn);\n            }\n        } else {\n            throw new RuntimeException(\"Unable to save TaxonPath\");\n        }\n    }\n\n    private String getTaxonPathId(final String metadataId, final String source, final Connection conn) throws SQLException {\n        final String sql = \"SELECT TaxonPathId FROM TaxonPaths WHERE MetadataID = ? AND Source = ?\";\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.setString(2, source);\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified taxon,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxon(TaxonBean taxon, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        String taxonId = taxon.getTaxonId();\n        String taxonPathId = taxon.getTaxonPathId();\n        String id = taxon.getId();\n        String entry = taxon.getEntry();\n        // Checks to see if a Taxon matching this  bean already exists\n        // in the database\n        String existingTaxon = getTaxonId(taxon, conn);\n        if (null != existingTaxon) {\n            taxon.setTaxonId(existingTaxon);\n            return;\n        }\n        if (taxonId == null) {\n            // Use INSERT statement\n            sql.append(TAXONINSERTSQL);\n        } else {\n            sql.append(TAXONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(taxonPathId));\n        values.addElement(new StringValue(id));\n        values.addElement(new StringValue(entry));\n        if (taxonId != null) {\n            values.addElement(new StringValue(taxonId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    private String getTaxonId(TaxonBean taxon, Connection conn) throws SQLException {\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String sql = \"SELECT TaxonID FROM Taxons WHERE Id = ? AND Entry = ? AND TaxonPathID = ?\";\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, taxon.getId());\n            ps.setString(2, taxon.getEntry());\n            ps.setString(3, taxon.getTaxonPathId());\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified contextURL,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContextURL(ContextURLBean contextURL, Connection conn) throws SQLException {\n        if (contextURL == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String contextURLId = contextURL.getContextURLId();\n        if (contextURLId == null) {\n            // Use INSERT statement\n            sql.append(CONTEXTURLINSERTSQL);\n        } else {\n            sql.append(CONTEXTURLUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contextURL.getMetadataId()));\n        values.addElement(new StringValue(contextURL.getContextURL()));\n        values.addElement(new StringValue(contextURL.getContextURLDescription()));\n        if (contextURLId != null) {\n            values.addElement(new StringValue(contextURLId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified contributor,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContributor(ContributorBean contributor, Connection conn) throws SQLException {\n        if (contributor == null) {\n            return;\n        }\n        String vCardID = saveVCard(contributor.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String contributorId = contributor.getContributorId();\n        if (contributorId == null) {\n            // Use INSERT statement\n            sql.append(CONTRIBUTORINSERTSQL);\n        } else {\n            sql.append(CONTRIBUTORUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contributor.getMetadataId()));\n        values.addElement(new StringValue(contributor.getRole()));\n        values.addElement(new StringValue(vCardID));\n        java.sql.Date contributeDate = null;\n        if (null != contributor.getDate()) {\n            contributeDate = new java.sql.Date(contributor.getDate().getTime());\n        }\n        values.addElement(new DateValue(contributeDate));\n        values.addElement(new StringValue(contributor.getDateDescription()));\n        values.addElement(new StringValue(contributor.getVersion()));\n        values.addElement(new StringValue(contributor.getStatus()));\n        if (contributorId != null) {\n            values.addElement(new StringValue(contributor.getContributorId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified requirement,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRequirement(RequirementBean requirement, Connection conn) throws SQLException {\n        if (requirement == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String requirementId = requirement.getRequirementId();\n        if (requirementId == null) {\n            // Use INSERT statement\n            sql.append(REQUIREMENTINSERTSQL);\n        } else {\n            sql.append(REQUIREMENTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(requirement.getMetadataId()));\n        values.addElement(new StringValue(requirement.getRequirementType()));\n        values.addElement(new StringValue(requirement.getRequirementName()));\n        values.addElement(new StringValue(requirement.getOtherPlatform()));\n        values.addElement(new StringValue(requirement.getDuration()));\n        values.addElement(new StringValue(requirement.getDescription()));\n        if (requirementId != null) {\n            values.addElement(new StringValue(requirement.getRequirementId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified relation,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRelation(RelationBean relation, Connection conn) throws SQLException {\n        if (relation == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String relationId = relation.getRelationId();\n        if (relationId == null) {\n            // Use INSERT statement\n            sql.append(RELATIONINSERTSQL);\n        } else {\n            sql.append(RELATIONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(relation.getMetadataId()));\n        values.addElement(new StringValue(relation.getResource()));\n        values.addElement(new StringValue(relation.getKind()));\n        values.addElement(new StringValue(relation.getDescription()));\n        values.addElement(new StringValue(relation.getCatalogue()));\n        values.addElement(new StringValue(relation.getEntry()));\n        if (relationId != null) {\n            values.addElement(new StringValue(relation.getRelationId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveKeyword(KeywordBean keyword, Connection conn) throws SQLException {\n        if (keyword == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String keywordId = keyword.getKeywordId();\n        if (keywordId == null) {\n            // Use INSERT statement\n            sql.append(KEYWORDINSERTSQL);\n        } else {\n            sql.append(KEYWORDUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(keyword.getMetadataId()));\n        values.addElement(new StringValue(keyword.getKeyword()));\n        if (keywordId != null) {\n            values.addElement(new StringValue(keywordId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTargetUserGroup(TargetUserGroupBean tug, Connection conn) throws SQLException {\n        if (tug == null) {\n            return;\n        }\n        List<TargetUserGroupBean> existingTugs = new ArrayList<TargetUserGroupBean>();\n        Vector rows = null;\n        if (null != tug.getMetadataId()) {\n            rows = getMetadataProperties(tug.getMetadataId(), \"TargetUserGroup\", \"TargetUserGroups\", conn);\n        }\n        if (null != rows) {\n            try {\n                for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                    Row row = (Row) iter.next();\n                    String tugDescription = row.getString(\"TargetUserGroup\");\n                    TargetUserGroupBean temp = new TargetUserGroupBean();\n                    temp.setMetadataId(tug.getMetadataId());\n                    temp.setTargetUserGroup(tugDescription);\n                    existingTugs.add(temp);\n                }\n            } catch (NoSuchColumnException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (null != tug.getTargetUserGroup()) {\n            for (TargetUserGroupBean existingTug : existingTugs) {\n                if (tug.getTargetUserGroup().equals(existingTug.getTargetUserGroup())) {\n                    // We don't need to save this TUG, because it already exists\n                    return;\n                }\n            }\n        }\n        String sql = TARGETUSERGROUPINSERTSQL;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(tug.getMetadataId()));\n        values.addElement(new StringValue(tug.getTargetUserGroup()));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public void deleteTargetUserGroupsByMetadataId(final String metadataId, final Connection conn) throws SQLException {\n        if (null == metadataId)\n            return;\n        final String sql = \"DELETE FROM TargetUserGroups WHERE MetadataId = ?\";\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified format,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveFormat(FormatBean format, Connection conn) throws SQLException {\n        if (format == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String formatId = format.getFormatId();\n        if (formatId == null) {\n            // Use INSERT statement\n            sql.append(FORMATINSERTSQL);\n        } else {\n            sql.append(FORMATUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(format.getMetadataId()));\n        values.addElement(new StringValue(format.getFormat()));\n        if (formatId != null) {\n            values.addElement(new StringValue(formatId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public List getMetametadataIdentifiers(String metadataId, Connection conn) {\n        List<MetametadataIdentifierBean> ret = new ArrayList<MetametadataIdentifierBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT MetametadataIdentifierID, Catalogue, Entry, MetadataSchema FROM MetametadataIdentifiers WHERE MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataIdentifierBean mib = new MetametadataIdentifierBean();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n                mib.setMetadataId(metadataId);\n                mib.setCatalog(rs.getString(2));\n                mib.setEntry(rs.getString(3));\n                mib.setMetadataSchema(rs.getString(4));\n                ret.add(mib);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return ret;\n    }\n\n    public List getMetametadataContributors(String metadataId, Connection conn) throws SQLException {\n        List<MetametadataContributorBean> ret = new ArrayList<MetametadataContributorBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT A.MetametadataContributorID, A.Role, A.ContributeDate, A.ContributeDateDescription, B.vCard FROM MetametadataContributors A INNER JOIN vCards B ON A.vCardID = B.vCardID WHERE A.MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataContributorBean mcb = new MetametadataContributorBean();\n                mcb.setMetametadataContributorId(rs.getString(1));\n                mcb.setRole(rs.getString(2));\n                mcb.setDate(rs.getDate(3));\n                mcb.setDateDescription(rs.getString(4));\n                mcb.setvCard(rs.getString(5));\n                mcb.setMetadataId(metadataId);\n                ret.add(mcb);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/CommonDAOTest2.java",
		"test_prompt": "// CommonDAOTest2.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CommonDAO}.\n* It contains ten unit test cases for the {@link CommonDAO#deleteMetadataReferences(String, Connection)} method.\n*/\nclass CommonDAOTest2 {"
	},
	{
		"original_code": "// CommonDAO.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class CommonDAO implements Serializable {\n\n    public CommonDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private static final String THUMBNAILINSERTSQL = \"INSERT INTO Thumbnails (MetadataId, Location, FileWidth, FileHeight) VALUES(?, ?, ?, ?)\";\n\n    private static final String THUMBNAILUPDATESQL = \"UPDATE Thumbnails SET MetadataId = ?, Location= ?, FileWidth= ?, FileHeight = ? WHERE ThumbnailID = ?\";\n\n    private static final String COPYRIGHTINSERTSQL = \"INSERT INTO Copyrights (MetadataID, CopyrightTextID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTUPDATESQL = \"UPDATE Copyrights SET MetadataID = ?, CopyrightTextID = ? WHERE CopyrightID = ?\";\n\n    private static final String COPYRIGHTTEXTINSERTSQL = \"INSERT INTO CopyrightTexts (CopyrightText, Cost, CopyrightAndOtherRestriction) VALUES(?, ?, ?)\";\n\n    private static final String COPYRIGHTTEXTUPDATESQL = \"UPDATE CopyrightTexts SET CopyrightText = ?, Cost = ?, CopyrightAndOtherRestriction = ? WHERE CopyrightTextID = ?\";\n\n    private static final String COPYRIGHTTEXTLOOKUPIDSQL = \"SELECT CopyrightTextID FROM CopyrightTexts WHERE CopyrightText = ?\";\n\n    private static final String DISEASEDIAGNOSISINSERTSQL = \"INSERT INTO DiseaseDiagnoses (MetadataID, DiseaseDiagnosis) VALUES(?, ?)\";\n\n    private static final String DISEASEDIAGNOSISUPDATESQL = \"UPDATE DiseaseDiagnoses SET MetadataID = ?, DiseaseDiagnosis = ? WHERE DiseaseDiagnosisID = ?\";\n\n    private static final String COPYRIGHTHOLDERINSERTSQL = \"INSERT INTO CopyrightHolders (MetadataID, vCardID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTHOLDERUPDATESQL = \"UPDATE CopyrightHolders SET MetadataID = ?, vCardID = ? WHERE CopyrightHolderID = ?\";\n\n    private static final String KEYWORDINSERTSQL = \"INSERT INTO Keywords (MetadataID, Keyword) VALUES(?, ?)\";\n\n    private static final String KEYWORDUPDATESQL = \"UPDATE Keywords SET MetadataID = ?, Keyword = ? WHERE KeywordID = ?\";\n\n    private static final String FORMATINSERTSQL = \"INSERT INTO Formats (MetadataID, Format) VALUES(?, ?)\";\n\n    private static final String FORMATUPDATESQL = \"UPDATE Formats SET MetadataID = ?, Format = ? WHERE FormatID = ?\";\n\n    private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source, Purpose, Description, Keyword) VALUES(?, ?, ?, ?, ?)\";\n\n    //  private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source) VALUES(?, ?)\";\n    private static final String TAXONINSERTSQL = \"INSERT INTO Taxons (TaxonPathID, ID, Entry) VALUES(?, ?, ?)\";\n\n    private static final String TAXONUPDATESQL = \"UPDATE Taxons SET TaxonPathID = ?, ID = ?, Entry = ? WHERE TaxonID = ?\";\n\n    private static final String CONTEXTURLINSERTSQL = \"INSERT INTO ContextURLs (MetadataID, ContextURL, ContextURLDescription) VALUES(?, ?, ?)\";\n\n    private static final String CONTEXTURLUPDATESQL = \"UPDATE ContextURLs SET MetadataID = ?, ContextURL = ?, ContextURLDescription = ? WHERE ContextURLID = ?\";\n\n    private static final String REQUIREMENTINSERTSQL = \"INSERT INTO Requirements (MetadataID, RequirementType, RequirementName, OtherPlatformRequirements, Duration, Description) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String REQUIREMENTUPDATESQL = \"UPDATE Requirements SET MetadataID = ?, RequirementType = ?, RequirementName = ?, OtherPlatformRequirements = ?, Duration = ?, Description = ? WHERE RequirementID = ?\";\n\n    private static final String CONTRIBUTORINSERTSQL = \"INSERT INTO Contributors (MetadataID, Role, vCardID, ContributeDate, ContributeDateDescription, Version, Status) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String CONTRIBUTORUPDATESQL = \"UPDATE Contributors SET MetadataID = ?, Role = ?, vCardID = ?, ContributeDate = ?, ContributeDateDescription = ?, Version = ?, Status = ? WHERE ContributorID = ?\";\n\n    private static final String RELATIONINSERTSQL = \"INSERT INTO Relations (MetadataID, Resource, Kind, Description, Catalogue, Entry) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String RELATIONUPDATESQL = \"UPDATE Relations SET MetadataID = ?, Resource = ?, Kind = ?, Description = ?, Catalogue = ?, Entry = ? WHERE RelationID = ?\";\n\n    private static final String TARGETUSERGROUPINSERTSQL = \"INSERT INTO TargetUserGroups (MetadataId, TargetUserGroup) VALUES (?, ?)\";\n\n    private static final String DELETEDITEMSINSERTSQL = \"INSERT INTO DeletedItems (GlobalID, FileName, Title, Location, ContributeUserID, ContributeDate, DeleteDate, Comments) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"UPDATE Metadata SET \").append(propertyName).append(\" = ? WHERE \");\n        sql.append(\"MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(propertyValue);\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataStringProperty(String propertyName, String propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new StringValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataTimestampProperty(String propertyName, Timestamp propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new TimestampValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Returns a Vector of Rows with all of the requested columns from the\n     * requested table that have the specified metadataId in their\n     * MetadataID column, or null if no matches are found.\n     */\n    public Vector getMetadataProperties(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        if (metadataId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT \").append(columnNames).append(\" FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        return rows;\n    }\n\n    public TimestampValue getTimestampValue(Date date) {\n        TimestampValue ret;\n        if (null != date) {\n            ret = new TimestampValue(new Timestamp(date.getTime()));\n        } else {\n            ret = new TimestampValue(null);\n        }\n        return ret;\n    }\n\n    public IntValue getIntValue(String intString) {\n        int parsedInt = 0;\n        try {\n            parsedInt = Integer.parseInt(intString);\n        } catch (NumberFormatException ex) {\n            //XXX logging?\n        }\n        return new IntValue(parsedInt);\n    }\n\n    public LongValue getLongValue(String longString) {\n        long parsedLong = 0;\n        try {\n            parsedLong = Long.parseLong(longString);\n        } catch (NumberFormatException e) {\n        }\n        return new LongValue(parsedLong);\n    }\n\n    /**\n     * Gets all rows from a given table.  The return value is a Vector\n     * of com.ora.jsp.sql.Row object or null if an error occurs.\n     */\n    public Vector getAllRows(String tableName) throws SQLException {\n        if (tableName == null) {\n            return null;\n        }\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(\"SELECT * FROM \" + tableName);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId, Connection conn) throws SQLException {\n        // Get the metadata info from the database\n        Row metadataRow = getMetadataProperty(metadataId, \"Metadata.*, Publications.Name AS PubName, Publications.PublicationDate AS PubDate\", \"Metadata LEFT OUTER JOIN Publications ON Metadata.PublicationId = Publications.PublicationId\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        MetadataBean metadataInfo = new MetadataBean();\n        try {\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setContributeDate(DateTools.parse(metadataRow.getString(\"ContributeDate\")));\n            metadataInfo.setAnnotated(metadataRow.getString(\"Annotated\"));\n            metadataInfo.setInappropriate(metadataRow.getString(\"Inappropriate\"));\n            metadataInfo.setArchived(metadataRow.getString(\"Archived\"));\n            metadataInfo.setPrivate(metadataRow.getString(\"Private\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setSpecimenType(metadataRow.getString(\"SpecimenType\"));\n            metadataInfo.setRadiographType(metadataRow.getString(\"RadiographType\"));\n            metadataInfo.setOrientation(metadataRow.getString(\"Orientation\"));\n            metadataInfo.setMagnification(metadataRow.getString(\"Magnification\"));\n            metadataInfo.setClinicalHistory(metadataRow.getString(\"ClinicalHistory\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setDuration(metadataRow.getString(\"Duration\"));\n            metadataInfo.setApproveDate(DateTools.parse(metadataRow.getString(\"ApproveDate\")));\n            metadataInfo.setCatalogDate(DateTools.parse(metadataRow.getString(\"CatalogDate\")));\n            metadataInfo.setRejectDate(DateTools.parse(metadataRow.getString(\"RejectDate\")));\n            metadataInfo.setCreationDate(DateTools.parse(metadataRow.getString(\"CreationDate\")));\n            metadataInfo.setPublicationName(metadataRow.getString(\"PubName\"));\n            metadataInfo.setPublicationDate(DateTools.parse(metadataRow.getString(\"PubDate\")));\n            // For some reason a null integer gets returned from getString as \"0\"\n            // so this ensures the publicationId is populated as null correctly\n            final String publicationId = metadataRow.getString(\"PublicationId\");\n            metadataInfo.setPublicationId(\"0\".equals(publicationId) ? null : publicationId);\n            metadataInfo.setLanguageType(metadataRow.getString(\"LanguageType\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * metadata or null if the metadata is not found.\n     */\n    public Row getMetadataProperty(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        Vector results = getMetadataProperties(metadataId, columnNames, tableName, conn);\n        if (results != null) {\n            return (Row) results.firstElement();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Removes all taxons and taxon paths associated with the given metadataId.\n     */\n    public void removeTaxonPaths(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Taxons WHERE TaxonPathID in (SELECT TaxonPathID FROM TaxonPaths WHERE MetadataID = ?)\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        sql.append(\"DELETE FROM TaxonPaths WHERE MetadataID = ?\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all copyright entries with the given metadataId\n     * from the Copyrights table.\n     */\n    public void removeCopyrights(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Copyrights WHERE MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        //clean up the copyright texts\n        sql.append(\"DELETE FROM CopyrightTexts WHERE CopyrightTextID NOT IN (SELECT CopyrightTextID FROM Copyrights)\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values = new Vector();\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all entries in a table that have a given metadataId.\n     */\n    public void removeMetadataFromTable(String metadataId, String tableName, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Deletes the metadata entry from the metadata table.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadata(String metadataId) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            removeMetadataFromTable(metadataId, \"Metadata\", conn);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return success;\n    }\n\n    public String getMetadataPropertyAsString(String metadataId, String columnName, String tableName, Connection conn) throws SQLException {\n        Row row = getMetadataProperty(metadataId, columnName, tableName, conn);\n        if (row != null) {\n            try {\n                return row.getString(columnName);\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = getMetadata(metadataId, conn);\n        addToDeletedItems(metadata, comment, conn);\n        success = deleteMetadataReferences(metadataId, conn);\n        removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Takes information from the metadata bean and stores it in the\n     * deleted items table, with the addition of the provided comment.\n     */\n    public void addToDeletedItems(MetadataBean metadata, String comment, Connection conn) throws SQLException {\n        if (metadata == null) {\n            throw new SQLException(\"Invalid metadata provided.\");\n        }\n        Timestamp deleteDate = new Timestamp(System.currentTimeMillis());\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(DELETEDITEMSINSERTSQL);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getGlobalId()));\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(getIntValue(metadata.getContributeUserId()));\n        values.addElement(getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new TimestampValue(deleteDate));\n        values.addElement(new StringValue(comment));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all references to the given metadataId, EXCEPT for the main\n     * entry in the Metadata table.  All other references are removed from\n     * the other tables (Formats, Keywords, Requirements, etc).\n     * Also deleted are all taxons associated with taxonpaths associated with\n     * this metadata reference.  Also, all copyrights associated with the\n     * metadata are deleted.  If the copyright to be deleted contains the only\n     * reference to the associated copyright text, then the copyright text\n     * is also deleted.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadataReferences(String metadataId, Connection conn) throws SQLException {\n        //first do the easy removals...\n        removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        removeMetadataFromTable(metadataId, \"Formats\", conn);\n        removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        removeMetadataFromTable(metadataId, \"Relations\", conn);\n        removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n        removeTaxonPaths(metadataId, conn);\n        removeCopyrights(metadataId, conn);\n        return true;\n    }\n\n    /**\n     * Returns a ThumbnailBean associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public ThumbnailBean getThumbnail(String metadataId, Connection conn) throws SQLException {\n        ThumbnailBean result = null;\n        if (metadataId != null) {\n            Vector rows = getMetadataProperties(metadataId, \"*\", \"Thumbnails\", conn);\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new ThumbnailBean();\n                    result.setThumbnailId(row.getString(\"ThumbnailID\"));\n                    result.setMetadataId(metadataId);\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"FileWidth\"));\n                    result.setFileHeight(row.getString(\"FileHeight\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a SourceCollection Bean associated with the\n     * given source collection name.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public SourceCollectionBean getSCollectionBean(String name, Connection conn) throws SQLException {\n        SourceCollectionBean result = null;\n        if (name != null) {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT * FROM SourceCollection WHERE name = ?\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(name));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new SourceCollectionBean();\n                    result.setSourceId(row.getString(\"SourceCollectionID\"));\n                    result.setSourceName(\"Name\");\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"Width\"));\n                    result.setFileHeight(row.getString(\"Height\"));\n                    result.setLink(row.getString(\"Link\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Inserts the information about the specified thumbnail,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveThumbnail(ThumbnailBean thumbnail, Connection conn) throws SQLException {\n        if (thumbnail == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String thumbnailId = thumbnail.getThumbnailId();\n        Vector values = new Vector();\n        if (thumbnailId == null) {\n            // Use INSERT statement\n            sql.append(THUMBNAILINSERTSQL);\n        } else {\n            sql.append(THUMBNAILUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values.addElement(new StringValue(thumbnail.getMetadataId()));\n        values.addElement(new StringValue(thumbnail.getLocation()));\n        values.addElement(new StringValue(thumbnail.getFileWidth()));\n        values.addElement(new StringValue(thumbnail.getFileHeight()));\n        if (thumbnailId != null) {\n            values.addElement(new StringValue(thumbnailId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified diseaseDiagnosis,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveDiseaseDiagnosis(DiseaseDiagnosisBean diseaseDiagnosis, Connection conn) throws SQLException {\n        if (diseaseDiagnosis == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String diseaseDiagnosisId = diseaseDiagnosis.getDiseaseDiagnosisId();\n        if (diseaseDiagnosisId == null) {\n            // Use INSERT statement\n            sql.append(DISEASEDIAGNOSISINSERTSQL);\n        } else {\n            sql.append(DISEASEDIAGNOSISUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(diseaseDiagnosis.getMetadataId()));\n        values.addElement(new StringValue(diseaseDiagnosis.getDiseaseDiagnosis()));\n        if (diseaseDiagnosisId != null) {\n            values.addElement(new StringValue(diseaseDiagnosisId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified copyright,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyright(CopyrightBean copyright, Connection conn) throws SQLException {\n        if (copyright == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String copyrightId = copyright.getCopyrightId();\n        if (copyrightId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyright.getMetadataId()));\n        String copyrightTextId = saveCopyrightText(copyright.getCopyrightText(), conn);\n        values.addElement(new StringValue(copyrightTextId));\n        if (copyrightId != null) {\n            values.addElement(new StringValue(copyright.getCopyrightId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Stores a CopyrightTextBean in the database.  If the provided\n     * CopyrightTextBean has a copyrightTextId that is non-null, an update\n     * will be attempted.  Otherwise, an insert will be performed.\n     * The copyrightTextId will be returned.  This will either be obtained\n     * from the provided bean, or by doing another database lookup after\n     * the insert (looking for a match on the copyrightText).\n     */\n    public String saveCopyrightText(CopyrightTextBean copyrightText, Connection conn) throws SQLException {\n        if (copyrightText == null) {\n            return null;\n        }\n        String copyrightTextId = null;\n        copyrightTextId = copyrightText.getCopyrightTextId();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        Vector values = new Vector();\n        StringValue textValue = new StringValue(copyrightText.getCopyrightText());\n        values.addElement(textValue);\n        values.addElement(new StringValue(copyrightText.getCost()));\n        values.addElement(new StringValue(copyrightText.getCopyrightAndOtherRestriction()));\n        if (copyrightTextId != null) {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTUPDATESQL);\n            values.addElement(new StringValue(copyrightText.getCopyrightTextId()));\n        } else {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTINSERTSQL);\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        if (copyrightTextId == null) {\n            try {\n                sqlCommandBean.setSqlValue(COPYRIGHTTEXTLOOKUPIDSQL);\n                values.clear();\n                values.addElement(textValue);\n                Vector rows;\n                rows = sqlCommandBean.executeQuery();\n                Row aRow = (Row) rows.firstElement();\n                copyrightTextId = aRow.getString(\"CopyrightTextID\");\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return copyrightTextId;\n    }\n\n    /**\n     * Inserts the information about the specified copyrightHolder,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyrightHolder(CopyrightHolderBean copyrightHolder, Connection conn) throws SQLException {\n        if (copyrightHolder == null) {\n            return;\n        }\n        String vCardID = saveVCard(copyrightHolder.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String copyrightHolderId = copyrightHolder.getCopyrightHolderId();\n        if (copyrightHolderId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTHOLDERINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTHOLDERUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyrightHolder.getMetadataId()));\n        values.addElement(new StringValue(vCardID));\n        if (copyrightHolderId != null) {\n            values.addElement(new StringValue(copyrightHolderId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * @param vCard non-null vcard String\n     * @param conn\n     *\n     * @return\n     *\n     * @throws SQLException\n     */\n    public String saveVCard(String vCard, Connection conn) throws SQLException {\n        vCard = vCard.trim();\n        String vCardID = getVCardIDByVCard(vCard, conn);\n        if (vCardID == null) {\n            // No current vCard found, so we have to insert one\n            SQLCommandBean sqlInsertCommand = new SQLCommandBean();\n            sqlInsertCommand.setConnection(conn);\n            sqlInsertCommand.setSqlValue(\"INSERT INTO vCards (vCard) VALUES (?)\");\n            Vector insertValues = new Vector();\n            insertValues.add(new StringValue(vCard));\n            sqlInsertCommand.setValues(insertValues);\n            sqlInsertCommand.executeUpdate();\n            vCardID = getVCardIDByVCard(vCard, conn);\n        }\n        return vCardID;\n    }\n\n    /**\n     * Returns a vCardID or null if no VCard matching the vCard parameter\n     * is found.\n     *\n     * @param vCard The String of the vCard to be found\n     * @param conn The connection to the database.\n     *\n     * @return <code>null</code>If no vCard is found, otherwise returns a\n     *         <code>String</code> containing the vCardID\n     */\n    private String getVCardIDByVCard(String vCard, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommand = new SQLCommandBean();\n        sqlCommand.setConnection(conn);\n        sqlCommand.setSqlValue(\"SELECT vCardID FROM vCards WHERE vCard LIKE ?\");\n        Vector values = new Vector();\n        values.add(new StringValue(vCard));\n        sqlCommand.setValues(values);\n        Vector results;\n        try {\n            results = sqlCommand.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.getMessage());\n        }\n        if (results != null && results.size() > 0) {\n            Row row = (Row) results.get(0);\n            try {\n                return row.getString(\"vCardID\");\n            } catch (NoSuchColumnException e) {\n                throw new SQLException(e.getMessage());\n            }\n        } else\n            return null;\n    }\n\n    public void saveTaxonPath(TaxonPathBean taxonPath) throws SQLException {\n        if (null == taxonPath) {\n            return;\n        }\n        Connection conn = dataSource.getConnection();\n        try {\n            saveTaxonPath(taxonPath, conn);\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Inserts the information about the specified taxon path,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxonPath(TaxonPathBean taxonPath, Connection conn) throws SQLException {\n        if (taxonPath == null) {\n            return;\n        }\n        String taxonPathId = taxonPath.getTaxonPathId();\n        final String source = taxonPath.getSource();\n        final String purpose = taxonPath.getPurpose();\n        final String description = taxonPath.getDescription();\n        final String keyword = taxonPath.getKeyword();\n        final String metadataId = taxonPath.getMetadataId();\n        // Checks if a taxon path like this already exists in the db\n        if (null == taxonPathId) {\n            taxonPathId = getTaxonPathId(metadataId, source, conn);\n        }\n        if (taxonPathId == null) {\n            // Use INSERT statement\n            final String sql = TAXONPATHINSERTSQL;\n            final SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql);\n            // Sets a temporary source so that we can grab the taxon path id with a unique value\n            final String tempSource = metadataId + System.currentTimeMillis();\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            values.addElement(new StringValue(tempSource));\n            values.addElement(new StringValue(purpose));\n            values.addElement(new StringValue(description));\n            values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            // Gets the taxon path id using the unique temporary source value\n            sqlCommandBean.setSqlValue(\"SELECT TaxonPathID FROM \" + \"TaxonPaths WHERE Source = ?\");\n            values.clear();\n            values.addElement(new StringValue(tempSource));\n            //  values.addElement(new StringValue(purpose));\n            // values.addElement(new StringValue(description));\n            //  values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    Row aRow = (Row) rows.firstElement();\n                    // taxonPathId is used below to set the taxon path bean's taxon path id\n                    taxonPathId = aRow.getString(\"TaxonPathID\");\n                    // fixes the temporary source\n                    sqlCommandBean.setSqlValue(\"UPDATE TaxonPaths SET \" + \"Source = ?, Purpose = ?, Description = ?, Keyword = ? \" + \"WHERE TaxonPathID = ?\");\n                    values.clear();\n                    values.addElement(new StringValue(source));\n                    values.addElement(new StringValue(purpose));\n                    values.addElement(new StringValue(description));\n                    values.addElement(new StringValue(keyword));\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    sqlCommandBean.executeUpdate();\n                }\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            } catch (UnsupportedTypeException ex2) {\n                throw new SQLException(ex2.toString());\n            }\n        }\n        taxonPath.setTaxonPathId(taxonPathId);\n        // There should be a taxon path id now\n        if (taxonPathId != null && taxonPath.getTaxons() != null) {\n            Iterator taxonIterator = taxonPath.getTaxons().iterator();\n            while (taxonIterator.hasNext()) {\n                TaxonBean taxon = (TaxonBean) taxonIterator.next();\n                taxon.setTaxonPathId(taxonPathId);\n                saveTaxon(taxon, conn);\n            }\n        } else {\n            throw new RuntimeException(\"Unable to save TaxonPath\");\n        }\n    }\n\n    private String getTaxonPathId(final String metadataId, final String source, final Connection conn) throws SQLException {\n        final String sql = \"SELECT TaxonPathId FROM TaxonPaths WHERE MetadataID = ? AND Source = ?\";\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.setString(2, source);\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified taxon,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxon(TaxonBean taxon, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        String taxonId = taxon.getTaxonId();\n        String taxonPathId = taxon.getTaxonPathId();\n        String id = taxon.getId();\n        String entry = taxon.getEntry();\n        // Checks to see if a Taxon matching this  bean already exists\n        // in the database\n        String existingTaxon = getTaxonId(taxon, conn);\n        if (null != existingTaxon) {\n            taxon.setTaxonId(existingTaxon);\n            return;\n        }\n        if (taxonId == null) {\n            // Use INSERT statement\n            sql.append(TAXONINSERTSQL);\n        } else {\n            sql.append(TAXONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(taxonPathId));\n        values.addElement(new StringValue(id));\n        values.addElement(new StringValue(entry));\n        if (taxonId != null) {\n            values.addElement(new StringValue(taxonId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    private String getTaxonId(TaxonBean taxon, Connection conn) throws SQLException {\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String sql = \"SELECT TaxonID FROM Taxons WHERE Id = ? AND Entry = ? AND TaxonPathID = ?\";\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, taxon.getId());\n            ps.setString(2, taxon.getEntry());\n            ps.setString(3, taxon.getTaxonPathId());\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified contextURL,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContextURL(ContextURLBean contextURL, Connection conn) throws SQLException {\n        if (contextURL == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String contextURLId = contextURL.getContextURLId();\n        if (contextURLId == null) {\n            // Use INSERT statement\n            sql.append(CONTEXTURLINSERTSQL);\n        } else {\n            sql.append(CONTEXTURLUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contextURL.getMetadataId()));\n        values.addElement(new StringValue(contextURL.getContextURL()));\n        values.addElement(new StringValue(contextURL.getContextURLDescription()));\n        if (contextURLId != null) {\n            values.addElement(new StringValue(contextURLId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified contributor,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContributor(ContributorBean contributor, Connection conn) throws SQLException {\n        if (contributor == null) {\n            return;\n        }\n        String vCardID = saveVCard(contributor.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String contributorId = contributor.getContributorId();\n        if (contributorId == null) {\n            // Use INSERT statement\n            sql.append(CONTRIBUTORINSERTSQL);\n        } else {\n            sql.append(CONTRIBUTORUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contributor.getMetadataId()));\n        values.addElement(new StringValue(contributor.getRole()));\n        values.addElement(new StringValue(vCardID));\n        java.sql.Date contributeDate = null;\n        if (null != contributor.getDate()) {\n            contributeDate = new java.sql.Date(contributor.getDate().getTime());\n        }\n        values.addElement(new DateValue(contributeDate));\n        values.addElement(new StringValue(contributor.getDateDescription()));\n        values.addElement(new StringValue(contributor.getVersion()));\n        values.addElement(new StringValue(contributor.getStatus()));\n        if (contributorId != null) {\n            values.addElement(new StringValue(contributor.getContributorId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified requirement,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRequirement(RequirementBean requirement, Connection conn) throws SQLException {\n        if (requirement == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String requirementId = requirement.getRequirementId();\n        if (requirementId == null) {\n            // Use INSERT statement\n            sql.append(REQUIREMENTINSERTSQL);\n        } else {\n            sql.append(REQUIREMENTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(requirement.getMetadataId()));\n        values.addElement(new StringValue(requirement.getRequirementType()));\n        values.addElement(new StringValue(requirement.getRequirementName()));\n        values.addElement(new StringValue(requirement.getOtherPlatform()));\n        values.addElement(new StringValue(requirement.getDuration()));\n        values.addElement(new StringValue(requirement.getDescription()));\n        if (requirementId != null) {\n            values.addElement(new StringValue(requirement.getRequirementId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified relation,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRelation(RelationBean relation, Connection conn) throws SQLException {\n        if (relation == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String relationId = relation.getRelationId();\n        if (relationId == null) {\n            // Use INSERT statement\n            sql.append(RELATIONINSERTSQL);\n        } else {\n            sql.append(RELATIONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(relation.getMetadataId()));\n        values.addElement(new StringValue(relation.getResource()));\n        values.addElement(new StringValue(relation.getKind()));\n        values.addElement(new StringValue(relation.getDescription()));\n        values.addElement(new StringValue(relation.getCatalogue()));\n        values.addElement(new StringValue(relation.getEntry()));\n        if (relationId != null) {\n            values.addElement(new StringValue(relation.getRelationId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveKeyword(KeywordBean keyword, Connection conn) throws SQLException {\n        if (keyword == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String keywordId = keyword.getKeywordId();\n        if (keywordId == null) {\n            // Use INSERT statement\n            sql.append(KEYWORDINSERTSQL);\n        } else {\n            sql.append(KEYWORDUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(keyword.getMetadataId()));\n        values.addElement(new StringValue(keyword.getKeyword()));\n        if (keywordId != null) {\n            values.addElement(new StringValue(keywordId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTargetUserGroup(TargetUserGroupBean tug, Connection conn) throws SQLException {\n        if (tug == null) {\n            return;\n        }\n        List<TargetUserGroupBean> existingTugs = new ArrayList<TargetUserGroupBean>();\n        Vector rows = null;\n        if (null != tug.getMetadataId()) {\n            rows = getMetadataProperties(tug.getMetadataId(), \"TargetUserGroup\", \"TargetUserGroups\", conn);\n        }\n        if (null != rows) {\n            try {\n                for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                    Row row = (Row) iter.next();\n                    String tugDescription = row.getString(\"TargetUserGroup\");\n                    TargetUserGroupBean temp = new TargetUserGroupBean();\n                    temp.setMetadataId(tug.getMetadataId());\n                    temp.setTargetUserGroup(tugDescription);\n                    existingTugs.add(temp);\n                }\n            } catch (NoSuchColumnException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (null != tug.getTargetUserGroup()) {\n            for (TargetUserGroupBean existingTug : existingTugs) {\n                if (tug.getTargetUserGroup().equals(existingTug.getTargetUserGroup())) {\n                    // We don't need to save this TUG, because it already exists\n                    return;\n                }\n            }\n        }\n        String sql = TARGETUSERGROUPINSERTSQL;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(tug.getMetadataId()));\n        values.addElement(new StringValue(tug.getTargetUserGroup()));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public void deleteTargetUserGroupsByMetadataId(final String metadataId, final Connection conn) throws SQLException {\n        if (null == metadataId)\n            return;\n        final String sql = \"DELETE FROM TargetUserGroups WHERE MetadataId = ?\";\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified format,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveFormat(FormatBean format, Connection conn) throws SQLException {\n        if (format == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String formatId = format.getFormatId();\n        if (formatId == null) {\n            // Use INSERT statement\n            sql.append(FORMATINSERTSQL);\n        } else {\n            sql.append(FORMATUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(format.getMetadataId()));\n        values.addElement(new StringValue(format.getFormat()));\n        if (formatId != null) {\n            values.addElement(new StringValue(formatId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public List getMetametadataIdentifiers(String metadataId, Connection conn) {\n        List<MetametadataIdentifierBean> ret = new ArrayList<MetametadataIdentifierBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT MetametadataIdentifierID, Catalogue, Entry, MetadataSchema FROM MetametadataIdentifiers WHERE MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataIdentifierBean mib = new MetametadataIdentifierBean();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n                mib.setMetadataId(metadataId);\n                mib.setCatalog(rs.getString(2));\n                mib.setEntry(rs.getString(3));\n                mib.setMetadataSchema(rs.getString(4));\n                ret.add(mib);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return ret;\n    }\n\n    public List getMetametadataContributors(String metadataId, Connection conn) throws SQLException {\n        List<MetametadataContributorBean> ret = new ArrayList<MetametadataContributorBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT A.MetametadataContributorID, A.Role, A.ContributeDate, A.ContributeDateDescription, B.vCard FROM MetametadataContributors A INNER JOIN vCards B ON A.vCardID = B.vCardID WHERE A.MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataContributorBean mcb = new MetametadataContributorBean();\n                mcb.setMetametadataContributorId(rs.getString(1));\n                mcb.setRole(rs.getString(2));\n                mcb.setDate(rs.getDate(3));\n                mcb.setDateDescription(rs.getString(4));\n                mcb.setvCard(rs.getString(5));\n                mcb.setMetadataId(metadataId);\n                ret.add(mcb);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/CommonDAOTest3.java",
		"test_prompt": "// CommonDAOTest3.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CommonDAO}.\n* It contains ten unit test cases for the {@link CommonDAO#saveCopyrightText(CopyrightTextBean, Connection)} method.\n*/\nclass CommonDAOTest3 {"
	},
	{
		"original_code": "// CommonDAO.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class CommonDAO implements Serializable {\n\n    public CommonDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private static final String THUMBNAILINSERTSQL = \"INSERT INTO Thumbnails (MetadataId, Location, FileWidth, FileHeight) VALUES(?, ?, ?, ?)\";\n\n    private static final String THUMBNAILUPDATESQL = \"UPDATE Thumbnails SET MetadataId = ?, Location= ?, FileWidth= ?, FileHeight = ? WHERE ThumbnailID = ?\";\n\n    private static final String COPYRIGHTINSERTSQL = \"INSERT INTO Copyrights (MetadataID, CopyrightTextID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTUPDATESQL = \"UPDATE Copyrights SET MetadataID = ?, CopyrightTextID = ? WHERE CopyrightID = ?\";\n\n    private static final String COPYRIGHTTEXTINSERTSQL = \"INSERT INTO CopyrightTexts (CopyrightText, Cost, CopyrightAndOtherRestriction) VALUES(?, ?, ?)\";\n\n    private static final String COPYRIGHTTEXTUPDATESQL = \"UPDATE CopyrightTexts SET CopyrightText = ?, Cost = ?, CopyrightAndOtherRestriction = ? WHERE CopyrightTextID = ?\";\n\n    private static final String COPYRIGHTTEXTLOOKUPIDSQL = \"SELECT CopyrightTextID FROM CopyrightTexts WHERE CopyrightText = ?\";\n\n    private static final String DISEASEDIAGNOSISINSERTSQL = \"INSERT INTO DiseaseDiagnoses (MetadataID, DiseaseDiagnosis) VALUES(?, ?)\";\n\n    private static final String DISEASEDIAGNOSISUPDATESQL = \"UPDATE DiseaseDiagnoses SET MetadataID = ?, DiseaseDiagnosis = ? WHERE DiseaseDiagnosisID = ?\";\n\n    private static final String COPYRIGHTHOLDERINSERTSQL = \"INSERT INTO CopyrightHolders (MetadataID, vCardID) VALUES(?, ?)\";\n\n    private static final String COPYRIGHTHOLDERUPDATESQL = \"UPDATE CopyrightHolders SET MetadataID = ?, vCardID = ? WHERE CopyrightHolderID = ?\";\n\n    private static final String KEYWORDINSERTSQL = \"INSERT INTO Keywords (MetadataID, Keyword) VALUES(?, ?)\";\n\n    private static final String KEYWORDUPDATESQL = \"UPDATE Keywords SET MetadataID = ?, Keyword = ? WHERE KeywordID = ?\";\n\n    private static final String FORMATINSERTSQL = \"INSERT INTO Formats (MetadataID, Format) VALUES(?, ?)\";\n\n    private static final String FORMATUPDATESQL = \"UPDATE Formats SET MetadataID = ?, Format = ? WHERE FormatID = ?\";\n\n    private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source, Purpose, Description, Keyword) VALUES(?, ?, ?, ?, ?)\";\n\n    //  private static final String TAXONPATHINSERTSQL = \"INSERT INTO TaxonPaths (MetadataID, Source) VALUES(?, ?)\";\n    private static final String TAXONINSERTSQL = \"INSERT INTO Taxons (TaxonPathID, ID, Entry) VALUES(?, ?, ?)\";\n\n    private static final String TAXONUPDATESQL = \"UPDATE Taxons SET TaxonPathID = ?, ID = ?, Entry = ? WHERE TaxonID = ?\";\n\n    private static final String CONTEXTURLINSERTSQL = \"INSERT INTO ContextURLs (MetadataID, ContextURL, ContextURLDescription) VALUES(?, ?, ?)\";\n\n    private static final String CONTEXTURLUPDATESQL = \"UPDATE ContextURLs SET MetadataID = ?, ContextURL = ?, ContextURLDescription = ? WHERE ContextURLID = ?\";\n\n    private static final String REQUIREMENTINSERTSQL = \"INSERT INTO Requirements (MetadataID, RequirementType, RequirementName, OtherPlatformRequirements, Duration, Description) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String REQUIREMENTUPDATESQL = \"UPDATE Requirements SET MetadataID = ?, RequirementType = ?, RequirementName = ?, OtherPlatformRequirements = ?, Duration = ?, Description = ? WHERE RequirementID = ?\";\n\n    private static final String CONTRIBUTORINSERTSQL = \"INSERT INTO Contributors (MetadataID, Role, vCardID, ContributeDate, ContributeDateDescription, Version, Status) VALUES(?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String CONTRIBUTORUPDATESQL = \"UPDATE Contributors SET MetadataID = ?, Role = ?, vCardID = ?, ContributeDate = ?, ContributeDateDescription = ?, Version = ?, Status = ? WHERE ContributorID = ?\";\n\n    private static final String RELATIONINSERTSQL = \"INSERT INTO Relations (MetadataID, Resource, Kind, Description, Catalogue, Entry) VALUES(?, ?, ?, ?, ?, ?)\";\n\n    private static final String RELATIONUPDATESQL = \"UPDATE Relations SET MetadataID = ?, Resource = ?, Kind = ?, Description = ?, Catalogue = ?, Entry = ? WHERE RelationID = ?\";\n\n    private static final String TARGETUSERGROUPINSERTSQL = \"INSERT INTO TargetUserGroups (MetadataId, TargetUserGroup) VALUES (?, ?)\";\n\n    private static final String DELETEDITEMSINSERTSQL = \"INSERT INTO DeletedItems (GlobalID, FileName, Title, Location, ContributeUserID, ContributeDate, DeleteDate, Comments) VALUES(?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"UPDATE Metadata SET \").append(propertyName).append(\" = ? WHERE \");\n        sql.append(\"MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(propertyValue);\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataStringProperty(String propertyName, String propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new StringValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataTimestampProperty(String propertyName, Timestamp propertyValue, String metadataId, Connection conn) throws SQLException {\n        updateMetadataValueProperty(propertyName, new TimestampValue(propertyValue), metadataId, conn);\n    }\n\n    /**\n     * Returns a Vector of Rows with all of the requested columns from the\n     * requested table that have the specified metadataId in their\n     * MetadataID column, or null if no matches are found.\n     */\n    public Vector getMetadataProperties(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        if (metadataId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT \").append(columnNames).append(\" FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        return rows;\n    }\n\n    public TimestampValue getTimestampValue(Date date) {\n        TimestampValue ret;\n        if (null != date) {\n            ret = new TimestampValue(new Timestamp(date.getTime()));\n        } else {\n            ret = new TimestampValue(null);\n        }\n        return ret;\n    }\n\n    public IntValue getIntValue(String intString) {\n        int parsedInt = 0;\n        try {\n            parsedInt = Integer.parseInt(intString);\n        } catch (NumberFormatException ex) {\n            //XXX logging?\n        }\n        return new IntValue(parsedInt);\n    }\n\n    public LongValue getLongValue(String longString) {\n        long parsedLong = 0;\n        try {\n            parsedLong = Long.parseLong(longString);\n        } catch (NumberFormatException e) {\n        }\n        return new LongValue(parsedLong);\n    }\n\n    /**\n     * Gets all rows from a given table.  The return value is a Vector\n     * of com.ora.jsp.sql.Row object or null if an error occurs.\n     */\n    public Vector getAllRows(String tableName) throws SQLException {\n        if (tableName == null) {\n            return null;\n        }\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(\"SELECT * FROM \" + tableName);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId, Connection conn) throws SQLException {\n        // Get the metadata info from the database\n        Row metadataRow = getMetadataProperty(metadataId, \"Metadata.*, Publications.Name AS PubName, Publications.PublicationDate AS PubDate\", \"Metadata LEFT OUTER JOIN Publications ON Metadata.PublicationId = Publications.PublicationId\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        MetadataBean metadataInfo = new MetadataBean();\n        try {\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setContributeDate(DateTools.parse(metadataRow.getString(\"ContributeDate\")));\n            metadataInfo.setAnnotated(metadataRow.getString(\"Annotated\"));\n            metadataInfo.setInappropriate(metadataRow.getString(\"Inappropriate\"));\n            metadataInfo.setArchived(metadataRow.getString(\"Archived\"));\n            metadataInfo.setPrivate(metadataRow.getString(\"Private\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setSpecimenType(metadataRow.getString(\"SpecimenType\"));\n            metadataInfo.setRadiographType(metadataRow.getString(\"RadiographType\"));\n            metadataInfo.setOrientation(metadataRow.getString(\"Orientation\"));\n            metadataInfo.setMagnification(metadataRow.getString(\"Magnification\"));\n            metadataInfo.setClinicalHistory(metadataRow.getString(\"ClinicalHistory\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setDuration(metadataRow.getString(\"Duration\"));\n            metadataInfo.setApproveDate(DateTools.parse(metadataRow.getString(\"ApproveDate\")));\n            metadataInfo.setCatalogDate(DateTools.parse(metadataRow.getString(\"CatalogDate\")));\n            metadataInfo.setRejectDate(DateTools.parse(metadataRow.getString(\"RejectDate\")));\n            metadataInfo.setCreationDate(DateTools.parse(metadataRow.getString(\"CreationDate\")));\n            metadataInfo.setPublicationName(metadataRow.getString(\"PubName\"));\n            metadataInfo.setPublicationDate(DateTools.parse(metadataRow.getString(\"PubDate\")));\n            // For some reason a null integer gets returned from getString as \"0\"\n            // so this ensures the publicationId is populated as null correctly\n            final String publicationId = metadataRow.getString(\"PublicationId\");\n            metadataInfo.setPublicationId(\"0\".equals(publicationId) ? null : publicationId);\n            metadataInfo.setLanguageType(metadataRow.getString(\"LanguageType\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * metadata or null if the metadata is not found.\n     */\n    public Row getMetadataProperty(String metadataId, String columnNames, String tableName, Connection conn) throws SQLException {\n        Vector results = getMetadataProperties(metadataId, columnNames, tableName, conn);\n        if (results != null) {\n            return (Row) results.firstElement();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Removes all taxons and taxon paths associated with the given metadataId.\n     */\n    public void removeTaxonPaths(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Taxons WHERE TaxonPathID in (SELECT TaxonPathID FROM TaxonPaths WHERE MetadataID = ?)\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        sql.append(\"DELETE FROM TaxonPaths WHERE MetadataID = ?\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all copyright entries with the given metadataId\n     * from the Copyrights table.\n     */\n    public void removeCopyrights(String metadataId, Connection conn) throws SQLException {\n        if (metadataId == null || conn == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM Copyrights WHERE MetadataID = ?\");\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        sql.setLength(0);\n        //clean up the copyright texts\n        sql.append(\"DELETE FROM CopyrightTexts WHERE CopyrightTextID NOT IN (SELECT CopyrightTextID FROM Copyrights)\");\n        sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values = new Vector();\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all entries in a table that have a given metadataId.\n     */\n    public void removeMetadataFromTable(String metadataId, String tableName, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"DELETE FROM \").append(tableName).append(\" \").append(\"WHERE MetadataID = ?\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadataId));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Deletes the metadata entry from the metadata table.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadata(String metadataId) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            removeMetadataFromTable(metadataId, \"Metadata\", conn);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return success;\n    }\n\n    public String getMetadataPropertyAsString(String metadataId, String columnName, String tableName, Connection conn) throws SQLException {\n        Row row = getMetadataProperty(metadataId, columnName, tableName, conn);\n        if (row != null) {\n            try {\n                return row.getString(columnName);\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = getMetadata(metadataId, conn);\n        addToDeletedItems(metadata, comment, conn);\n        success = deleteMetadataReferences(metadataId, conn);\n        removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Takes information from the metadata bean and stores it in the\n     * deleted items table, with the addition of the provided comment.\n     */\n    public void addToDeletedItems(MetadataBean metadata, String comment, Connection conn) throws SQLException {\n        if (metadata == null) {\n            throw new SQLException(\"Invalid metadata provided.\");\n        }\n        Timestamp deleteDate = new Timestamp(System.currentTimeMillis());\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(DELETEDITEMSINSERTSQL);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getGlobalId()));\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(getIntValue(metadata.getContributeUserId()));\n        values.addElement(getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new TimestampValue(deleteDate));\n        values.addElement(new StringValue(comment));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Removes all references to the given metadataId, EXCEPT for the main\n     * entry in the Metadata table.  All other references are removed from\n     * the other tables (Formats, Keywords, Requirements, etc).\n     * Also deleted are all taxons associated with taxonpaths associated with\n     * this metadata reference.  Also, all copyrights associated with the\n     * metadata are deleted.  If the copyright to be deleted contains the only\n     * reference to the associated copyright text, then the copyright text\n     * is also deleted.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean deleteMetadataReferences(String metadataId, Connection conn) throws SQLException {\n        //first do the easy removals...\n        removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        removeMetadataFromTable(metadataId, \"Formats\", conn);\n        removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        removeMetadataFromTable(metadataId, \"Relations\", conn);\n        removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n        removeTaxonPaths(metadataId, conn);\n        removeCopyrights(metadataId, conn);\n        return true;\n    }\n\n    /**\n     * Returns a ThumbnailBean associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public ThumbnailBean getThumbnail(String metadataId, Connection conn) throws SQLException {\n        ThumbnailBean result = null;\n        if (metadataId != null) {\n            Vector rows = getMetadataProperties(metadataId, \"*\", \"Thumbnails\", conn);\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new ThumbnailBean();\n                    result.setThumbnailId(row.getString(\"ThumbnailID\"));\n                    result.setMetadataId(metadataId);\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"FileWidth\"));\n                    result.setFileHeight(row.getString(\"FileHeight\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a SourceCollection Bean associated with the\n     * given source collection name.\n     * If no keywords are found or an error occurs,\n     * null is returned.\n     */\n    public SourceCollectionBean getSCollectionBean(String name, Connection conn) throws SQLException {\n        SourceCollectionBean result = null;\n        if (name != null) {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT * FROM SourceCollection WHERE name = ?\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(name));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new SourceCollectionBean();\n                    result.setSourceId(row.getString(\"SourceCollectionID\"));\n                    result.setSourceName(\"Name\");\n                    result.setLocation(row.getString(\"Location\"));\n                    result.setFileWidth(row.getString(\"Width\"));\n                    result.setFileHeight(row.getString(\"Height\"));\n                    result.setLink(row.getString(\"Link\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Inserts the information about the specified thumbnail,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveThumbnail(ThumbnailBean thumbnail, Connection conn) throws SQLException {\n        if (thumbnail == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String thumbnailId = thumbnail.getThumbnailId();\n        Vector values = new Vector();\n        if (thumbnailId == null) {\n            // Use INSERT statement\n            sql.append(THUMBNAILINSERTSQL);\n        } else {\n            sql.append(THUMBNAILUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        values.addElement(new StringValue(thumbnail.getMetadataId()));\n        values.addElement(new StringValue(thumbnail.getLocation()));\n        values.addElement(new StringValue(thumbnail.getFileWidth()));\n        values.addElement(new StringValue(thumbnail.getFileHeight()));\n        if (thumbnailId != null) {\n            values.addElement(new StringValue(thumbnailId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified diseaseDiagnosis,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveDiseaseDiagnosis(DiseaseDiagnosisBean diseaseDiagnosis, Connection conn) throws SQLException {\n        if (diseaseDiagnosis == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String diseaseDiagnosisId = diseaseDiagnosis.getDiseaseDiagnosisId();\n        if (diseaseDiagnosisId == null) {\n            // Use INSERT statement\n            sql.append(DISEASEDIAGNOSISINSERTSQL);\n        } else {\n            sql.append(DISEASEDIAGNOSISUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(diseaseDiagnosis.getMetadataId()));\n        values.addElement(new StringValue(diseaseDiagnosis.getDiseaseDiagnosis()));\n        if (diseaseDiagnosisId != null) {\n            values.addElement(new StringValue(diseaseDiagnosisId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified copyright,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyright(CopyrightBean copyright, Connection conn) throws SQLException {\n        if (copyright == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String copyrightId = copyright.getCopyrightId();\n        if (copyrightId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyright.getMetadataId()));\n        String copyrightTextId = saveCopyrightText(copyright.getCopyrightText(), conn);\n        values.addElement(new StringValue(copyrightTextId));\n        if (copyrightId != null) {\n            values.addElement(new StringValue(copyright.getCopyrightId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Stores a CopyrightTextBean in the database.  If the provided\n     * CopyrightTextBean has a copyrightTextId that is non-null, an update\n     * will be attempted.  Otherwise, an insert will be performed.\n     * The copyrightTextId will be returned.  This will either be obtained\n     * from the provided bean, or by doing another database lookup after\n     * the insert (looking for a match on the copyrightText).\n     */\n    public String saveCopyrightText(CopyrightTextBean copyrightText, Connection conn) throws SQLException {\n        if (copyrightText == null) {\n            return null;\n        }\n        String copyrightTextId = null;\n        copyrightTextId = copyrightText.getCopyrightTextId();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        Vector values = new Vector();\n        StringValue textValue = new StringValue(copyrightText.getCopyrightText());\n        values.addElement(textValue);\n        values.addElement(new StringValue(copyrightText.getCost()));\n        values.addElement(new StringValue(copyrightText.getCopyrightAndOtherRestriction()));\n        if (copyrightTextId != null) {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTUPDATESQL);\n            values.addElement(new StringValue(copyrightText.getCopyrightTextId()));\n        } else {\n            sqlCommandBean.setSqlValue(COPYRIGHTTEXTINSERTSQL);\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n        if (copyrightTextId == null) {\n            try {\n                sqlCommandBean.setSqlValue(COPYRIGHTTEXTLOOKUPIDSQL);\n                values.clear();\n                values.addElement(textValue);\n                Vector rows;\n                rows = sqlCommandBean.executeQuery();\n                Row aRow = (Row) rows.firstElement();\n                copyrightTextId = aRow.getString(\"CopyrightTextID\");\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return copyrightTextId;\n    }\n\n    /**\n     * Inserts the information about the specified copyrightHolder,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveCopyrightHolder(CopyrightHolderBean copyrightHolder, Connection conn) throws SQLException {\n        if (copyrightHolder == null) {\n            return;\n        }\n        String vCardID = saveVCard(copyrightHolder.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String copyrightHolderId = copyrightHolder.getCopyrightHolderId();\n        if (copyrightHolderId == null) {\n            // Use INSERT statement\n            sql.append(COPYRIGHTHOLDERINSERTSQL);\n        } else {\n            sql.append(COPYRIGHTHOLDERUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(copyrightHolder.getMetadataId()));\n        values.addElement(new StringValue(vCardID));\n        if (copyrightHolderId != null) {\n            values.addElement(new StringValue(copyrightHolderId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * @param vCard non-null vcard String\n     * @param conn\n     *\n     * @return\n     *\n     * @throws SQLException\n     */\n    public String saveVCard(String vCard, Connection conn) throws SQLException {\n        vCard = vCard.trim();\n        String vCardID = getVCardIDByVCard(vCard, conn);\n        if (vCardID == null) {\n            // No current vCard found, so we have to insert one\n            SQLCommandBean sqlInsertCommand = new SQLCommandBean();\n            sqlInsertCommand.setConnection(conn);\n            sqlInsertCommand.setSqlValue(\"INSERT INTO vCards (vCard) VALUES (?)\");\n            Vector insertValues = new Vector();\n            insertValues.add(new StringValue(vCard));\n            sqlInsertCommand.setValues(insertValues);\n            sqlInsertCommand.executeUpdate();\n            vCardID = getVCardIDByVCard(vCard, conn);\n        }\n        return vCardID;\n    }\n\n    /**\n     * Returns a vCardID or null if no VCard matching the vCard parameter\n     * is found.\n     *\n     * @param vCard The String of the vCard to be found\n     * @param conn The connection to the database.\n     *\n     * @return <code>null</code>If no vCard is found, otherwise returns a\n     *         <code>String</code> containing the vCardID\n     */\n    private String getVCardIDByVCard(String vCard, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommand = new SQLCommandBean();\n        sqlCommand.setConnection(conn);\n        sqlCommand.setSqlValue(\"SELECT vCardID FROM vCards WHERE vCard LIKE ?\");\n        Vector values = new Vector();\n        values.add(new StringValue(vCard));\n        sqlCommand.setValues(values);\n        Vector results;\n        try {\n            results = sqlCommand.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.getMessage());\n        }\n        if (results != null && results.size() > 0) {\n            Row row = (Row) results.get(0);\n            try {\n                return row.getString(\"vCardID\");\n            } catch (NoSuchColumnException e) {\n                throw new SQLException(e.getMessage());\n            }\n        } else\n            return null;\n    }\n\n    public void saveTaxonPath(TaxonPathBean taxonPath) throws SQLException {\n        if (null == taxonPath) {\n            return;\n        }\n        Connection conn = dataSource.getConnection();\n        try {\n            saveTaxonPath(taxonPath, conn);\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Inserts the information about the specified taxon path,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxonPath(TaxonPathBean taxonPath, Connection conn) throws SQLException {\n        if (taxonPath == null) {\n            return;\n        }\n        String taxonPathId = taxonPath.getTaxonPathId();\n        final String source = taxonPath.getSource();\n        final String purpose = taxonPath.getPurpose();\n        final String description = taxonPath.getDescription();\n        final String keyword = taxonPath.getKeyword();\n        final String metadataId = taxonPath.getMetadataId();\n        // Checks if a taxon path like this already exists in the db\n        if (null == taxonPathId) {\n            taxonPathId = getTaxonPathId(metadataId, source, conn);\n        }\n        if (taxonPathId == null) {\n            // Use INSERT statement\n            final String sql = TAXONPATHINSERTSQL;\n            final SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql);\n            // Sets a temporary source so that we can grab the taxon path id with a unique value\n            final String tempSource = metadataId + System.currentTimeMillis();\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            values.addElement(new StringValue(tempSource));\n            values.addElement(new StringValue(purpose));\n            values.addElement(new StringValue(description));\n            values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            // Gets the taxon path id using the unique temporary source value\n            sqlCommandBean.setSqlValue(\"SELECT TaxonPathID FROM \" + \"TaxonPaths WHERE Source = ?\");\n            values.clear();\n            values.addElement(new StringValue(tempSource));\n            //  values.addElement(new StringValue(purpose));\n            // values.addElement(new StringValue(description));\n            //  values.addElement(new StringValue(keyword));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    Row aRow = (Row) rows.firstElement();\n                    // taxonPathId is used below to set the taxon path bean's taxon path id\n                    taxonPathId = aRow.getString(\"TaxonPathID\");\n                    // fixes the temporary source\n                    sqlCommandBean.setSqlValue(\"UPDATE TaxonPaths SET \" + \"Source = ?, Purpose = ?, Description = ?, Keyword = ? \" + \"WHERE TaxonPathID = ?\");\n                    values.clear();\n                    values.addElement(new StringValue(source));\n                    values.addElement(new StringValue(purpose));\n                    values.addElement(new StringValue(description));\n                    values.addElement(new StringValue(keyword));\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    sqlCommandBean.executeUpdate();\n                }\n            } catch (NoSuchColumnException ex) {\n                throw new SQLException(ex.toString());\n            } catch (UnsupportedTypeException ex2) {\n                throw new SQLException(ex2.toString());\n            }\n        }\n        taxonPath.setTaxonPathId(taxonPathId);\n        // There should be a taxon path id now\n        if (taxonPathId != null && taxonPath.getTaxons() != null) {\n            Iterator taxonIterator = taxonPath.getTaxons().iterator();\n            while (taxonIterator.hasNext()) {\n                TaxonBean taxon = (TaxonBean) taxonIterator.next();\n                taxon.setTaxonPathId(taxonPathId);\n                saveTaxon(taxon, conn);\n            }\n        } else {\n            throw new RuntimeException(\"Unable to save TaxonPath\");\n        }\n    }\n\n    private String getTaxonPathId(final String metadataId, final String source, final Connection conn) throws SQLException {\n        final String sql = \"SELECT TaxonPathId FROM TaxonPaths WHERE MetadataID = ? AND Source = ?\";\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.setString(2, source);\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified taxon,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTaxon(TaxonBean taxon, Connection conn) throws SQLException {\n        StringBuffer sql = new StringBuffer();\n        String taxonId = taxon.getTaxonId();\n        String taxonPathId = taxon.getTaxonPathId();\n        String id = taxon.getId();\n        String entry = taxon.getEntry();\n        // Checks to see if a Taxon matching this  bean already exists\n        // in the database\n        String existingTaxon = getTaxonId(taxon, conn);\n        if (null != existingTaxon) {\n            taxon.setTaxonId(existingTaxon);\n            return;\n        }\n        if (taxonId == null) {\n            // Use INSERT statement\n            sql.append(TAXONINSERTSQL);\n        } else {\n            sql.append(TAXONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(taxonPathId));\n        values.addElement(new StringValue(id));\n        values.addElement(new StringValue(entry));\n        if (taxonId != null) {\n            values.addElement(new StringValue(taxonId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    private String getTaxonId(TaxonBean taxon, Connection conn) throws SQLException {\n        String ret = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String sql = \"SELECT TaxonID FROM Taxons WHERE Id = ? AND Entry = ? AND TaxonPathID = ?\";\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, taxon.getId());\n            ps.setString(2, taxon.getEntry());\n            ps.setString(3, taxon.getTaxonPathId());\n            rs = ps.executeQuery();\n            if (rs.next()) {\n                ret = rs.getString(1);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Inserts the information about the specified contextURL,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContextURL(ContextURLBean contextURL, Connection conn) throws SQLException {\n        if (contextURL == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String contextURLId = contextURL.getContextURLId();\n        if (contextURLId == null) {\n            // Use INSERT statement\n            sql.append(CONTEXTURLINSERTSQL);\n        } else {\n            sql.append(CONTEXTURLUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contextURL.getMetadataId()));\n        values.addElement(new StringValue(contextURL.getContextURL()));\n        values.addElement(new StringValue(contextURL.getContextURLDescription()));\n        if (contextURLId != null) {\n            values.addElement(new StringValue(contextURLId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified contributor,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveContributor(ContributorBean contributor, Connection conn) throws SQLException {\n        if (contributor == null) {\n            return;\n        }\n        String vCardID = saveVCard(contributor.getVCard(), conn);\n        StringBuffer sql = new StringBuffer();\n        String contributorId = contributor.getContributorId();\n        if (contributorId == null) {\n            // Use INSERT statement\n            sql.append(CONTRIBUTORINSERTSQL);\n        } else {\n            sql.append(CONTRIBUTORUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(contributor.getMetadataId()));\n        values.addElement(new StringValue(contributor.getRole()));\n        values.addElement(new StringValue(vCardID));\n        java.sql.Date contributeDate = null;\n        if (null != contributor.getDate()) {\n            contributeDate = new java.sql.Date(contributor.getDate().getTime());\n        }\n        values.addElement(new DateValue(contributeDate));\n        values.addElement(new StringValue(contributor.getDateDescription()));\n        values.addElement(new StringValue(contributor.getVersion()));\n        values.addElement(new StringValue(contributor.getStatus()));\n        if (contributorId != null) {\n            values.addElement(new StringValue(contributor.getContributorId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified requirement,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRequirement(RequirementBean requirement, Connection conn) throws SQLException {\n        if (requirement == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String requirementId = requirement.getRequirementId();\n        if (requirementId == null) {\n            // Use INSERT statement\n            sql.append(REQUIREMENTINSERTSQL);\n        } else {\n            sql.append(REQUIREMENTUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(requirement.getMetadataId()));\n        values.addElement(new StringValue(requirement.getRequirementType()));\n        values.addElement(new StringValue(requirement.getRequirementName()));\n        values.addElement(new StringValue(requirement.getOtherPlatform()));\n        values.addElement(new StringValue(requirement.getDuration()));\n        values.addElement(new StringValue(requirement.getDescription()));\n        if (requirementId != null) {\n            values.addElement(new StringValue(requirement.getRequirementId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified relation,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveRelation(RelationBean relation, Connection conn) throws SQLException {\n        if (relation == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String relationId = relation.getRelationId();\n        if (relationId == null) {\n            // Use INSERT statement\n            sql.append(RELATIONINSERTSQL);\n        } else {\n            sql.append(RELATIONUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(relation.getMetadataId()));\n        values.addElement(new StringValue(relation.getResource()));\n        values.addElement(new StringValue(relation.getKind()));\n        values.addElement(new StringValue(relation.getDescription()));\n        values.addElement(new StringValue(relation.getCatalogue()));\n        values.addElement(new StringValue(relation.getEntry()));\n        if (relationId != null) {\n            values.addElement(new StringValue(relation.getRelationId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveKeyword(KeywordBean keyword, Connection conn) throws SQLException {\n        if (keyword == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String keywordId = keyword.getKeywordId();\n        if (keywordId == null) {\n            // Use INSERT statement\n            sql.append(KEYWORDINSERTSQL);\n        } else {\n            sql.append(KEYWORDUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(keyword.getMetadataId()));\n        values.addElement(new StringValue(keyword.getKeyword()));\n        if (keywordId != null) {\n            values.addElement(new StringValue(keywordId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Inserts the information about the specified keyword,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveTargetUserGroup(TargetUserGroupBean tug, Connection conn) throws SQLException {\n        if (tug == null) {\n            return;\n        }\n        List<TargetUserGroupBean> existingTugs = new ArrayList<TargetUserGroupBean>();\n        Vector rows = null;\n        if (null != tug.getMetadataId()) {\n            rows = getMetadataProperties(tug.getMetadataId(), \"TargetUserGroup\", \"TargetUserGroups\", conn);\n        }\n        if (null != rows) {\n            try {\n                for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                    Row row = (Row) iter.next();\n                    String tugDescription = row.getString(\"TargetUserGroup\");\n                    TargetUserGroupBean temp = new TargetUserGroupBean();\n                    temp.setMetadataId(tug.getMetadataId());\n                    temp.setTargetUserGroup(tugDescription);\n                    existingTugs.add(temp);\n                }\n            } catch (NoSuchColumnException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (null != tug.getTargetUserGroup()) {\n            for (TargetUserGroupBean existingTug : existingTugs) {\n                if (tug.getTargetUserGroup().equals(existingTug.getTargetUserGroup())) {\n                    // We don't need to save this TUG, because it already exists\n                    return;\n                }\n            }\n        }\n        String sql = TARGETUSERGROUPINSERTSQL;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(tug.getMetadataId()));\n        values.addElement(new StringValue(tug.getTargetUserGroup()));\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public void deleteTargetUserGroupsByMetadataId(final String metadataId, final Connection conn) throws SQLException {\n        if (null == metadataId)\n            return;\n        final String sql = \"DELETE FROM TargetUserGroups WHERE MetadataId = ?\";\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, metadataId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified format,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveFormat(FormatBean format, Connection conn) throws SQLException {\n        if (format == null) {\n            return;\n        }\n        StringBuffer sql = new StringBuffer();\n        String formatId = format.getFormatId();\n        if (formatId == null) {\n            // Use INSERT statement\n            sql.append(FORMATINSERTSQL);\n        } else {\n            sql.append(FORMATUPDATESQL);\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(format.getMetadataId()));\n        values.addElement(new StringValue(format.getFormat()));\n        if (formatId != null) {\n            values.addElement(new StringValue(formatId));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    public List getMetametadataIdentifiers(String metadataId, Connection conn) {\n        List<MetametadataIdentifierBean> ret = new ArrayList<MetametadataIdentifierBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT MetametadataIdentifierID, Catalogue, Entry, MetadataSchema FROM MetametadataIdentifiers WHERE MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataIdentifierBean mib = new MetametadataIdentifierBean();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n                mib.setMetadataId(metadataId);\n                mib.setCatalog(rs.getString(2));\n                mib.setEntry(rs.getString(3));\n                mib.setMetadataSchema(rs.getString(4));\n                ret.add(mib);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return ret;\n    }\n\n    public List getMetametadataContributors(String metadataId, Connection conn) throws SQLException {\n        List<MetametadataContributorBean> ret = new ArrayList<MetametadataContributorBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(\"SELECT A.MetametadataContributorID, A.Role, A.ContributeDate, A.ContributeDateDescription, B.vCard FROM MetametadataContributors A INNER JOIN vCards B ON A.vCardID = B.vCardID WHERE A.MetadataID = ?\");\n            ps.setString(1, metadataId);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                MetametadataContributorBean mcb = new MetametadataContributorBean();\n                mcb.setMetametadataContributorId(rs.getString(1));\n                mcb.setRole(rs.getString(2));\n                mcb.setDate(rs.getDate(3));\n                mcb.setDateDescription(rs.getString(4));\n                mcb.setvCard(rs.getString(5));\n                mcb.setMetadataId(metadataId);\n                ret.add(mcb);\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/CommonDAOTest4.java",
		"test_prompt": "// CommonDAOTest4.java\npackage org.heal.util;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.Value;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.IntValue;\nimport com.ora.jsp.sql.value.LongValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport com.ora.jsp.sql.value.DateValue;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.MetametadataContributorBean;\nimport org.heal.module.metadata.MetametadataIdentifierBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.SourceCollectionBean;\nimport org.heal.module.metadata.TargetUserGroupBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CommonDAO}.\n* It contains ten unit test cases for the {@link CommonDAO#saveVCard(String, Connection)} method.\n*/\nclass CommonDAOTest4 {"
	},
	{
		"original_code": "// VCardBean.java\npackage org.heal.util;\n\nimport java.io.Serializable;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\n/**\n * Represents VCard data.  Very incomplete implementation, but this is all\n * that is needed at the moment.\n *\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@libscan.med.utah.edu\">schaefer@libscan.med.utah.edu</A>)\n * @version 1.0\n */\npublic class VCardBean implements Serializable {\n\n    private String vCard;\n\n    // Name fields\n    private String firstName;\n\n    private String lastName;\n\n    private String middleName;\n\n    private String formattedName;\n\n    private String title;\n\n    private String organization;\n\n    private String email;\n\n    private String phone;\n\n    private String fax;\n\n    public void setVCard(String vCard) {\n        this.vCard = vCard;\n        firstName = lastName = middleName = formattedName = null;\n        title = null;\n        organization = null;\n        email = null;\n        phone = fax = null;\n        parseVCard(this);\n    }\n\n    /**\n     * @return A String representation of this vCard object.  If a\n     *         vCard cannot be found or generated, this will return\n     *         <code>null</code>.\n     */\n    public String getVCard() {\n        String ret;\n        if (null == vCard) {\n            // tries to generate a vcard for this object\n            // (this may return null if a vcard cannot be generated)\n            ret = generateVCard(this);\n        } else {\n            ret = vCard;\n        }\n        return ret;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public String getMiddleName() {\n        return middleName;\n    }\n\n    public void setMiddleName(String middleName) {\n        this.middleName = middleName;\n    }\n\n    public String getFormattedName() {\n        return formattedName;\n    }\n\n    public void setFormattedName(String formattedName) {\n        this.formattedName = formattedName;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getOrganization() {\n        return organization;\n    }\n\n    public void setOrganization(String organization) {\n        this.organization = organization;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getFax() {\n        return fax;\n    }\n\n    public void setFax(String fax) {\n        this.fax = fax;\n    }\n\n    public String toString() {\n        return getVCard();\n    }\n\n    /**\n     * Generates a vCard String from the various member variables. If no\n     * vCard can be generated, it returns <code>null</code>.\n     * <p/>\n     * DESIGN DECISION: Since this is used primarily to generate vCards\n     * inputted via contribute and/or imported records, there are extra\n     * restrictions beyond the N and FN (name fields) requirements for\n     * a vCard -- to generate a vcard we additionally require an EMAIL,\n     * an ORG, and a TITLE.\n     */\n    private static String generateVCard(VCardBean vcb) {\n        // Makes sure required fields are there\n        if (null == vcb.getFirstName() || null == vcb.getLastName() || null == vcb.getEmail() || null == vcb.getOrganization()) {\n            return null;\n        }\n        StringBuffer vCard = new StringBuffer(\"BEGIN:VCARD\\n\");\n        // FN field\n        {\n            StringBuffer name;\n            if (vcb.getFormattedName() != null) {\n                name = new StringBuffer(vcb.getFormattedName());\n            } else {\n                name = new StringBuffer(vcb.getFirstName()).append(\" \");\n                String middleName = vcb.getMiddleName();\n                if (middleName != null && middleName.length() != 0) {\n                    name.append(middleName).append(\" \");\n                }\n                name.append(vcb.getLastName());\n            }\n            vCard.append(\"FN:\").append(name.toString()).append(\"\\n\");\n        }\n        // N field\n        vCard.append(\"N:\").append(vcb.getLastName()).append(\";\");\n        if (vcb.getMiddleName() != null) {\n            vCard.append(vcb.getMiddleName());\n        }\n        vCard.append(\";\").append(vcb.getFirstName()).append(\";\").append(\"\\n\");\n        // TITLE field\n        if (null != vcb.getTitle()) {\n            vCard.append(\"TITLE:\").append(addBackslashes(vcb.getTitle())).append(\"\\n\");\n        }\n        // ORG field\n        vCard.append(\"ORG:\").append(addBackslashes(vcb.getOrganization())).append(\"\\n\");\n        // EMAIL field\n        vCard.append(\"EMAIL;TYPE=INTERNET:\").append(vcb.getEmail()).append(\"\\n\");\n        // TEL;TYPE=VOICE field\n        if (vcb.getPhone() != null && vcb.getPhone().length() != 0) {\n            vCard.append(\"TEL;TYPE=VOICE:\").append(vcb.getPhone()).append(\"\\n\");\n        }\n        // TEL;TYPE=FAX field\n        if (vcb.getFax() != null && vcb.getFax().length() != 0) {\n            vCard.append(\"TEL;TYPE=FAX:\").append(vcb.getFax()).append(\"\\n\");\n        }\n        vCard.append(\"END:VCARD\");\n        return vCard.toString();\n        //        this.vCard = vCard.toString();\n    }\n\n    /**\n     * Folds lines which are more than 75 characters long into multiple lines\n     * delimited by <code>\"\\r\\n\\t\"</code> (a CRLF + a whitespace character).\n     *\n     * @param str An unfolded String.\n     *\n     * @return A folded String.\n     */\n    private static String foldLines(String str) {\n        StringBuffer ret = new StringBuffer();\n        while (str.length() > 75) {\n            ret.append(str.substring(0, 75) + \"\\r\\n\\t\");\n            str = str.substring(75, str.length());\n        }\n        ret.append(str);\n        return ret.toString();\n    }\n\n    /**\n     * If lines are folded using a CRLF + a whitespace character, this unfolds\n     * the line in the String.\n     *\n     * @param str A String with folded lines.\n     *\n     * @return A String without folded lines.\n     */\n    private static String unfoldLines(String str) {\n        return str.replaceAll(\"\\r\\n\\\\s\", \"\");\n    }\n\n    /**\n     * Takes what's in the vCard field and seperates it out to the seperate\n     * vCard variables.  If the vCard is valid for our purposes, we set the\n     * VCardBean properties accordingly.\n     */\n    private static void parseVCard(VCardBean vcb) {\n        String vCard = vcb.getVCard();\n        if (null == vCard || !vCard.toUpperCase().startsWith(\"BEGIN:VCARD\")) {\n            return;\n        }\n        vCard = unfoldLines(vCard);\n        StringTokenizer tokenizer = new StringTokenizer(vCard, \"\\n\");\n        // Basic vCard types\n        String FN = null;\n        String N = null;\n        String ORG = null;\n        String EMAIL = null;\n        String TEL = null;\n        String TITLE = null;\n        String TEL_FAX = null;\n        boolean beginFound = false;\n        boolean endFound = false;\n        while (tokenizer.hasMoreElements() && !endFound) {\n            String element = (String) tokenizer.nextElement();\n            int index = element.indexOf(\":\");\n            // Malformed vCard, so reset the field data and return without setting\n            // the VCardBean properties\n            if (index == -1) {\n                return;\n            }\n            if (index == element.length() - 1) {\n                continue;\n            }\n            String type = element.substring(0, index);\n            String data = element.substring(index + 1, element.length());\n            String subtype = \"\";\n            // Checks for subtypes\n            if ((index = type.indexOf(\";\")) != -1) {\n                if (index + 1 != type.length()) {\n                    subtype = type.substring(index + 1, type.length());\n                }\n                type = type.substring(0, index);\n            }\n            // Cleans up the strings\n            type = type.trim();\n            data = data.trim();\n            // Looks for the beginning of the vCard, which should be the first element\n            if (!beginFound) {\n                if (type.equalsIgnoreCase(\"begin\") && data.equalsIgnoreCase(\"vcard\")) {\n                    beginFound = true;\n                }\n                continue;\n            }\n            // Looks for the end element\n            if (type.equalsIgnoreCase(\"end\") && data.equalsIgnoreCase(\"vcard\")) {\n                endFound = true;\n                continue;\n            }\n            // FN type\n            if (type.equalsIgnoreCase(\"fn\")) {\n                FN = data;\n                continue;\n            }\n            // N type\n            if (type.equalsIgnoreCase(\"n\")) {\n                N = data;\n                continue;\n            }\n            // ORG type\n            if (type.equalsIgnoreCase(\"org\")) {\n                ORG = data;\n                continue;\n            }\n            // EMAIL type\n            if (type.equalsIgnoreCase(\"email\")) {\n                EMAIL = data;\n                continue;\n            }\n            // TEL type\n            if (type.equalsIgnoreCase(\"tel\")) {\n                if (\"type=fax\".equalsIgnoreCase(subtype)) {\n                    TEL_FAX = data;\n                } else {\n                    TEL = data;\n                }\n                continue;\n            }\n            // TITLE type\n            if (type.equalsIgnoreCase(\"title\")) {\n                TITLE = data;\n                continue;\n            }\n        }\n        // end loop\n        // Parses vCard into the seperate fields\n        // this doesn't take into account \\;'s which should be escaped, but\n        // this is only a partial implementation of vcard so for now we don't worry about it\n        if (N != null) {\n            String[] name = N.split(\";\");\n            if (name.length >= 3) {\n                vcb.setFirstName(name[2].trim());\n                vcb.setMiddleName(name[1].trim());\n                vcb.setLastName(name[0].trim());\n            }\n        }\n        if (null != FN) {\n            vcb.setFormattedName(FN.trim());\n        }\n        if (null != ORG) {\n            vcb.setOrganization(removeBackslashes(ORG.trim()));\n        }\n        if (null != EMAIL) {\n            vcb.setEmail(EMAIL.trim());\n        }\n        if (null != TITLE) {\n            vcb.setTitle(removeBackslashes(TITLE.trim()));\n        }\n        if (TEL != null) {\n            vcb.setPhone(TEL.trim());\n        }\n        if (null != TEL_FAX) {\n            vcb.setFax(TEL_FAX.trim());\n        }\n    }\n\n    /**\n     * Adds escape characters (backslashes) to characters with special meaning in vCard attributres.\n     *\n     * @param str\n     *\n     * @return The string with backslashes added before commas and semicolons.\n     */\n    private static String addBackslashes(String str) {\n        return str.replaceAll(\",\", \"\\\\,\").replaceAll(\";\", \"\\\\;\");\n    }\n\n    /**\n     * Removes escape characters (backslashes) from characters with special meaning in vCard attributes.\n     * Used when translating a vCard String\n     *\n     * @param str\n     *\n     * @return The String with backslashes removed from before commas and semicolons.\n     */\n    private static String removeBackslashes(String str) {\n        return str.replaceAll(\"\\\\,\", \",\").replaceAll(\"\\\\;\", \";\");\n    }\n\n    public boolean isValidVCard() {\n        return (null == vCard ? false : vCard.toLowerCase().startsWith(\"begin:vcard\"));\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/VCardBeanTest.java",
		"test_prompt": "// VCardBeanTest.java\npackage org.heal.util;\n\nimport java.io.Serializable;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VCardBean}.\n* It contains ten unit test cases for the {@link VCardBean#isValidVCard()} method.\n*/\nclass VCardBeanTest {"
	},
	{
		"original_code": "// InterfaceUtilitiesBean.java\npackage org.heal.util;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.module.metadata.*;\nimport org.heal.module.user.*;\nimport java.sql.SQLException;\n\n/**\n * The creation of this class is intended to remove much of the java\n * code from the JSP pages by providing methods to get such things as\n * thumbnail images, etc.  This should be created in the controller\n * servlet and then exposed to the application as\n * \"interfaceUtilitiesBean\" in the application scope.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class InterfaceUtilitiesBean implements Serializable {\n\n    private HashMap thumbnailMap = new HashMap();\n\n    private ThumbnailBean unknownThumbnail;\n\n    private FileLocator fileLocator = null;\n\n    public void init(FileLocator locator) {\n        fileLocator = locator;\n        ThumbnailBean thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_animation.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"animation\", thumbnail);\n        thumbnailMap.put(\"application/x-shockwave-flash\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_audio.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"audio\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_website.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"web page\", thumbnail);\n        thumbnailMap.put(\"text/html\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_presentation.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"presentation\", thumbnail);\n        thumbnailMap.put(\"application/vnd.ms-powerpoint\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_video.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"video\", thumbnail);\n        thumbnailMap.put(\"video/quicktime\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_photograph.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"image\", thumbnail);\n        thumbnailMap.put(\"image/jpg\", thumbnail);\n        thumbnailMap.put(\"image/png\", thumbnail);\n        thumbnailMap.put(\"image/gif\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_portableDoc.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"portable document\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_other.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"unknown\", thumbnail);\n        unknownThumbnail = thumbnail;\n    }\n\n    /**\n     * Takes the ThumbnailBean and checks it out or replaces it.\n     * If there is a thumbnail specified,\n     * then the method cleans the settings (changing nulls\n     * to \"\") so that the output can be put directly into\n     * an HTML page.  If there is no thumbnail setting, the\n     * format is used to lookup a generic thumbnail.  If\n     * no generic matches the format, a generic 'unknown'\n     * thumbnail is used.  All generic thumbnails are stored\n     * in the images directory in the base of the heal\n     * application heirarchy.  The second parameter should be\n     * used to specify the relative path from the web page\n     * being displayed to the application base.  For instance:\n     * search/searchresults.jsp would pass \"../\" or \"..\"\n     * The trailing slash is optional as the method will check\n     * for it before appending the path.\n     * NOTE: THIS METHOD RETURNS THE FULL URL TO ACCESS THE\n     * THUMBNAIL FOR THIS CONTENT\n     */\n    public ThumbnailBean getThumbnail(ThumbnailBean thumbnail, String format, String pathToAppBase) {\n        //added temp - JV\n        ThumbnailBean temp = new ThumbnailBean();\n        if (thumbnail == null) {\n            if (format != null) {\n                thumbnail = (ThumbnailBean) thumbnailMap.get(format.toLowerCase());\n            }\n            if (thumbnail == null) {\n                thumbnail = unknownThumbnail;\n            }\n            if (thumbnail != null && pathToAppBase != null) {\n                //WE ARE GOING TO MODIFY THE LOCATION, SO\n                //WE NEED TO CLONE THE THUMBNAIL...\n                //thumbnail = (ThumbnailBean) thumbnail.clone();\n                temp = (ThumbnailBean) thumbnail.clone();\n                String newLoc;\n                if (!pathToAppBase.endsWith(\"/\")) {\n                    newLoc = pathToAppBase + \"/\" + thumbnail.getLocation();\n                } else {\n                    newLoc = pathToAppBase + thumbnail.getLocation();\n                }\n                temp.setLocation(newLoc);\n            }\n        } else {\n            //sanitize the string values\n            if (thumbnail.getLocation() == null) {\n                thumbnail.setLocation(\"\");\n            } else {\n                //copied thumbnail into temp because we are rewriting location field - JV\n                //previously thumbnail location kept growing every time reload was pressed - JV\n                //This happened because we are appending http://baseurl to location everytime - JV\n                temp = (ThumbnailBean) thumbnail.clone();\n                temp.setLocation(fileLocator.getThumbnailURL(thumbnail.getLocation()));\n            }\n            if (thumbnail.getFileWidth() == null) {\n                temp.setFileWidth(\"\");\n            }\n            if (thumbnail.getFileHeight() == null) {\n                temp.setFileHeight(\"\");\n            }\n        }\n        return temp;\n    }\n\n    /**\n     * Given a string and a maximum number of characters\n     * to display.  If the provided string's length is\n     * greater than the maximum to display, it will be\n     * abbreviated to the maximum and have an ellipsis\n     * tagged onto the end.  The ellipsis will not count\n     * against the maximum number of characters to\n     * display.  For instance:\n     * getAbbreviatedString(\"dimple\",3) would return\n     * a new String - \"dim...\"\n     * If the passed String is null, \"\" is returned.\n     * Otherwise, if the whole original String would\n     * fit, it is simply returned back to the caller.\n     * Finally, if the maxCharsToDisplay is <=0, only\n     * the ellipsis is returned.\n     */\n    public String getAbbreviatedString(String aString, int maxCharsToDisplay) {\n        String returnValue;\n        int length;\n        if (aString == null) {\n            returnValue = \"\";\n        } else if (maxCharsToDisplay <= 0) {\n            returnValue = \"...\";\n        } else if ((aString.length()) > maxCharsToDisplay) {\n            returnValue = aString.substring(0, maxCharsToDisplay) + \"...\";\n        } else {\n            returnValue = aString;\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the user's name in a manner useful for display to the\n     * user.  In this case it is:\"lastname, firstname middleinitial\".\n     * If no name is found, an empty string is returned.\n     */\n    public String getUserDisplayName(String userId, UserRegistryBean registry) throws SQLException {\n        if (userId == null || userId.trim().length() <= 0 || registry == null) {\n            return \"\";\n        }\n        UserBean user = null;\n        user = registry.getUserFromID(userId);\n        if (user != null) {\n            String first = convertNullToEmptyString(user.getFirstName());\n            String last = convertNullToEmptyString(user.getLastName());\n            String middle = convertNullToEmptyString(user.getMiddleInitial());\n            String result = last + \", \" + first + \" \" + middle;\n            return result;\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * If the provided string is null, then \"\" is returned (empty string)\n     * otherwise, the original string is returned.\n     */\n    public String convertNullToEmptyString(String aString) {\n        if (aString == null) {\n            return \"\";\n        } else {\n            return aString;\n        }\n    }\n\n    /**\n     * if bool is true, \"yes\" is returned - otherwise \"no\" is returned\n     */\n    public String booleanToYesNo(boolean bool) {\n        if (bool) {\n            return \"yes\";\n        }\n        return \"no\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/InterfaceUtilitiesBeanTest0.java",
		"test_prompt": "// InterfaceUtilitiesBeanTest0.java\npackage org.heal.util;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.module.metadata.*;\nimport org.heal.module.user.*;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InterfaceUtilitiesBean}.\n* It contains ten unit test cases for the {@link InterfaceUtilitiesBean#convertNullToEmptyString(String)} method.\n*/\nclass InterfaceUtilitiesBeanTest0 {"
	},
	{
		"original_code": "// InterfaceUtilitiesBean.java\npackage org.heal.util;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.module.metadata.*;\nimport org.heal.module.user.*;\nimport java.sql.SQLException;\n\n/**\n * The creation of this class is intended to remove much of the java\n * code from the JSP pages by providing methods to get such things as\n * thumbnail images, etc.  This should be created in the controller\n * servlet and then exposed to the application as\n * \"interfaceUtilitiesBean\" in the application scope.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class InterfaceUtilitiesBean implements Serializable {\n\n    private HashMap thumbnailMap = new HashMap();\n\n    private ThumbnailBean unknownThumbnail;\n\n    private FileLocator fileLocator = null;\n\n    public void init(FileLocator locator) {\n        fileLocator = locator;\n        ThumbnailBean thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_animation.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"animation\", thumbnail);\n        thumbnailMap.put(\"application/x-shockwave-flash\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_audio.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"audio\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_website.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"web page\", thumbnail);\n        thumbnailMap.put(\"text/html\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_presentation.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"presentation\", thumbnail);\n        thumbnailMap.put(\"application/vnd.ms-powerpoint\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_video.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"video\", thumbnail);\n        thumbnailMap.put(\"video/quicktime\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_photograph.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"image\", thumbnail);\n        thumbnailMap.put(\"image/jpg\", thumbnail);\n        thumbnailMap.put(\"image/png\", thumbnail);\n        thumbnailMap.put(\"image/gif\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_portableDoc.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"portable document\", thumbnail);\n        thumbnail = new ThumbnailBean();\n        //impossible database value\n        thumbnail.setThumbnailId(\"\");\n        //impossible database value\n        thumbnail.setMetadataId(\"\");\n        thumbnail.setLocation(\"images/thumbnails/thb_other.jpg\");\n        thumbnail.setFileWidth(\"80\");\n        thumbnail.setFileHeight(\"86\");\n        thumbnailMap.put(\"unknown\", thumbnail);\n        unknownThumbnail = thumbnail;\n    }\n\n    /**\n     * Takes the ThumbnailBean and checks it out or replaces it.\n     * If there is a thumbnail specified,\n     * then the method cleans the settings (changing nulls\n     * to \"\") so that the output can be put directly into\n     * an HTML page.  If there is no thumbnail setting, the\n     * format is used to lookup a generic thumbnail.  If\n     * no generic matches the format, a generic 'unknown'\n     * thumbnail is used.  All generic thumbnails are stored\n     * in the images directory in the base of the heal\n     * application heirarchy.  The second parameter should be\n     * used to specify the relative path from the web page\n     * being displayed to the application base.  For instance:\n     * search/searchresults.jsp would pass \"../\" or \"..\"\n     * The trailing slash is optional as the method will check\n     * for it before appending the path.\n     * NOTE: THIS METHOD RETURNS THE FULL URL TO ACCESS THE\n     * THUMBNAIL FOR THIS CONTENT\n     */\n    public ThumbnailBean getThumbnail(ThumbnailBean thumbnail, String format, String pathToAppBase) {\n        //added temp - JV\n        ThumbnailBean temp = new ThumbnailBean();\n        if (thumbnail == null) {\n            if (format != null) {\n                thumbnail = (ThumbnailBean) thumbnailMap.get(format.toLowerCase());\n            }\n            if (thumbnail == null) {\n                thumbnail = unknownThumbnail;\n            }\n            if (thumbnail != null && pathToAppBase != null) {\n                //WE ARE GOING TO MODIFY THE LOCATION, SO\n                //WE NEED TO CLONE THE THUMBNAIL...\n                //thumbnail = (ThumbnailBean) thumbnail.clone();\n                temp = (ThumbnailBean) thumbnail.clone();\n                String newLoc;\n                if (!pathToAppBase.endsWith(\"/\")) {\n                    newLoc = pathToAppBase + \"/\" + thumbnail.getLocation();\n                } else {\n                    newLoc = pathToAppBase + thumbnail.getLocation();\n                }\n                temp.setLocation(newLoc);\n            }\n        } else {\n            //sanitize the string values\n            if (thumbnail.getLocation() == null) {\n                thumbnail.setLocation(\"\");\n            } else {\n                //copied thumbnail into temp because we are rewriting location field - JV\n                //previously thumbnail location kept growing every time reload was pressed - JV\n                //This happened because we are appending http://baseurl to location everytime - JV\n                temp = (ThumbnailBean) thumbnail.clone();\n                temp.setLocation(fileLocator.getThumbnailURL(thumbnail.getLocation()));\n            }\n            if (thumbnail.getFileWidth() == null) {\n                temp.setFileWidth(\"\");\n            }\n            if (thumbnail.getFileHeight() == null) {\n                temp.setFileHeight(\"\");\n            }\n        }\n        return temp;\n    }\n\n    /**\n     * Given a string and a maximum number of characters\n     * to display.  If the provided string's length is\n     * greater than the maximum to display, it will be\n     * abbreviated to the maximum and have an ellipsis\n     * tagged onto the end.  The ellipsis will not count\n     * against the maximum number of characters to\n     * display.  For instance:\n     * getAbbreviatedString(\"dimple\",3) would return\n     * a new String - \"dim...\"\n     * If the passed String is null, \"\" is returned.\n     * Otherwise, if the whole original String would\n     * fit, it is simply returned back to the caller.\n     * Finally, if the maxCharsToDisplay is <=0, only\n     * the ellipsis is returned.\n     */\n    public String getAbbreviatedString(String aString, int maxCharsToDisplay) {\n        String returnValue;\n        int length;\n        if (aString == null) {\n            returnValue = \"\";\n        } else if (maxCharsToDisplay <= 0) {\n            returnValue = \"...\";\n        } else if ((aString.length()) > maxCharsToDisplay) {\n            returnValue = aString.substring(0, maxCharsToDisplay) + \"...\";\n        } else {\n            returnValue = aString;\n        }\n        return returnValue;\n    }\n\n    /**\n     * Returns the user's name in a manner useful for display to the\n     * user.  In this case it is:\"lastname, firstname middleinitial\".\n     * If no name is found, an empty string is returned.\n     */\n    public String getUserDisplayName(String userId, UserRegistryBean registry) throws SQLException {\n        if (userId == null || userId.trim().length() <= 0 || registry == null) {\n            return \"\";\n        }\n        UserBean user = null;\n        user = registry.getUserFromID(userId);\n        if (user != null) {\n            String first = convertNullToEmptyString(user.getFirstName());\n            String last = convertNullToEmptyString(user.getLastName());\n            String middle = convertNullToEmptyString(user.getMiddleInitial());\n            String result = last + \", \" + first + \" \" + middle;\n            return result;\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * If the provided string is null, then \"\" is returned (empty string)\n     * otherwise, the original string is returned.\n     */\n    public String convertNullToEmptyString(String aString) {\n        if (aString == null) {\n            return \"\";\n        } else {\n            return aString;\n        }\n    }\n\n    /**\n     * if bool is true, \"yes\" is returned - otherwise \"no\" is returned\n     */\n    public String booleanToYesNo(boolean bool) {\n        if (bool) {\n            return \"yes\";\n        }\n        return \"no\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/InterfaceUtilitiesBeanTest1.java",
		"test_prompt": "// InterfaceUtilitiesBeanTest1.java\npackage org.heal.util;\n\nimport java.io.*;\nimport java.util.*;\nimport org.heal.module.metadata.*;\nimport org.heal.module.user.*;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InterfaceUtilitiesBean}.\n* It contains ten unit test cases for the {@link InterfaceUtilitiesBean#booleanToYesNo(boolean)} method.\n*/\nclass InterfaceUtilitiesBeanTest1 {"
	},
	{
		"original_code": "// ParameterMap.java\npackage org.heal.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\n\n/**\n * Convenience class for manipulating a ServletRequest.getParameterMap()\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class ParameterMap extends HashMap {\n\n    public ParameterMap() {\n        super();\n    }\n\n    public ParameterMap(Map map) {\n        super(map);\n    }\n\n    /**\n     * Initializes a ParameterMap with keys/values parsed from a\n     * query string.<br/><br/>\n     *\n     * For example, given the URL\n     * <code>\"http://www.healcentral.org/healapp/searchResults?searchtype=simple&keywords=foo&page=1\"</code>\n     * the query string would be <code>\"searchtype=simple&keywords=foo&page=1\"</code>.<br/><br/>\n     *\n     * The preferred constructor is ParameterMap(java.util.Map), but this is provided for\n     * cases where an initial map is not available, but a query string is.\n     *\n     * @param queryString A String representation of a ParameterMap.\n     */\n    public ParameterMap(String queryString) {\n        StringTokenizer pairs = new StringTokenizer(queryString, \"&\");\n        while (pairs.hasMoreTokens()) {\n            String pair = pairs.nextToken();\n            int equalIndex = pair.indexOf(\"=\");\n            // Don't go any further for this pair if a '=' cannot be found\n            if (-1 == equalIndex) {\n                continue;\n            }\n            String key = pair.substring(0, equalIndex);\n            String value;\n            if ((equalIndex + 1) < pair.length()) {\n                value = pair.substring((equalIndex + 1), pair.length());\n            } else {\n                value = \"\";\n            }\n            String[] paramValue;\n            if (!containsKey(key)) {\n                paramValue = new String[1];\n                paramValue[0] = value;\n            } else {\n                // copies the old array into a new array which is one\n                // element larger\n                String[] temp = (String[]) get(key);\n                paramValue = new String[temp.length + 1];\n                for (int i = 0; i < temp.length; ++i) {\n                    paramValue[i] = temp[i];\n                }\n                paramValue[temp.length] = value;\n            }\n            put(key, paramValue);\n        }\n    }\n\n    /**\n     * @param key\n     * @param value\n     * @return\n     * @throws IllegalArgumentException Thrown when a key is not a String, or a value is\n     *      not a String[].\n     */\n    public Object put(Object key, Object value) {\n        if (!(value instanceof String[])) {\n            throw new IllegalArgumentException(\"Cannot put a non-String[] value into a ParameterMap\");\n        }\n        if (!(key instanceof String)) {\n            throw new IllegalArgumentException(\"Cannot put a non-String key into a ParameterMap\");\n        }\n        return super.put(key, value);\n    }\n\n    /**\n     * Over-ridden method to correctly put a single String value\n     * into the parameter map as a String[] (since that's how\n     * parameters need to be stored).\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public Object put(String key, String value) {\n        String[] temp = { value };\n        return super.put(key, temp);\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer();\n        Iterator iter = entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry pair = (Map.Entry) iter.next();\n            String[] values = (String[]) pair.getValue();\n            for (int i = 0; i < values.length; ++i) {\n                ret.append((String) pair.getKey()).append(\"=\").append(values[i]);\n                if (iter.hasNext() || (i + 1) < values.length) {\n                    // only adds a & if there are more parameters to add\n                    ret.append(\"&\");\n                }\n            }\n        }\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/ParameterMapTest0.java",
		"test_prompt": "// ParameterMapTest0.java\npackage org.heal.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterMap}.\n* It contains ten unit test cases for the {@link ParameterMap#put(Object, Object)} method.\n*/\nclass ParameterMapTest0 {"
	},
	{
		"original_code": "// ParameterMap.java\npackage org.heal.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\n\n/**\n * Convenience class for manipulating a ServletRequest.getParameterMap()\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class ParameterMap extends HashMap {\n\n    public ParameterMap() {\n        super();\n    }\n\n    public ParameterMap(Map map) {\n        super(map);\n    }\n\n    /**\n     * Initializes a ParameterMap with keys/values parsed from a\n     * query string.<br/><br/>\n     *\n     * For example, given the URL\n     * <code>\"http://www.healcentral.org/healapp/searchResults?searchtype=simple&keywords=foo&page=1\"</code>\n     * the query string would be <code>\"searchtype=simple&keywords=foo&page=1\"</code>.<br/><br/>\n     *\n     * The preferred constructor is ParameterMap(java.util.Map), but this is provided for\n     * cases where an initial map is not available, but a query string is.\n     *\n     * @param queryString A String representation of a ParameterMap.\n     */\n    public ParameterMap(String queryString) {\n        StringTokenizer pairs = new StringTokenizer(queryString, \"&\");\n        while (pairs.hasMoreTokens()) {\n            String pair = pairs.nextToken();\n            int equalIndex = pair.indexOf(\"=\");\n            // Don't go any further for this pair if a '=' cannot be found\n            if (-1 == equalIndex) {\n                continue;\n            }\n            String key = pair.substring(0, equalIndex);\n            String value;\n            if ((equalIndex + 1) < pair.length()) {\n                value = pair.substring((equalIndex + 1), pair.length());\n            } else {\n                value = \"\";\n            }\n            String[] paramValue;\n            if (!containsKey(key)) {\n                paramValue = new String[1];\n                paramValue[0] = value;\n            } else {\n                // copies the old array into a new array which is one\n                // element larger\n                String[] temp = (String[]) get(key);\n                paramValue = new String[temp.length + 1];\n                for (int i = 0; i < temp.length; ++i) {\n                    paramValue[i] = temp[i];\n                }\n                paramValue[temp.length] = value;\n            }\n            put(key, paramValue);\n        }\n    }\n\n    /**\n     * @param key\n     * @param value\n     * @return\n     * @throws IllegalArgumentException Thrown when a key is not a String, or a value is\n     *      not a String[].\n     */\n    public Object put(Object key, Object value) {\n        if (!(value instanceof String[])) {\n            throw new IllegalArgumentException(\"Cannot put a non-String[] value into a ParameterMap\");\n        }\n        if (!(key instanceof String)) {\n            throw new IllegalArgumentException(\"Cannot put a non-String key into a ParameterMap\");\n        }\n        return super.put(key, value);\n    }\n\n    /**\n     * Over-ridden method to correctly put a single String value\n     * into the parameter map as a String[] (since that's how\n     * parameters need to be stored).\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public Object put(String key, String value) {\n        String[] temp = { value };\n        return super.put(key, temp);\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer();\n        Iterator iter = entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry pair = (Map.Entry) iter.next();\n            String[] values = (String[]) pair.getValue();\n            for (int i = 0; i < values.length; ++i) {\n                ret.append((String) pair.getKey()).append(\"=\").append(values[i]);\n                if (iter.hasNext() || (i + 1) < values.length) {\n                    // only adds a & if there are more parameters to add\n                    ret.append(\"&\");\n                }\n            }\n        }\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/ParameterMapTest1.java",
		"test_prompt": "// ParameterMapTest1.java\npackage org.heal.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterMap}.\n* It contains ten unit test cases for the {@link ParameterMap#put(String, String)} method.\n*/\nclass ParameterMapTest1 {"
	},
	{
		"original_code": "// FileLocator.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\n\n/**\n * This class translates URLs to file system paths and vice versa.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class FileLocator implements Serializable {\n\n    public static final String DEFAULT_UPLOAD_DIRECTORY = \"upload\";\n\n    public static final String DEFAULT_THUMBNAIL_DIRECTORY = \"thumbnails\";\n\n    public static final String DEFAULT_CONTENT_DIRECTORY = \"content\";\n\n    public static final String DEFAULT_PACKAGE_DIRECTORY = \"package\";\n\n    private String uploadDirectory = DEFAULT_UPLOAD_DIRECTORY;\n\n    private File uploadDirectoryFile = null;\n\n    private String uploadFilePath = null;\n\n    private String uploadURL = null;\n\n    private String serverBaseURL = null;\n\n    private int serverBaseURLLength = -1;\n\n    private String contentDirectory = DEFAULT_CONTENT_DIRECTORY;\n\n    private File contentDirectoryFile = null;\n\n    private String contentFilePath = null;\n\n    private String contentURL = null;\n\n    private String baseFilePath = null;\n\n    private int baseFilePathLength = -1;\n\n    private String packageDirectory = DEFAULT_PACKAGE_DIRECTORY;\n\n    private File packageDirectoryFile = null;\n\n    private String packageFilePath = null;\n\n    private String packageURL = null;\n\n    private String thumbnailDirectory = DEFAULT_THUMBNAIL_DIRECTORY;\n\n    private File thumbnailDirectoryFile = null;\n\n    private String thumbnailFilePath = null;\n\n    private String thumbnailURL = null;\n\n    //512 Megabytes\n    private long maxUploadSize = 512 * 1024 * 1024;\n\n    /**\n     * Returns the maximum size allowed for uploaded files.\n     * This value is in bytes.\n     */\n    public long getMaxUploadSize() {\n        return maxUploadSize;\n    }\n\n    /**\n     * Sets the maximum size allowed for uploaded files.\n     * This value is in bytes.\n     */\n    public void setMaxUploadSize(long newMaxUploadSize) {\n        maxUploadSize = newMaxUploadSize;\n    }\n\n    /**\n     * Returns the upload directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the upload directory.  The URL for the upload\n     * directory will then be: http://<baseURL>/<uploadDirectory>/\n     * and the path to the upload directory will reside at:\n     * <baseFilePath>/<uploadDirectory>/\n     */\n    public String getUploadDirectory() {\n        return uploadDirectory;\n    }\n\n    /**\n     * Determines the directory to store content below the base directory\n     * used in the various sections of the application (i.e. content or upload)\n     * This plus the filename should be used to create the location setting\n     * in the Metadata table.\n     * The directory is created by combining information from the given\n     * user with the given format (i.e. illustration/photograph)\n     * The returned directory is of the format:\n     * <user id>/<contentFormat>\n     * If user is null, or contentformat is null (or empty), returns null.\n     */\n    public String getLocationDirectory(UserBean user, String contentFormat) {\n        if (user == null || contentFormat == null || contentFormat.length() < 1) {\n            return null;\n        }\n        return user.getUserId() + File.separator + contentFormat;\n    }\n\n    /**\n     * Returns the thumbnail directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the thumbnail directory.  The URL for the thumbnail\n     * directory will then be: http://<baseURL>/<thumbnailDirectory>/\n     * and the path to the thumbnail directory will reside at:\n     * <baseFilePath>/<thumbnailDirectory>/\n     */\n    public String getThumbnailDirectory() {\n        return thumbnailDirectory;\n    }\n\n    /**\n     * Returns the server base URL property setting.\n     * This is the base url on the server where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This baseurl + the upload directory should point to the\n     * upload directory in the webserver.\n     */\n    public String getServerBaseURL() {\n        return serverBaseURL;\n    }\n\n    /**\n     * Returns the base file path property setting.\n     * This is the base directory on the filesystem where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This filepath + the upload directory should point to the\n     * upload directory in the filesystem.\n     */\n    public String getBaseFilePath() {\n        return baseFilePath;\n    }\n\n    /**\n     * Returns the content directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the content directory.  The URL for the content\n     * directory will then be: http://<baseURL>/<contentDirectory>/\n     * and the path to the content directory will reside at:\n     * <baseFilePath>/<contentDirectory>/\n     */\n    public String getContentDirectory() {\n        return contentDirectory;\n    }\n\n    /**\n     * Returns the package directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the package directory.  The URL for the package\n     * directory will then be: http://<baseURL>/<packageDirectory>/\n     * and the path to the package directory will reside at:\n     * <baseFilePath>/<packageDirectory>/\n     */\n    public String getPackageDirectory() {\n        return packageDirectory;\n    }\n\n    /**\n     * Sets the thumbnail directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the thumbnail directory.  The URL for the thumbnail\n     * directory will then be: http://<baseURL>/<thumbnailDirectory>/\n     * and the path to the thumbnail directory will reside at:\n     * <baseFilePath>/<thumbnailDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setThumbnailDirectory(String newThumbnail) {\n        thumbnailDirectory = newThumbnail;\n    }\n\n    /**\n     * Sets the upload directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the upload directory.  The URL for the upload\n     * directory will then be: http://<baseURL>/<uploadDirectory>/\n     * and the path to the upload directory will reside at:\n     * <baseFilePath>/<uploadDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setUploadDirectory(String newUpload) {\n        uploadDirectory = newUpload;\n    }\n\n    /**\n     * Sets the server base URL property setting.\n     * This is the base url on the server where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This baseurl + the upload directory should point to the\n     * upload directory in the webserver.\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setServerBaseURL(String newBaseURL) {\n        serverBaseURL = newBaseURL;\n        if (serverBaseURL != null) {\n            serverBaseURLLength = serverBaseURL.length();\n        } else {\n            serverBaseURLLength = -1;\n        }\n    }\n\n    /**\n     * Sets the base file path property setting.\n     * This is the base directory on the filesystem where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This filepath + the upload directory should point to the\n     * upload directory in the filesystem.\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setBaseFilePath(String newFilePath) {\n        baseFilePath = newFilePath;\n        if (baseFilePath != null) {\n            baseFilePathLength = baseFilePath.length();\n        } else {\n            baseFilePathLength = -1;\n        }\n    }\n\n    /**\n     * Sets the content directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the content directory.  The URL for the content\n     * directory will then be: http://<baseURL>/<contentDirectory>/\n     * and the path to the content directory will reside at:\n     * <baseFilePath>/<contentDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setContentDirectory(String newContentDirectory) {\n        contentDirectory = newContentDirectory;\n    }\n\n    /**\n     * Sets the package directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the package directory.  The URL for the package\n     * directory will then be: http://<baseURL>/<packageDirectory>/\n     * and the path to the package directory will reside at:\n     * <baseFilePath>/<packageDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setPackageDirectory(String newPackage) {\n        packageDirectory = newPackage;\n    }\n\n    /**\n     * Given a URL, calculates the file system path to use to access\n     * the file.  The calculation is made using the base URL and\n     * base file path properties.\n     */\n    public String getFilePathFromURL(String url) {\n        if (url == null) {\n            return null;\n        }\n        int index;\n        String temp, postfix;\n        String result = null;\n        index = url.indexOf(serverBaseURL);\n        if (index != -1) {\n            postfix = url.substring(index + serverBaseURLLength);\n            temp = baseFilePath + File.separator + postfix;\n            result = temp.replace('/', File.separatorChar);\n        }\n        return result;\n    }\n\n    /**\n     * Given a file path, calculates the url to use to access\n     * the file via the web server.  The calculation is made using the\n     * base URL and base file path properties.\n     */\n    public String getURLFromFilePath(String path) {\n        if (path == null) {\n            return null;\n        }\n        int index;\n        String temp, postfix;\n        String result = null;\n        index = path.indexOf(baseFilePath);\n        if (index != -1) {\n            postfix = path.substring(index + baseFilePathLength);\n            temp = serverBaseURL + File.separator + postfix;\n            result = temp.replace(File.separatorChar, '/');\n        }\n        return result;\n    }\n\n    /**\n     * Generates the content filepath and url and the upload filepath and url\n     * properties.  This method is called whenever the contentDirectory\n     * uploadDirectory, baseFilePath, or serverBaseURL properties are changed.\n     * This method should be called once all of the settings have been made\n     * and the FileLocator is ready for use.\n     */\n    public void generateFullDirectories() {\n        if (baseFilePath != null) {\n            if (contentDirectory != null) {\n                contentFilePath = baseFilePath + File.separator + contentDirectory;\n                contentDirectoryFile = new File(contentFilePath);\n                if (!contentDirectoryFile.exists()) {\n                    contentDirectoryFile.mkdirs();\n                }\n            }\n            if (uploadDirectory != null) {\n                uploadFilePath = baseFilePath + File.separator + uploadDirectory;\n                uploadDirectoryFile = new File(uploadFilePath);\n                if (!uploadDirectoryFile.exists()) {\n                    uploadDirectoryFile.mkdirs();\n                }\n            }\n            if (thumbnailDirectory != null) {\n                thumbnailFilePath = baseFilePath + File.separator + thumbnailDirectory;\n                thumbnailDirectoryFile = new File(thumbnailFilePath);\n                if (!thumbnailDirectoryFile.exists()) {\n                    thumbnailDirectoryFile.mkdirs();\n                }\n            }\n            if (packageDirectory != null) {\n                packageFilePath = baseFilePath + File.separator + packageDirectory;\n                packageDirectoryFile = new File(packageFilePath);\n                if (!packageDirectoryFile.exists()) {\n                    packageDirectoryFile.mkdirs();\n                }\n            }\n        }\n        if (serverBaseURL != null) {\n            if (contentDirectory != null) {\n                contentURL = serverBaseURL + '/' + contentDirectory + '/';\n            }\n            if (uploadDirectory != null) {\n                uploadURL = serverBaseURL + '/' + uploadDirectory + '/';\n            }\n            if (thumbnailDirectory != null) {\n                thumbnailURL = serverBaseURL + '/' + thumbnailDirectory + '/';\n            }\n            if (packageDirectory != null) {\n                packageURL = serverBaseURL + '/' + packageDirectory + '/';\n            }\n        }\n    }\n\n    /**\n     * Returns the file path generated from the uploadDirectory and base\n     * file path properties.\n     */\n    public String getUploadFilePath() {\n        return uploadFilePath;\n    }\n\n    /**\n     * Returns the file path result of the package directory concatenated\n     * with the provided source location.\n     */\n    public String getUploadFilePath(String sourceLocation) {\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(uploadFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the upload directory concatenated\n     * with the provided source location.\n     */\n    public String getUploadURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http://\")) /*same mod as getContentURL*/\n        {\n            return sourceLocation;\n        } else {\n            return uploadURL + sourceLocation.replaceAll(\"\\\\\\\\\", \"/\");\n        }\n    }\n\n    /**\n     * Returns the url generated from the uploadDirectory and server base\n     * url properties.\n     */\n    public String getUploadURL() {\n        return uploadURL;\n    }\n\n    /**\n     * Returns the file path generated from the thumbnailDirectory and base\n     * file path properties.\n     */\n    public String getThumbnailFilePath() {\n        return thumbnailFilePath;\n    }\n\n    /**\n     * Returns the file path result of the thumbnail directory concatenated\n     * with the provided source location.\n     */\n    public String getThumbnailFilePath(String sourceLocation) {\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(thumbnailFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the thumbnail directory concatenated\n     * with the provided source location.\n     */\n    public String getThumbnailURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http:\")) {\n            return sourceLocation;\n        } else {\n            return thumbnailURL + sourceLocation;\n        }\n    }\n\n    /**\n     * Returns the url generated from the thumbnailDirectory and server base\n     * url properties.\n     */\n    public String getThumbnailURL() {\n        return thumbnailURL;\n    }\n\n    /**\n     * Returns the file path generated from the contentDirectory and base\n     * file path properties.\n     */\n    public String getContentFilePath() {\n        return contentFilePath;\n    }\n\n    /**\n     * Returns the file path result of the content directory concatenated\n     * with the provided source location.\n     */\n    public String getContentFilePath(String sourceLocation) {\n        if (sourceLocation.toLowerCase().startsWith(getContentURL().toLowerCase())) {\n            sourceLocation = sourceLocation.substring(getContentURL().length());\n        }\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(contentFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the content directory concatenated\n     * with the provided source location.\n     */\n    /* mod by JV for http:// starting items */\n    public String getContentURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http://\")) {\n            return sourceLocation;\n        } else {\n            return contentURL + sourceLocation;\n        }\n    }\n\n    /**\n     * Returns the url generated from the contentDirectory and server base\n     * url properties.\n     */\n    public String getContentURL() {\n        return contentURL;\n    }\n\n    /**\n     * Returns the file path generated from the packageDirectory and base\n     * file path properties.\n     */\n    public String getPackageFilePath() {\n        return packageFilePath;\n    }\n\n    /**\n     * Returns the directory storing packages.\n     */\n    public File getPackageDirectoryFile() {\n        return packageDirectoryFile;\n    }\n\n    /**\n     * Returns the url generated from the packageDirectory and server base\n     * url properties.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Returns a string consisting of only the path of a given location that\n     * falls below the preset content, package, and upload directories.  This\n     * method works for both URLs and file paths.  This method relies upon\n     * the base url, base file, content, package, and upload path settings.\n     * Given a base url of 'http://www.healcentral.org/'\n     * a file url of 'd:\\apache\\htdocs\\'\n     * a content path of 'content'\n     * a package path of 'package'\n     * and an upload path of 'upload'\n     * The following results will be given:\n     * getRelativePath(c:\\apache\\content\\brain\\picture.jpg) = brain\\picture.jpg\n     * getRelativePath(http://www.healcentral.org/content/brain/picture.jpg) =\n     * brain/picture.jpg\n     * <p/>\n     * The approach to determining the relative path is to look for first the\n     * content directory, then the upload directory, then the package\n     * directory to see if any of them appear in the location string\n     * (using the String.indexOf() method).\n     * <p/>\n     * If the parameter is null, or the content, upload, or package paths are\n     * not foud, then null is returned.\n     */\n    public String getRelativePath(String location) {\n        int index = -1;\n        char separator;\n        String result = null;\n        int locationLen;\n        if (location != null) {\n            locationLen = location.length();\n            //check each directory type\n            if ((contentDirectory != null && (index = location.indexOf(File.separator + contentDirectory + File.separator)) != -1)) {\n                //move the index to past the location of the directory\n                index += contentDirectory.length();\n            } else if ((uploadDirectory != null && (index = location.indexOf(File.separator + uploadDirectory + File.separator)) != -1)) {\n                index += uploadDirectory.length();\n            } else if ((thumbnailDirectory != null && (index = location.indexOf(File.separator + thumbnailDirectory + File.separator)) != -1)) {\n                index += thumbnailDirectory.length();\n            } else if ((packageDirectory != null && (index = location.indexOf(File.separator + packageDirectory + File.separator)) != -1)) {\n                index += packageDirectory.length();\n            }\n            /* if we found the location, see if we need to skip a\n             * file separator or URL separator\n             */\n            if (index != -1) {\n                separator = location.charAt(index);\n                if (separator == File.separatorChar || separator == '/') {\n                    //we found a separator, so skip over it\n                    index++;\n                }\n                //if the index isn't past the end, get the rest of the string\n                if (index < locationLen) {\n                    result = location.substring(index);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Moves the given file from the upload directory to the content\n     * directory.  There is no error checking for conflicts.\n     */\n    public boolean moveFromUploadToContent(String location) throws IOException {\n        boolean success = false;\n        String filepath = convertLocationToFilePath(location);\n        if (filepath != null) {\n            File from = new File(uploadFilePath, filepath);\n            if (from.exists()) {\n                File to = new File(contentFilePath, filepath);\n                success = from.renameTo(to);\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Just like the getRelativePath method, but replaces any occurences of\n     * '/' with File.separatorChar.\n     */\n    public String getRelativeFilePath(String location) {\n        String retval = getRelativePath(location);\n        if (retval != null) {\n            retval.replace('/', File.separatorChar);\n        }\n        return retval;\n    }\n\n    /**\n     * Just like the getRelativePath method, but replaces any occurences of\n     * File.separatorChar with '/'.\n     */\n    public String getRelativeURLPath(String location) {\n        String retval = getRelativePath(location);\n        if (retval != null) {\n            retval.replace(File.separatorChar, '/');\n        }\n        return retval;\n    }\n\n    /**\n     * Given a \"location\" setting (see the Location field of the\n     * Metadata table) it replaces all of the path separators to\n     * be those of the local operating system, allowing the\n     * application to get a path to the content file.\n     * example: location = \"2/Photograph/brain.jpg\", returns\n     * \"2\\Photograph\\brain.jpg\" on Windows,\n     * \"2/Photograph/brain.jpg\" on Solaris\n     * Returns null if the location parameter is null.\n     */\n    public String convertLocationToFilePath(String location) {\n        if (location == null) {\n            return null;\n        }\n        String retval = new String(location);\n        return retval.replace('/', File.separatorChar);\n    }\n\n    /**\n     * Given a file path setting it replaces all of the path\n     * separators to be '/' as is standardized in the\n     * Location field of the Metadata table in the database.\n     * The path field should contain the local operating systems\n     * File.separatorChar as the separator between directories.\n     * This method should only be used for relative file paths\n     * of the format below, and the path shouldn't contain\n     * the upload, content, package, or thumbnail directories,\n     * but rather the relative path below those.\n     * <p/>\n     * example: (Windows)path = \"2\\Photograph\\brain.jpg\", or\n     * \"2/Photograph/brain.jpg\" on Solaris\n     * returns\n     * \"2/Photograph/brain.jpg\"\n     * Returns null if the filepath parameter is null.\n     */\n    public String convertFilePathToLocation(String location) {\n        if (location == null) {\n            return null;\n        }\n        String retval = new String(location);\n        return retval.replace(File.separatorChar, '/');\n    }\n\n    /**\n     * Given a location directory (i.e. one generated via the\n     * getLocationDirectory method), checks all possible places a file by\n     * the name of locationdirectory/name could be.  If a redundancy is\n     * detected, it will separate the filename and extension information\n     * in name and begin adding numbers to the name until no redundancy is\n     * found.  For example, if location directory is \"1/audio\" and the name\n     * is \"sound.avi\" and the file <uploaddir>/1/audio/sound.avi is found or\n     * the file <contentdir>/1/audio/sound.avi is found, then the method will\n     * try against <uploaddir>/1/audio/sound1.avi and\n     * <contentdir>/1/audio/sound1.avi, sound2.avi, sound3.avi, etc. until no\n     * conflict is found.  When no conflict is found the returned String\n     * will be of the form: 1/audio/sound4.avi\n     * <p/>\n     * Checks files in both the upload and content directories.\n     * Also creates the parent directory of the file if it does not exist.\n     */\n    public String getUniqueFileLocation(String locationDirectory, String name) {\n        String filePath = locationDirectory + File.separator + name;\n        //try quick and dirty first...\n        File uploadFile = new File(uploadFilePath, filePath);\n        if (!uploadFile.exists()) {\n            File contentFile = new File(contentFilePath, filePath);\n            if (!contentFile.exists()) {\n                File uploadParent = uploadFile.getParentFile();\n                if (!uploadParent.exists()) {\n                    uploadParent.mkdirs();\n                }\n                File contentParent = contentFile.getParentFile();\n                if (!contentParent.exists()) {\n                    contentParent.mkdirs();\n                }\n                return filePath;\n            }\n        }\n        //if we get here, one of the files existed\n        //if we have a redundancy, start at 2(e.g. brain2.jpg)\n        int counter = 2;\n        int extensionIndex = name.lastIndexOf('.');\n        //extension will contain the period also: e.g. \".jpg\"\n        String extension = \"\";\n        String fileName = name;\n        if (extensionIndex > 0) {\n            extension = name.substring(extensionIndex);\n            fileName = name.substring(0, extensionIndex);\n        }\n        while (true) {\n            filePath = locationDirectory + File.separator + fileName + counter + extension;\n            uploadFile = new File(uploadFilePath, filePath);\n            if (!uploadFile.exists()) {\n                File contentFile = new File(contentFilePath, filePath);\n                if (!contentFile.exists()) {\n                    File uploadParent = uploadFile.getParentFile();\n                    if (!uploadParent.exists()) {\n                        uploadParent.mkdirs();\n                    }\n                    File contentParent = contentFile.getParentFile();\n                    if (!contentParent.exists()) {\n                        contentParent.mkdirs();\n                    }\n                    return filePath;\n                }\n            }\n            //if we get here we had a collision, so we increment the counter.\n            counter++;\n        }\n    }\n\n    public void createParentDir(String filepath) {\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/FileLocatorTest0.java",
		"test_prompt": "// FileLocatorTest0.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileLocator}.\n* It contains ten unit test cases for the {@link FileLocator#moveFromUploadToContent(String)} method.\n*/\nclass FileLocatorTest0 {"
	},
	{
		"original_code": "// FileLocator.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\n\n/**\n * This class translates URLs to file system paths and vice versa.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class FileLocator implements Serializable {\n\n    public static final String DEFAULT_UPLOAD_DIRECTORY = \"upload\";\n\n    public static final String DEFAULT_THUMBNAIL_DIRECTORY = \"thumbnails\";\n\n    public static final String DEFAULT_CONTENT_DIRECTORY = \"content\";\n\n    public static final String DEFAULT_PACKAGE_DIRECTORY = \"package\";\n\n    private String uploadDirectory = DEFAULT_UPLOAD_DIRECTORY;\n\n    private File uploadDirectoryFile = null;\n\n    private String uploadFilePath = null;\n\n    private String uploadURL = null;\n\n    private String serverBaseURL = null;\n\n    private int serverBaseURLLength = -1;\n\n    private String contentDirectory = DEFAULT_CONTENT_DIRECTORY;\n\n    private File contentDirectoryFile = null;\n\n    private String contentFilePath = null;\n\n    private String contentURL = null;\n\n    private String baseFilePath = null;\n\n    private int baseFilePathLength = -1;\n\n    private String packageDirectory = DEFAULT_PACKAGE_DIRECTORY;\n\n    private File packageDirectoryFile = null;\n\n    private String packageFilePath = null;\n\n    private String packageURL = null;\n\n    private String thumbnailDirectory = DEFAULT_THUMBNAIL_DIRECTORY;\n\n    private File thumbnailDirectoryFile = null;\n\n    private String thumbnailFilePath = null;\n\n    private String thumbnailURL = null;\n\n    //512 Megabytes\n    private long maxUploadSize = 512 * 1024 * 1024;\n\n    /**\n     * Returns the maximum size allowed for uploaded files.\n     * This value is in bytes.\n     */\n    public long getMaxUploadSize() {\n        return maxUploadSize;\n    }\n\n    /**\n     * Sets the maximum size allowed for uploaded files.\n     * This value is in bytes.\n     */\n    public void setMaxUploadSize(long newMaxUploadSize) {\n        maxUploadSize = newMaxUploadSize;\n    }\n\n    /**\n     * Returns the upload directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the upload directory.  The URL for the upload\n     * directory will then be: http://<baseURL>/<uploadDirectory>/\n     * and the path to the upload directory will reside at:\n     * <baseFilePath>/<uploadDirectory>/\n     */\n    public String getUploadDirectory() {\n        return uploadDirectory;\n    }\n\n    /**\n     * Determines the directory to store content below the base directory\n     * used in the various sections of the application (i.e. content or upload)\n     * This plus the filename should be used to create the location setting\n     * in the Metadata table.\n     * The directory is created by combining information from the given\n     * user with the given format (i.e. illustration/photograph)\n     * The returned directory is of the format:\n     * <user id>/<contentFormat>\n     * If user is null, or contentformat is null (or empty), returns null.\n     */\n    public String getLocationDirectory(UserBean user, String contentFormat) {\n        if (user == null || contentFormat == null || contentFormat.length() < 1) {\n            return null;\n        }\n        return user.getUserId() + File.separator + contentFormat;\n    }\n\n    /**\n     * Returns the thumbnail directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the thumbnail directory.  The URL for the thumbnail\n     * directory will then be: http://<baseURL>/<thumbnailDirectory>/\n     * and the path to the thumbnail directory will reside at:\n     * <baseFilePath>/<thumbnailDirectory>/\n     */\n    public String getThumbnailDirectory() {\n        return thumbnailDirectory;\n    }\n\n    /**\n     * Returns the server base URL property setting.\n     * This is the base url on the server where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This baseurl + the upload directory should point to the\n     * upload directory in the webserver.\n     */\n    public String getServerBaseURL() {\n        return serverBaseURL;\n    }\n\n    /**\n     * Returns the base file path property setting.\n     * This is the base directory on the filesystem where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This filepath + the upload directory should point to the\n     * upload directory in the filesystem.\n     */\n    public String getBaseFilePath() {\n        return baseFilePath;\n    }\n\n    /**\n     * Returns the content directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the content directory.  The URL for the content\n     * directory will then be: http://<baseURL>/<contentDirectory>/\n     * and the path to the content directory will reside at:\n     * <baseFilePath>/<contentDirectory>/\n     */\n    public String getContentDirectory() {\n        return contentDirectory;\n    }\n\n    /**\n     * Returns the package directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the package directory.  The URL for the package\n     * directory will then be: http://<baseURL>/<packageDirectory>/\n     * and the path to the package directory will reside at:\n     * <baseFilePath>/<packageDirectory>/\n     */\n    public String getPackageDirectory() {\n        return packageDirectory;\n    }\n\n    /**\n     * Sets the thumbnail directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the thumbnail directory.  The URL for the thumbnail\n     * directory will then be: http://<baseURL>/<thumbnailDirectory>/\n     * and the path to the thumbnail directory will reside at:\n     * <baseFilePath>/<thumbnailDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setThumbnailDirectory(String newThumbnail) {\n        thumbnailDirectory = newThumbnail;\n    }\n\n    /**\n     * Sets the upload directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the upload directory.  The URL for the upload\n     * directory will then be: http://<baseURL>/<uploadDirectory>/\n     * and the path to the upload directory will reside at:\n     * <baseFilePath>/<uploadDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setUploadDirectory(String newUpload) {\n        uploadDirectory = newUpload;\n    }\n\n    /**\n     * Sets the server base URL property setting.\n     * This is the base url on the server where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This baseurl + the upload directory should point to the\n     * upload directory in the webserver.\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setServerBaseURL(String newBaseURL) {\n        serverBaseURL = newBaseURL;\n        if (serverBaseURL != null) {\n            serverBaseURLLength = serverBaseURL.length();\n        } else {\n            serverBaseURLLength = -1;\n        }\n    }\n\n    /**\n     * Sets the base file path property setting.\n     * This is the base directory on the filesystem where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This filepath + the upload directory should point to the\n     * upload directory in the filesystem.\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setBaseFilePath(String newFilePath) {\n        baseFilePath = newFilePath;\n        if (baseFilePath != null) {\n            baseFilePathLength = baseFilePath.length();\n        } else {\n            baseFilePathLength = -1;\n        }\n    }\n\n    /**\n     * Sets the content directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the content directory.  The URL for the content\n     * directory will then be: http://<baseURL>/<contentDirectory>/\n     * and the path to the content directory will reside at:\n     * <baseFilePath>/<contentDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setContentDirectory(String newContentDirectory) {\n        contentDirectory = newContentDirectory;\n    }\n\n    /**\n     * Sets the package directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the package directory.  The URL for the package\n     * directory will then be: http://<baseURL>/<packageDirectory>/\n     * and the path to the package directory will reside at:\n     * <baseFilePath>/<packageDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setPackageDirectory(String newPackage) {\n        packageDirectory = newPackage;\n    }\n\n    /**\n     * Given a URL, calculates the file system path to use to access\n     * the file.  The calculation is made using the base URL and\n     * base file path properties.\n     */\n    public String getFilePathFromURL(String url) {\n        if (url == null) {\n            return null;\n        }\n        int index;\n        String temp, postfix;\n        String result = null;\n        index = url.indexOf(serverBaseURL);\n        if (index != -1) {\n            postfix = url.substring(index + serverBaseURLLength);\n            temp = baseFilePath + File.separator + postfix;\n            result = temp.replace('/', File.separatorChar);\n        }\n        return result;\n    }\n\n    /**\n     * Given a file path, calculates the url to use to access\n     * the file via the web server.  The calculation is made using the\n     * base URL and base file path properties.\n     */\n    public String getURLFromFilePath(String path) {\n        if (path == null) {\n            return null;\n        }\n        int index;\n        String temp, postfix;\n        String result = null;\n        index = path.indexOf(baseFilePath);\n        if (index != -1) {\n            postfix = path.substring(index + baseFilePathLength);\n            temp = serverBaseURL + File.separator + postfix;\n            result = temp.replace(File.separatorChar, '/');\n        }\n        return result;\n    }\n\n    /**\n     * Generates the content filepath and url and the upload filepath and url\n     * properties.  This method is called whenever the contentDirectory\n     * uploadDirectory, baseFilePath, or serverBaseURL properties are changed.\n     * This method should be called once all of the settings have been made\n     * and the FileLocator is ready for use.\n     */\n    public void generateFullDirectories() {\n        if (baseFilePath != null) {\n            if (contentDirectory != null) {\n                contentFilePath = baseFilePath + File.separator + contentDirectory;\n                contentDirectoryFile = new File(contentFilePath);\n                if (!contentDirectoryFile.exists()) {\n                    contentDirectoryFile.mkdirs();\n                }\n            }\n            if (uploadDirectory != null) {\n                uploadFilePath = baseFilePath + File.separator + uploadDirectory;\n                uploadDirectoryFile = new File(uploadFilePath);\n                if (!uploadDirectoryFile.exists()) {\n                    uploadDirectoryFile.mkdirs();\n                }\n            }\n            if (thumbnailDirectory != null) {\n                thumbnailFilePath = baseFilePath + File.separator + thumbnailDirectory;\n                thumbnailDirectoryFile = new File(thumbnailFilePath);\n                if (!thumbnailDirectoryFile.exists()) {\n                    thumbnailDirectoryFile.mkdirs();\n                }\n            }\n            if (packageDirectory != null) {\n                packageFilePath = baseFilePath + File.separator + packageDirectory;\n                packageDirectoryFile = new File(packageFilePath);\n                if (!packageDirectoryFile.exists()) {\n                    packageDirectoryFile.mkdirs();\n                }\n            }\n        }\n        if (serverBaseURL != null) {\n            if (contentDirectory != null) {\n                contentURL = serverBaseURL + '/' + contentDirectory + '/';\n            }\n            if (uploadDirectory != null) {\n                uploadURL = serverBaseURL + '/' + uploadDirectory + '/';\n            }\n            if (thumbnailDirectory != null) {\n                thumbnailURL = serverBaseURL + '/' + thumbnailDirectory + '/';\n            }\n            if (packageDirectory != null) {\n                packageURL = serverBaseURL + '/' + packageDirectory + '/';\n            }\n        }\n    }\n\n    /**\n     * Returns the file path generated from the uploadDirectory and base\n     * file path properties.\n     */\n    public String getUploadFilePath() {\n        return uploadFilePath;\n    }\n\n    /**\n     * Returns the file path result of the package directory concatenated\n     * with the provided source location.\n     */\n    public String getUploadFilePath(String sourceLocation) {\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(uploadFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the upload directory concatenated\n     * with the provided source location.\n     */\n    public String getUploadURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http://\")) /*same mod as getContentURL*/\n        {\n            return sourceLocation;\n        } else {\n            return uploadURL + sourceLocation.replaceAll(\"\\\\\\\\\", \"/\");\n        }\n    }\n\n    /**\n     * Returns the url generated from the uploadDirectory and server base\n     * url properties.\n     */\n    public String getUploadURL() {\n        return uploadURL;\n    }\n\n    /**\n     * Returns the file path generated from the thumbnailDirectory and base\n     * file path properties.\n     */\n    public String getThumbnailFilePath() {\n        return thumbnailFilePath;\n    }\n\n    /**\n     * Returns the file path result of the thumbnail directory concatenated\n     * with the provided source location.\n     */\n    public String getThumbnailFilePath(String sourceLocation) {\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(thumbnailFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the thumbnail directory concatenated\n     * with the provided source location.\n     */\n    public String getThumbnailURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http:\")) {\n            return sourceLocation;\n        } else {\n            return thumbnailURL + sourceLocation;\n        }\n    }\n\n    /**\n     * Returns the url generated from the thumbnailDirectory and server base\n     * url properties.\n     */\n    public String getThumbnailURL() {\n        return thumbnailURL;\n    }\n\n    /**\n     * Returns the file path generated from the contentDirectory and base\n     * file path properties.\n     */\n    public String getContentFilePath() {\n        return contentFilePath;\n    }\n\n    /**\n     * Returns the file path result of the content directory concatenated\n     * with the provided source location.\n     */\n    public String getContentFilePath(String sourceLocation) {\n        if (sourceLocation.toLowerCase().startsWith(getContentURL().toLowerCase())) {\n            sourceLocation = sourceLocation.substring(getContentURL().length());\n        }\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(contentFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the content directory concatenated\n     * with the provided source location.\n     */\n    /* mod by JV for http:// starting items */\n    public String getContentURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http://\")) {\n            return sourceLocation;\n        } else {\n            return contentURL + sourceLocation;\n        }\n    }\n\n    /**\n     * Returns the url generated from the contentDirectory and server base\n     * url properties.\n     */\n    public String getContentURL() {\n        return contentURL;\n    }\n\n    /**\n     * Returns the file path generated from the packageDirectory and base\n     * file path properties.\n     */\n    public String getPackageFilePath() {\n        return packageFilePath;\n    }\n\n    /**\n     * Returns the directory storing packages.\n     */\n    public File getPackageDirectoryFile() {\n        return packageDirectoryFile;\n    }\n\n    /**\n     * Returns the url generated from the packageDirectory and server base\n     * url properties.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Returns a string consisting of only the path of a given location that\n     * falls below the preset content, package, and upload directories.  This\n     * method works for both URLs and file paths.  This method relies upon\n     * the base url, base file, content, package, and upload path settings.\n     * Given a base url of 'http://www.healcentral.org/'\n     * a file url of 'd:\\apache\\htdocs\\'\n     * a content path of 'content'\n     * a package path of 'package'\n     * and an upload path of 'upload'\n     * The following results will be given:\n     * getRelativePath(c:\\apache\\content\\brain\\picture.jpg) = brain\\picture.jpg\n     * getRelativePath(http://www.healcentral.org/content/brain/picture.jpg) =\n     * brain/picture.jpg\n     * <p/>\n     * The approach to determining the relative path is to look for first the\n     * content directory, then the upload directory, then the package\n     * directory to see if any of them appear in the location string\n     * (using the String.indexOf() method).\n     * <p/>\n     * If the parameter is null, or the content, upload, or package paths are\n     * not foud, then null is returned.\n     */\n    public String getRelativePath(String location) {\n        int index = -1;\n        char separator;\n        String result = null;\n        int locationLen;\n        if (location != null) {\n            locationLen = location.length();\n            //check each directory type\n            if ((contentDirectory != null && (index = location.indexOf(File.separator + contentDirectory + File.separator)) != -1)) {\n                //move the index to past the location of the directory\n                index += contentDirectory.length();\n            } else if ((uploadDirectory != null && (index = location.indexOf(File.separator + uploadDirectory + File.separator)) != -1)) {\n                index += uploadDirectory.length();\n            } else if ((thumbnailDirectory != null && (index = location.indexOf(File.separator + thumbnailDirectory + File.separator)) != -1)) {\n                index += thumbnailDirectory.length();\n            } else if ((packageDirectory != null && (index = location.indexOf(File.separator + packageDirectory + File.separator)) != -1)) {\n                index += packageDirectory.length();\n            }\n            /* if we found the location, see if we need to skip a\n             * file separator or URL separator\n             */\n            if (index != -1) {\n                separator = location.charAt(index);\n                if (separator == File.separatorChar || separator == '/') {\n                    //we found a separator, so skip over it\n                    index++;\n                }\n                //if the index isn't past the end, get the rest of the string\n                if (index < locationLen) {\n                    result = location.substring(index);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Moves the given file from the upload directory to the content\n     * directory.  There is no error checking for conflicts.\n     */\n    public boolean moveFromUploadToContent(String location) throws IOException {\n        boolean success = false;\n        String filepath = convertLocationToFilePath(location);\n        if (filepath != null) {\n            File from = new File(uploadFilePath, filepath);\n            if (from.exists()) {\n                File to = new File(contentFilePath, filepath);\n                success = from.renameTo(to);\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Just like the getRelativePath method, but replaces any occurences of\n     * '/' with File.separatorChar.\n     */\n    public String getRelativeFilePath(String location) {\n        String retval = getRelativePath(location);\n        if (retval != null) {\n            retval.replace('/', File.separatorChar);\n        }\n        return retval;\n    }\n\n    /**\n     * Just like the getRelativePath method, but replaces any occurences of\n     * File.separatorChar with '/'.\n     */\n    public String getRelativeURLPath(String location) {\n        String retval = getRelativePath(location);\n        if (retval != null) {\n            retval.replace(File.separatorChar, '/');\n        }\n        return retval;\n    }\n\n    /**\n     * Given a \"location\" setting (see the Location field of the\n     * Metadata table) it replaces all of the path separators to\n     * be those of the local operating system, allowing the\n     * application to get a path to the content file.\n     * example: location = \"2/Photograph/brain.jpg\", returns\n     * \"2\\Photograph\\brain.jpg\" on Windows,\n     * \"2/Photograph/brain.jpg\" on Solaris\n     * Returns null if the location parameter is null.\n     */\n    public String convertLocationToFilePath(String location) {\n        if (location == null) {\n            return null;\n        }\n        String retval = new String(location);\n        return retval.replace('/', File.separatorChar);\n    }\n\n    /**\n     * Given a file path setting it replaces all of the path\n     * separators to be '/' as is standardized in the\n     * Location field of the Metadata table in the database.\n     * The path field should contain the local operating systems\n     * File.separatorChar as the separator between directories.\n     * This method should only be used for relative file paths\n     * of the format below, and the path shouldn't contain\n     * the upload, content, package, or thumbnail directories,\n     * but rather the relative path below those.\n     * <p/>\n     * example: (Windows)path = \"2\\Photograph\\brain.jpg\", or\n     * \"2/Photograph/brain.jpg\" on Solaris\n     * returns\n     * \"2/Photograph/brain.jpg\"\n     * Returns null if the filepath parameter is null.\n     */\n    public String convertFilePathToLocation(String location) {\n        if (location == null) {\n            return null;\n        }\n        String retval = new String(location);\n        return retval.replace(File.separatorChar, '/');\n    }\n\n    /**\n     * Given a location directory (i.e. one generated via the\n     * getLocationDirectory method), checks all possible places a file by\n     * the name of locationdirectory/name could be.  If a redundancy is\n     * detected, it will separate the filename and extension information\n     * in name and begin adding numbers to the name until no redundancy is\n     * found.  For example, if location directory is \"1/audio\" and the name\n     * is \"sound.avi\" and the file <uploaddir>/1/audio/sound.avi is found or\n     * the file <contentdir>/1/audio/sound.avi is found, then the method will\n     * try against <uploaddir>/1/audio/sound1.avi and\n     * <contentdir>/1/audio/sound1.avi, sound2.avi, sound3.avi, etc. until no\n     * conflict is found.  When no conflict is found the returned String\n     * will be of the form: 1/audio/sound4.avi\n     * <p/>\n     * Checks files in both the upload and content directories.\n     * Also creates the parent directory of the file if it does not exist.\n     */\n    public String getUniqueFileLocation(String locationDirectory, String name) {\n        String filePath = locationDirectory + File.separator + name;\n        //try quick and dirty first...\n        File uploadFile = new File(uploadFilePath, filePath);\n        if (!uploadFile.exists()) {\n            File contentFile = new File(contentFilePath, filePath);\n            if (!contentFile.exists()) {\n                File uploadParent = uploadFile.getParentFile();\n                if (!uploadParent.exists()) {\n                    uploadParent.mkdirs();\n                }\n                File contentParent = contentFile.getParentFile();\n                if (!contentParent.exists()) {\n                    contentParent.mkdirs();\n                }\n                return filePath;\n            }\n        }\n        //if we get here, one of the files existed\n        //if we have a redundancy, start at 2(e.g. brain2.jpg)\n        int counter = 2;\n        int extensionIndex = name.lastIndexOf('.');\n        //extension will contain the period also: e.g. \".jpg\"\n        String extension = \"\";\n        String fileName = name;\n        if (extensionIndex > 0) {\n            extension = name.substring(extensionIndex);\n            fileName = name.substring(0, extensionIndex);\n        }\n        while (true) {\n            filePath = locationDirectory + File.separator + fileName + counter + extension;\n            uploadFile = new File(uploadFilePath, filePath);\n            if (!uploadFile.exists()) {\n                File contentFile = new File(contentFilePath, filePath);\n                if (!contentFile.exists()) {\n                    File uploadParent = uploadFile.getParentFile();\n                    if (!uploadParent.exists()) {\n                        uploadParent.mkdirs();\n                    }\n                    File contentParent = contentFile.getParentFile();\n                    if (!contentParent.exists()) {\n                        contentParent.mkdirs();\n                    }\n                    return filePath;\n                }\n            }\n            //if we get here we had a collision, so we increment the counter.\n            counter++;\n        }\n    }\n\n    public void createParentDir(String filepath) {\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/FileLocatorTest1.java",
		"test_prompt": "// FileLocatorTest1.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileLocator}.\n* It contains ten unit test cases for the {@link FileLocator#convertLocationToFilePath(String)} method.\n*/\nclass FileLocatorTest1 {"
	},
	{
		"original_code": "// FileLocator.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\n\n/**\n * This class translates URLs to file system paths and vice versa.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class FileLocator implements Serializable {\n\n    public static final String DEFAULT_UPLOAD_DIRECTORY = \"upload\";\n\n    public static final String DEFAULT_THUMBNAIL_DIRECTORY = \"thumbnails\";\n\n    public static final String DEFAULT_CONTENT_DIRECTORY = \"content\";\n\n    public static final String DEFAULT_PACKAGE_DIRECTORY = \"package\";\n\n    private String uploadDirectory = DEFAULT_UPLOAD_DIRECTORY;\n\n    private File uploadDirectoryFile = null;\n\n    private String uploadFilePath = null;\n\n    private String uploadURL = null;\n\n    private String serverBaseURL = null;\n\n    private int serverBaseURLLength = -1;\n\n    private String contentDirectory = DEFAULT_CONTENT_DIRECTORY;\n\n    private File contentDirectoryFile = null;\n\n    private String contentFilePath = null;\n\n    private String contentURL = null;\n\n    private String baseFilePath = null;\n\n    private int baseFilePathLength = -1;\n\n    private String packageDirectory = DEFAULT_PACKAGE_DIRECTORY;\n\n    private File packageDirectoryFile = null;\n\n    private String packageFilePath = null;\n\n    private String packageURL = null;\n\n    private String thumbnailDirectory = DEFAULT_THUMBNAIL_DIRECTORY;\n\n    private File thumbnailDirectoryFile = null;\n\n    private String thumbnailFilePath = null;\n\n    private String thumbnailURL = null;\n\n    //512 Megabytes\n    private long maxUploadSize = 512 * 1024 * 1024;\n\n    /**\n     * Returns the maximum size allowed for uploaded files.\n     * This value is in bytes.\n     */\n    public long getMaxUploadSize() {\n        return maxUploadSize;\n    }\n\n    /**\n     * Sets the maximum size allowed for uploaded files.\n     * This value is in bytes.\n     */\n    public void setMaxUploadSize(long newMaxUploadSize) {\n        maxUploadSize = newMaxUploadSize;\n    }\n\n    /**\n     * Returns the upload directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the upload directory.  The URL for the upload\n     * directory will then be: http://<baseURL>/<uploadDirectory>/\n     * and the path to the upload directory will reside at:\n     * <baseFilePath>/<uploadDirectory>/\n     */\n    public String getUploadDirectory() {\n        return uploadDirectory;\n    }\n\n    /**\n     * Determines the directory to store content below the base directory\n     * used in the various sections of the application (i.e. content or upload)\n     * This plus the filename should be used to create the location setting\n     * in the Metadata table.\n     * The directory is created by combining information from the given\n     * user with the given format (i.e. illustration/photograph)\n     * The returned directory is of the format:\n     * <user id>/<contentFormat>\n     * If user is null, or contentformat is null (or empty), returns null.\n     */\n    public String getLocationDirectory(UserBean user, String contentFormat) {\n        if (user == null || contentFormat == null || contentFormat.length() < 1) {\n            return null;\n        }\n        return user.getUserId() + File.separator + contentFormat;\n    }\n\n    /**\n     * Returns the thumbnail directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the thumbnail directory.  The URL for the thumbnail\n     * directory will then be: http://<baseURL>/<thumbnailDirectory>/\n     * and the path to the thumbnail directory will reside at:\n     * <baseFilePath>/<thumbnailDirectory>/\n     */\n    public String getThumbnailDirectory() {\n        return thumbnailDirectory;\n    }\n\n    /**\n     * Returns the server base URL property setting.\n     * This is the base url on the server where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This baseurl + the upload directory should point to the\n     * upload directory in the webserver.\n     */\n    public String getServerBaseURL() {\n        return serverBaseURL;\n    }\n\n    /**\n     * Returns the base file path property setting.\n     * This is the base directory on the filesystem where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This filepath + the upload directory should point to the\n     * upload directory in the filesystem.\n     */\n    public String getBaseFilePath() {\n        return baseFilePath;\n    }\n\n    /**\n     * Returns the content directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the content directory.  The URL for the content\n     * directory will then be: http://<baseURL>/<contentDirectory>/\n     * and the path to the content directory will reside at:\n     * <baseFilePath>/<contentDirectory>/\n     */\n    public String getContentDirectory() {\n        return contentDirectory;\n    }\n\n    /**\n     * Returns the package directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the package directory.  The URL for the package\n     * directory will then be: http://<baseURL>/<packageDirectory>/\n     * and the path to the package directory will reside at:\n     * <baseFilePath>/<packageDirectory>/\n     */\n    public String getPackageDirectory() {\n        return packageDirectory;\n    }\n\n    /**\n     * Sets the thumbnail directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the thumbnail directory.  The URL for the thumbnail\n     * directory will then be: http://<baseURL>/<thumbnailDirectory>/\n     * and the path to the thumbnail directory will reside at:\n     * <baseFilePath>/<thumbnailDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setThumbnailDirectory(String newThumbnail) {\n        thumbnailDirectory = newThumbnail;\n    }\n\n    /**\n     * Sets the upload directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the upload directory.  The URL for the upload\n     * directory will then be: http://<baseURL>/<uploadDirectory>/\n     * and the path to the upload directory will reside at:\n     * <baseFilePath>/<uploadDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setUploadDirectory(String newUpload) {\n        uploadDirectory = newUpload;\n    }\n\n    /**\n     * Sets the server base URL property setting.\n     * This is the base url on the server where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This baseurl + the upload directory should point to the\n     * upload directory in the webserver.\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setServerBaseURL(String newBaseURL) {\n        serverBaseURL = newBaseURL;\n        if (serverBaseURL != null) {\n            serverBaseURLLength = serverBaseURL.length();\n        } else {\n            serverBaseURLLength = -1;\n        }\n    }\n\n    /**\n     * Sets the base file path property setting.\n     * This is the base directory on the filesystem where all content\n     * (uploaded, cataloged, approved - all content in the system).\n     * This filepath + the upload directory should point to the\n     * upload directory in the filesystem.\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setBaseFilePath(String newFilePath) {\n        baseFilePath = newFilePath;\n        if (baseFilePath != null) {\n            baseFilePathLength = baseFilePath.length();\n        } else {\n            baseFilePathLength = -1;\n        }\n    }\n\n    /**\n     * Sets the content directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the content directory.  The URL for the content\n     * directory will then be: http://<baseURL>/<contentDirectory>/\n     * and the path to the content directory will reside at:\n     * <baseFilePath>/<contentDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setContentDirectory(String newContentDirectory) {\n        contentDirectory = newContentDirectory;\n    }\n\n    /**\n     * Sets the package directory property setting.\n     * This is the path that is tacked on after either the baseURL\n     * or the baseFilePath to get the logical or translated locations\n     * of the files in the package directory.  The URL for the package\n     * directory will then be: http://<baseURL>/<packageDirectory>/\n     * and the path to the package directory will reside at:\n     * <baseFilePath>/<packageDirectory>/\n     * Be sure to call generateFullDirectories before using this class\n     * after changing this setting.\n     */\n    public void setPackageDirectory(String newPackage) {\n        packageDirectory = newPackage;\n    }\n\n    /**\n     * Given a URL, calculates the file system path to use to access\n     * the file.  The calculation is made using the base URL and\n     * base file path properties.\n     */\n    public String getFilePathFromURL(String url) {\n        if (url == null) {\n            return null;\n        }\n        int index;\n        String temp, postfix;\n        String result = null;\n        index = url.indexOf(serverBaseURL);\n        if (index != -1) {\n            postfix = url.substring(index + serverBaseURLLength);\n            temp = baseFilePath + File.separator + postfix;\n            result = temp.replace('/', File.separatorChar);\n        }\n        return result;\n    }\n\n    /**\n     * Given a file path, calculates the url to use to access\n     * the file via the web server.  The calculation is made using the\n     * base URL and base file path properties.\n     */\n    public String getURLFromFilePath(String path) {\n        if (path == null) {\n            return null;\n        }\n        int index;\n        String temp, postfix;\n        String result = null;\n        index = path.indexOf(baseFilePath);\n        if (index != -1) {\n            postfix = path.substring(index + baseFilePathLength);\n            temp = serverBaseURL + File.separator + postfix;\n            result = temp.replace(File.separatorChar, '/');\n        }\n        return result;\n    }\n\n    /**\n     * Generates the content filepath and url and the upload filepath and url\n     * properties.  This method is called whenever the contentDirectory\n     * uploadDirectory, baseFilePath, or serverBaseURL properties are changed.\n     * This method should be called once all of the settings have been made\n     * and the FileLocator is ready for use.\n     */\n    public void generateFullDirectories() {\n        if (baseFilePath != null) {\n            if (contentDirectory != null) {\n                contentFilePath = baseFilePath + File.separator + contentDirectory;\n                contentDirectoryFile = new File(contentFilePath);\n                if (!contentDirectoryFile.exists()) {\n                    contentDirectoryFile.mkdirs();\n                }\n            }\n            if (uploadDirectory != null) {\n                uploadFilePath = baseFilePath + File.separator + uploadDirectory;\n                uploadDirectoryFile = new File(uploadFilePath);\n                if (!uploadDirectoryFile.exists()) {\n                    uploadDirectoryFile.mkdirs();\n                }\n            }\n            if (thumbnailDirectory != null) {\n                thumbnailFilePath = baseFilePath + File.separator + thumbnailDirectory;\n                thumbnailDirectoryFile = new File(thumbnailFilePath);\n                if (!thumbnailDirectoryFile.exists()) {\n                    thumbnailDirectoryFile.mkdirs();\n                }\n            }\n            if (packageDirectory != null) {\n                packageFilePath = baseFilePath + File.separator + packageDirectory;\n                packageDirectoryFile = new File(packageFilePath);\n                if (!packageDirectoryFile.exists()) {\n                    packageDirectoryFile.mkdirs();\n                }\n            }\n        }\n        if (serverBaseURL != null) {\n            if (contentDirectory != null) {\n                contentURL = serverBaseURL + '/' + contentDirectory + '/';\n            }\n            if (uploadDirectory != null) {\n                uploadURL = serverBaseURL + '/' + uploadDirectory + '/';\n            }\n            if (thumbnailDirectory != null) {\n                thumbnailURL = serverBaseURL + '/' + thumbnailDirectory + '/';\n            }\n            if (packageDirectory != null) {\n                packageURL = serverBaseURL + '/' + packageDirectory + '/';\n            }\n        }\n    }\n\n    /**\n     * Returns the file path generated from the uploadDirectory and base\n     * file path properties.\n     */\n    public String getUploadFilePath() {\n        return uploadFilePath;\n    }\n\n    /**\n     * Returns the file path result of the package directory concatenated\n     * with the provided source location.\n     */\n    public String getUploadFilePath(String sourceLocation) {\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(uploadFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the upload directory concatenated\n     * with the provided source location.\n     */\n    public String getUploadURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http://\")) /*same mod as getContentURL*/\n        {\n            return sourceLocation;\n        } else {\n            return uploadURL + sourceLocation.replaceAll(\"\\\\\\\\\", \"/\");\n        }\n    }\n\n    /**\n     * Returns the url generated from the uploadDirectory and server base\n     * url properties.\n     */\n    public String getUploadURL() {\n        return uploadURL;\n    }\n\n    /**\n     * Returns the file path generated from the thumbnailDirectory and base\n     * file path properties.\n     */\n    public String getThumbnailFilePath() {\n        return thumbnailFilePath;\n    }\n\n    /**\n     * Returns the file path result of the thumbnail directory concatenated\n     * with the provided source location.\n     */\n    public String getThumbnailFilePath(String sourceLocation) {\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(thumbnailFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the thumbnail directory concatenated\n     * with the provided source location.\n     */\n    public String getThumbnailURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http:\")) {\n            return sourceLocation;\n        } else {\n            return thumbnailURL + sourceLocation;\n        }\n    }\n\n    /**\n     * Returns the url generated from the thumbnailDirectory and server base\n     * url properties.\n     */\n    public String getThumbnailURL() {\n        return thumbnailURL;\n    }\n\n    /**\n     * Returns the file path generated from the contentDirectory and base\n     * file path properties.\n     */\n    public String getContentFilePath() {\n        return contentFilePath;\n    }\n\n    /**\n     * Returns the file path result of the content directory concatenated\n     * with the provided source location.\n     */\n    public String getContentFilePath(String sourceLocation) {\n        if (sourceLocation.toLowerCase().startsWith(getContentURL().toLowerCase())) {\n            sourceLocation = sourceLocation.substring(getContentURL().length());\n        }\n        String convertedSource = sourceLocation.replace('/', File.separatorChar);\n        File fullPath = new File(contentFilePath, convertedSource);\n        String retval = null;\n        try {\n            retval = fullPath.getCanonicalPath();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        return retval;\n    }\n\n    /**\n     * Returns the url result of the content directory concatenated\n     * with the provided source location.\n     */\n    /* mod by JV for http:// starting items */\n    public String getContentURL(String sourceLocation) {\n        if (sourceLocation.startsWith(\"http://\")) {\n            return sourceLocation;\n        } else {\n            return contentURL + sourceLocation;\n        }\n    }\n\n    /**\n     * Returns the url generated from the contentDirectory and server base\n     * url properties.\n     */\n    public String getContentURL() {\n        return contentURL;\n    }\n\n    /**\n     * Returns the file path generated from the packageDirectory and base\n     * file path properties.\n     */\n    public String getPackageFilePath() {\n        return packageFilePath;\n    }\n\n    /**\n     * Returns the directory storing packages.\n     */\n    public File getPackageDirectoryFile() {\n        return packageDirectoryFile;\n    }\n\n    /**\n     * Returns the url generated from the packageDirectory and server base\n     * url properties.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Returns a string consisting of only the path of a given location that\n     * falls below the preset content, package, and upload directories.  This\n     * method works for both URLs and file paths.  This method relies upon\n     * the base url, base file, content, package, and upload path settings.\n     * Given a base url of 'http://www.healcentral.org/'\n     * a file url of 'd:\\apache\\htdocs\\'\n     * a content path of 'content'\n     * a package path of 'package'\n     * and an upload path of 'upload'\n     * The following results will be given:\n     * getRelativePath(c:\\apache\\content\\brain\\picture.jpg) = brain\\picture.jpg\n     * getRelativePath(http://www.healcentral.org/content/brain/picture.jpg) =\n     * brain/picture.jpg\n     * <p/>\n     * The approach to determining the relative path is to look for first the\n     * content directory, then the upload directory, then the package\n     * directory to see if any of them appear in the location string\n     * (using the String.indexOf() method).\n     * <p/>\n     * If the parameter is null, or the content, upload, or package paths are\n     * not foud, then null is returned.\n     */\n    public String getRelativePath(String location) {\n        int index = -1;\n        char separator;\n        String result = null;\n        int locationLen;\n        if (location != null) {\n            locationLen = location.length();\n            //check each directory type\n            if ((contentDirectory != null && (index = location.indexOf(File.separator + contentDirectory + File.separator)) != -1)) {\n                //move the index to past the location of the directory\n                index += contentDirectory.length();\n            } else if ((uploadDirectory != null && (index = location.indexOf(File.separator + uploadDirectory + File.separator)) != -1)) {\n                index += uploadDirectory.length();\n            } else if ((thumbnailDirectory != null && (index = location.indexOf(File.separator + thumbnailDirectory + File.separator)) != -1)) {\n                index += thumbnailDirectory.length();\n            } else if ((packageDirectory != null && (index = location.indexOf(File.separator + packageDirectory + File.separator)) != -1)) {\n                index += packageDirectory.length();\n            }\n            /* if we found the location, see if we need to skip a\n             * file separator or URL separator\n             */\n            if (index != -1) {\n                separator = location.charAt(index);\n                if (separator == File.separatorChar || separator == '/') {\n                    //we found a separator, so skip over it\n                    index++;\n                }\n                //if the index isn't past the end, get the rest of the string\n                if (index < locationLen) {\n                    result = location.substring(index);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Moves the given file from the upload directory to the content\n     * directory.  There is no error checking for conflicts.\n     */\n    public boolean moveFromUploadToContent(String location) throws IOException {\n        boolean success = false;\n        String filepath = convertLocationToFilePath(location);\n        if (filepath != null) {\n            File from = new File(uploadFilePath, filepath);\n            if (from.exists()) {\n                File to = new File(contentFilePath, filepath);\n                success = from.renameTo(to);\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Just like the getRelativePath method, but replaces any occurences of\n     * '/' with File.separatorChar.\n     */\n    public String getRelativeFilePath(String location) {\n        String retval = getRelativePath(location);\n        if (retval != null) {\n            retval.replace('/', File.separatorChar);\n        }\n        return retval;\n    }\n\n    /**\n     * Just like the getRelativePath method, but replaces any occurences of\n     * File.separatorChar with '/'.\n     */\n    public String getRelativeURLPath(String location) {\n        String retval = getRelativePath(location);\n        if (retval != null) {\n            retval.replace(File.separatorChar, '/');\n        }\n        return retval;\n    }\n\n    /**\n     * Given a \"location\" setting (see the Location field of the\n     * Metadata table) it replaces all of the path separators to\n     * be those of the local operating system, allowing the\n     * application to get a path to the content file.\n     * example: location = \"2/Photograph/brain.jpg\", returns\n     * \"2\\Photograph\\brain.jpg\" on Windows,\n     * \"2/Photograph/brain.jpg\" on Solaris\n     * Returns null if the location parameter is null.\n     */\n    public String convertLocationToFilePath(String location) {\n        if (location == null) {\n            return null;\n        }\n        String retval = new String(location);\n        return retval.replace('/', File.separatorChar);\n    }\n\n    /**\n     * Given a file path setting it replaces all of the path\n     * separators to be '/' as is standardized in the\n     * Location field of the Metadata table in the database.\n     * The path field should contain the local operating systems\n     * File.separatorChar as the separator between directories.\n     * This method should only be used for relative file paths\n     * of the format below, and the path shouldn't contain\n     * the upload, content, package, or thumbnail directories,\n     * but rather the relative path below those.\n     * <p/>\n     * example: (Windows)path = \"2\\Photograph\\brain.jpg\", or\n     * \"2/Photograph/brain.jpg\" on Solaris\n     * returns\n     * \"2/Photograph/brain.jpg\"\n     * Returns null if the filepath parameter is null.\n     */\n    public String convertFilePathToLocation(String location) {\n        if (location == null) {\n            return null;\n        }\n        String retval = new String(location);\n        return retval.replace(File.separatorChar, '/');\n    }\n\n    /**\n     * Given a location directory (i.e. one generated via the\n     * getLocationDirectory method), checks all possible places a file by\n     * the name of locationdirectory/name could be.  If a redundancy is\n     * detected, it will separate the filename and extension information\n     * in name and begin adding numbers to the name until no redundancy is\n     * found.  For example, if location directory is \"1/audio\" and the name\n     * is \"sound.avi\" and the file <uploaddir>/1/audio/sound.avi is found or\n     * the file <contentdir>/1/audio/sound.avi is found, then the method will\n     * try against <uploaddir>/1/audio/sound1.avi and\n     * <contentdir>/1/audio/sound1.avi, sound2.avi, sound3.avi, etc. until no\n     * conflict is found.  When no conflict is found the returned String\n     * will be of the form: 1/audio/sound4.avi\n     * <p/>\n     * Checks files in both the upload and content directories.\n     * Also creates the parent directory of the file if it does not exist.\n     */\n    public String getUniqueFileLocation(String locationDirectory, String name) {\n        String filePath = locationDirectory + File.separator + name;\n        //try quick and dirty first...\n        File uploadFile = new File(uploadFilePath, filePath);\n        if (!uploadFile.exists()) {\n            File contentFile = new File(contentFilePath, filePath);\n            if (!contentFile.exists()) {\n                File uploadParent = uploadFile.getParentFile();\n                if (!uploadParent.exists()) {\n                    uploadParent.mkdirs();\n                }\n                File contentParent = contentFile.getParentFile();\n                if (!contentParent.exists()) {\n                    contentParent.mkdirs();\n                }\n                return filePath;\n            }\n        }\n        //if we get here, one of the files existed\n        //if we have a redundancy, start at 2(e.g. brain2.jpg)\n        int counter = 2;\n        int extensionIndex = name.lastIndexOf('.');\n        //extension will contain the period also: e.g. \".jpg\"\n        String extension = \"\";\n        String fileName = name;\n        if (extensionIndex > 0) {\n            extension = name.substring(extensionIndex);\n            fileName = name.substring(0, extensionIndex);\n        }\n        while (true) {\n            filePath = locationDirectory + File.separator + fileName + counter + extension;\n            uploadFile = new File(uploadFilePath, filePath);\n            if (!uploadFile.exists()) {\n                File contentFile = new File(contentFilePath, filePath);\n                if (!contentFile.exists()) {\n                    File uploadParent = uploadFile.getParentFile();\n                    if (!uploadParent.exists()) {\n                        uploadParent.mkdirs();\n                    }\n                    File contentParent = contentFile.getParentFile();\n                    if (!contentParent.exists()) {\n                        contentParent.mkdirs();\n                    }\n                    return filePath;\n                }\n            }\n            //if we get here we had a collision, so we increment the counter.\n            counter++;\n        }\n    }\n\n    public void createParentDir(String filepath) {\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/util/FileLocatorTest2.java",
		"test_prompt": "// FileLocatorTest2.java\npackage org.heal.util;\n\nimport org.heal.module.user.UserBean;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileLocator}.\n* It contains ten unit test cases for the {@link FileLocator#convertFilePathToLocation(String)} method.\n*/\nclass FileLocatorTest2 {"
	},
	{
		"original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL = new String(\"approval\");\n\n    public static final String TYPE_CATALOG = new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private MetadataDAO md = new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE = \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY = \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY = \"UPDATE QueuedRecords\" + \" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE\" + \" QueuedRecordId = ?\";\n\n    private static final String DELETE_QUEUE_ENTRY = \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId = ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource = dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List<QueuedRecordBean> getQueueByType(final String type) {\n        List<QueuedRecordBean> result = null;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            result = getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List<QueuedRecordBean> getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List<QueuedRecordBean> getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException {\n        final List<QueuedRecordBean> result = new ArrayList<QueuedRecordBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember = new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs != null) {\n                rs.close();\n            }\n            if (ps != null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId = temp.getShortMetadata().getMetadataId();\n            // Here we're putting a MetadataBean into a ShortMetadataBean reference\n            // because it's necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return <code>true</code> if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result = false;\n        if (null == queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null == queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate = null != queuedRecord.getQueuedRecordId();\n        final String sql = isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final QueuedRecordBean temp = new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final CompleteMetadataBean cmb = md.getCompleteMetadata(metadataId, conn);\n            final Date now = new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/catalog/QueueDAOTest0.java",
		"test_prompt": "// QueueDAOTest0.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#saveQueuedRecord(QueuedRecordBean)} method.\n*/\nclass QueueDAOTest0 {"
	},
	{
		"original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL = new String(\"approval\");\n\n    public static final String TYPE_CATALOG = new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private MetadataDAO md = new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE = \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY = \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY = \"UPDATE QueuedRecords\" + \" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE\" + \" QueuedRecordId = ?\";\n\n    private static final String DELETE_QUEUE_ENTRY = \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId = ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource = dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List<QueuedRecordBean> getQueueByType(final String type) {\n        List<QueuedRecordBean> result = null;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            result = getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List<QueuedRecordBean> getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List<QueuedRecordBean> getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException {\n        final List<QueuedRecordBean> result = new ArrayList<QueuedRecordBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember = new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs != null) {\n                rs.close();\n            }\n            if (ps != null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId = temp.getShortMetadata().getMetadataId();\n            // Here we're putting a MetadataBean into a ShortMetadataBean reference\n            // because it's necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return <code>true</code> if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result = false;\n        if (null == queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null == queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate = null != queuedRecord.getQueuedRecordId();\n        final String sql = isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final QueuedRecordBean temp = new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final CompleteMetadataBean cmb = md.getCompleteMetadata(metadataId, conn);\n            final Date now = new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/catalog/QueueDAOTest1.java",
		"test_prompt": "// QueueDAOTest1.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#enqueue(String, String)} method.\n*/\nclass QueueDAOTest1 {"
	},
	{
		"original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL = new String(\"approval\");\n\n    public static final String TYPE_CATALOG = new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private MetadataDAO md = new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE = \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY = \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY = \"UPDATE QueuedRecords\" + \" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE\" + \" QueuedRecordId = ?\";\n\n    private static final String DELETE_QUEUE_ENTRY = \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId = ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource = dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List<QueuedRecordBean> getQueueByType(final String type) {\n        List<QueuedRecordBean> result = null;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            result = getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List<QueuedRecordBean> getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List<QueuedRecordBean> getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException {\n        final List<QueuedRecordBean> result = new ArrayList<QueuedRecordBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember = new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs != null) {\n                rs.close();\n            }\n            if (ps != null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId = temp.getShortMetadata().getMetadataId();\n            // Here we're putting a MetadataBean into a ShortMetadataBean reference\n            // because it's necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return <code>true</code> if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result = false;\n        if (null == queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null == queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate = null != queuedRecord.getQueuedRecordId();\n        final String sql = isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final QueuedRecordBean temp = new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final CompleteMetadataBean cmb = md.getCompleteMetadata(metadataId, conn);\n            final Date now = new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/catalog/QueueDAOTest2.java",
		"test_prompt": "// QueueDAOTest2.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#dequeue(String)} method.\n*/\nclass QueueDAOTest2 {"
	},
	{
		"original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL = new String(\"approval\");\n\n    public static final String TYPE_CATALOG = new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private MetadataDAO md = new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE = \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY = \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY = \"UPDATE QueuedRecords\" + \" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE\" + \" QueuedRecordId = ?\";\n\n    private static final String DELETE_QUEUE_ENTRY = \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId = ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource = dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List<QueuedRecordBean> getQueueByType(final String type) {\n        List<QueuedRecordBean> result = null;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            result = getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List<QueuedRecordBean> getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List<QueuedRecordBean> getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException {\n        final List<QueuedRecordBean> result = new ArrayList<QueuedRecordBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember = new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs != null) {\n                rs.close();\n            }\n            if (ps != null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId = temp.getShortMetadata().getMetadataId();\n            // Here we're putting a MetadataBean into a ShortMetadataBean reference\n            // because it's necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return <code>true</code> if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result = false;\n        if (null == queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null == queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate = null != queuedRecord.getQueuedRecordId();\n        final String sql = isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final QueuedRecordBean temp = new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final CompleteMetadataBean cmb = md.getCompleteMetadata(metadataId, conn);\n            final Date now = new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/catalog/QueueDAOTest3.java",
		"test_prompt": "// QueueDAOTest3.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#markRecordApproved(String)} method.\n*/\nclass QueueDAOTest3 {"
	},
	{
		"original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL = new String(\"approval\");\n\n    public static final String TYPE_CATALOG = new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private MetadataDAO md = new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE = \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY = \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY = \"UPDATE QueuedRecords\" + \" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE\" + \" QueuedRecordId = ?\";\n\n    private static final String DELETE_QUEUE_ENTRY = \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId = ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource = dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List<QueuedRecordBean> getQueueByType(final String type) {\n        List<QueuedRecordBean> result = null;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            result = getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List<QueuedRecordBean> getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List<QueuedRecordBean> getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException {\n        final List<QueuedRecordBean> result = new ArrayList<QueuedRecordBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember = new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs != null) {\n                rs.close();\n            }\n            if (ps != null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId = temp.getShortMetadata().getMetadataId();\n            // Here we're putting a MetadataBean into a ShortMetadataBean reference\n            // because it's necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return <code>true</code> if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result = false;\n        if (null == queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null == queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate = null != queuedRecord.getQueuedRecordId();\n        final String sql = isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final QueuedRecordBean temp = new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final CompleteMetadataBean cmb = md.getCompleteMetadata(metadataId, conn);\n            final Date now = new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/catalog/QueueDAOTest4.java",
		"test_prompt": "// QueueDAOTest4.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#markRecordCataloged(String)} method.\n*/\nclass QueueDAOTest4 {"
	},
	{
		"original_code": "// QueueDAO.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A DAO for managing queues stored in the database\n */\npublic class QueueDAO implements Serializable {\n\n    public QueueDAO() {\n    }\n\n    public static final String TYPE_APPROVAL = new String(\"approval\");\n\n    public static final String TYPE_CATALOG = new String(\"catalog\");\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private MetadataDAO md = new MetadataDAO();\n\n    private static final String SELECT_QUEUE_BY_TYPE = \"SELECT QueuedRecordId,\" + \" MetadataId, Status, Comments FROM QueuedRecords WHERE Type LIKE ?\";\n\n    private static final String INSERT_QUEUE_ENTRY = \"INSERT INTO QueuedRecords\" + \" (Type, MetadataId, Status, Comments) VALUES (?, ?, ?, ?)\";\n\n    private static final String UPDATE_QUEUE_ENTRY = \"UPDATE QueuedRecords\" + \" SET Type = ?, MetadataId = ?, Status = ?, Comments = ? WHERE\" + \" QueuedRecordId = ?\";\n\n    private static final String DELETE_QUEUE_ENTRY = \"DELETE FROM QueuedRecords\" + \" WHERE QueuedRecordId = ?\";\n\n    public void setDataSource(final DataSource dataSource) {\n        this.dataSource = dataSource;\n        cd.setDataSource(dataSource);\n        md.setDataSource(dataSource);\n    }\n\n    /**\n     * @param type The type of QueuedRecordBeans to get.\n     *\n     * @return A List of QueuedRecordBeans.\n     */\n    public List<QueuedRecordBean> getQueueByType(final String type) {\n        List<QueuedRecordBean> result = null;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            result = getQueue(type, conn);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the catalog queue.\n     */\n    public List<QueuedRecordBean> getCatalogQueue() {\n        return getQueueByType(TYPE_CATALOG);\n    }\n\n    /**\n     * @return The List of QueuedRecordBeans representing the approval queue.\n     */\n    public List<QueuedRecordBean> getApprovalQueue() {\n        return getQueueByType(TYPE_APPROVAL);\n    }\n\n    public List<QueuedRecordBean> getQueue(final String type, final Connection conn) throws SQLException {\n        final List<QueuedRecordBean> result = new ArrayList<QueuedRecordBean>();\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(SELECT_QUEUE_BY_TYPE);\n            ps.setString(1, type);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                final QueuedRecordBean queueMember = new QueuedRecordBean();\n                queueMember.setQueuedRecordId(rs.getString(1));\n                queueMember.getShortMetadata().setMetadataId(rs.getString(2));\n                queueMember.setStatus(rs.getString(3));\n                queueMember.setComments(rs.getString(4));\n                result.add(queueMember);\n            }\n        } finally {\n            if (rs != null) {\n                rs.close();\n            }\n            if (ps != null) {\n                ps.close();\n            }\n        }\n        for (QueuedRecordBean temp : result) {\n            final String metadataId = temp.getShortMetadata().getMetadataId();\n            // Here we're putting a MetadataBean into a ShortMetadataBean reference\n            // because it's necessary for the queue display pages\n            temp.setShortMetadata(md.getMetadata(metadataId));\n        }\n        return result;\n    }\n\n    /**\n     * Saves a {@link QueuedRecordBean} to the database.\n     *\n     * @param queuedRecord A non-null QueuedRecordBean to save.\n     *\n     * @return <code>true</code> if the save is successful, false otherwise.\n     */\n    public boolean saveQueuedRecord(final QueuedRecordBean queuedRecord) {\n        boolean result = false;\n        if (null == queuedRecord) {\n            throw new IllegalArgumentException(\"queuedRecord argument must be non-null\");\n        }\n        if (null == queuedRecord.getType()) {\n            throw new IllegalArgumentException(\"Cannot save a QueuedRecordBean without a type\");\n        }\n        if (null == queuedRecord.getShortMetadata() || null == queuedRecord.getShortMetadata().getMetadataId()) {\n            throw new IllegalArgumentException(\"Cannot save a queued record without a metadataId\");\n        }\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            saveQueuedRecord(queuedRecord, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void saveQueuedRecord(final QueuedRecordBean queuedRecord, final Connection conn) throws SQLException {\n        final boolean isUpdate = null != queuedRecord.getQueuedRecordId();\n        final String sql = isUpdate ? UPDATE_QUEUE_ENTRY : INSERT_QUEUE_ENTRY;\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, queuedRecord.getType());\n            ps.setString(2, queuedRecord.getShortMetadata().getMetadataId());\n            ps.setString(3, queuedRecord.getStatus());\n            ps.setString(4, queuedRecord.getComments());\n            if (isUpdate) {\n                ps.setString(5, queuedRecord.getQueuedRecordId());\n            }\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean enqueue(final String type, final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final QueuedRecordBean temp = new QueuedRecordBean();\n            temp.setType(type);\n            temp.getShortMetadata().setMetadataId(metadataId);\n            saveQueuedRecord(temp, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean dequeue(final String queuedRecordId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            dequeue(queuedRecordId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public void dequeue(final String queuedRecordId, final Connection conn) throws SQLException {\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(DELETE_QUEUE_ENTRY);\n            ps.setString(1, queuedRecordId);\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public boolean markRecordApproved(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"ApproveDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean markRecordCataloged(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            final CompleteMetadataBean cmb = md.getCompleteMetadata(metadataId, conn);\n            final Date now = new Date();\n            cmb.setCatalogDate(now);\n            cmb.setPublicationDate(now);\n            cmb.setPrivate(false);\n            md.saveCompleteMetadata(cmb, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n\n    public boolean rejectRecord(final String metadataId) {\n        boolean result = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            cd.updateMetadataTimestampProperty(\"RejectDate\", new Timestamp(System.currentTimeMillis()), metadataId, conn);\n            result = true;\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (null != conn) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/catalog/QueueDAOTest5.java",
		"test_prompt": "// QueueDAOTest5.java\npackage org.heal.module.catalog;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QueueDAO}.\n* It contains ten unit test cases for the {@link QueueDAO#rejectRecord(String)} method.\n*/\nclass QueueDAOTest5 {"
	},
	{
		"original_code": "// AdministrationDAO.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\n\n/**\n * This DAO was created by Grace, its content came from original AdministrationServicesBean.java.\n * @author Seth Wright\n * @modify by Grace Yang\n * @version 0.1\n */\npublic class AdministrationDAO implements Serializable {\n\n    //The accessor for database information\n    private DataSource dataSource;\n\n    CommonDAO cd = new CommonDAO();\n\n    //The java bean/module used for getting the user information\n    private UserRegistryBean userRegistry = null;\n\n    //The file locator used to locate content to be deleted.\n    private FileLocator fileLocator = null;\n\n    /**\n     * Sets the file locator to be used to translate metadata location\n     * entries into file paths so that the deleteContent method can\n     * actually delete the content.\n     */\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Returns the FileLocator being used by the Admin services.\n     */\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Sets the module used by the administration services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Performs a possible long running overall consistency and integrity\n     * check of the data in teh library.  Returns a IntegrityReportBean\n     * that contains statistics on corrupt files, orphaned files, content\n     * without metadata, missing files, and duplicate files.\n     */\n    public void checkSystemIntegrity() {\n        //XXX not implemented\n    }\n\n    /**\n     * Marks a given metadata's entry as hidden, thus keeping it from showing\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean hideContent(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", true, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Marks a given metadata's entry as visible, thus allowing it to show\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean makeContentVisible(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", false, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Removes all references to the metadata from the metadata tables, then\n     * makes a new entry in the DeletedItems table.  Finally, the content\n     * file itself is deleted.\n     * Note:  All entries in the database associated with the metadata\n     * will be deleted, this includes taxons related to taxon paths associated\n     * with the metadata Id.  Also, copyright texts that are only referenced\n     * from copyright entries associated with this metadata Id will also\n     * be deleted.\n     */\n    public boolean deleteContent(String metadataId) {\n        boolean success = false;\n        MetadataBean metadata;\n        ThumbnailBean thumbnail;\n        String thumbnailLocation;\n        File thumbnailFile;\n        String contentLocation;\n        File contentFile;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            metadata = cd.getMetadata(metadataId, conn);\n            if (metadata != null) {\n                contentLocation = metadata.getLocation();\n                thumbnail = cd.getThumbnail(metadataId, conn);\n                if (thumbnail != null) {\n                    thumbnailLocation = thumbnail.getLocation();\n                    if (thumbnailLocation != null) {\n                        thumbnailFile = new File(fileLocator.getThumbnailFilePath(thumbnailLocation));\n                        if (thumbnailFile != null) {\n                            thumbnailFile.delete();\n                        }\n                    }\n                }\n                moveToDeletedItems(metadataId, \"Content deleted.\", conn);\n                conn.commit();\n                contentFile = new File(fileLocator.getContentFilePath(contentLocation));\n                if (contentFile != null) {\n                    success = contentFile.delete();\n                } else {\n                    success = true;\n                }\n            } else {\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                } catch (Exception ex) {\n                    //ignore for now\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Sets the permissions of the user in the database.\n     * Returns true if the permissions were successfully set, false if\n     * an error occured.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        return userRegistry.setPermissions(userId, permissions);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            cd.updateMetadataValueProperty(propertyName, propertyValue, metadataId, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = cd.getMetadata(metadataId, conn);\n        cd.addToDeletedItems(metadata, comment, conn);\n        success = cd.deleteMetadataReferences(metadataId, conn);\n        cd.removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/admin/AdministrationDAOTest0.java",
		"test_prompt": "// AdministrationDAOTest0.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministrationDAO}.\n* It contains ten unit test cases for the {@link AdministrationDAO#hideContent(String)} method.\n*/\nclass AdministrationDAOTest0 {"
	},
	{
		"original_code": "// AdministrationDAO.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\n\n/**\n * This DAO was created by Grace, its content came from original AdministrationServicesBean.java.\n * @author Seth Wright\n * @modify by Grace Yang\n * @version 0.1\n */\npublic class AdministrationDAO implements Serializable {\n\n    //The accessor for database information\n    private DataSource dataSource;\n\n    CommonDAO cd = new CommonDAO();\n\n    //The java bean/module used for getting the user information\n    private UserRegistryBean userRegistry = null;\n\n    //The file locator used to locate content to be deleted.\n    private FileLocator fileLocator = null;\n\n    /**\n     * Sets the file locator to be used to translate metadata location\n     * entries into file paths so that the deleteContent method can\n     * actually delete the content.\n     */\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Returns the FileLocator being used by the Admin services.\n     */\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Sets the module used by the administration services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Performs a possible long running overall consistency and integrity\n     * check of the data in teh library.  Returns a IntegrityReportBean\n     * that contains statistics on corrupt files, orphaned files, content\n     * without metadata, missing files, and duplicate files.\n     */\n    public void checkSystemIntegrity() {\n        //XXX not implemented\n    }\n\n    /**\n     * Marks a given metadata's entry as hidden, thus keeping it from showing\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean hideContent(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", true, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Marks a given metadata's entry as visible, thus allowing it to show\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean makeContentVisible(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", false, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Removes all references to the metadata from the metadata tables, then\n     * makes a new entry in the DeletedItems table.  Finally, the content\n     * file itself is deleted.\n     * Note:  All entries in the database associated with the metadata\n     * will be deleted, this includes taxons related to taxon paths associated\n     * with the metadata Id.  Also, copyright texts that are only referenced\n     * from copyright entries associated with this metadata Id will also\n     * be deleted.\n     */\n    public boolean deleteContent(String metadataId) {\n        boolean success = false;\n        MetadataBean metadata;\n        ThumbnailBean thumbnail;\n        String thumbnailLocation;\n        File thumbnailFile;\n        String contentLocation;\n        File contentFile;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            metadata = cd.getMetadata(metadataId, conn);\n            if (metadata != null) {\n                contentLocation = metadata.getLocation();\n                thumbnail = cd.getThumbnail(metadataId, conn);\n                if (thumbnail != null) {\n                    thumbnailLocation = thumbnail.getLocation();\n                    if (thumbnailLocation != null) {\n                        thumbnailFile = new File(fileLocator.getThumbnailFilePath(thumbnailLocation));\n                        if (thumbnailFile != null) {\n                            thumbnailFile.delete();\n                        }\n                    }\n                }\n                moveToDeletedItems(metadataId, \"Content deleted.\", conn);\n                conn.commit();\n                contentFile = new File(fileLocator.getContentFilePath(contentLocation));\n                if (contentFile != null) {\n                    success = contentFile.delete();\n                } else {\n                    success = true;\n                }\n            } else {\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                } catch (Exception ex) {\n                    //ignore for now\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Sets the permissions of the user in the database.\n     * Returns true if the permissions were successfully set, false if\n     * an error occured.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        return userRegistry.setPermissions(userId, permissions);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            cd.updateMetadataValueProperty(propertyName, propertyValue, metadataId, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = cd.getMetadata(metadataId, conn);\n        cd.addToDeletedItems(metadata, comment, conn);\n        success = cd.deleteMetadataReferences(metadataId, conn);\n        cd.removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/admin/AdministrationDAOTest1.java",
		"test_prompt": "// AdministrationDAOTest1.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministrationDAO}.\n* It contains ten unit test cases for the {@link AdministrationDAO#makeContentVisible(String)} method.\n*/\nclass AdministrationDAOTest1 {"
	},
	{
		"original_code": "// AdministrationDAO.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\n\n/**\n * This DAO was created by Grace, its content came from original AdministrationServicesBean.java.\n * @author Seth Wright\n * @modify by Grace Yang\n * @version 0.1\n */\npublic class AdministrationDAO implements Serializable {\n\n    //The accessor for database information\n    private DataSource dataSource;\n\n    CommonDAO cd = new CommonDAO();\n\n    //The java bean/module used for getting the user information\n    private UserRegistryBean userRegistry = null;\n\n    //The file locator used to locate content to be deleted.\n    private FileLocator fileLocator = null;\n\n    /**\n     * Sets the file locator to be used to translate metadata location\n     * entries into file paths so that the deleteContent method can\n     * actually delete the content.\n     */\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Returns the FileLocator being used by the Admin services.\n     */\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Sets the module used by the administration services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Performs a possible long running overall consistency and integrity\n     * check of the data in teh library.  Returns a IntegrityReportBean\n     * that contains statistics on corrupt files, orphaned files, content\n     * without metadata, missing files, and duplicate files.\n     */\n    public void checkSystemIntegrity() {\n        //XXX not implemented\n    }\n\n    /**\n     * Marks a given metadata's entry as hidden, thus keeping it from showing\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean hideContent(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", true, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Marks a given metadata's entry as visible, thus allowing it to show\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean makeContentVisible(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", false, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Removes all references to the metadata from the metadata tables, then\n     * makes a new entry in the DeletedItems table.  Finally, the content\n     * file itself is deleted.\n     * Note:  All entries in the database associated with the metadata\n     * will be deleted, this includes taxons related to taxon paths associated\n     * with the metadata Id.  Also, copyright texts that are only referenced\n     * from copyright entries associated with this metadata Id will also\n     * be deleted.\n     */\n    public boolean deleteContent(String metadataId) {\n        boolean success = false;\n        MetadataBean metadata;\n        ThumbnailBean thumbnail;\n        String thumbnailLocation;\n        File thumbnailFile;\n        String contentLocation;\n        File contentFile;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            metadata = cd.getMetadata(metadataId, conn);\n            if (metadata != null) {\n                contentLocation = metadata.getLocation();\n                thumbnail = cd.getThumbnail(metadataId, conn);\n                if (thumbnail != null) {\n                    thumbnailLocation = thumbnail.getLocation();\n                    if (thumbnailLocation != null) {\n                        thumbnailFile = new File(fileLocator.getThumbnailFilePath(thumbnailLocation));\n                        if (thumbnailFile != null) {\n                            thumbnailFile.delete();\n                        }\n                    }\n                }\n                moveToDeletedItems(metadataId, \"Content deleted.\", conn);\n                conn.commit();\n                contentFile = new File(fileLocator.getContentFilePath(contentLocation));\n                if (contentFile != null) {\n                    success = contentFile.delete();\n                } else {\n                    success = true;\n                }\n            } else {\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                } catch (Exception ex) {\n                    //ignore for now\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Sets the permissions of the user in the database.\n     * Returns true if the permissions were successfully set, false if\n     * an error occured.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        return userRegistry.setPermissions(userId, permissions);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            cd.updateMetadataValueProperty(propertyName, propertyValue, metadataId, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = cd.getMetadata(metadataId, conn);\n        cd.addToDeletedItems(metadata, comment, conn);\n        success = cd.deleteMetadataReferences(metadataId, conn);\n        cd.removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/admin/AdministrationDAOTest2.java",
		"test_prompt": "// AdministrationDAOTest2.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministrationDAO}.\n* It contains ten unit test cases for the {@link AdministrationDAO#deleteContent(String)} method.\n*/\nclass AdministrationDAOTest2 {"
	},
	{
		"original_code": "// AdministrationDAO.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\n\n/**\n * This DAO was created by Grace, its content came from original AdministrationServicesBean.java.\n * @author Seth Wright\n * @modify by Grace Yang\n * @version 0.1\n */\npublic class AdministrationDAO implements Serializable {\n\n    //The accessor for database information\n    private DataSource dataSource;\n\n    CommonDAO cd = new CommonDAO();\n\n    //The java bean/module used for getting the user information\n    private UserRegistryBean userRegistry = null;\n\n    //The file locator used to locate content to be deleted.\n    private FileLocator fileLocator = null;\n\n    /**\n     * Sets the file locator to be used to translate metadata location\n     * entries into file paths so that the deleteContent method can\n     * actually delete the content.\n     */\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Returns the FileLocator being used by the Admin services.\n     */\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Sets the module used by the administration services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Performs a possible long running overall consistency and integrity\n     * check of the data in teh library.  Returns a IntegrityReportBean\n     * that contains statistics on corrupt files, orphaned files, content\n     * without metadata, missing files, and duplicate files.\n     */\n    public void checkSystemIntegrity() {\n        //XXX not implemented\n    }\n\n    /**\n     * Marks a given metadata's entry as hidden, thus keeping it from showing\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean hideContent(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", true, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Marks a given metadata's entry as visible, thus allowing it to show\n     * up in searches, etc.  Returns true if successful, false otherwise.\n     */\n    public boolean makeContentVisible(String metadataId) {\n        boolean success = false;\n        try {\n            updateMetadataBooleanProperty(\"Private\", false, metadataId);\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Removes all references to the metadata from the metadata tables, then\n     * makes a new entry in the DeletedItems table.  Finally, the content\n     * file itself is deleted.\n     * Note:  All entries in the database associated with the metadata\n     * will be deleted, this includes taxons related to taxon paths associated\n     * with the metadata Id.  Also, copyright texts that are only referenced\n     * from copyright entries associated with this metadata Id will also\n     * be deleted.\n     */\n    public boolean deleteContent(String metadataId) {\n        boolean success = false;\n        MetadataBean metadata;\n        ThumbnailBean thumbnail;\n        String thumbnailLocation;\n        File thumbnailFile;\n        String contentLocation;\n        File contentFile;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            metadata = cd.getMetadata(metadataId, conn);\n            if (metadata != null) {\n                contentLocation = metadata.getLocation();\n                thumbnail = cd.getThumbnail(metadataId, conn);\n                if (thumbnail != null) {\n                    thumbnailLocation = thumbnail.getLocation();\n                    if (thumbnailLocation != null) {\n                        thumbnailFile = new File(fileLocator.getThumbnailFilePath(thumbnailLocation));\n                        if (thumbnailFile != null) {\n                            thumbnailFile.delete();\n                        }\n                    }\n                }\n                moveToDeletedItems(metadataId, \"Content deleted.\", conn);\n                conn.commit();\n                contentFile = new File(fileLocator.getContentFilePath(contentLocation));\n                if (contentFile != null) {\n                    success = contentFile.delete();\n                } else {\n                    success = true;\n                }\n            } else {\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                } catch (Exception ex) {\n                    //ignore for now\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Sets the permissions of the user in the database.\n     * Returns true if the permissions were successfully set, false if\n     * an error occured.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        return userRegistry.setPermissions(userId, permissions);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataBooleanProperty(String propertyName, boolean propertyValue, String metadataId) throws SQLException {\n        updateMetadataValueProperty(propertyName, new BooleanValue(propertyValue), metadataId);\n    }\n\n    /**\n     * Given a property name and value and a metadata Id, updates\n     * the metadata's table to reflect the given value.\n     */\n    public void updateMetadataValueProperty(String propertyName, Value propertyValue, String metadataId) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            cd.updateMetadataValueProperty(propertyName, propertyValue, metadataId, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = cd.getMetadata(metadataId, conn);\n        cd.addToDeletedItems(metadata, comment, conn);\n        success = cd.deleteMetadataReferences(metadataId, conn);\n        cd.removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/admin/AdministrationDAOTest3.java",
		"test_prompt": "// AdministrationDAOTest3.java\npackage org.heal.module.admin;\n\nimport java.io.*;\nimport java.sql.SQLException;\nimport java.sql.*;\nimport javax.sql.DataSource;\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport org.heal.module.user.*;\nimport org.heal.util.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministrationDAO}.\n* It contains ten unit test cases for the {@link AdministrationDAO#moveToDeletedItems(String, String, Connection)} method.\n*/\nclass AdministrationDAOTest3 {"
	},
	{
		"original_code": "// UserRegistryBean.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\n/**\n * This contains methods for authenticating a user,\n * and retrieving and updating user information.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserRegistryBean implements Serializable {\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Returns true if the specified user name and password\n     * match an employee in the database.\n     */\n    public UserBean verifyLogin(String userName, String password, boolean emailIsUsername) throws SQLException {\n        UserBean userInfo = getUser(userName, emailIsUsername);\n        if (userInfo != null && password.equals(userInfo.getPassword())) {\n            return userInfo;\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the given user has the specified permissions.\n     */\n    public boolean checkPermissions(UserBean user, String accessLevel) {\n        /* XXX not currently implemented */\n        return false;\n    }\n\n    /**\n     * Returns true if the user was found in the database, false\n     * otherwise.  Throws an SQLException in the event something goes\n     * wrong.\n     */\n    public boolean userExists(String userName) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(userName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return (userRow != null);\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUserIds() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserId FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserId\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUsernames() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfUsers() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(distinct email) as Expr1 FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getAreaofExpertiseSummary(String value) throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(userid) as Expr1 FROM USERS where professionalSpecialty = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new StringValue(value));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified employee, or null if\n     * not found.\n     */\n    public UserBean getUser(String userName, boolean emailIsUsername) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserProperties(userName, emailIsUsername, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it2 = userInstructionalLevel.iterator();\n            while (it2.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it2.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified email address, or null if\n     * not found.\n     */\n    public UserBean getUserFromEmail(String email) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(email, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return rowToBean(userRow);\n    }\n\n    public UserBean getUserFromID(String userID) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserPropertiesFromID(userID, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it = userInstructionalLevel.iterator();\n            while (it.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAreaofExpertiseValues() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT distinct ProfessionalSpecialty FROM USERS where modifiedLogin = '1'\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"ProfessionalSpecialty\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private UserBean rowToBean(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        UserBean userInfo = new UserBean();\n        try {\n            userInfo.setUserId(userRow.getString(\"UserID\"));\n            userInfo.setUserName(userRow.getString(\"UserName\"));\n            userInfo.setPassword(userRow.getString(\"Password\"));\n            userInfo.setMinor(userRow.getBoolean(\"Minor\"));\n            userInfo.setAdministrator(userRow.getBoolean(\"Administrator\"));\n            userInfo.setCataloger(userRow.getBoolean(\"Cataloger\"));\n            userInfo.setApprover(userRow.getBoolean(\"Approver\"));\n            userInfo.setFirstName(userRow.getString(\"FirstName\"));\n            userInfo.setLastName(userRow.getString(\"LastName\"));\n            userInfo.setMiddleInitial(userRow.getString(\"MI\"));\n            userInfo.setEmail(userRow.getString(\"Email\"));\n            //userInfo.setProfessionalTitle(userRow.getString(\"ProfessionalTitle\"));\n            userInfo.setProfessionalSpecialty(userRow.getString(\"ProfessionalSpecialty\"));\n            userInfo.setPhoneNumber(userRow.getString(\"PhoneNumber\"));\n            userInfo.setInstitutionName(userRow.getString(\"InstitutionName\"));\n            userInfo.setAddress1(userRow.getString(\"Address1\"));\n            userInfo.setAddress2(userRow.getString(\"Address2\"));\n            userInfo.setCity(userRow.getString(\"City\"));\n            userInfo.setState(userRow.getString(\"State\"));\n            userInfo.setZipCode(userRow.getString(\"ZipCode\"));\n            userInfo.setCountry(userRow.getString(\"Country\"));\n            userInfo.setMailingList(userRow.getBoolean(\"mailingList\"));\n            userInfo.setLoginModified(userRow.getBoolean(\"modifiedLogin\"));\n            userInfo.setEmailValidated(userRow.getBoolean(\"emailValidated\"));\n            userInfo.setIAMSEMember(userRow.getBoolean(\"IAMSEMember\"));\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return userInfo;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private ProfessionalRoleBean rowToProfessionalRole(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        ProfessionalRoleBean professionalRole = new ProfessionalRoleBean();\n        try {\n            professionalRole.setProfessionalRoleId(userRow.getString(\"ProfessionalRoleId\"));\n            professionalRole.setUserId(userRow.getString(\"UserId\"));\n            professionalRole.setProfessionalRole(userRow.getString(\"ProfessionalRole\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return professionalRole;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private InstructionalLevelBean rowToInstructionalLevel(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        InstructionalLevelBean instructionalLevel = new InstructionalLevelBean();\n        try {\n            instructionalLevel.setInstructionalLevelId(userRow.getString(\"InstructionalLevelId\"));\n            instructionalLevel.setUserId(userRow.getString(\"UserId\"));\n            instructionalLevel.setInstructionalLevel(userRow.getString(\"InstructionalLevel\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return instructionalLevel;\n    }\n\n    /**\n     * Inserts the information about the specified user, or\n     * updates the information if it's already defined.\n     */\n    public String saveRegistration(UserBean userInfo) throws SQLException {\n        // Save the user info from the database\n        Connection conn = dataSource.getConnection();\n        Connection conn2 = dataSource.getConnection();\n        String userId = \"\";\n        conn.setAutoCommit(false);\n        conn2.setAutoCommit(false);\n        try {\n            saveCompleteUserProperties(userInfo, conn);\n            conn.commit();\n            userId = userInfo.getUserId();\n            if (userInfo.getUserId() == null || userInfo.getUserId().length() == 0) {\n                UserBean userInfo2 = getUserFromEmail(userInfo.getEmail());\n                userInfo.setUserId(userInfo2.getUserId());\n                userId = userInfo2.getUserId();\n            }\n            saveUserProfessionalRole(userInfo, conn2);\n            saveUserInstructionalLevel(userInfo, conn2);\n            conn2.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n                conn2.setAutoCommit(true);\n                conn2.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return userId;\n    }\n\n    /**\n     * Inserts the XML encoded user registration information into the\n     * database, or updates the information if it is already defined.\n     */\n    public void saveRegistration(String xmlRegistration) throws SQLException {\n        UserBean userInfo = new UserBean();\n        userInfo.parseXML(xmlRegistration);\n        saveRegistration(userInfo);\n    }\n\n    /**\n     * Looks up a user property in the Users table that matches the given\n     * UserName.  The property should be a String value such that calling\n     * Row.getString() doesn't cause any problems.\n     */\n    private String getUserStringProperty(String userName, String propertyName, Connection conn) throws SQLException {\n        if (userName == null || propertyName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT \" + propertyName + \" FROM USERS WHERE UserName = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        String result = null;\n        try {\n            result = aRow.getString(propertyName);\n        } catch (NoSuchColumnException ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserProperties(String userName, boolean emailIsUsername, Connection conn) throws SQLException {\n        if (userName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"\";\n        if (emailIsUsername) {\n            sql = \"SELECT * FROM USERS WHERE Email = ? and modifiedLogin = 1\";\n        } else {\n            sql = \"SELECT * FROM USERS WHERE UserName = ?\";\n        }\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserProfessionalRole(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersProfessionalRole WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserInstructionalLevel(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersInstructionalLevel WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserPropertiesFromID(String userID, Connection conn) throws SQLException {\n        if (userID == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userID));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user's email address is not found.\n     */\n    private Row getUserPropertiesFromEmail(String email, Connection conn) throws SQLException {\n        if (email == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE email = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(email));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Given a user ID and a set of permissions, looks up the user in the\n     * database and if the user is found, updates their permissions.  Returns\n     * false if either parameter is null, the user was not found in the\n     * database, or an error occured.  Otherwise the method returns true.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        if (userId == null || permissions == null) {\n            return false;\n        }\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            Row userRow = getUserProperties(userId, false, conn);\n            UserBean user = rowToBean(userRow);\n            if (user != null) {\n                user.setMinor(permissions.isMinor());\n                user.setAdministrator(permissions.isAdministrator());\n                user.setCataloger(permissions.isCataloger());\n                user.setApprover(permissions.isApprover());\n                saveUserProperties(user, conn);\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveCompleteUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        saveUserProperties(userInfo, conn);\n        //conn.commit();\n        //if(userInfo.getUserId() == null || userInfo.getUserId().length()==0)\n        //{\n        //userInfo=getUserFromEmail(userInfo.getEmail());\n        //}\n        //saveUserProfessionalRole(userInfo, conn);\n        //saveUserInstructionalLevel(userInfo, conn);\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        UserBean dbInfo = getUser(userInfo.getUserName(), false);\n        StringBuffer sql = new StringBuffer();\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Users \").append(\"(Password, Minor, Administrator, \").append(\"Cataloger, Approver, FirstName, LastName, MI, \").//append(\"Email, ProfessionalTitle, ProfessionalSpecialty, \").\n            append(\"Email, ProfessionalSpecialty, \").append(\"PhoneNumber, InstitutionName, Address1, Address2, \").append(\"City, State, ZipCode, Country, mailingList, modifiedLogin, emailValidated, IAMSEMember, UserName) \").append(\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \").append(\"?, ?, ?, ?, ?, ?, ?, ?,?,?)\");\n        } else {\n            // Use UPDATE statement\n            sql.append(\"UPDATE Users SET \").append(\"Password = ?, Minor = ?, Administrator = ?, \").append(\"Cataloger = ?, Approver = ?, FirstName = ?, \").append(\"LastName = ?, MI = ?, Email = ?, \").//append(\"ProfessionalTitle = ?, ProfessionalSpecialty = ?, \").\n            append(\"ProfessionalSpecialty = ?, \").append(\"PhoneNumber = ?, InstitutionName = ?, Address1 = ?, \").append(\"Address2 = ?, City = ?, State = ?, ZipCode = ?, \").append(\"Country = ?, mailingList = ?, modifiedLogin = ?, emailValidated = ?, IAMSEMember = ? WHERE UserName= ?\");\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql.toString());\n            ps.setString(1, userInfo.getPassword());\n            ps.setBoolean(2, userInfo.isMinor());\n            ps.setBoolean(3, userInfo.isAdministrator());\n            ps.setBoolean(4, userInfo.isCataloger());\n            ps.setBoolean(5, userInfo.isApprover());\n            ps.setString(6, userInfo.getFirstName());\n            ps.setString(7, userInfo.getLastName());\n            ps.setString(8, userInfo.getMiddleInitial());\n            ps.setString(9, userInfo.getEmail());\n            //ps.setString(10, userInfo.getProfessionalTitle());\n            ps.setString(10, userInfo.getProfessionalSpecialty());\n            ps.setString(11, userInfo.getPhoneNumber());\n            ps.setString(12, userInfo.getInstitutionName());\n            ps.setString(13, userInfo.getAddress1());\n            ps.setString(14, userInfo.getAddress2());\n            ps.setString(15, userInfo.getCity());\n            ps.setString(16, userInfo.getState());\n            ps.setString(17, userInfo.getZipCode());\n            ps.setString(18, userInfo.getCountry());\n            ps.setBoolean(19, userInfo.getMailingList());\n            ps.setBoolean(20, true);\n            ps.setBoolean(21, userInfo.isEmailValidated());\n            ps.setBoolean(22, userInfo.isIAMSEMember());\n            ps.setString(23, userInfo.getUserName());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n    }\n\n    public void reset(String username) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET modifiedLogin = 0 where username = ?\");\n            ps.setString(1, username);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean validateEmail(String email, int userId) {\n        PreparedStatement ps = null;\n        int rowCount = 0;\n        boolean update = false;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 1 where email = ? and userId = ?\");\n            ps.setString(1, email);\n            ps.setInt(2, userId);\n            rowCount = ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n        if (rowCount > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateEmail(String email, String newemail) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 0, UserName = ?, email= ? where email = ?\");\n            ps.setString(1, newemail);\n            ps.setString(2, newemail);\n            ps.setString(3, email);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n        } finally {\n            if (null != ps) {\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProfessionalRole(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersProfessionalRole where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        ProfessionalRoleBean prb = null;\n        ArrayList prbs = userInfo.getProfessionalRole();\n        Iterator it = prbs.iterator();\n        while (it.hasNext()) {\n            prb = (ProfessionalRoleBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersProfessionalRole \").append(\"(UserId, ProfessionalRole) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, prb.getProfessionalRole());\n                //System.err.println(\"heree\");\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserInstructionalLevel(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersInstructionalLevel where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        InstructionalLevelBean ilb = null;\n        ArrayList ilbs = userInfo.getInstructionalLevel();\n        Iterator it = ilbs.iterator();\n        while (it.hasNext()) {\n            ilb = (InstructionalLevelBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersInstructionalLevel \").append(\"(UserId, InstructionalLevel) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, ilb.getInstructionalLevel());\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and adds an entry for it\n     * in the Subscriber's table (if it doesn't already exist).\n     * Returns true if successful (also if it already exists in the table)\n     * and false if an error occurs.\n     */\n    public boolean addUserToSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                if (getSubscriber(userId, conn) != null) {\n                    success = true;\n                } else {\n                    success = addSubscriber(userId, conn);\n                }\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and removes any entries for it\n     * in the Subscriber's table.  Returns true if on success and false if\n     * an error occurs.\n     */\n    public boolean removeUserFromSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                success = deleteSubscriber(userId, conn);\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to delete a subscriber from the subscribers table.\n     * This method will delete all subscribers found with the given\n     * UserID (there should only be one, but just in case).\n     */\n    private boolean deleteSubscriber(String userId, Connection conn) throws SQLException {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use DELETE statement\n            sql.append(\"DELETE FROM Subscribers WHERE UserID = ?\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to add a subscriber to the subscribers table.\n     * This method will insert a subscriber regardless of whether or not\n     * it already exists in the tabel.\n     */\n    private boolean addSubscriber(String userId, Connection conn) {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Subscribers (UserID) VALUES(?)\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * If the given userId is found in the subscriber table, then\n     * its corresponding Row is returned.  Otherwise, null is returned\n     * if no subscriber is found.  In case of an error, an SQLException\n     * is throw.\n     */\n    private Row getSubscriber(String userId, Connection conn) throws SQLException {\n        if (userId == null || conn == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM Subscribers WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Looks up all entries in the Users table with a true value for the\n     * administrator setting.  Returns an ArrayList of Strings containing\n     * the email addresses of the found users.\n     */\n    public ArrayList getAdminEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE Administrator = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new BooleanValue(true));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the usernames corresponding to user ids\n     * found in the subscribers table.\n     * Returns an ArrayList of strings.\n     */\n    public ArrayList getAllSubscribers() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList users = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    users = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        users.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            users = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return users;\n    }\n\n    /**\n     * This method gets all of the email addresses found in the users table\n     * corresponding to the given usernames.  Only users with email addresses\n     * in the table will have a value returned.  If an error occurs, null is\n     * returned, other wise a possibly empty (if no user email addresses were\n     * found) ArrayList is returned.\n     */\n    public ArrayList getEmailAddresses(String[] userNames) {\n        //Get the useraddresses from the database\n        if (userNames == null || userNames.length <= 0) {\n            return null;\n        }\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sqlBuffer = new StringBuffer(\"SELECT Email FROM Users WHERE \");\n            sqlBuffer.append(\"UserName = '\" + userNames[0] + \"'\");\n            for (int i = 1; i < userNames.length; i++) {\n                sqlBuffer.append(\" or UserName = '\" + userNames[i] + \"'\");\n            }\n            sqlCommandBean.setSqlValue(sqlBuffer.toString());\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the userIDs found in the subscribers table and\n     * then looks up all the email addresses of those entries from the\n     * Users table.\n     */\n    public ArrayList getSubscriberEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserRegistryBeanTest0.java",
		"test_prompt": "// UserRegistryBeanTest0.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserRegistryBean}.\n* It contains ten unit test cases for the {@link UserRegistryBean#verifyLogin(String, String, boolean)} method.\n*/\nclass UserRegistryBeanTest0 {"
	},
	{
		"original_code": "// UserRegistryBean.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\n/**\n * This contains methods for authenticating a user,\n * and retrieving and updating user information.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserRegistryBean implements Serializable {\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Returns true if the specified user name and password\n     * match an employee in the database.\n     */\n    public UserBean verifyLogin(String userName, String password, boolean emailIsUsername) throws SQLException {\n        UserBean userInfo = getUser(userName, emailIsUsername);\n        if (userInfo != null && password.equals(userInfo.getPassword())) {\n            return userInfo;\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the given user has the specified permissions.\n     */\n    public boolean checkPermissions(UserBean user, String accessLevel) {\n        /* XXX not currently implemented */\n        return false;\n    }\n\n    /**\n     * Returns true if the user was found in the database, false\n     * otherwise.  Throws an SQLException in the event something goes\n     * wrong.\n     */\n    public boolean userExists(String userName) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(userName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return (userRow != null);\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUserIds() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserId FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserId\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUsernames() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfUsers() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(distinct email) as Expr1 FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getAreaofExpertiseSummary(String value) throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(userid) as Expr1 FROM USERS where professionalSpecialty = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new StringValue(value));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified employee, or null if\n     * not found.\n     */\n    public UserBean getUser(String userName, boolean emailIsUsername) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserProperties(userName, emailIsUsername, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it2 = userInstructionalLevel.iterator();\n            while (it2.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it2.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified email address, or null if\n     * not found.\n     */\n    public UserBean getUserFromEmail(String email) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(email, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return rowToBean(userRow);\n    }\n\n    public UserBean getUserFromID(String userID) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserPropertiesFromID(userID, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it = userInstructionalLevel.iterator();\n            while (it.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAreaofExpertiseValues() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT distinct ProfessionalSpecialty FROM USERS where modifiedLogin = '1'\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"ProfessionalSpecialty\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private UserBean rowToBean(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        UserBean userInfo = new UserBean();\n        try {\n            userInfo.setUserId(userRow.getString(\"UserID\"));\n            userInfo.setUserName(userRow.getString(\"UserName\"));\n            userInfo.setPassword(userRow.getString(\"Password\"));\n            userInfo.setMinor(userRow.getBoolean(\"Minor\"));\n            userInfo.setAdministrator(userRow.getBoolean(\"Administrator\"));\n            userInfo.setCataloger(userRow.getBoolean(\"Cataloger\"));\n            userInfo.setApprover(userRow.getBoolean(\"Approver\"));\n            userInfo.setFirstName(userRow.getString(\"FirstName\"));\n            userInfo.setLastName(userRow.getString(\"LastName\"));\n            userInfo.setMiddleInitial(userRow.getString(\"MI\"));\n            userInfo.setEmail(userRow.getString(\"Email\"));\n            //userInfo.setProfessionalTitle(userRow.getString(\"ProfessionalTitle\"));\n            userInfo.setProfessionalSpecialty(userRow.getString(\"ProfessionalSpecialty\"));\n            userInfo.setPhoneNumber(userRow.getString(\"PhoneNumber\"));\n            userInfo.setInstitutionName(userRow.getString(\"InstitutionName\"));\n            userInfo.setAddress1(userRow.getString(\"Address1\"));\n            userInfo.setAddress2(userRow.getString(\"Address2\"));\n            userInfo.setCity(userRow.getString(\"City\"));\n            userInfo.setState(userRow.getString(\"State\"));\n            userInfo.setZipCode(userRow.getString(\"ZipCode\"));\n            userInfo.setCountry(userRow.getString(\"Country\"));\n            userInfo.setMailingList(userRow.getBoolean(\"mailingList\"));\n            userInfo.setLoginModified(userRow.getBoolean(\"modifiedLogin\"));\n            userInfo.setEmailValidated(userRow.getBoolean(\"emailValidated\"));\n            userInfo.setIAMSEMember(userRow.getBoolean(\"IAMSEMember\"));\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return userInfo;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private ProfessionalRoleBean rowToProfessionalRole(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        ProfessionalRoleBean professionalRole = new ProfessionalRoleBean();\n        try {\n            professionalRole.setProfessionalRoleId(userRow.getString(\"ProfessionalRoleId\"));\n            professionalRole.setUserId(userRow.getString(\"UserId\"));\n            professionalRole.setProfessionalRole(userRow.getString(\"ProfessionalRole\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return professionalRole;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private InstructionalLevelBean rowToInstructionalLevel(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        InstructionalLevelBean instructionalLevel = new InstructionalLevelBean();\n        try {\n            instructionalLevel.setInstructionalLevelId(userRow.getString(\"InstructionalLevelId\"));\n            instructionalLevel.setUserId(userRow.getString(\"UserId\"));\n            instructionalLevel.setInstructionalLevel(userRow.getString(\"InstructionalLevel\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return instructionalLevel;\n    }\n\n    /**\n     * Inserts the information about the specified user, or\n     * updates the information if it's already defined.\n     */\n    public String saveRegistration(UserBean userInfo) throws SQLException {\n        // Save the user info from the database\n        Connection conn = dataSource.getConnection();\n        Connection conn2 = dataSource.getConnection();\n        String userId = \"\";\n        conn.setAutoCommit(false);\n        conn2.setAutoCommit(false);\n        try {\n            saveCompleteUserProperties(userInfo, conn);\n            conn.commit();\n            userId = userInfo.getUserId();\n            if (userInfo.getUserId() == null || userInfo.getUserId().length() == 0) {\n                UserBean userInfo2 = getUserFromEmail(userInfo.getEmail());\n                userInfo.setUserId(userInfo2.getUserId());\n                userId = userInfo2.getUserId();\n            }\n            saveUserProfessionalRole(userInfo, conn2);\n            saveUserInstructionalLevel(userInfo, conn2);\n            conn2.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n                conn2.setAutoCommit(true);\n                conn2.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return userId;\n    }\n\n    /**\n     * Inserts the XML encoded user registration information into the\n     * database, or updates the information if it is already defined.\n     */\n    public void saveRegistration(String xmlRegistration) throws SQLException {\n        UserBean userInfo = new UserBean();\n        userInfo.parseXML(xmlRegistration);\n        saveRegistration(userInfo);\n    }\n\n    /**\n     * Looks up a user property in the Users table that matches the given\n     * UserName.  The property should be a String value such that calling\n     * Row.getString() doesn't cause any problems.\n     */\n    private String getUserStringProperty(String userName, String propertyName, Connection conn) throws SQLException {\n        if (userName == null || propertyName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT \" + propertyName + \" FROM USERS WHERE UserName = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        String result = null;\n        try {\n            result = aRow.getString(propertyName);\n        } catch (NoSuchColumnException ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserProperties(String userName, boolean emailIsUsername, Connection conn) throws SQLException {\n        if (userName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"\";\n        if (emailIsUsername) {\n            sql = \"SELECT * FROM USERS WHERE Email = ? and modifiedLogin = 1\";\n        } else {\n            sql = \"SELECT * FROM USERS WHERE UserName = ?\";\n        }\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserProfessionalRole(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersProfessionalRole WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserInstructionalLevel(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersInstructionalLevel WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserPropertiesFromID(String userID, Connection conn) throws SQLException {\n        if (userID == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userID));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user's email address is not found.\n     */\n    private Row getUserPropertiesFromEmail(String email, Connection conn) throws SQLException {\n        if (email == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE email = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(email));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Given a user ID and a set of permissions, looks up the user in the\n     * database and if the user is found, updates their permissions.  Returns\n     * false if either parameter is null, the user was not found in the\n     * database, or an error occured.  Otherwise the method returns true.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        if (userId == null || permissions == null) {\n            return false;\n        }\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            Row userRow = getUserProperties(userId, false, conn);\n            UserBean user = rowToBean(userRow);\n            if (user != null) {\n                user.setMinor(permissions.isMinor());\n                user.setAdministrator(permissions.isAdministrator());\n                user.setCataloger(permissions.isCataloger());\n                user.setApprover(permissions.isApprover());\n                saveUserProperties(user, conn);\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveCompleteUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        saveUserProperties(userInfo, conn);\n        //conn.commit();\n        //if(userInfo.getUserId() == null || userInfo.getUserId().length()==0)\n        //{\n        //userInfo=getUserFromEmail(userInfo.getEmail());\n        //}\n        //saveUserProfessionalRole(userInfo, conn);\n        //saveUserInstructionalLevel(userInfo, conn);\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        UserBean dbInfo = getUser(userInfo.getUserName(), false);\n        StringBuffer sql = new StringBuffer();\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Users \").append(\"(Password, Minor, Administrator, \").append(\"Cataloger, Approver, FirstName, LastName, MI, \").//append(\"Email, ProfessionalTitle, ProfessionalSpecialty, \").\n            append(\"Email, ProfessionalSpecialty, \").append(\"PhoneNumber, InstitutionName, Address1, Address2, \").append(\"City, State, ZipCode, Country, mailingList, modifiedLogin, emailValidated, IAMSEMember, UserName) \").append(\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \").append(\"?, ?, ?, ?, ?, ?, ?, ?,?,?)\");\n        } else {\n            // Use UPDATE statement\n            sql.append(\"UPDATE Users SET \").append(\"Password = ?, Minor = ?, Administrator = ?, \").append(\"Cataloger = ?, Approver = ?, FirstName = ?, \").append(\"LastName = ?, MI = ?, Email = ?, \").//append(\"ProfessionalTitle = ?, ProfessionalSpecialty = ?, \").\n            append(\"ProfessionalSpecialty = ?, \").append(\"PhoneNumber = ?, InstitutionName = ?, Address1 = ?, \").append(\"Address2 = ?, City = ?, State = ?, ZipCode = ?, \").append(\"Country = ?, mailingList = ?, modifiedLogin = ?, emailValidated = ?, IAMSEMember = ? WHERE UserName= ?\");\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql.toString());\n            ps.setString(1, userInfo.getPassword());\n            ps.setBoolean(2, userInfo.isMinor());\n            ps.setBoolean(3, userInfo.isAdministrator());\n            ps.setBoolean(4, userInfo.isCataloger());\n            ps.setBoolean(5, userInfo.isApprover());\n            ps.setString(6, userInfo.getFirstName());\n            ps.setString(7, userInfo.getLastName());\n            ps.setString(8, userInfo.getMiddleInitial());\n            ps.setString(9, userInfo.getEmail());\n            //ps.setString(10, userInfo.getProfessionalTitle());\n            ps.setString(10, userInfo.getProfessionalSpecialty());\n            ps.setString(11, userInfo.getPhoneNumber());\n            ps.setString(12, userInfo.getInstitutionName());\n            ps.setString(13, userInfo.getAddress1());\n            ps.setString(14, userInfo.getAddress2());\n            ps.setString(15, userInfo.getCity());\n            ps.setString(16, userInfo.getState());\n            ps.setString(17, userInfo.getZipCode());\n            ps.setString(18, userInfo.getCountry());\n            ps.setBoolean(19, userInfo.getMailingList());\n            ps.setBoolean(20, true);\n            ps.setBoolean(21, userInfo.isEmailValidated());\n            ps.setBoolean(22, userInfo.isIAMSEMember());\n            ps.setString(23, userInfo.getUserName());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n    }\n\n    public void reset(String username) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET modifiedLogin = 0 where username = ?\");\n            ps.setString(1, username);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean validateEmail(String email, int userId) {\n        PreparedStatement ps = null;\n        int rowCount = 0;\n        boolean update = false;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 1 where email = ? and userId = ?\");\n            ps.setString(1, email);\n            ps.setInt(2, userId);\n            rowCount = ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n        if (rowCount > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateEmail(String email, String newemail) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 0, UserName = ?, email= ? where email = ?\");\n            ps.setString(1, newemail);\n            ps.setString(2, newemail);\n            ps.setString(3, email);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n        } finally {\n            if (null != ps) {\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProfessionalRole(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersProfessionalRole where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        ProfessionalRoleBean prb = null;\n        ArrayList prbs = userInfo.getProfessionalRole();\n        Iterator it = prbs.iterator();\n        while (it.hasNext()) {\n            prb = (ProfessionalRoleBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersProfessionalRole \").append(\"(UserId, ProfessionalRole) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, prb.getProfessionalRole());\n                //System.err.println(\"heree\");\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserInstructionalLevel(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersInstructionalLevel where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        InstructionalLevelBean ilb = null;\n        ArrayList ilbs = userInfo.getInstructionalLevel();\n        Iterator it = ilbs.iterator();\n        while (it.hasNext()) {\n            ilb = (InstructionalLevelBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersInstructionalLevel \").append(\"(UserId, InstructionalLevel) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, ilb.getInstructionalLevel());\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and adds an entry for it\n     * in the Subscriber's table (if it doesn't already exist).\n     * Returns true if successful (also if it already exists in the table)\n     * and false if an error occurs.\n     */\n    public boolean addUserToSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                if (getSubscriber(userId, conn) != null) {\n                    success = true;\n                } else {\n                    success = addSubscriber(userId, conn);\n                }\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and removes any entries for it\n     * in the Subscriber's table.  Returns true if on success and false if\n     * an error occurs.\n     */\n    public boolean removeUserFromSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                success = deleteSubscriber(userId, conn);\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to delete a subscriber from the subscribers table.\n     * This method will delete all subscribers found with the given\n     * UserID (there should only be one, but just in case).\n     */\n    private boolean deleteSubscriber(String userId, Connection conn) throws SQLException {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use DELETE statement\n            sql.append(\"DELETE FROM Subscribers WHERE UserID = ?\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to add a subscriber to the subscribers table.\n     * This method will insert a subscriber regardless of whether or not\n     * it already exists in the tabel.\n     */\n    private boolean addSubscriber(String userId, Connection conn) {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Subscribers (UserID) VALUES(?)\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * If the given userId is found in the subscriber table, then\n     * its corresponding Row is returned.  Otherwise, null is returned\n     * if no subscriber is found.  In case of an error, an SQLException\n     * is throw.\n     */\n    private Row getSubscriber(String userId, Connection conn) throws SQLException {\n        if (userId == null || conn == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM Subscribers WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Looks up all entries in the Users table with a true value for the\n     * administrator setting.  Returns an ArrayList of Strings containing\n     * the email addresses of the found users.\n     */\n    public ArrayList getAdminEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE Administrator = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new BooleanValue(true));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the usernames corresponding to user ids\n     * found in the subscribers table.\n     * Returns an ArrayList of strings.\n     */\n    public ArrayList getAllSubscribers() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList users = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    users = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        users.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            users = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return users;\n    }\n\n    /**\n     * This method gets all of the email addresses found in the users table\n     * corresponding to the given usernames.  Only users with email addresses\n     * in the table will have a value returned.  If an error occurs, null is\n     * returned, other wise a possibly empty (if no user email addresses were\n     * found) ArrayList is returned.\n     */\n    public ArrayList getEmailAddresses(String[] userNames) {\n        //Get the useraddresses from the database\n        if (userNames == null || userNames.length <= 0) {\n            return null;\n        }\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sqlBuffer = new StringBuffer(\"SELECT Email FROM Users WHERE \");\n            sqlBuffer.append(\"UserName = '\" + userNames[0] + \"'\");\n            for (int i = 1; i < userNames.length; i++) {\n                sqlBuffer.append(\" or UserName = '\" + userNames[i] + \"'\");\n            }\n            sqlCommandBean.setSqlValue(sqlBuffer.toString());\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the userIDs found in the subscribers table and\n     * then looks up all the email addresses of those entries from the\n     * Users table.\n     */\n    public ArrayList getSubscriberEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserRegistryBeanTest1.java",
		"test_prompt": "// UserRegistryBeanTest1.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserRegistryBean}.\n* It contains ten unit test cases for the {@link UserRegistryBean#checkPermissions(UserBean, String)} method.\n*/\nclass UserRegistryBeanTest1 {"
	},
	{
		"original_code": "// UserRegistryBean.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\n/**\n * This contains methods for authenticating a user,\n * and retrieving and updating user information.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserRegistryBean implements Serializable {\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Returns true if the specified user name and password\n     * match an employee in the database.\n     */\n    public UserBean verifyLogin(String userName, String password, boolean emailIsUsername) throws SQLException {\n        UserBean userInfo = getUser(userName, emailIsUsername);\n        if (userInfo != null && password.equals(userInfo.getPassword())) {\n            return userInfo;\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the given user has the specified permissions.\n     */\n    public boolean checkPermissions(UserBean user, String accessLevel) {\n        /* XXX not currently implemented */\n        return false;\n    }\n\n    /**\n     * Returns true if the user was found in the database, false\n     * otherwise.  Throws an SQLException in the event something goes\n     * wrong.\n     */\n    public boolean userExists(String userName) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(userName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return (userRow != null);\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUserIds() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserId FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserId\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUsernames() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfUsers() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(distinct email) as Expr1 FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getAreaofExpertiseSummary(String value) throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(userid) as Expr1 FROM USERS where professionalSpecialty = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new StringValue(value));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified employee, or null if\n     * not found.\n     */\n    public UserBean getUser(String userName, boolean emailIsUsername) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserProperties(userName, emailIsUsername, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it2 = userInstructionalLevel.iterator();\n            while (it2.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it2.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified email address, or null if\n     * not found.\n     */\n    public UserBean getUserFromEmail(String email) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(email, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return rowToBean(userRow);\n    }\n\n    public UserBean getUserFromID(String userID) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserPropertiesFromID(userID, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it = userInstructionalLevel.iterator();\n            while (it.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAreaofExpertiseValues() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT distinct ProfessionalSpecialty FROM USERS where modifiedLogin = '1'\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"ProfessionalSpecialty\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private UserBean rowToBean(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        UserBean userInfo = new UserBean();\n        try {\n            userInfo.setUserId(userRow.getString(\"UserID\"));\n            userInfo.setUserName(userRow.getString(\"UserName\"));\n            userInfo.setPassword(userRow.getString(\"Password\"));\n            userInfo.setMinor(userRow.getBoolean(\"Minor\"));\n            userInfo.setAdministrator(userRow.getBoolean(\"Administrator\"));\n            userInfo.setCataloger(userRow.getBoolean(\"Cataloger\"));\n            userInfo.setApprover(userRow.getBoolean(\"Approver\"));\n            userInfo.setFirstName(userRow.getString(\"FirstName\"));\n            userInfo.setLastName(userRow.getString(\"LastName\"));\n            userInfo.setMiddleInitial(userRow.getString(\"MI\"));\n            userInfo.setEmail(userRow.getString(\"Email\"));\n            //userInfo.setProfessionalTitle(userRow.getString(\"ProfessionalTitle\"));\n            userInfo.setProfessionalSpecialty(userRow.getString(\"ProfessionalSpecialty\"));\n            userInfo.setPhoneNumber(userRow.getString(\"PhoneNumber\"));\n            userInfo.setInstitutionName(userRow.getString(\"InstitutionName\"));\n            userInfo.setAddress1(userRow.getString(\"Address1\"));\n            userInfo.setAddress2(userRow.getString(\"Address2\"));\n            userInfo.setCity(userRow.getString(\"City\"));\n            userInfo.setState(userRow.getString(\"State\"));\n            userInfo.setZipCode(userRow.getString(\"ZipCode\"));\n            userInfo.setCountry(userRow.getString(\"Country\"));\n            userInfo.setMailingList(userRow.getBoolean(\"mailingList\"));\n            userInfo.setLoginModified(userRow.getBoolean(\"modifiedLogin\"));\n            userInfo.setEmailValidated(userRow.getBoolean(\"emailValidated\"));\n            userInfo.setIAMSEMember(userRow.getBoolean(\"IAMSEMember\"));\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return userInfo;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private ProfessionalRoleBean rowToProfessionalRole(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        ProfessionalRoleBean professionalRole = new ProfessionalRoleBean();\n        try {\n            professionalRole.setProfessionalRoleId(userRow.getString(\"ProfessionalRoleId\"));\n            professionalRole.setUserId(userRow.getString(\"UserId\"));\n            professionalRole.setProfessionalRole(userRow.getString(\"ProfessionalRole\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return professionalRole;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private InstructionalLevelBean rowToInstructionalLevel(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        InstructionalLevelBean instructionalLevel = new InstructionalLevelBean();\n        try {\n            instructionalLevel.setInstructionalLevelId(userRow.getString(\"InstructionalLevelId\"));\n            instructionalLevel.setUserId(userRow.getString(\"UserId\"));\n            instructionalLevel.setInstructionalLevel(userRow.getString(\"InstructionalLevel\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return instructionalLevel;\n    }\n\n    /**\n     * Inserts the information about the specified user, or\n     * updates the information if it's already defined.\n     */\n    public String saveRegistration(UserBean userInfo) throws SQLException {\n        // Save the user info from the database\n        Connection conn = dataSource.getConnection();\n        Connection conn2 = dataSource.getConnection();\n        String userId = \"\";\n        conn.setAutoCommit(false);\n        conn2.setAutoCommit(false);\n        try {\n            saveCompleteUserProperties(userInfo, conn);\n            conn.commit();\n            userId = userInfo.getUserId();\n            if (userInfo.getUserId() == null || userInfo.getUserId().length() == 0) {\n                UserBean userInfo2 = getUserFromEmail(userInfo.getEmail());\n                userInfo.setUserId(userInfo2.getUserId());\n                userId = userInfo2.getUserId();\n            }\n            saveUserProfessionalRole(userInfo, conn2);\n            saveUserInstructionalLevel(userInfo, conn2);\n            conn2.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n                conn2.setAutoCommit(true);\n                conn2.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return userId;\n    }\n\n    /**\n     * Inserts the XML encoded user registration information into the\n     * database, or updates the information if it is already defined.\n     */\n    public void saveRegistration(String xmlRegistration) throws SQLException {\n        UserBean userInfo = new UserBean();\n        userInfo.parseXML(xmlRegistration);\n        saveRegistration(userInfo);\n    }\n\n    /**\n     * Looks up a user property in the Users table that matches the given\n     * UserName.  The property should be a String value such that calling\n     * Row.getString() doesn't cause any problems.\n     */\n    private String getUserStringProperty(String userName, String propertyName, Connection conn) throws SQLException {\n        if (userName == null || propertyName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT \" + propertyName + \" FROM USERS WHERE UserName = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        String result = null;\n        try {\n            result = aRow.getString(propertyName);\n        } catch (NoSuchColumnException ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserProperties(String userName, boolean emailIsUsername, Connection conn) throws SQLException {\n        if (userName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"\";\n        if (emailIsUsername) {\n            sql = \"SELECT * FROM USERS WHERE Email = ? and modifiedLogin = 1\";\n        } else {\n            sql = \"SELECT * FROM USERS WHERE UserName = ?\";\n        }\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserProfessionalRole(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersProfessionalRole WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserInstructionalLevel(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersInstructionalLevel WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserPropertiesFromID(String userID, Connection conn) throws SQLException {\n        if (userID == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userID));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user's email address is not found.\n     */\n    private Row getUserPropertiesFromEmail(String email, Connection conn) throws SQLException {\n        if (email == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE email = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(email));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Given a user ID and a set of permissions, looks up the user in the\n     * database and if the user is found, updates their permissions.  Returns\n     * false if either parameter is null, the user was not found in the\n     * database, or an error occured.  Otherwise the method returns true.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        if (userId == null || permissions == null) {\n            return false;\n        }\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            Row userRow = getUserProperties(userId, false, conn);\n            UserBean user = rowToBean(userRow);\n            if (user != null) {\n                user.setMinor(permissions.isMinor());\n                user.setAdministrator(permissions.isAdministrator());\n                user.setCataloger(permissions.isCataloger());\n                user.setApprover(permissions.isApprover());\n                saveUserProperties(user, conn);\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveCompleteUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        saveUserProperties(userInfo, conn);\n        //conn.commit();\n        //if(userInfo.getUserId() == null || userInfo.getUserId().length()==0)\n        //{\n        //userInfo=getUserFromEmail(userInfo.getEmail());\n        //}\n        //saveUserProfessionalRole(userInfo, conn);\n        //saveUserInstructionalLevel(userInfo, conn);\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        UserBean dbInfo = getUser(userInfo.getUserName(), false);\n        StringBuffer sql = new StringBuffer();\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Users \").append(\"(Password, Minor, Administrator, \").append(\"Cataloger, Approver, FirstName, LastName, MI, \").//append(\"Email, ProfessionalTitle, ProfessionalSpecialty, \").\n            append(\"Email, ProfessionalSpecialty, \").append(\"PhoneNumber, InstitutionName, Address1, Address2, \").append(\"City, State, ZipCode, Country, mailingList, modifiedLogin, emailValidated, IAMSEMember, UserName) \").append(\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \").append(\"?, ?, ?, ?, ?, ?, ?, ?,?,?)\");\n        } else {\n            // Use UPDATE statement\n            sql.append(\"UPDATE Users SET \").append(\"Password = ?, Minor = ?, Administrator = ?, \").append(\"Cataloger = ?, Approver = ?, FirstName = ?, \").append(\"LastName = ?, MI = ?, Email = ?, \").//append(\"ProfessionalTitle = ?, ProfessionalSpecialty = ?, \").\n            append(\"ProfessionalSpecialty = ?, \").append(\"PhoneNumber = ?, InstitutionName = ?, Address1 = ?, \").append(\"Address2 = ?, City = ?, State = ?, ZipCode = ?, \").append(\"Country = ?, mailingList = ?, modifiedLogin = ?, emailValidated = ?, IAMSEMember = ? WHERE UserName= ?\");\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql.toString());\n            ps.setString(1, userInfo.getPassword());\n            ps.setBoolean(2, userInfo.isMinor());\n            ps.setBoolean(3, userInfo.isAdministrator());\n            ps.setBoolean(4, userInfo.isCataloger());\n            ps.setBoolean(5, userInfo.isApprover());\n            ps.setString(6, userInfo.getFirstName());\n            ps.setString(7, userInfo.getLastName());\n            ps.setString(8, userInfo.getMiddleInitial());\n            ps.setString(9, userInfo.getEmail());\n            //ps.setString(10, userInfo.getProfessionalTitle());\n            ps.setString(10, userInfo.getProfessionalSpecialty());\n            ps.setString(11, userInfo.getPhoneNumber());\n            ps.setString(12, userInfo.getInstitutionName());\n            ps.setString(13, userInfo.getAddress1());\n            ps.setString(14, userInfo.getAddress2());\n            ps.setString(15, userInfo.getCity());\n            ps.setString(16, userInfo.getState());\n            ps.setString(17, userInfo.getZipCode());\n            ps.setString(18, userInfo.getCountry());\n            ps.setBoolean(19, userInfo.getMailingList());\n            ps.setBoolean(20, true);\n            ps.setBoolean(21, userInfo.isEmailValidated());\n            ps.setBoolean(22, userInfo.isIAMSEMember());\n            ps.setString(23, userInfo.getUserName());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n    }\n\n    public void reset(String username) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET modifiedLogin = 0 where username = ?\");\n            ps.setString(1, username);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean validateEmail(String email, int userId) {\n        PreparedStatement ps = null;\n        int rowCount = 0;\n        boolean update = false;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 1 where email = ? and userId = ?\");\n            ps.setString(1, email);\n            ps.setInt(2, userId);\n            rowCount = ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n        if (rowCount > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateEmail(String email, String newemail) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 0, UserName = ?, email= ? where email = ?\");\n            ps.setString(1, newemail);\n            ps.setString(2, newemail);\n            ps.setString(3, email);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n        } finally {\n            if (null != ps) {\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProfessionalRole(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersProfessionalRole where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        ProfessionalRoleBean prb = null;\n        ArrayList prbs = userInfo.getProfessionalRole();\n        Iterator it = prbs.iterator();\n        while (it.hasNext()) {\n            prb = (ProfessionalRoleBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersProfessionalRole \").append(\"(UserId, ProfessionalRole) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, prb.getProfessionalRole());\n                //System.err.println(\"heree\");\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserInstructionalLevel(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersInstructionalLevel where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        InstructionalLevelBean ilb = null;\n        ArrayList ilbs = userInfo.getInstructionalLevel();\n        Iterator it = ilbs.iterator();\n        while (it.hasNext()) {\n            ilb = (InstructionalLevelBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersInstructionalLevel \").append(\"(UserId, InstructionalLevel) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, ilb.getInstructionalLevel());\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and adds an entry for it\n     * in the Subscriber's table (if it doesn't already exist).\n     * Returns true if successful (also if it already exists in the table)\n     * and false if an error occurs.\n     */\n    public boolean addUserToSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                if (getSubscriber(userId, conn) != null) {\n                    success = true;\n                } else {\n                    success = addSubscriber(userId, conn);\n                }\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and removes any entries for it\n     * in the Subscriber's table.  Returns true if on success and false if\n     * an error occurs.\n     */\n    public boolean removeUserFromSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                success = deleteSubscriber(userId, conn);\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to delete a subscriber from the subscribers table.\n     * This method will delete all subscribers found with the given\n     * UserID (there should only be one, but just in case).\n     */\n    private boolean deleteSubscriber(String userId, Connection conn) throws SQLException {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use DELETE statement\n            sql.append(\"DELETE FROM Subscribers WHERE UserID = ?\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to add a subscriber to the subscribers table.\n     * This method will insert a subscriber regardless of whether or not\n     * it already exists in the tabel.\n     */\n    private boolean addSubscriber(String userId, Connection conn) {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Subscribers (UserID) VALUES(?)\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * If the given userId is found in the subscriber table, then\n     * its corresponding Row is returned.  Otherwise, null is returned\n     * if no subscriber is found.  In case of an error, an SQLException\n     * is throw.\n     */\n    private Row getSubscriber(String userId, Connection conn) throws SQLException {\n        if (userId == null || conn == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM Subscribers WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Looks up all entries in the Users table with a true value for the\n     * administrator setting.  Returns an ArrayList of Strings containing\n     * the email addresses of the found users.\n     */\n    public ArrayList getAdminEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE Administrator = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new BooleanValue(true));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the usernames corresponding to user ids\n     * found in the subscribers table.\n     * Returns an ArrayList of strings.\n     */\n    public ArrayList getAllSubscribers() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList users = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    users = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        users.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            users = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return users;\n    }\n\n    /**\n     * This method gets all of the email addresses found in the users table\n     * corresponding to the given usernames.  Only users with email addresses\n     * in the table will have a value returned.  If an error occurs, null is\n     * returned, other wise a possibly empty (if no user email addresses were\n     * found) ArrayList is returned.\n     */\n    public ArrayList getEmailAddresses(String[] userNames) {\n        //Get the useraddresses from the database\n        if (userNames == null || userNames.length <= 0) {\n            return null;\n        }\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sqlBuffer = new StringBuffer(\"SELECT Email FROM Users WHERE \");\n            sqlBuffer.append(\"UserName = '\" + userNames[0] + \"'\");\n            for (int i = 1; i < userNames.length; i++) {\n                sqlBuffer.append(\" or UserName = '\" + userNames[i] + \"'\");\n            }\n            sqlCommandBean.setSqlValue(sqlBuffer.toString());\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the userIDs found in the subscribers table and\n     * then looks up all the email addresses of those entries from the\n     * Users table.\n     */\n    public ArrayList getSubscriberEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserRegistryBeanTest2.java",
		"test_prompt": "// UserRegistryBeanTest2.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserRegistryBean}.\n* It contains ten unit test cases for the {@link UserRegistryBean#userExists(String)} method.\n*/\nclass UserRegistryBeanTest2 {"
	},
	{
		"original_code": "// UserRegistryBean.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\n/**\n * This contains methods for authenticating a user,\n * and retrieving and updating user information.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserRegistryBean implements Serializable {\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Returns true if the specified user name and password\n     * match an employee in the database.\n     */\n    public UserBean verifyLogin(String userName, String password, boolean emailIsUsername) throws SQLException {\n        UserBean userInfo = getUser(userName, emailIsUsername);\n        if (userInfo != null && password.equals(userInfo.getPassword())) {\n            return userInfo;\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the given user has the specified permissions.\n     */\n    public boolean checkPermissions(UserBean user, String accessLevel) {\n        /* XXX not currently implemented */\n        return false;\n    }\n\n    /**\n     * Returns true if the user was found in the database, false\n     * otherwise.  Throws an SQLException in the event something goes\n     * wrong.\n     */\n    public boolean userExists(String userName) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(userName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return (userRow != null);\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUserIds() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserId FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserId\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUsernames() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfUsers() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(distinct email) as Expr1 FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getAreaofExpertiseSummary(String value) throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(userid) as Expr1 FROM USERS where professionalSpecialty = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new StringValue(value));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified employee, or null if\n     * not found.\n     */\n    public UserBean getUser(String userName, boolean emailIsUsername) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserProperties(userName, emailIsUsername, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it2 = userInstructionalLevel.iterator();\n            while (it2.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it2.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified email address, or null if\n     * not found.\n     */\n    public UserBean getUserFromEmail(String email) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(email, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return rowToBean(userRow);\n    }\n\n    public UserBean getUserFromID(String userID) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserPropertiesFromID(userID, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it = userInstructionalLevel.iterator();\n            while (it.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAreaofExpertiseValues() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT distinct ProfessionalSpecialty FROM USERS where modifiedLogin = '1'\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"ProfessionalSpecialty\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private UserBean rowToBean(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        UserBean userInfo = new UserBean();\n        try {\n            userInfo.setUserId(userRow.getString(\"UserID\"));\n            userInfo.setUserName(userRow.getString(\"UserName\"));\n            userInfo.setPassword(userRow.getString(\"Password\"));\n            userInfo.setMinor(userRow.getBoolean(\"Minor\"));\n            userInfo.setAdministrator(userRow.getBoolean(\"Administrator\"));\n            userInfo.setCataloger(userRow.getBoolean(\"Cataloger\"));\n            userInfo.setApprover(userRow.getBoolean(\"Approver\"));\n            userInfo.setFirstName(userRow.getString(\"FirstName\"));\n            userInfo.setLastName(userRow.getString(\"LastName\"));\n            userInfo.setMiddleInitial(userRow.getString(\"MI\"));\n            userInfo.setEmail(userRow.getString(\"Email\"));\n            //userInfo.setProfessionalTitle(userRow.getString(\"ProfessionalTitle\"));\n            userInfo.setProfessionalSpecialty(userRow.getString(\"ProfessionalSpecialty\"));\n            userInfo.setPhoneNumber(userRow.getString(\"PhoneNumber\"));\n            userInfo.setInstitutionName(userRow.getString(\"InstitutionName\"));\n            userInfo.setAddress1(userRow.getString(\"Address1\"));\n            userInfo.setAddress2(userRow.getString(\"Address2\"));\n            userInfo.setCity(userRow.getString(\"City\"));\n            userInfo.setState(userRow.getString(\"State\"));\n            userInfo.setZipCode(userRow.getString(\"ZipCode\"));\n            userInfo.setCountry(userRow.getString(\"Country\"));\n            userInfo.setMailingList(userRow.getBoolean(\"mailingList\"));\n            userInfo.setLoginModified(userRow.getBoolean(\"modifiedLogin\"));\n            userInfo.setEmailValidated(userRow.getBoolean(\"emailValidated\"));\n            userInfo.setIAMSEMember(userRow.getBoolean(\"IAMSEMember\"));\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return userInfo;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private ProfessionalRoleBean rowToProfessionalRole(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        ProfessionalRoleBean professionalRole = new ProfessionalRoleBean();\n        try {\n            professionalRole.setProfessionalRoleId(userRow.getString(\"ProfessionalRoleId\"));\n            professionalRole.setUserId(userRow.getString(\"UserId\"));\n            professionalRole.setProfessionalRole(userRow.getString(\"ProfessionalRole\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return professionalRole;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private InstructionalLevelBean rowToInstructionalLevel(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        InstructionalLevelBean instructionalLevel = new InstructionalLevelBean();\n        try {\n            instructionalLevel.setInstructionalLevelId(userRow.getString(\"InstructionalLevelId\"));\n            instructionalLevel.setUserId(userRow.getString(\"UserId\"));\n            instructionalLevel.setInstructionalLevel(userRow.getString(\"InstructionalLevel\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return instructionalLevel;\n    }\n\n    /**\n     * Inserts the information about the specified user, or\n     * updates the information if it's already defined.\n     */\n    public String saveRegistration(UserBean userInfo) throws SQLException {\n        // Save the user info from the database\n        Connection conn = dataSource.getConnection();\n        Connection conn2 = dataSource.getConnection();\n        String userId = \"\";\n        conn.setAutoCommit(false);\n        conn2.setAutoCommit(false);\n        try {\n            saveCompleteUserProperties(userInfo, conn);\n            conn.commit();\n            userId = userInfo.getUserId();\n            if (userInfo.getUserId() == null || userInfo.getUserId().length() == 0) {\n                UserBean userInfo2 = getUserFromEmail(userInfo.getEmail());\n                userInfo.setUserId(userInfo2.getUserId());\n                userId = userInfo2.getUserId();\n            }\n            saveUserProfessionalRole(userInfo, conn2);\n            saveUserInstructionalLevel(userInfo, conn2);\n            conn2.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n                conn2.setAutoCommit(true);\n                conn2.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return userId;\n    }\n\n    /**\n     * Inserts the XML encoded user registration information into the\n     * database, or updates the information if it is already defined.\n     */\n    public void saveRegistration(String xmlRegistration) throws SQLException {\n        UserBean userInfo = new UserBean();\n        userInfo.parseXML(xmlRegistration);\n        saveRegistration(userInfo);\n    }\n\n    /**\n     * Looks up a user property in the Users table that matches the given\n     * UserName.  The property should be a String value such that calling\n     * Row.getString() doesn't cause any problems.\n     */\n    private String getUserStringProperty(String userName, String propertyName, Connection conn) throws SQLException {\n        if (userName == null || propertyName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT \" + propertyName + \" FROM USERS WHERE UserName = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        String result = null;\n        try {\n            result = aRow.getString(propertyName);\n        } catch (NoSuchColumnException ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserProperties(String userName, boolean emailIsUsername, Connection conn) throws SQLException {\n        if (userName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"\";\n        if (emailIsUsername) {\n            sql = \"SELECT * FROM USERS WHERE Email = ? and modifiedLogin = 1\";\n        } else {\n            sql = \"SELECT * FROM USERS WHERE UserName = ?\";\n        }\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserProfessionalRole(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersProfessionalRole WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserInstructionalLevel(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersInstructionalLevel WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserPropertiesFromID(String userID, Connection conn) throws SQLException {\n        if (userID == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userID));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user's email address is not found.\n     */\n    private Row getUserPropertiesFromEmail(String email, Connection conn) throws SQLException {\n        if (email == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE email = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(email));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Given a user ID and a set of permissions, looks up the user in the\n     * database and if the user is found, updates their permissions.  Returns\n     * false if either parameter is null, the user was not found in the\n     * database, or an error occured.  Otherwise the method returns true.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        if (userId == null || permissions == null) {\n            return false;\n        }\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            Row userRow = getUserProperties(userId, false, conn);\n            UserBean user = rowToBean(userRow);\n            if (user != null) {\n                user.setMinor(permissions.isMinor());\n                user.setAdministrator(permissions.isAdministrator());\n                user.setCataloger(permissions.isCataloger());\n                user.setApprover(permissions.isApprover());\n                saveUserProperties(user, conn);\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveCompleteUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        saveUserProperties(userInfo, conn);\n        //conn.commit();\n        //if(userInfo.getUserId() == null || userInfo.getUserId().length()==0)\n        //{\n        //userInfo=getUserFromEmail(userInfo.getEmail());\n        //}\n        //saveUserProfessionalRole(userInfo, conn);\n        //saveUserInstructionalLevel(userInfo, conn);\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        UserBean dbInfo = getUser(userInfo.getUserName(), false);\n        StringBuffer sql = new StringBuffer();\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Users \").append(\"(Password, Minor, Administrator, \").append(\"Cataloger, Approver, FirstName, LastName, MI, \").//append(\"Email, ProfessionalTitle, ProfessionalSpecialty, \").\n            append(\"Email, ProfessionalSpecialty, \").append(\"PhoneNumber, InstitutionName, Address1, Address2, \").append(\"City, State, ZipCode, Country, mailingList, modifiedLogin, emailValidated, IAMSEMember, UserName) \").append(\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \").append(\"?, ?, ?, ?, ?, ?, ?, ?,?,?)\");\n        } else {\n            // Use UPDATE statement\n            sql.append(\"UPDATE Users SET \").append(\"Password = ?, Minor = ?, Administrator = ?, \").append(\"Cataloger = ?, Approver = ?, FirstName = ?, \").append(\"LastName = ?, MI = ?, Email = ?, \").//append(\"ProfessionalTitle = ?, ProfessionalSpecialty = ?, \").\n            append(\"ProfessionalSpecialty = ?, \").append(\"PhoneNumber = ?, InstitutionName = ?, Address1 = ?, \").append(\"Address2 = ?, City = ?, State = ?, ZipCode = ?, \").append(\"Country = ?, mailingList = ?, modifiedLogin = ?, emailValidated = ?, IAMSEMember = ? WHERE UserName= ?\");\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql.toString());\n            ps.setString(1, userInfo.getPassword());\n            ps.setBoolean(2, userInfo.isMinor());\n            ps.setBoolean(3, userInfo.isAdministrator());\n            ps.setBoolean(4, userInfo.isCataloger());\n            ps.setBoolean(5, userInfo.isApprover());\n            ps.setString(6, userInfo.getFirstName());\n            ps.setString(7, userInfo.getLastName());\n            ps.setString(8, userInfo.getMiddleInitial());\n            ps.setString(9, userInfo.getEmail());\n            //ps.setString(10, userInfo.getProfessionalTitle());\n            ps.setString(10, userInfo.getProfessionalSpecialty());\n            ps.setString(11, userInfo.getPhoneNumber());\n            ps.setString(12, userInfo.getInstitutionName());\n            ps.setString(13, userInfo.getAddress1());\n            ps.setString(14, userInfo.getAddress2());\n            ps.setString(15, userInfo.getCity());\n            ps.setString(16, userInfo.getState());\n            ps.setString(17, userInfo.getZipCode());\n            ps.setString(18, userInfo.getCountry());\n            ps.setBoolean(19, userInfo.getMailingList());\n            ps.setBoolean(20, true);\n            ps.setBoolean(21, userInfo.isEmailValidated());\n            ps.setBoolean(22, userInfo.isIAMSEMember());\n            ps.setString(23, userInfo.getUserName());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n    }\n\n    public void reset(String username) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET modifiedLogin = 0 where username = ?\");\n            ps.setString(1, username);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean validateEmail(String email, int userId) {\n        PreparedStatement ps = null;\n        int rowCount = 0;\n        boolean update = false;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 1 where email = ? and userId = ?\");\n            ps.setString(1, email);\n            ps.setInt(2, userId);\n            rowCount = ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n        if (rowCount > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateEmail(String email, String newemail) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 0, UserName = ?, email= ? where email = ?\");\n            ps.setString(1, newemail);\n            ps.setString(2, newemail);\n            ps.setString(3, email);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n        } finally {\n            if (null != ps) {\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProfessionalRole(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersProfessionalRole where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        ProfessionalRoleBean prb = null;\n        ArrayList prbs = userInfo.getProfessionalRole();\n        Iterator it = prbs.iterator();\n        while (it.hasNext()) {\n            prb = (ProfessionalRoleBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersProfessionalRole \").append(\"(UserId, ProfessionalRole) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, prb.getProfessionalRole());\n                //System.err.println(\"heree\");\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserInstructionalLevel(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersInstructionalLevel where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        InstructionalLevelBean ilb = null;\n        ArrayList ilbs = userInfo.getInstructionalLevel();\n        Iterator it = ilbs.iterator();\n        while (it.hasNext()) {\n            ilb = (InstructionalLevelBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersInstructionalLevel \").append(\"(UserId, InstructionalLevel) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, ilb.getInstructionalLevel());\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and adds an entry for it\n     * in the Subscriber's table (if it doesn't already exist).\n     * Returns true if successful (also if it already exists in the table)\n     * and false if an error occurs.\n     */\n    public boolean addUserToSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                if (getSubscriber(userId, conn) != null) {\n                    success = true;\n                } else {\n                    success = addSubscriber(userId, conn);\n                }\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and removes any entries for it\n     * in the Subscriber's table.  Returns true if on success and false if\n     * an error occurs.\n     */\n    public boolean removeUserFromSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                success = deleteSubscriber(userId, conn);\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to delete a subscriber from the subscribers table.\n     * This method will delete all subscribers found with the given\n     * UserID (there should only be one, but just in case).\n     */\n    private boolean deleteSubscriber(String userId, Connection conn) throws SQLException {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use DELETE statement\n            sql.append(\"DELETE FROM Subscribers WHERE UserID = ?\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to add a subscriber to the subscribers table.\n     * This method will insert a subscriber regardless of whether or not\n     * it already exists in the tabel.\n     */\n    private boolean addSubscriber(String userId, Connection conn) {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Subscribers (UserID) VALUES(?)\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * If the given userId is found in the subscriber table, then\n     * its corresponding Row is returned.  Otherwise, null is returned\n     * if no subscriber is found.  In case of an error, an SQLException\n     * is throw.\n     */\n    private Row getSubscriber(String userId, Connection conn) throws SQLException {\n        if (userId == null || conn == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM Subscribers WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Looks up all entries in the Users table with a true value for the\n     * administrator setting.  Returns an ArrayList of Strings containing\n     * the email addresses of the found users.\n     */\n    public ArrayList getAdminEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE Administrator = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new BooleanValue(true));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the usernames corresponding to user ids\n     * found in the subscribers table.\n     * Returns an ArrayList of strings.\n     */\n    public ArrayList getAllSubscribers() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList users = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    users = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        users.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            users = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return users;\n    }\n\n    /**\n     * This method gets all of the email addresses found in the users table\n     * corresponding to the given usernames.  Only users with email addresses\n     * in the table will have a value returned.  If an error occurs, null is\n     * returned, other wise a possibly empty (if no user email addresses were\n     * found) ArrayList is returned.\n     */\n    public ArrayList getEmailAddresses(String[] userNames) {\n        //Get the useraddresses from the database\n        if (userNames == null || userNames.length <= 0) {\n            return null;\n        }\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sqlBuffer = new StringBuffer(\"SELECT Email FROM Users WHERE \");\n            sqlBuffer.append(\"UserName = '\" + userNames[0] + \"'\");\n            for (int i = 1; i < userNames.length; i++) {\n                sqlBuffer.append(\" or UserName = '\" + userNames[i] + \"'\");\n            }\n            sqlCommandBean.setSqlValue(sqlBuffer.toString());\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the userIDs found in the subscribers table and\n     * then looks up all the email addresses of those entries from the\n     * Users table.\n     */\n    public ArrayList getSubscriberEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserRegistryBeanTest3.java",
		"test_prompt": "// UserRegistryBeanTest3.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserRegistryBean}.\n* It contains ten unit test cases for the {@link UserRegistryBean#saveRegistration(UserBean)} method.\n*/\nclass UserRegistryBeanTest3 {"
	},
	{
		"original_code": "// UserRegistryBean.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\n/**\n * This contains methods for authenticating a user,\n * and retrieving and updating user information.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserRegistryBean implements Serializable {\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Returns true if the specified user name and password\n     * match an employee in the database.\n     */\n    public UserBean verifyLogin(String userName, String password, boolean emailIsUsername) throws SQLException {\n        UserBean userInfo = getUser(userName, emailIsUsername);\n        if (userInfo != null && password.equals(userInfo.getPassword())) {\n            return userInfo;\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the given user has the specified permissions.\n     */\n    public boolean checkPermissions(UserBean user, String accessLevel) {\n        /* XXX not currently implemented */\n        return false;\n    }\n\n    /**\n     * Returns true if the user was found in the database, false\n     * otherwise.  Throws an SQLException in the event something goes\n     * wrong.\n     */\n    public boolean userExists(String userName) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(userName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return (userRow != null);\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUserIds() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserId FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserId\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUsernames() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfUsers() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(distinct email) as Expr1 FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getAreaofExpertiseSummary(String value) throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(userid) as Expr1 FROM USERS where professionalSpecialty = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new StringValue(value));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified employee, or null if\n     * not found.\n     */\n    public UserBean getUser(String userName, boolean emailIsUsername) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserProperties(userName, emailIsUsername, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it2 = userInstructionalLevel.iterator();\n            while (it2.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it2.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified email address, or null if\n     * not found.\n     */\n    public UserBean getUserFromEmail(String email) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(email, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return rowToBean(userRow);\n    }\n\n    public UserBean getUserFromID(String userID) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserPropertiesFromID(userID, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it = userInstructionalLevel.iterator();\n            while (it.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAreaofExpertiseValues() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT distinct ProfessionalSpecialty FROM USERS where modifiedLogin = '1'\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"ProfessionalSpecialty\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private UserBean rowToBean(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        UserBean userInfo = new UserBean();\n        try {\n            userInfo.setUserId(userRow.getString(\"UserID\"));\n            userInfo.setUserName(userRow.getString(\"UserName\"));\n            userInfo.setPassword(userRow.getString(\"Password\"));\n            userInfo.setMinor(userRow.getBoolean(\"Minor\"));\n            userInfo.setAdministrator(userRow.getBoolean(\"Administrator\"));\n            userInfo.setCataloger(userRow.getBoolean(\"Cataloger\"));\n            userInfo.setApprover(userRow.getBoolean(\"Approver\"));\n            userInfo.setFirstName(userRow.getString(\"FirstName\"));\n            userInfo.setLastName(userRow.getString(\"LastName\"));\n            userInfo.setMiddleInitial(userRow.getString(\"MI\"));\n            userInfo.setEmail(userRow.getString(\"Email\"));\n            //userInfo.setProfessionalTitle(userRow.getString(\"ProfessionalTitle\"));\n            userInfo.setProfessionalSpecialty(userRow.getString(\"ProfessionalSpecialty\"));\n            userInfo.setPhoneNumber(userRow.getString(\"PhoneNumber\"));\n            userInfo.setInstitutionName(userRow.getString(\"InstitutionName\"));\n            userInfo.setAddress1(userRow.getString(\"Address1\"));\n            userInfo.setAddress2(userRow.getString(\"Address2\"));\n            userInfo.setCity(userRow.getString(\"City\"));\n            userInfo.setState(userRow.getString(\"State\"));\n            userInfo.setZipCode(userRow.getString(\"ZipCode\"));\n            userInfo.setCountry(userRow.getString(\"Country\"));\n            userInfo.setMailingList(userRow.getBoolean(\"mailingList\"));\n            userInfo.setLoginModified(userRow.getBoolean(\"modifiedLogin\"));\n            userInfo.setEmailValidated(userRow.getBoolean(\"emailValidated\"));\n            userInfo.setIAMSEMember(userRow.getBoolean(\"IAMSEMember\"));\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return userInfo;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private ProfessionalRoleBean rowToProfessionalRole(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        ProfessionalRoleBean professionalRole = new ProfessionalRoleBean();\n        try {\n            professionalRole.setProfessionalRoleId(userRow.getString(\"ProfessionalRoleId\"));\n            professionalRole.setUserId(userRow.getString(\"UserId\"));\n            professionalRole.setProfessionalRole(userRow.getString(\"ProfessionalRole\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return professionalRole;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private InstructionalLevelBean rowToInstructionalLevel(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        InstructionalLevelBean instructionalLevel = new InstructionalLevelBean();\n        try {\n            instructionalLevel.setInstructionalLevelId(userRow.getString(\"InstructionalLevelId\"));\n            instructionalLevel.setUserId(userRow.getString(\"UserId\"));\n            instructionalLevel.setInstructionalLevel(userRow.getString(\"InstructionalLevel\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return instructionalLevel;\n    }\n\n    /**\n     * Inserts the information about the specified user, or\n     * updates the information if it's already defined.\n     */\n    public String saveRegistration(UserBean userInfo) throws SQLException {\n        // Save the user info from the database\n        Connection conn = dataSource.getConnection();\n        Connection conn2 = dataSource.getConnection();\n        String userId = \"\";\n        conn.setAutoCommit(false);\n        conn2.setAutoCommit(false);\n        try {\n            saveCompleteUserProperties(userInfo, conn);\n            conn.commit();\n            userId = userInfo.getUserId();\n            if (userInfo.getUserId() == null || userInfo.getUserId().length() == 0) {\n                UserBean userInfo2 = getUserFromEmail(userInfo.getEmail());\n                userInfo.setUserId(userInfo2.getUserId());\n                userId = userInfo2.getUserId();\n            }\n            saveUserProfessionalRole(userInfo, conn2);\n            saveUserInstructionalLevel(userInfo, conn2);\n            conn2.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n                conn2.setAutoCommit(true);\n                conn2.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return userId;\n    }\n\n    /**\n     * Inserts the XML encoded user registration information into the\n     * database, or updates the information if it is already defined.\n     */\n    public void saveRegistration(String xmlRegistration) throws SQLException {\n        UserBean userInfo = new UserBean();\n        userInfo.parseXML(xmlRegistration);\n        saveRegistration(userInfo);\n    }\n\n    /**\n     * Looks up a user property in the Users table that matches the given\n     * UserName.  The property should be a String value such that calling\n     * Row.getString() doesn't cause any problems.\n     */\n    private String getUserStringProperty(String userName, String propertyName, Connection conn) throws SQLException {\n        if (userName == null || propertyName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT \" + propertyName + \" FROM USERS WHERE UserName = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        String result = null;\n        try {\n            result = aRow.getString(propertyName);\n        } catch (NoSuchColumnException ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserProperties(String userName, boolean emailIsUsername, Connection conn) throws SQLException {\n        if (userName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"\";\n        if (emailIsUsername) {\n            sql = \"SELECT * FROM USERS WHERE Email = ? and modifiedLogin = 1\";\n        } else {\n            sql = \"SELECT * FROM USERS WHERE UserName = ?\";\n        }\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserProfessionalRole(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersProfessionalRole WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserInstructionalLevel(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersInstructionalLevel WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserPropertiesFromID(String userID, Connection conn) throws SQLException {\n        if (userID == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userID));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user's email address is not found.\n     */\n    private Row getUserPropertiesFromEmail(String email, Connection conn) throws SQLException {\n        if (email == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE email = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(email));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Given a user ID and a set of permissions, looks up the user in the\n     * database and if the user is found, updates their permissions.  Returns\n     * false if either parameter is null, the user was not found in the\n     * database, or an error occured.  Otherwise the method returns true.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        if (userId == null || permissions == null) {\n            return false;\n        }\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            Row userRow = getUserProperties(userId, false, conn);\n            UserBean user = rowToBean(userRow);\n            if (user != null) {\n                user.setMinor(permissions.isMinor());\n                user.setAdministrator(permissions.isAdministrator());\n                user.setCataloger(permissions.isCataloger());\n                user.setApprover(permissions.isApprover());\n                saveUserProperties(user, conn);\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveCompleteUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        saveUserProperties(userInfo, conn);\n        //conn.commit();\n        //if(userInfo.getUserId() == null || userInfo.getUserId().length()==0)\n        //{\n        //userInfo=getUserFromEmail(userInfo.getEmail());\n        //}\n        //saveUserProfessionalRole(userInfo, conn);\n        //saveUserInstructionalLevel(userInfo, conn);\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        UserBean dbInfo = getUser(userInfo.getUserName(), false);\n        StringBuffer sql = new StringBuffer();\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Users \").append(\"(Password, Minor, Administrator, \").append(\"Cataloger, Approver, FirstName, LastName, MI, \").//append(\"Email, ProfessionalTitle, ProfessionalSpecialty, \").\n            append(\"Email, ProfessionalSpecialty, \").append(\"PhoneNumber, InstitutionName, Address1, Address2, \").append(\"City, State, ZipCode, Country, mailingList, modifiedLogin, emailValidated, IAMSEMember, UserName) \").append(\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \").append(\"?, ?, ?, ?, ?, ?, ?, ?,?,?)\");\n        } else {\n            // Use UPDATE statement\n            sql.append(\"UPDATE Users SET \").append(\"Password = ?, Minor = ?, Administrator = ?, \").append(\"Cataloger = ?, Approver = ?, FirstName = ?, \").append(\"LastName = ?, MI = ?, Email = ?, \").//append(\"ProfessionalTitle = ?, ProfessionalSpecialty = ?, \").\n            append(\"ProfessionalSpecialty = ?, \").append(\"PhoneNumber = ?, InstitutionName = ?, Address1 = ?, \").append(\"Address2 = ?, City = ?, State = ?, ZipCode = ?, \").append(\"Country = ?, mailingList = ?, modifiedLogin = ?, emailValidated = ?, IAMSEMember = ? WHERE UserName= ?\");\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql.toString());\n            ps.setString(1, userInfo.getPassword());\n            ps.setBoolean(2, userInfo.isMinor());\n            ps.setBoolean(3, userInfo.isAdministrator());\n            ps.setBoolean(4, userInfo.isCataloger());\n            ps.setBoolean(5, userInfo.isApprover());\n            ps.setString(6, userInfo.getFirstName());\n            ps.setString(7, userInfo.getLastName());\n            ps.setString(8, userInfo.getMiddleInitial());\n            ps.setString(9, userInfo.getEmail());\n            //ps.setString(10, userInfo.getProfessionalTitle());\n            ps.setString(10, userInfo.getProfessionalSpecialty());\n            ps.setString(11, userInfo.getPhoneNumber());\n            ps.setString(12, userInfo.getInstitutionName());\n            ps.setString(13, userInfo.getAddress1());\n            ps.setString(14, userInfo.getAddress2());\n            ps.setString(15, userInfo.getCity());\n            ps.setString(16, userInfo.getState());\n            ps.setString(17, userInfo.getZipCode());\n            ps.setString(18, userInfo.getCountry());\n            ps.setBoolean(19, userInfo.getMailingList());\n            ps.setBoolean(20, true);\n            ps.setBoolean(21, userInfo.isEmailValidated());\n            ps.setBoolean(22, userInfo.isIAMSEMember());\n            ps.setString(23, userInfo.getUserName());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n    }\n\n    public void reset(String username) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET modifiedLogin = 0 where username = ?\");\n            ps.setString(1, username);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean validateEmail(String email, int userId) {\n        PreparedStatement ps = null;\n        int rowCount = 0;\n        boolean update = false;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 1 where email = ? and userId = ?\");\n            ps.setString(1, email);\n            ps.setInt(2, userId);\n            rowCount = ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n        if (rowCount > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateEmail(String email, String newemail) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 0, UserName = ?, email= ? where email = ?\");\n            ps.setString(1, newemail);\n            ps.setString(2, newemail);\n            ps.setString(3, email);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n        } finally {\n            if (null != ps) {\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProfessionalRole(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersProfessionalRole where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        ProfessionalRoleBean prb = null;\n        ArrayList prbs = userInfo.getProfessionalRole();\n        Iterator it = prbs.iterator();\n        while (it.hasNext()) {\n            prb = (ProfessionalRoleBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersProfessionalRole \").append(\"(UserId, ProfessionalRole) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, prb.getProfessionalRole());\n                //System.err.println(\"heree\");\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserInstructionalLevel(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersInstructionalLevel where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        InstructionalLevelBean ilb = null;\n        ArrayList ilbs = userInfo.getInstructionalLevel();\n        Iterator it = ilbs.iterator();\n        while (it.hasNext()) {\n            ilb = (InstructionalLevelBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersInstructionalLevel \").append(\"(UserId, InstructionalLevel) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, ilb.getInstructionalLevel());\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and adds an entry for it\n     * in the Subscriber's table (if it doesn't already exist).\n     * Returns true if successful (also if it already exists in the table)\n     * and false if an error occurs.\n     */\n    public boolean addUserToSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                if (getSubscriber(userId, conn) != null) {\n                    success = true;\n                } else {\n                    success = addSubscriber(userId, conn);\n                }\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and removes any entries for it\n     * in the Subscriber's table.  Returns true if on success and false if\n     * an error occurs.\n     */\n    public boolean removeUserFromSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                success = deleteSubscriber(userId, conn);\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to delete a subscriber from the subscribers table.\n     * This method will delete all subscribers found with the given\n     * UserID (there should only be one, but just in case).\n     */\n    private boolean deleteSubscriber(String userId, Connection conn) throws SQLException {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use DELETE statement\n            sql.append(\"DELETE FROM Subscribers WHERE UserID = ?\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to add a subscriber to the subscribers table.\n     * This method will insert a subscriber regardless of whether or not\n     * it already exists in the tabel.\n     */\n    private boolean addSubscriber(String userId, Connection conn) {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Subscribers (UserID) VALUES(?)\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * If the given userId is found in the subscriber table, then\n     * its corresponding Row is returned.  Otherwise, null is returned\n     * if no subscriber is found.  In case of an error, an SQLException\n     * is throw.\n     */\n    private Row getSubscriber(String userId, Connection conn) throws SQLException {\n        if (userId == null || conn == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM Subscribers WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Looks up all entries in the Users table with a true value for the\n     * administrator setting.  Returns an ArrayList of Strings containing\n     * the email addresses of the found users.\n     */\n    public ArrayList getAdminEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE Administrator = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new BooleanValue(true));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the usernames corresponding to user ids\n     * found in the subscribers table.\n     * Returns an ArrayList of strings.\n     */\n    public ArrayList getAllSubscribers() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList users = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    users = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        users.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            users = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return users;\n    }\n\n    /**\n     * This method gets all of the email addresses found in the users table\n     * corresponding to the given usernames.  Only users with email addresses\n     * in the table will have a value returned.  If an error occurs, null is\n     * returned, other wise a possibly empty (if no user email addresses were\n     * found) ArrayList is returned.\n     */\n    public ArrayList getEmailAddresses(String[] userNames) {\n        //Get the useraddresses from the database\n        if (userNames == null || userNames.length <= 0) {\n            return null;\n        }\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sqlBuffer = new StringBuffer(\"SELECT Email FROM Users WHERE \");\n            sqlBuffer.append(\"UserName = '\" + userNames[0] + \"'\");\n            for (int i = 1; i < userNames.length; i++) {\n                sqlBuffer.append(\" or UserName = '\" + userNames[i] + \"'\");\n            }\n            sqlCommandBean.setSqlValue(sqlBuffer.toString());\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the userIDs found in the subscribers table and\n     * then looks up all the email addresses of those entries from the\n     * Users table.\n     */\n    public ArrayList getSubscriberEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserRegistryBeanTest4.java",
		"test_prompt": "// UserRegistryBeanTest4.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserRegistryBean}.\n* It contains ten unit test cases for the {@link UserRegistryBean#validateEmail(String, int)} method.\n*/\nclass UserRegistryBeanTest4 {"
	},
	{
		"original_code": "// UserRegistryBean.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\n/**\n * This contains methods for authenticating a user,\n * and retrieving and updating user information.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserRegistryBean implements Serializable {\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Returns true if the specified user name and password\n     * match an employee in the database.\n     */\n    public UserBean verifyLogin(String userName, String password, boolean emailIsUsername) throws SQLException {\n        UserBean userInfo = getUser(userName, emailIsUsername);\n        if (userInfo != null && password.equals(userInfo.getPassword())) {\n            return userInfo;\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the given user has the specified permissions.\n     */\n    public boolean checkPermissions(UserBean user, String accessLevel) {\n        /* XXX not currently implemented */\n        return false;\n    }\n\n    /**\n     * Returns true if the user was found in the database, false\n     * otherwise.  Throws an SQLException in the event something goes\n     * wrong.\n     */\n    public boolean userExists(String userName) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(userName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return (userRow != null);\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUserIds() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserId FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserId\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUsernames() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfUsers() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(distinct email) as Expr1 FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getAreaofExpertiseSummary(String value) throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(userid) as Expr1 FROM USERS where professionalSpecialty = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new StringValue(value));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified employee, or null if\n     * not found.\n     */\n    public UserBean getUser(String userName, boolean emailIsUsername) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserProperties(userName, emailIsUsername, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it2 = userInstructionalLevel.iterator();\n            while (it2.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it2.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified email address, or null if\n     * not found.\n     */\n    public UserBean getUserFromEmail(String email) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(email, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return rowToBean(userRow);\n    }\n\n    public UserBean getUserFromID(String userID) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserPropertiesFromID(userID, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it = userInstructionalLevel.iterator();\n            while (it.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAreaofExpertiseValues() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT distinct ProfessionalSpecialty FROM USERS where modifiedLogin = '1'\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"ProfessionalSpecialty\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private UserBean rowToBean(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        UserBean userInfo = new UserBean();\n        try {\n            userInfo.setUserId(userRow.getString(\"UserID\"));\n            userInfo.setUserName(userRow.getString(\"UserName\"));\n            userInfo.setPassword(userRow.getString(\"Password\"));\n            userInfo.setMinor(userRow.getBoolean(\"Minor\"));\n            userInfo.setAdministrator(userRow.getBoolean(\"Administrator\"));\n            userInfo.setCataloger(userRow.getBoolean(\"Cataloger\"));\n            userInfo.setApprover(userRow.getBoolean(\"Approver\"));\n            userInfo.setFirstName(userRow.getString(\"FirstName\"));\n            userInfo.setLastName(userRow.getString(\"LastName\"));\n            userInfo.setMiddleInitial(userRow.getString(\"MI\"));\n            userInfo.setEmail(userRow.getString(\"Email\"));\n            //userInfo.setProfessionalTitle(userRow.getString(\"ProfessionalTitle\"));\n            userInfo.setProfessionalSpecialty(userRow.getString(\"ProfessionalSpecialty\"));\n            userInfo.setPhoneNumber(userRow.getString(\"PhoneNumber\"));\n            userInfo.setInstitutionName(userRow.getString(\"InstitutionName\"));\n            userInfo.setAddress1(userRow.getString(\"Address1\"));\n            userInfo.setAddress2(userRow.getString(\"Address2\"));\n            userInfo.setCity(userRow.getString(\"City\"));\n            userInfo.setState(userRow.getString(\"State\"));\n            userInfo.setZipCode(userRow.getString(\"ZipCode\"));\n            userInfo.setCountry(userRow.getString(\"Country\"));\n            userInfo.setMailingList(userRow.getBoolean(\"mailingList\"));\n            userInfo.setLoginModified(userRow.getBoolean(\"modifiedLogin\"));\n            userInfo.setEmailValidated(userRow.getBoolean(\"emailValidated\"));\n            userInfo.setIAMSEMember(userRow.getBoolean(\"IAMSEMember\"));\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return userInfo;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private ProfessionalRoleBean rowToProfessionalRole(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        ProfessionalRoleBean professionalRole = new ProfessionalRoleBean();\n        try {\n            professionalRole.setProfessionalRoleId(userRow.getString(\"ProfessionalRoleId\"));\n            professionalRole.setUserId(userRow.getString(\"UserId\"));\n            professionalRole.setProfessionalRole(userRow.getString(\"ProfessionalRole\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return professionalRole;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private InstructionalLevelBean rowToInstructionalLevel(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        InstructionalLevelBean instructionalLevel = new InstructionalLevelBean();\n        try {\n            instructionalLevel.setInstructionalLevelId(userRow.getString(\"InstructionalLevelId\"));\n            instructionalLevel.setUserId(userRow.getString(\"UserId\"));\n            instructionalLevel.setInstructionalLevel(userRow.getString(\"InstructionalLevel\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return instructionalLevel;\n    }\n\n    /**\n     * Inserts the information about the specified user, or\n     * updates the information if it's already defined.\n     */\n    public String saveRegistration(UserBean userInfo) throws SQLException {\n        // Save the user info from the database\n        Connection conn = dataSource.getConnection();\n        Connection conn2 = dataSource.getConnection();\n        String userId = \"\";\n        conn.setAutoCommit(false);\n        conn2.setAutoCommit(false);\n        try {\n            saveCompleteUserProperties(userInfo, conn);\n            conn.commit();\n            userId = userInfo.getUserId();\n            if (userInfo.getUserId() == null || userInfo.getUserId().length() == 0) {\n                UserBean userInfo2 = getUserFromEmail(userInfo.getEmail());\n                userInfo.setUserId(userInfo2.getUserId());\n                userId = userInfo2.getUserId();\n            }\n            saveUserProfessionalRole(userInfo, conn2);\n            saveUserInstructionalLevel(userInfo, conn2);\n            conn2.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n                conn2.setAutoCommit(true);\n                conn2.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return userId;\n    }\n\n    /**\n     * Inserts the XML encoded user registration information into the\n     * database, or updates the information if it is already defined.\n     */\n    public void saveRegistration(String xmlRegistration) throws SQLException {\n        UserBean userInfo = new UserBean();\n        userInfo.parseXML(xmlRegistration);\n        saveRegistration(userInfo);\n    }\n\n    /**\n     * Looks up a user property in the Users table that matches the given\n     * UserName.  The property should be a String value such that calling\n     * Row.getString() doesn't cause any problems.\n     */\n    private String getUserStringProperty(String userName, String propertyName, Connection conn) throws SQLException {\n        if (userName == null || propertyName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT \" + propertyName + \" FROM USERS WHERE UserName = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        String result = null;\n        try {\n            result = aRow.getString(propertyName);\n        } catch (NoSuchColumnException ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserProperties(String userName, boolean emailIsUsername, Connection conn) throws SQLException {\n        if (userName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"\";\n        if (emailIsUsername) {\n            sql = \"SELECT * FROM USERS WHERE Email = ? and modifiedLogin = 1\";\n        } else {\n            sql = \"SELECT * FROM USERS WHERE UserName = ?\";\n        }\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserProfessionalRole(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersProfessionalRole WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserInstructionalLevel(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersInstructionalLevel WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserPropertiesFromID(String userID, Connection conn) throws SQLException {\n        if (userID == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userID));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user's email address is not found.\n     */\n    private Row getUserPropertiesFromEmail(String email, Connection conn) throws SQLException {\n        if (email == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE email = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(email));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Given a user ID and a set of permissions, looks up the user in the\n     * database and if the user is found, updates their permissions.  Returns\n     * false if either parameter is null, the user was not found in the\n     * database, or an error occured.  Otherwise the method returns true.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        if (userId == null || permissions == null) {\n            return false;\n        }\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            Row userRow = getUserProperties(userId, false, conn);\n            UserBean user = rowToBean(userRow);\n            if (user != null) {\n                user.setMinor(permissions.isMinor());\n                user.setAdministrator(permissions.isAdministrator());\n                user.setCataloger(permissions.isCataloger());\n                user.setApprover(permissions.isApprover());\n                saveUserProperties(user, conn);\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveCompleteUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        saveUserProperties(userInfo, conn);\n        //conn.commit();\n        //if(userInfo.getUserId() == null || userInfo.getUserId().length()==0)\n        //{\n        //userInfo=getUserFromEmail(userInfo.getEmail());\n        //}\n        //saveUserProfessionalRole(userInfo, conn);\n        //saveUserInstructionalLevel(userInfo, conn);\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        UserBean dbInfo = getUser(userInfo.getUserName(), false);\n        StringBuffer sql = new StringBuffer();\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Users \").append(\"(Password, Minor, Administrator, \").append(\"Cataloger, Approver, FirstName, LastName, MI, \").//append(\"Email, ProfessionalTitle, ProfessionalSpecialty, \").\n            append(\"Email, ProfessionalSpecialty, \").append(\"PhoneNumber, InstitutionName, Address1, Address2, \").append(\"City, State, ZipCode, Country, mailingList, modifiedLogin, emailValidated, IAMSEMember, UserName) \").append(\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \").append(\"?, ?, ?, ?, ?, ?, ?, ?,?,?)\");\n        } else {\n            // Use UPDATE statement\n            sql.append(\"UPDATE Users SET \").append(\"Password = ?, Minor = ?, Administrator = ?, \").append(\"Cataloger = ?, Approver = ?, FirstName = ?, \").append(\"LastName = ?, MI = ?, Email = ?, \").//append(\"ProfessionalTitle = ?, ProfessionalSpecialty = ?, \").\n            append(\"ProfessionalSpecialty = ?, \").append(\"PhoneNumber = ?, InstitutionName = ?, Address1 = ?, \").append(\"Address2 = ?, City = ?, State = ?, ZipCode = ?, \").append(\"Country = ?, mailingList = ?, modifiedLogin = ?, emailValidated = ?, IAMSEMember = ? WHERE UserName= ?\");\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql.toString());\n            ps.setString(1, userInfo.getPassword());\n            ps.setBoolean(2, userInfo.isMinor());\n            ps.setBoolean(3, userInfo.isAdministrator());\n            ps.setBoolean(4, userInfo.isCataloger());\n            ps.setBoolean(5, userInfo.isApprover());\n            ps.setString(6, userInfo.getFirstName());\n            ps.setString(7, userInfo.getLastName());\n            ps.setString(8, userInfo.getMiddleInitial());\n            ps.setString(9, userInfo.getEmail());\n            //ps.setString(10, userInfo.getProfessionalTitle());\n            ps.setString(10, userInfo.getProfessionalSpecialty());\n            ps.setString(11, userInfo.getPhoneNumber());\n            ps.setString(12, userInfo.getInstitutionName());\n            ps.setString(13, userInfo.getAddress1());\n            ps.setString(14, userInfo.getAddress2());\n            ps.setString(15, userInfo.getCity());\n            ps.setString(16, userInfo.getState());\n            ps.setString(17, userInfo.getZipCode());\n            ps.setString(18, userInfo.getCountry());\n            ps.setBoolean(19, userInfo.getMailingList());\n            ps.setBoolean(20, true);\n            ps.setBoolean(21, userInfo.isEmailValidated());\n            ps.setBoolean(22, userInfo.isIAMSEMember());\n            ps.setString(23, userInfo.getUserName());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n    }\n\n    public void reset(String username) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET modifiedLogin = 0 where username = ?\");\n            ps.setString(1, username);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean validateEmail(String email, int userId) {\n        PreparedStatement ps = null;\n        int rowCount = 0;\n        boolean update = false;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 1 where email = ? and userId = ?\");\n            ps.setString(1, email);\n            ps.setInt(2, userId);\n            rowCount = ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n        if (rowCount > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateEmail(String email, String newemail) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 0, UserName = ?, email= ? where email = ?\");\n            ps.setString(1, newemail);\n            ps.setString(2, newemail);\n            ps.setString(3, email);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n        } finally {\n            if (null != ps) {\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProfessionalRole(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersProfessionalRole where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        ProfessionalRoleBean prb = null;\n        ArrayList prbs = userInfo.getProfessionalRole();\n        Iterator it = prbs.iterator();\n        while (it.hasNext()) {\n            prb = (ProfessionalRoleBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersProfessionalRole \").append(\"(UserId, ProfessionalRole) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, prb.getProfessionalRole());\n                //System.err.println(\"heree\");\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserInstructionalLevel(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersInstructionalLevel where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        InstructionalLevelBean ilb = null;\n        ArrayList ilbs = userInfo.getInstructionalLevel();\n        Iterator it = ilbs.iterator();\n        while (it.hasNext()) {\n            ilb = (InstructionalLevelBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersInstructionalLevel \").append(\"(UserId, InstructionalLevel) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, ilb.getInstructionalLevel());\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and adds an entry for it\n     * in the Subscriber's table (if it doesn't already exist).\n     * Returns true if successful (also if it already exists in the table)\n     * and false if an error occurs.\n     */\n    public boolean addUserToSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                if (getSubscriber(userId, conn) != null) {\n                    success = true;\n                } else {\n                    success = addSubscriber(userId, conn);\n                }\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and removes any entries for it\n     * in the Subscriber's table.  Returns true if on success and false if\n     * an error occurs.\n     */\n    public boolean removeUserFromSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                success = deleteSubscriber(userId, conn);\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to delete a subscriber from the subscribers table.\n     * This method will delete all subscribers found with the given\n     * UserID (there should only be one, but just in case).\n     */\n    private boolean deleteSubscriber(String userId, Connection conn) throws SQLException {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use DELETE statement\n            sql.append(\"DELETE FROM Subscribers WHERE UserID = ?\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to add a subscriber to the subscribers table.\n     * This method will insert a subscriber regardless of whether or not\n     * it already exists in the tabel.\n     */\n    private boolean addSubscriber(String userId, Connection conn) {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Subscribers (UserID) VALUES(?)\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * If the given userId is found in the subscriber table, then\n     * its corresponding Row is returned.  Otherwise, null is returned\n     * if no subscriber is found.  In case of an error, an SQLException\n     * is throw.\n     */\n    private Row getSubscriber(String userId, Connection conn) throws SQLException {\n        if (userId == null || conn == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM Subscribers WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Looks up all entries in the Users table with a true value for the\n     * administrator setting.  Returns an ArrayList of Strings containing\n     * the email addresses of the found users.\n     */\n    public ArrayList getAdminEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE Administrator = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new BooleanValue(true));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the usernames corresponding to user ids\n     * found in the subscribers table.\n     * Returns an ArrayList of strings.\n     */\n    public ArrayList getAllSubscribers() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList users = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    users = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        users.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            users = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return users;\n    }\n\n    /**\n     * This method gets all of the email addresses found in the users table\n     * corresponding to the given usernames.  Only users with email addresses\n     * in the table will have a value returned.  If an error occurs, null is\n     * returned, other wise a possibly empty (if no user email addresses were\n     * found) ArrayList is returned.\n     */\n    public ArrayList getEmailAddresses(String[] userNames) {\n        //Get the useraddresses from the database\n        if (userNames == null || userNames.length <= 0) {\n            return null;\n        }\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sqlBuffer = new StringBuffer(\"SELECT Email FROM Users WHERE \");\n            sqlBuffer.append(\"UserName = '\" + userNames[0] + \"'\");\n            for (int i = 1; i < userNames.length; i++) {\n                sqlBuffer.append(\" or UserName = '\" + userNames[i] + \"'\");\n            }\n            sqlCommandBean.setSqlValue(sqlBuffer.toString());\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the userIDs found in the subscribers table and\n     * then looks up all the email addresses of those entries from the\n     * Users table.\n     */\n    public ArrayList getSubscriberEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserRegistryBeanTest5.java",
		"test_prompt": "// UserRegistryBeanTest5.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserRegistryBean}.\n* It contains ten unit test cases for the {@link UserRegistryBean#addUserToSubscribers(String)} method.\n*/\nclass UserRegistryBeanTest5 {"
	},
	{
		"original_code": "// UserRegistryBean.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\n/**\n * This contains methods for authenticating a user,\n * and retrieving and updating user information.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserRegistryBean implements Serializable {\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Returns true if the specified user name and password\n     * match an employee in the database.\n     */\n    public UserBean verifyLogin(String userName, String password, boolean emailIsUsername) throws SQLException {\n        UserBean userInfo = getUser(userName, emailIsUsername);\n        if (userInfo != null && password.equals(userInfo.getPassword())) {\n            return userInfo;\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the given user has the specified permissions.\n     */\n    public boolean checkPermissions(UserBean user, String accessLevel) {\n        /* XXX not currently implemented */\n        return false;\n    }\n\n    /**\n     * Returns true if the user was found in the database, false\n     * otherwise.  Throws an SQLException in the event something goes\n     * wrong.\n     */\n    public boolean userExists(String userName) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(userName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return (userRow != null);\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUserIds() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserId FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserId\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAllUsernames() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfUsers() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(distinct email) as Expr1 FROM USERS\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getAreaofExpertiseSummary(String value) throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(userid) as Expr1 FROM USERS where professionalSpecialty = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new StringValue(value));\n            sqlCommandBean.setValues(values);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified employee, or null if\n     * not found.\n     */\n    public UserBean getUser(String userName, boolean emailIsUsername) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserProperties(userName, emailIsUsername, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it2 = userInstructionalLevel.iterator();\n            while (it2.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it2.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns an UserBean initialized with the information\n     * found in the database for the specified email address, or null if\n     * not found.\n     */\n    public UserBean getUserFromEmail(String email) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        try {\n            userRow = getUserPropertiesFromEmail(email, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return rowToBean(userRow);\n    }\n\n    public UserBean getUserFromID(String userID) throws SQLException {\n        // Get the user info from the database\n        Connection conn = dataSource.getConnection();\n        Row userRow = null;\n        Vector userProfessionalRoleRow = null;\n        Vector userInstructionalLevel = null;\n        UserBean userBean = new UserBean();\n        try {\n            userRow = getUserPropertiesFromID(userID, conn);\n            userBean = rowToBean(userRow);\n            if (userRow != null) {\n                userProfessionalRoleRow = getUserProfessionalRole(userBean.getUserId(), conn);\n                userInstructionalLevel = getUserInstructionalLevel(userBean.getUserId(), conn);\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (userProfessionalRoleRow != null) {\n            Iterator it = userProfessionalRoleRow.iterator();\n            while (it.hasNext()) {\n                userBean.addProfessionalRole(rowToProfessionalRole((Row) it.next()));\n            }\n        }\n        if (userInstructionalLevel != null) {\n            Iterator it = userInstructionalLevel.iterator();\n            while (it.hasNext()) {\n                userBean.addInstructionalLevel(rowToInstructionalLevel((Row) it.next()));\n            }\n        }\n        return userBean;\n    }\n\n    /**\n     * Returns a Vector of Strings of all of the usernames in the\n     * database.  Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public Vector getAreaofExpertiseValues() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        Vector names = null;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT distinct ProfessionalSpecialty FROM USERS where modifiedLogin = '1'\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            try {\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    names = new Vector();\n                    Object[] rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        String name = ((Row) rowArray[rowIndex]).getString(\"ProfessionalSpecialty\");\n                        names.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private UserBean rowToBean(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        UserBean userInfo = new UserBean();\n        try {\n            userInfo.setUserId(userRow.getString(\"UserID\"));\n            userInfo.setUserName(userRow.getString(\"UserName\"));\n            userInfo.setPassword(userRow.getString(\"Password\"));\n            userInfo.setMinor(userRow.getBoolean(\"Minor\"));\n            userInfo.setAdministrator(userRow.getBoolean(\"Administrator\"));\n            userInfo.setCataloger(userRow.getBoolean(\"Cataloger\"));\n            userInfo.setApprover(userRow.getBoolean(\"Approver\"));\n            userInfo.setFirstName(userRow.getString(\"FirstName\"));\n            userInfo.setLastName(userRow.getString(\"LastName\"));\n            userInfo.setMiddleInitial(userRow.getString(\"MI\"));\n            userInfo.setEmail(userRow.getString(\"Email\"));\n            //userInfo.setProfessionalTitle(userRow.getString(\"ProfessionalTitle\"));\n            userInfo.setProfessionalSpecialty(userRow.getString(\"ProfessionalSpecialty\"));\n            userInfo.setPhoneNumber(userRow.getString(\"PhoneNumber\"));\n            userInfo.setInstitutionName(userRow.getString(\"InstitutionName\"));\n            userInfo.setAddress1(userRow.getString(\"Address1\"));\n            userInfo.setAddress2(userRow.getString(\"Address2\"));\n            userInfo.setCity(userRow.getString(\"City\"));\n            userInfo.setState(userRow.getString(\"State\"));\n            userInfo.setZipCode(userRow.getString(\"ZipCode\"));\n            userInfo.setCountry(userRow.getString(\"Country\"));\n            userInfo.setMailingList(userRow.getBoolean(\"mailingList\"));\n            userInfo.setLoginModified(userRow.getBoolean(\"modifiedLogin\"));\n            userInfo.setEmailValidated(userRow.getBoolean(\"emailValidated\"));\n            userInfo.setIAMSEMember(userRow.getBoolean(\"IAMSEMember\"));\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return userInfo;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private ProfessionalRoleBean rowToProfessionalRole(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        ProfessionalRoleBean professionalRole = new ProfessionalRoleBean();\n        try {\n            professionalRole.setProfessionalRoleId(userRow.getString(\"ProfessionalRoleId\"));\n            professionalRole.setUserId(userRow.getString(\"UserId\"));\n            professionalRole.setProfessionalRole(userRow.getString(\"ProfessionalRole\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return professionalRole;\n    }\n\n    /**\n     * Takes a Row obtained from the database and translates that into\n     * a UserBean.  Returns null if the userRow is null and throws\n     * and SQLException if an error occurs.\n     */\n    private InstructionalLevelBean rowToInstructionalLevel(Row userRow) throws SQLException {\n        // Create a UserBean if the user was found\n        if (userRow == null) {\n            // Not found\n            return null;\n        }\n        InstructionalLevelBean instructionalLevel = new InstructionalLevelBean();\n        try {\n            instructionalLevel.setInstructionalLevelId(userRow.getString(\"InstructionalLevelId\"));\n            instructionalLevel.setUserId(userRow.getString(\"UserId\"));\n            instructionalLevel.setInstructionalLevel(userRow.getString(\"InstructionalLevel\"));\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n        return instructionalLevel;\n    }\n\n    /**\n     * Inserts the information about the specified user, or\n     * updates the information if it's already defined.\n     */\n    public String saveRegistration(UserBean userInfo) throws SQLException {\n        // Save the user info from the database\n        Connection conn = dataSource.getConnection();\n        Connection conn2 = dataSource.getConnection();\n        String userId = \"\";\n        conn.setAutoCommit(false);\n        conn2.setAutoCommit(false);\n        try {\n            saveCompleteUserProperties(userInfo, conn);\n            conn.commit();\n            userId = userInfo.getUserId();\n            if (userInfo.getUserId() == null || userInfo.getUserId().length() == 0) {\n                UserBean userInfo2 = getUserFromEmail(userInfo.getEmail());\n                userInfo.setUserId(userInfo2.getUserId());\n                userId = userInfo2.getUserId();\n            }\n            saveUserProfessionalRole(userInfo, conn2);\n            saveUserInstructionalLevel(userInfo, conn2);\n            conn2.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n                conn2.setAutoCommit(true);\n                conn2.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return userId;\n    }\n\n    /**\n     * Inserts the XML encoded user registration information into the\n     * database, or updates the information if it is already defined.\n     */\n    public void saveRegistration(String xmlRegistration) throws SQLException {\n        UserBean userInfo = new UserBean();\n        userInfo.parseXML(xmlRegistration);\n        saveRegistration(userInfo);\n    }\n\n    /**\n     * Looks up a user property in the Users table that matches the given\n     * UserName.  The property should be a String value such that calling\n     * Row.getString() doesn't cause any problems.\n     */\n    private String getUserStringProperty(String userName, String propertyName, Connection conn) throws SQLException {\n        if (userName == null || propertyName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT \" + propertyName + \" FROM USERS WHERE UserName = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        String result = null;\n        try {\n            result = aRow.getString(propertyName);\n        } catch (NoSuchColumnException ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserProperties(String userName, boolean emailIsUsername, Connection conn) throws SQLException {\n        if (userName == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"\";\n        if (emailIsUsername) {\n            sql = \"SELECT * FROM USERS WHERE Email = ? and modifiedLogin = 1\";\n        } else {\n            sql = \"SELECT * FROM USERS WHERE UserName = ?\";\n        }\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userName));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserProfessionalRole(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersProfessionalRole WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Vector getUserInstructionalLevel(String userId, Connection conn) throws SQLException {\n        if (userId == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM UsersInstructionalLevel WHERE UserId = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        //return (Row) rows.firstElement();\n        return rows;\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user is not found.\n     */\n    private Row getUserPropertiesFromID(String userID, Connection conn) throws SQLException {\n        if (userID == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userID));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Returns a Row with all information about the specified\n     * user or null if the user's email address is not found.\n     */\n    private Row getUserPropertiesFromEmail(String email, Connection conn) throws SQLException {\n        if (email == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM USERS WHERE email = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(email));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Given a user ID and a set of permissions, looks up the user in the\n     * database and if the user is found, updates their permissions.  Returns\n     * false if either parameter is null, the user was not found in the\n     * database, or an error occured.  Otherwise the method returns true.\n     */\n    public boolean setPermissions(String userId, UserPermissionsBean permissions) {\n        if (userId == null || permissions == null) {\n            return false;\n        }\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            conn.setAutoCommit(false);\n            Row userRow = getUserProperties(userId, false, conn);\n            UserBean user = rowToBean(userRow);\n            if (user != null) {\n                user.setMinor(permissions.isMinor());\n                user.setAdministrator(permissions.isAdministrator());\n                user.setCataloger(permissions.isCataloger());\n                user.setApprover(permissions.isApprover());\n                saveUserProperties(user, conn);\n                success = true;\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.setAutoCommit(true);\n                    conn.commit();\n                    conn.close();\n                }\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveCompleteUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        saveUserProperties(userInfo, conn);\n        //conn.commit();\n        //if(userInfo.getUserId() == null || userInfo.getUserId().length()==0)\n        //{\n        //userInfo=getUserFromEmail(userInfo.getEmail());\n        //}\n        //saveUserProfessionalRole(userInfo, conn);\n        //saveUserInstructionalLevel(userInfo, conn);\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProperties(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        UserBean dbInfo = getUser(userInfo.getUserName(), false);\n        StringBuffer sql = new StringBuffer();\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Users \").append(\"(Password, Minor, Administrator, \").append(\"Cataloger, Approver, FirstName, LastName, MI, \").//append(\"Email, ProfessionalTitle, ProfessionalSpecialty, \").\n            append(\"Email, ProfessionalSpecialty, \").append(\"PhoneNumber, InstitutionName, Address1, Address2, \").append(\"City, State, ZipCode, Country, mailingList, modifiedLogin, emailValidated, IAMSEMember, UserName) \").append(\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \").append(\"?, ?, ?, ?, ?, ?, ?, ?,?,?)\");\n        } else {\n            // Use UPDATE statement\n            sql.append(\"UPDATE Users SET \").append(\"Password = ?, Minor = ?, Administrator = ?, \").append(\"Cataloger = ?, Approver = ?, FirstName = ?, \").append(\"LastName = ?, MI = ?, Email = ?, \").//append(\"ProfessionalTitle = ?, ProfessionalSpecialty = ?, \").\n            append(\"ProfessionalSpecialty = ?, \").append(\"PhoneNumber = ?, InstitutionName = ?, Address1 = ?, \").append(\"Address2 = ?, City = ?, State = ?, ZipCode = ?, \").append(\"Country = ?, mailingList = ?, modifiedLogin = ?, emailValidated = ?, IAMSEMember = ? WHERE UserName= ?\");\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(sql.toString());\n            ps.setString(1, userInfo.getPassword());\n            ps.setBoolean(2, userInfo.isMinor());\n            ps.setBoolean(3, userInfo.isAdministrator());\n            ps.setBoolean(4, userInfo.isCataloger());\n            ps.setBoolean(5, userInfo.isApprover());\n            ps.setString(6, userInfo.getFirstName());\n            ps.setString(7, userInfo.getLastName());\n            ps.setString(8, userInfo.getMiddleInitial());\n            ps.setString(9, userInfo.getEmail());\n            //ps.setString(10, userInfo.getProfessionalTitle());\n            ps.setString(10, userInfo.getProfessionalSpecialty());\n            ps.setString(11, userInfo.getPhoneNumber());\n            ps.setString(12, userInfo.getInstitutionName());\n            ps.setString(13, userInfo.getAddress1());\n            ps.setString(14, userInfo.getAddress2());\n            ps.setString(15, userInfo.getCity());\n            ps.setString(16, userInfo.getState());\n            ps.setString(17, userInfo.getZipCode());\n            ps.setString(18, userInfo.getCountry());\n            ps.setBoolean(19, userInfo.getMailingList());\n            ps.setBoolean(20, true);\n            ps.setBoolean(21, userInfo.isEmailValidated());\n            ps.setBoolean(22, userInfo.isIAMSEMember());\n            ps.setString(23, userInfo.getUserName());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n    }\n\n    public void reset(String username) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET modifiedLogin = 0 where username = ?\");\n            ps.setString(1, username);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean validateEmail(String email, int userId) {\n        PreparedStatement ps = null;\n        int rowCount = 0;\n        boolean update = false;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 1 where email = ? and userId = ?\");\n            ps.setString(1, email);\n            ps.setInt(2, userId);\n            rowCount = ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n            sqlEx.printStackTrace();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                    sqlEx.printStackTrace();\n                }\n            }\n        }\n        if (rowCount > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateEmail(String email, String newemail) {\n        PreparedStatement ps = null;\n        try {\n            Connection conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"UPDATE Users SET emailValidated = 0, UserName = ?, email= ? where email = ?\");\n            ps.setString(1, newemail);\n            ps.setString(2, newemail);\n            ps.setString(3, email);\n            ps.executeUpdate();\n        } catch (SQLException sqlEx) {\n        } finally {\n            if (null != ps) {\n                try {\n                    ps.close();\n                } catch (SQLException sqlEx) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserProfessionalRole(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersProfessionalRole where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        ProfessionalRoleBean prb = null;\n        ArrayList prbs = userInfo.getProfessionalRole();\n        Iterator it = prbs.iterator();\n        while (it.hasNext()) {\n            prb = (ProfessionalRoleBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersProfessionalRole \").append(\"(UserId, ProfessionalRole) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, prb.getProfessionalRole());\n                //System.err.println(\"heree\");\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inserts the information about the specified user,\n     * or updates the information if it's already defined.\n     */\n    private void saveUserInstructionalLevel(UserBean userInfo, Connection conn) throws SQLException {\n        if (userInfo == null) {\n            return;\n        }\n        PreparedStatement ps = null;\n        try {\n            ps = conn.prepareStatement(\"DELETE UsersInstructionalLevel where UserId = ?\");\n            ps.setString(1, userInfo.getUserId());\n            ps.executeUpdate();\n        } finally {\n            if (null != ps) {\n                // If this isn't in a finally block, then an SQL Exception\n                // will leave the prepared statement open when it's returned\n                // to the connection pool, causing cloned connection transaction\n                // exceptions\n                ps.close();\n            }\n        }\n        String userId = userInfo.getUserId();\n        InstructionalLevelBean ilb = null;\n        ArrayList ilbs = userInfo.getInstructionalLevel();\n        Iterator it = ilbs.iterator();\n        while (it.hasNext()) {\n            ilb = (InstructionalLevelBean) it.next();\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO UsersInstructionalLevel \").append(\"(UserId, InstructionalLevel) \").append(\"VALUES (?,?)\");\n            try {\n                ps = conn.prepareStatement(sql.toString());\n                ps.setInt(1, Integer.parseInt(userId));\n                ps.setString(2, ilb.getInstructionalLevel());\n                ps.executeUpdate();\n            } finally {\n                if (null != ps) {\n                    // If this isn't in a finally block, then an SQL Exception\n                    // will leave the prepared statement open when it's returned\n                    // to the connection pool, causing cloned connection transaction\n                    // exceptions\n                    ps.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and adds an entry for it\n     * in the Subscriber's table (if it doesn't already exist).\n     * Returns true if successful (also if it already exists in the table)\n     * and false if an error occurs.\n     */\n    public boolean addUserToSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                if (getSubscriber(userId, conn) != null) {\n                    success = true;\n                } else {\n                    success = addSubscriber(userId, conn);\n                }\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Looks up the user's ID in the Users table and removes any entries for it\n     * in the Subscriber's table.  Returns true if on success and false if\n     * an error occurs.\n     */\n    public boolean removeUserFromSubscribers(String userName) {\n        boolean success = false;\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n            String userId = getUserStringProperty(userName, \"UserID\", conn);\n            if (userId != null) {\n                success = deleteSubscriber(userId, conn);\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException ex) {\n                //ignore, we just want the connection closed.\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to delete a subscriber from the subscribers table.\n     * This method will delete all subscribers found with the given\n     * UserID (there should only be one, but just in case).\n     */\n    private boolean deleteSubscriber(String userId, Connection conn) throws SQLException {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use DELETE statement\n            sql.append(\"DELETE FROM Subscribers WHERE UserID = ?\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * Attempts to add a subscriber to the subscribers table.\n     * This method will insert a subscriber regardless of whether or not\n     * it already exists in the tabel.\n     */\n    private boolean addSubscriber(String userId, Connection conn) {\n        boolean success = false;\n        if (userId == null || conn == null) {\n            return false;\n        }\n        try {\n            StringBuffer sql = new StringBuffer();\n            // Use INSERT statement\n            sql.append(\"INSERT INTO Subscribers (UserID) VALUES(?)\");\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(userId));\n            sqlCommandBean.setValues(values);\n            sqlCommandBean.executeUpdate();\n            success = true;\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        return success;\n    }\n\n    /**\n     * If the given userId is found in the subscriber table, then\n     * its corresponding Row is returned.  Otherwise, null is returned\n     * if no subscriber is found.  In case of an error, an SQLException\n     * is throw.\n     */\n    private Row getSubscriber(String userId, Connection conn) throws SQLException {\n        if (userId == null || conn == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sql = \"SELECT * FROM Subscribers WHERE UserID = ?\";\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(userId));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        // Can not happen here\n        if (rows == null || rows.size() == 0) {\n            // User not found\n            return null;\n        }\n        return (Row) rows.firstElement();\n    }\n\n    /**\n     * Looks up all entries in the Users table with a true value for the\n     * administrator setting.  Returns an ArrayList of Strings containing\n     * the email addresses of the found users.\n     */\n    public ArrayList getAdminEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE Administrator = ?\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector values = new Vector();\n            values.addElement(new BooleanValue(true));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the usernames corresponding to user ids\n     * found in the subscribers table.\n     * Returns an ArrayList of strings.\n     */\n    public ArrayList getAllSubscribers() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList users = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT UserName FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    users = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"UserName\");\n                        users.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            users = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return users;\n    }\n\n    /**\n     * This method gets all of the email addresses found in the users table\n     * corresponding to the given usernames.  Only users with email addresses\n     * in the table will have a value returned.  If an error occurs, null is\n     * returned, other wise a possibly empty (if no user email addresses were\n     * found) ArrayList is returned.\n     */\n    public ArrayList getEmailAddresses(String[] userNames) {\n        //Get the useraddresses from the database\n        if (userNames == null || userNames.length <= 0) {\n            return null;\n        }\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sqlBuffer = new StringBuffer(\"SELECT Email FROM Users WHERE \");\n            sqlBuffer.append(\"UserName = '\" + userNames[0] + \"'\");\n            for (int i = 1; i < userNames.length; i++) {\n                sqlBuffer.append(\" or UserName = '\" + userNames[i] + \"'\");\n            }\n            sqlCommandBean.setSqlValue(sqlBuffer.toString());\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n\n    /**\n     * This method gets all of the userIDs found in the subscribers table and\n     * then looks up all the email addresses of those entries from the\n     * Users table.\n     */\n    public ArrayList getSubscriberEmailAddresses() {\n        //Get the useraddresses from the database\n        Connection conn = null;\n        ArrayList addresses = null;\n        try {\n            conn = dataSource.getConnection();\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Email FROM Users WHERE UserID =some (SELECT UserID FROM Subscribers)\";\n            sqlCommandBean.setSqlValue(sql);\n            Vector rows = null;\n            String name;\n            Object[] rowArray;\n            try {\n                rows = sqlCommandBean.executeQuery();\n                if (rows != null && rows.size() > 0) {\n                    addresses = new ArrayList();\n                    rowArray = rows.toArray();\n                    for (int rowIndex = 0; rowIndex < rowArray.length; rowIndex++) {\n                        name = ((Row) rowArray[rowIndex]).getString(\"Email\");\n                        addresses.add(name);\n                    }\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            }\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            addresses = null;\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return addresses;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserRegistryBeanTest6.java",
		"test_prompt": "// UserRegistryBeanTest6.java\npackage org.heal.module.user;\n\nimport com.ora.jsp.sql.*;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport java.util.Iterator;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserRegistryBean}.\n* It contains ten unit test cases for the {@link UserRegistryBean#removeUserFromSubscribers(String)} method.\n*/\nclass UserRegistryBeanTest6 {"
	},
	{
		"original_code": "// UserPermissionsBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains permissions information about a heal user.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class UserPermissionsBean implements Serializable {\n\n    // Properties\n    private boolean minor = false;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    //Returns whether or not the user is a IAMSE Member.\n    public boolean isIAMSEMember() {\n        return IAMSEMember;\n    }\n\n    // Sets whether or not the user is a IAMSE Member.\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserPermissionsBeanTest0.java",
		"test_prompt": "// UserPermissionsBeanTest0.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserPermissionsBean}.\n* It contains ten unit test cases for the {@link UserPermissionsBean#isMinor()} method.\n*/\nclass UserPermissionsBeanTest0 {"
	},
	{
		"original_code": "// UserPermissionsBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains permissions information about a heal user.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class UserPermissionsBean implements Serializable {\n\n    // Properties\n    private boolean minor = false;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    //Returns whether or not the user is a IAMSE Member.\n    public boolean isIAMSEMember() {\n        return IAMSEMember;\n    }\n\n    // Sets whether or not the user is a IAMSE Member.\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserPermissionsBeanTest1.java",
		"test_prompt": "// UserPermissionsBeanTest1.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserPermissionsBean}.\n* It contains ten unit test cases for the {@link UserPermissionsBean#isAdministrator()} method.\n*/\nclass UserPermissionsBeanTest1 {"
	},
	{
		"original_code": "// UserPermissionsBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains permissions information about a heal user.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class UserPermissionsBean implements Serializable {\n\n    // Properties\n    private boolean minor = false;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    //Returns whether or not the user is a IAMSE Member.\n    public boolean isIAMSEMember() {\n        return IAMSEMember;\n    }\n\n    // Sets whether or not the user is a IAMSE Member.\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserPermissionsBeanTest2.java",
		"test_prompt": "// UserPermissionsBeanTest2.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserPermissionsBean}.\n* It contains ten unit test cases for the {@link UserPermissionsBean#isCataloger()} method.\n*/\nclass UserPermissionsBeanTest2 {"
	},
	{
		"original_code": "// UserPermissionsBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains permissions information about a heal user.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class UserPermissionsBean implements Serializable {\n\n    // Properties\n    private boolean minor = false;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    //Returns whether or not the user is a IAMSE Member.\n    public boolean isIAMSEMember() {\n        return IAMSEMember;\n    }\n\n    // Sets whether or not the user is a IAMSE Member.\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserPermissionsBeanTest3.java",
		"test_prompt": "// UserPermissionsBeanTest3.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserPermissionsBean}.\n* It contains ten unit test cases for the {@link UserPermissionsBean#isApprover()} method.\n*/\nclass UserPermissionsBeanTest3 {"
	},
	{
		"original_code": "// UserPermissionsBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains permissions information about a heal user.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class UserPermissionsBean implements Serializable {\n\n    // Properties\n    private boolean minor = false;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    //Returns whether or not the user is a IAMSE Member.\n    public boolean isIAMSEMember() {\n        return IAMSEMember;\n    }\n\n    // Sets whether or not the user is a IAMSE Member.\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserPermissionsBeanTest4.java",
		"test_prompt": "// UserPermissionsBeanTest4.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserPermissionsBean}.\n* It contains ten unit test cases for the {@link UserPermissionsBean#isIAMSEMember()} method.\n*/\nclass UserPermissionsBeanTest4 {"
	},
	{
		"original_code": "// UserBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about heal users.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserBean implements Serializable {\n\n    // Properties\n    private String userId = \"\";\n\n    private String userName = \"\";\n\n    private String password = \"\";\n\n    private boolean minor = true;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private String firstName = \"\";\n\n    private String lastName = \"\";\n\n    private String middleInitial = \"\";\n\n    private String email = \"\";\n\n    ArrayList professionalRole = new ArrayList();\n\n    String professionalSpecialty = \"\";\n\n    ArrayList instructionalLevel = new ArrayList();\n\n    private String phoneNumber = \"\";\n\n    private String institutionName = \"\";\n\n    private String address1 = \"\";\n\n    private String address2 = \"\";\n\n    private String city = \"\";\n\n    private String state = \"\";\n\n    private String zipCode = \"\";\n\n    private String country = \"\";\n\n    private boolean mailingList = true;\n\n    private boolean loginModified = false;\n\n    private boolean emailValidated = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns the bean's data in encoded in XML format.\n     */\n    public String getXML() {\n        //XXX implement this later.\n        return \"not implemented\";\n    }\n\n    /**\n     * Parses the XML string and stores the data in the bean.\n     */\n    public void parseXML(String xmlData) {\n        //XXX not implemented.\n    }\n\n    /**\n     * Returns the UserId property value.\n     */\n    public String getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setUserId(String newUserId) {\n        this.userId = newUserId;\n    }\n\n    /**\n     * Returns the userName property value.\n     */\n    public String getUserName() {\n        return userName;\n    }\n\n    /**\n     * Sets the userName property value.\n     */\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    /**\n     * Returns the password property value.\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password property value.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    /**\n     * Returns the firstName property value.\n     */\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    /**\n     * Sets the firstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.firstName = newFirstName;\n    }\n\n    /**\n     * Returns the lastName property value.\n     */\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    /**\n     * Sets the lastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.lastName = newLastName;\n    }\n\n    /**\n     * Returns the middleInitial property value.\n     */\n    public String getMiddleInitial() {\n        return this.middleInitial;\n    }\n\n    /**\n     * Sets the middleInitial property value.\n     */\n    public void setMiddleInitial(String newMiddleInitial) {\n        this.middleInitial = newMiddleInitial;\n    }\n\n    /**\n     * Returns the email property value.\n     */\n    public String getEmail() {\n        return this.email;\n    }\n\n    /**\n     * Sets the email property value.\n     */\n    public void setEmail(String newEmail) {\n        this.email = newEmail;\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getInstructionalLevel() {\n        return instructionalLevel;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setInstructionalLevel(ArrayList newInstructionalLevel) {\n        instructionalLevel = newInstructionalLevel;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addInstructionalLevel(InstructionalLevelBean newInstructionalLevel) {\n        instructionalLevel.add(newInstructionalLevel);\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getProfessionalRole() {\n        return professionalRole;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setProfessionalRole(ArrayList newProfessionalRole) {\n        professionalRole = newProfessionalRole;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addProfessionalRole(ProfessionalRoleBean newProfessionalRole) {\n        professionalRole.add(newProfessionalRole);\n    }\n\n    /**\n     * Returns the professionalSpecialty property value.\n     */\n    public String getProfessionalSpecialty() {\n        return this.professionalSpecialty;\n    }\n\n    /**\n     * Sets the professionalSpecialty property value.\n     */\n    public void setProfessionalSpecialty(String newProfessionalSpecialty) {\n        this.professionalSpecialty = newProfessionalSpecialty;\n    }\n\n    /**\n     * Returns the phoneNumber property value.\n     */\n    public String getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber property value.\n     */\n    public void setPhoneNumber(String newPhoneNumber) {\n        this.phoneNumber = newPhoneNumber;\n    }\n\n    /**\n     * Returns the institutionName property value.\n     */\n    public String getInstitutionName() {\n        return this.institutionName;\n    }\n\n    /**\n     * Sets the institutionName property value.\n     */\n    public void setInstitutionName(String newInstitutionName) {\n        this.institutionName = newInstitutionName;\n    }\n\n    /**\n     * Returns the address1 property value.\n     */\n    public String getAddress1() {\n        return this.address1;\n    }\n\n    /**\n     * Sets the address1 property value.\n     */\n    public void setAddress1(String newAddress1) {\n        this.address1 = newAddress1;\n    }\n\n    /**\n     * Returns the address2 property value.\n     */\n    public String getAddress2() {\n        return this.address2;\n    }\n\n    /**\n     * Sets the address2 property value.\n     */\n    public void setAddress2(String newAddress2) {\n        this.address2 = newAddress2;\n    }\n\n    /**\n     * Returns the city property value.\n     */\n    public String getCity() {\n        return this.city;\n    }\n\n    /**\n     * Sets the city property value.\n     */\n    public void setCity(String newCity) {\n        this.city = newCity;\n    }\n\n    /**\n     * Returns the state property value.\n     */\n    public String getState() {\n        return this.state;\n    }\n\n    /**\n     * Sets the state property value.\n     */\n    public void setState(String newState) {\n        this.state = newState;\n    }\n\n    /**\n     * Returns the zipCode property value.\n     */\n    public String getZipCode() {\n        return this.zipCode;\n    }\n\n    /**\n     * Sets the zipCode property value.\n     */\n    public void setZipCode(String newZipCode) {\n        this.zipCode = newZipCode;\n    }\n\n    /**\n     * Returns the country property value.\n     */\n    public String getCountry() {\n        return this.country;\n    }\n\n    /**\n     * Sets the country property value.\n     */\n    public void setCountry(String newCountry) {\n        this.country = newCountry;\n    }\n\n    /**\n     * Returns the mailingList property value.\n     */\n    public boolean getMailingList() {\n        return this.mailingList;\n    }\n\n    /**\n     * Sets the mailingList property value.\n     */\n    public void setMailingList(boolean newMailingList) {\n        this.mailingList = newMailingList;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isLoginModified() {\n        return this.loginModified;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setLoginModified(boolean newLoginModified) {\n        this.loginModified = newLoginModified;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isEmailValidated() {\n        return this.emailValidated;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setEmailValidated(boolean newEmailValidated) {\n        this.emailValidated = newEmailValidated;\n    }\n\n    public boolean isIAMSEMember() {\n        return this.IAMSEMember;\n    }\n\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserBeanTest0.java",
		"test_prompt": "// UserBeanTest0.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserBean}.\n* It contains ten unit test cases for the {@link UserBean#isMinor()} method.\n*/\nclass UserBeanTest0 {"
	},
	{
		"original_code": "// UserBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about heal users.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserBean implements Serializable {\n\n    // Properties\n    private String userId = \"\";\n\n    private String userName = \"\";\n\n    private String password = \"\";\n\n    private boolean minor = true;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private String firstName = \"\";\n\n    private String lastName = \"\";\n\n    private String middleInitial = \"\";\n\n    private String email = \"\";\n\n    ArrayList professionalRole = new ArrayList();\n\n    String professionalSpecialty = \"\";\n\n    ArrayList instructionalLevel = new ArrayList();\n\n    private String phoneNumber = \"\";\n\n    private String institutionName = \"\";\n\n    private String address1 = \"\";\n\n    private String address2 = \"\";\n\n    private String city = \"\";\n\n    private String state = \"\";\n\n    private String zipCode = \"\";\n\n    private String country = \"\";\n\n    private boolean mailingList = true;\n\n    private boolean loginModified = false;\n\n    private boolean emailValidated = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns the bean's data in encoded in XML format.\n     */\n    public String getXML() {\n        //XXX implement this later.\n        return \"not implemented\";\n    }\n\n    /**\n     * Parses the XML string and stores the data in the bean.\n     */\n    public void parseXML(String xmlData) {\n        //XXX not implemented.\n    }\n\n    /**\n     * Returns the UserId property value.\n     */\n    public String getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setUserId(String newUserId) {\n        this.userId = newUserId;\n    }\n\n    /**\n     * Returns the userName property value.\n     */\n    public String getUserName() {\n        return userName;\n    }\n\n    /**\n     * Sets the userName property value.\n     */\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    /**\n     * Returns the password property value.\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password property value.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    /**\n     * Returns the firstName property value.\n     */\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    /**\n     * Sets the firstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.firstName = newFirstName;\n    }\n\n    /**\n     * Returns the lastName property value.\n     */\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    /**\n     * Sets the lastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.lastName = newLastName;\n    }\n\n    /**\n     * Returns the middleInitial property value.\n     */\n    public String getMiddleInitial() {\n        return this.middleInitial;\n    }\n\n    /**\n     * Sets the middleInitial property value.\n     */\n    public void setMiddleInitial(String newMiddleInitial) {\n        this.middleInitial = newMiddleInitial;\n    }\n\n    /**\n     * Returns the email property value.\n     */\n    public String getEmail() {\n        return this.email;\n    }\n\n    /**\n     * Sets the email property value.\n     */\n    public void setEmail(String newEmail) {\n        this.email = newEmail;\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getInstructionalLevel() {\n        return instructionalLevel;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setInstructionalLevel(ArrayList newInstructionalLevel) {\n        instructionalLevel = newInstructionalLevel;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addInstructionalLevel(InstructionalLevelBean newInstructionalLevel) {\n        instructionalLevel.add(newInstructionalLevel);\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getProfessionalRole() {\n        return professionalRole;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setProfessionalRole(ArrayList newProfessionalRole) {\n        professionalRole = newProfessionalRole;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addProfessionalRole(ProfessionalRoleBean newProfessionalRole) {\n        professionalRole.add(newProfessionalRole);\n    }\n\n    /**\n     * Returns the professionalSpecialty property value.\n     */\n    public String getProfessionalSpecialty() {\n        return this.professionalSpecialty;\n    }\n\n    /**\n     * Sets the professionalSpecialty property value.\n     */\n    public void setProfessionalSpecialty(String newProfessionalSpecialty) {\n        this.professionalSpecialty = newProfessionalSpecialty;\n    }\n\n    /**\n     * Returns the phoneNumber property value.\n     */\n    public String getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber property value.\n     */\n    public void setPhoneNumber(String newPhoneNumber) {\n        this.phoneNumber = newPhoneNumber;\n    }\n\n    /**\n     * Returns the institutionName property value.\n     */\n    public String getInstitutionName() {\n        return this.institutionName;\n    }\n\n    /**\n     * Sets the institutionName property value.\n     */\n    public void setInstitutionName(String newInstitutionName) {\n        this.institutionName = newInstitutionName;\n    }\n\n    /**\n     * Returns the address1 property value.\n     */\n    public String getAddress1() {\n        return this.address1;\n    }\n\n    /**\n     * Sets the address1 property value.\n     */\n    public void setAddress1(String newAddress1) {\n        this.address1 = newAddress1;\n    }\n\n    /**\n     * Returns the address2 property value.\n     */\n    public String getAddress2() {\n        return this.address2;\n    }\n\n    /**\n     * Sets the address2 property value.\n     */\n    public void setAddress2(String newAddress2) {\n        this.address2 = newAddress2;\n    }\n\n    /**\n     * Returns the city property value.\n     */\n    public String getCity() {\n        return this.city;\n    }\n\n    /**\n     * Sets the city property value.\n     */\n    public void setCity(String newCity) {\n        this.city = newCity;\n    }\n\n    /**\n     * Returns the state property value.\n     */\n    public String getState() {\n        return this.state;\n    }\n\n    /**\n     * Sets the state property value.\n     */\n    public void setState(String newState) {\n        this.state = newState;\n    }\n\n    /**\n     * Returns the zipCode property value.\n     */\n    public String getZipCode() {\n        return this.zipCode;\n    }\n\n    /**\n     * Sets the zipCode property value.\n     */\n    public void setZipCode(String newZipCode) {\n        this.zipCode = newZipCode;\n    }\n\n    /**\n     * Returns the country property value.\n     */\n    public String getCountry() {\n        return this.country;\n    }\n\n    /**\n     * Sets the country property value.\n     */\n    public void setCountry(String newCountry) {\n        this.country = newCountry;\n    }\n\n    /**\n     * Returns the mailingList property value.\n     */\n    public boolean getMailingList() {\n        return this.mailingList;\n    }\n\n    /**\n     * Sets the mailingList property value.\n     */\n    public void setMailingList(boolean newMailingList) {\n        this.mailingList = newMailingList;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isLoginModified() {\n        return this.loginModified;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setLoginModified(boolean newLoginModified) {\n        this.loginModified = newLoginModified;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isEmailValidated() {\n        return this.emailValidated;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setEmailValidated(boolean newEmailValidated) {\n        this.emailValidated = newEmailValidated;\n    }\n\n    public boolean isIAMSEMember() {\n        return this.IAMSEMember;\n    }\n\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserBeanTest1.java",
		"test_prompt": "// UserBeanTest1.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserBean}.\n* It contains ten unit test cases for the {@link UserBean#isAdministrator()} method.\n*/\nclass UserBeanTest1 {"
	},
	{
		"original_code": "// UserBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about heal users.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserBean implements Serializable {\n\n    // Properties\n    private String userId = \"\";\n\n    private String userName = \"\";\n\n    private String password = \"\";\n\n    private boolean minor = true;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private String firstName = \"\";\n\n    private String lastName = \"\";\n\n    private String middleInitial = \"\";\n\n    private String email = \"\";\n\n    ArrayList professionalRole = new ArrayList();\n\n    String professionalSpecialty = \"\";\n\n    ArrayList instructionalLevel = new ArrayList();\n\n    private String phoneNumber = \"\";\n\n    private String institutionName = \"\";\n\n    private String address1 = \"\";\n\n    private String address2 = \"\";\n\n    private String city = \"\";\n\n    private String state = \"\";\n\n    private String zipCode = \"\";\n\n    private String country = \"\";\n\n    private boolean mailingList = true;\n\n    private boolean loginModified = false;\n\n    private boolean emailValidated = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns the bean's data in encoded in XML format.\n     */\n    public String getXML() {\n        //XXX implement this later.\n        return \"not implemented\";\n    }\n\n    /**\n     * Parses the XML string and stores the data in the bean.\n     */\n    public void parseXML(String xmlData) {\n        //XXX not implemented.\n    }\n\n    /**\n     * Returns the UserId property value.\n     */\n    public String getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setUserId(String newUserId) {\n        this.userId = newUserId;\n    }\n\n    /**\n     * Returns the userName property value.\n     */\n    public String getUserName() {\n        return userName;\n    }\n\n    /**\n     * Sets the userName property value.\n     */\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    /**\n     * Returns the password property value.\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password property value.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    /**\n     * Returns the firstName property value.\n     */\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    /**\n     * Sets the firstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.firstName = newFirstName;\n    }\n\n    /**\n     * Returns the lastName property value.\n     */\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    /**\n     * Sets the lastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.lastName = newLastName;\n    }\n\n    /**\n     * Returns the middleInitial property value.\n     */\n    public String getMiddleInitial() {\n        return this.middleInitial;\n    }\n\n    /**\n     * Sets the middleInitial property value.\n     */\n    public void setMiddleInitial(String newMiddleInitial) {\n        this.middleInitial = newMiddleInitial;\n    }\n\n    /**\n     * Returns the email property value.\n     */\n    public String getEmail() {\n        return this.email;\n    }\n\n    /**\n     * Sets the email property value.\n     */\n    public void setEmail(String newEmail) {\n        this.email = newEmail;\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getInstructionalLevel() {\n        return instructionalLevel;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setInstructionalLevel(ArrayList newInstructionalLevel) {\n        instructionalLevel = newInstructionalLevel;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addInstructionalLevel(InstructionalLevelBean newInstructionalLevel) {\n        instructionalLevel.add(newInstructionalLevel);\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getProfessionalRole() {\n        return professionalRole;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setProfessionalRole(ArrayList newProfessionalRole) {\n        professionalRole = newProfessionalRole;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addProfessionalRole(ProfessionalRoleBean newProfessionalRole) {\n        professionalRole.add(newProfessionalRole);\n    }\n\n    /**\n     * Returns the professionalSpecialty property value.\n     */\n    public String getProfessionalSpecialty() {\n        return this.professionalSpecialty;\n    }\n\n    /**\n     * Sets the professionalSpecialty property value.\n     */\n    public void setProfessionalSpecialty(String newProfessionalSpecialty) {\n        this.professionalSpecialty = newProfessionalSpecialty;\n    }\n\n    /**\n     * Returns the phoneNumber property value.\n     */\n    public String getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber property value.\n     */\n    public void setPhoneNumber(String newPhoneNumber) {\n        this.phoneNumber = newPhoneNumber;\n    }\n\n    /**\n     * Returns the institutionName property value.\n     */\n    public String getInstitutionName() {\n        return this.institutionName;\n    }\n\n    /**\n     * Sets the institutionName property value.\n     */\n    public void setInstitutionName(String newInstitutionName) {\n        this.institutionName = newInstitutionName;\n    }\n\n    /**\n     * Returns the address1 property value.\n     */\n    public String getAddress1() {\n        return this.address1;\n    }\n\n    /**\n     * Sets the address1 property value.\n     */\n    public void setAddress1(String newAddress1) {\n        this.address1 = newAddress1;\n    }\n\n    /**\n     * Returns the address2 property value.\n     */\n    public String getAddress2() {\n        return this.address2;\n    }\n\n    /**\n     * Sets the address2 property value.\n     */\n    public void setAddress2(String newAddress2) {\n        this.address2 = newAddress2;\n    }\n\n    /**\n     * Returns the city property value.\n     */\n    public String getCity() {\n        return this.city;\n    }\n\n    /**\n     * Sets the city property value.\n     */\n    public void setCity(String newCity) {\n        this.city = newCity;\n    }\n\n    /**\n     * Returns the state property value.\n     */\n    public String getState() {\n        return this.state;\n    }\n\n    /**\n     * Sets the state property value.\n     */\n    public void setState(String newState) {\n        this.state = newState;\n    }\n\n    /**\n     * Returns the zipCode property value.\n     */\n    public String getZipCode() {\n        return this.zipCode;\n    }\n\n    /**\n     * Sets the zipCode property value.\n     */\n    public void setZipCode(String newZipCode) {\n        this.zipCode = newZipCode;\n    }\n\n    /**\n     * Returns the country property value.\n     */\n    public String getCountry() {\n        return this.country;\n    }\n\n    /**\n     * Sets the country property value.\n     */\n    public void setCountry(String newCountry) {\n        this.country = newCountry;\n    }\n\n    /**\n     * Returns the mailingList property value.\n     */\n    public boolean getMailingList() {\n        return this.mailingList;\n    }\n\n    /**\n     * Sets the mailingList property value.\n     */\n    public void setMailingList(boolean newMailingList) {\n        this.mailingList = newMailingList;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isLoginModified() {\n        return this.loginModified;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setLoginModified(boolean newLoginModified) {\n        this.loginModified = newLoginModified;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isEmailValidated() {\n        return this.emailValidated;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setEmailValidated(boolean newEmailValidated) {\n        this.emailValidated = newEmailValidated;\n    }\n\n    public boolean isIAMSEMember() {\n        return this.IAMSEMember;\n    }\n\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserBeanTest2.java",
		"test_prompt": "// UserBeanTest2.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserBean}.\n* It contains ten unit test cases for the {@link UserBean#isCataloger()} method.\n*/\nclass UserBeanTest2 {"
	},
	{
		"original_code": "// UserBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about heal users.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserBean implements Serializable {\n\n    // Properties\n    private String userId = \"\";\n\n    private String userName = \"\";\n\n    private String password = \"\";\n\n    private boolean minor = true;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private String firstName = \"\";\n\n    private String lastName = \"\";\n\n    private String middleInitial = \"\";\n\n    private String email = \"\";\n\n    ArrayList professionalRole = new ArrayList();\n\n    String professionalSpecialty = \"\";\n\n    ArrayList instructionalLevel = new ArrayList();\n\n    private String phoneNumber = \"\";\n\n    private String institutionName = \"\";\n\n    private String address1 = \"\";\n\n    private String address2 = \"\";\n\n    private String city = \"\";\n\n    private String state = \"\";\n\n    private String zipCode = \"\";\n\n    private String country = \"\";\n\n    private boolean mailingList = true;\n\n    private boolean loginModified = false;\n\n    private boolean emailValidated = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns the bean's data in encoded in XML format.\n     */\n    public String getXML() {\n        //XXX implement this later.\n        return \"not implemented\";\n    }\n\n    /**\n     * Parses the XML string and stores the data in the bean.\n     */\n    public void parseXML(String xmlData) {\n        //XXX not implemented.\n    }\n\n    /**\n     * Returns the UserId property value.\n     */\n    public String getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setUserId(String newUserId) {\n        this.userId = newUserId;\n    }\n\n    /**\n     * Returns the userName property value.\n     */\n    public String getUserName() {\n        return userName;\n    }\n\n    /**\n     * Sets the userName property value.\n     */\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    /**\n     * Returns the password property value.\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password property value.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    /**\n     * Returns the firstName property value.\n     */\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    /**\n     * Sets the firstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.firstName = newFirstName;\n    }\n\n    /**\n     * Returns the lastName property value.\n     */\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    /**\n     * Sets the lastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.lastName = newLastName;\n    }\n\n    /**\n     * Returns the middleInitial property value.\n     */\n    public String getMiddleInitial() {\n        return this.middleInitial;\n    }\n\n    /**\n     * Sets the middleInitial property value.\n     */\n    public void setMiddleInitial(String newMiddleInitial) {\n        this.middleInitial = newMiddleInitial;\n    }\n\n    /**\n     * Returns the email property value.\n     */\n    public String getEmail() {\n        return this.email;\n    }\n\n    /**\n     * Sets the email property value.\n     */\n    public void setEmail(String newEmail) {\n        this.email = newEmail;\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getInstructionalLevel() {\n        return instructionalLevel;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setInstructionalLevel(ArrayList newInstructionalLevel) {\n        instructionalLevel = newInstructionalLevel;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addInstructionalLevel(InstructionalLevelBean newInstructionalLevel) {\n        instructionalLevel.add(newInstructionalLevel);\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getProfessionalRole() {\n        return professionalRole;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setProfessionalRole(ArrayList newProfessionalRole) {\n        professionalRole = newProfessionalRole;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addProfessionalRole(ProfessionalRoleBean newProfessionalRole) {\n        professionalRole.add(newProfessionalRole);\n    }\n\n    /**\n     * Returns the professionalSpecialty property value.\n     */\n    public String getProfessionalSpecialty() {\n        return this.professionalSpecialty;\n    }\n\n    /**\n     * Sets the professionalSpecialty property value.\n     */\n    public void setProfessionalSpecialty(String newProfessionalSpecialty) {\n        this.professionalSpecialty = newProfessionalSpecialty;\n    }\n\n    /**\n     * Returns the phoneNumber property value.\n     */\n    public String getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber property value.\n     */\n    public void setPhoneNumber(String newPhoneNumber) {\n        this.phoneNumber = newPhoneNumber;\n    }\n\n    /**\n     * Returns the institutionName property value.\n     */\n    public String getInstitutionName() {\n        return this.institutionName;\n    }\n\n    /**\n     * Sets the institutionName property value.\n     */\n    public void setInstitutionName(String newInstitutionName) {\n        this.institutionName = newInstitutionName;\n    }\n\n    /**\n     * Returns the address1 property value.\n     */\n    public String getAddress1() {\n        return this.address1;\n    }\n\n    /**\n     * Sets the address1 property value.\n     */\n    public void setAddress1(String newAddress1) {\n        this.address1 = newAddress1;\n    }\n\n    /**\n     * Returns the address2 property value.\n     */\n    public String getAddress2() {\n        return this.address2;\n    }\n\n    /**\n     * Sets the address2 property value.\n     */\n    public void setAddress2(String newAddress2) {\n        this.address2 = newAddress2;\n    }\n\n    /**\n     * Returns the city property value.\n     */\n    public String getCity() {\n        return this.city;\n    }\n\n    /**\n     * Sets the city property value.\n     */\n    public void setCity(String newCity) {\n        this.city = newCity;\n    }\n\n    /**\n     * Returns the state property value.\n     */\n    public String getState() {\n        return this.state;\n    }\n\n    /**\n     * Sets the state property value.\n     */\n    public void setState(String newState) {\n        this.state = newState;\n    }\n\n    /**\n     * Returns the zipCode property value.\n     */\n    public String getZipCode() {\n        return this.zipCode;\n    }\n\n    /**\n     * Sets the zipCode property value.\n     */\n    public void setZipCode(String newZipCode) {\n        this.zipCode = newZipCode;\n    }\n\n    /**\n     * Returns the country property value.\n     */\n    public String getCountry() {\n        return this.country;\n    }\n\n    /**\n     * Sets the country property value.\n     */\n    public void setCountry(String newCountry) {\n        this.country = newCountry;\n    }\n\n    /**\n     * Returns the mailingList property value.\n     */\n    public boolean getMailingList() {\n        return this.mailingList;\n    }\n\n    /**\n     * Sets the mailingList property value.\n     */\n    public void setMailingList(boolean newMailingList) {\n        this.mailingList = newMailingList;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isLoginModified() {\n        return this.loginModified;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setLoginModified(boolean newLoginModified) {\n        this.loginModified = newLoginModified;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isEmailValidated() {\n        return this.emailValidated;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setEmailValidated(boolean newEmailValidated) {\n        this.emailValidated = newEmailValidated;\n    }\n\n    public boolean isIAMSEMember() {\n        return this.IAMSEMember;\n    }\n\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserBeanTest3.java",
		"test_prompt": "// UserBeanTest3.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserBean}.\n* It contains ten unit test cases for the {@link UserBean#isApprover()} method.\n*/\nclass UserBeanTest3 {"
	},
	{
		"original_code": "// UserBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about heal users.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserBean implements Serializable {\n\n    // Properties\n    private String userId = \"\";\n\n    private String userName = \"\";\n\n    private String password = \"\";\n\n    private boolean minor = true;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private String firstName = \"\";\n\n    private String lastName = \"\";\n\n    private String middleInitial = \"\";\n\n    private String email = \"\";\n\n    ArrayList professionalRole = new ArrayList();\n\n    String professionalSpecialty = \"\";\n\n    ArrayList instructionalLevel = new ArrayList();\n\n    private String phoneNumber = \"\";\n\n    private String institutionName = \"\";\n\n    private String address1 = \"\";\n\n    private String address2 = \"\";\n\n    private String city = \"\";\n\n    private String state = \"\";\n\n    private String zipCode = \"\";\n\n    private String country = \"\";\n\n    private boolean mailingList = true;\n\n    private boolean loginModified = false;\n\n    private boolean emailValidated = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns the bean's data in encoded in XML format.\n     */\n    public String getXML() {\n        //XXX implement this later.\n        return \"not implemented\";\n    }\n\n    /**\n     * Parses the XML string and stores the data in the bean.\n     */\n    public void parseXML(String xmlData) {\n        //XXX not implemented.\n    }\n\n    /**\n     * Returns the UserId property value.\n     */\n    public String getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setUserId(String newUserId) {\n        this.userId = newUserId;\n    }\n\n    /**\n     * Returns the userName property value.\n     */\n    public String getUserName() {\n        return userName;\n    }\n\n    /**\n     * Sets the userName property value.\n     */\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    /**\n     * Returns the password property value.\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password property value.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    /**\n     * Returns the firstName property value.\n     */\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    /**\n     * Sets the firstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.firstName = newFirstName;\n    }\n\n    /**\n     * Returns the lastName property value.\n     */\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    /**\n     * Sets the lastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.lastName = newLastName;\n    }\n\n    /**\n     * Returns the middleInitial property value.\n     */\n    public String getMiddleInitial() {\n        return this.middleInitial;\n    }\n\n    /**\n     * Sets the middleInitial property value.\n     */\n    public void setMiddleInitial(String newMiddleInitial) {\n        this.middleInitial = newMiddleInitial;\n    }\n\n    /**\n     * Returns the email property value.\n     */\n    public String getEmail() {\n        return this.email;\n    }\n\n    /**\n     * Sets the email property value.\n     */\n    public void setEmail(String newEmail) {\n        this.email = newEmail;\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getInstructionalLevel() {\n        return instructionalLevel;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setInstructionalLevel(ArrayList newInstructionalLevel) {\n        instructionalLevel = newInstructionalLevel;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addInstructionalLevel(InstructionalLevelBean newInstructionalLevel) {\n        instructionalLevel.add(newInstructionalLevel);\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getProfessionalRole() {\n        return professionalRole;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setProfessionalRole(ArrayList newProfessionalRole) {\n        professionalRole = newProfessionalRole;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addProfessionalRole(ProfessionalRoleBean newProfessionalRole) {\n        professionalRole.add(newProfessionalRole);\n    }\n\n    /**\n     * Returns the professionalSpecialty property value.\n     */\n    public String getProfessionalSpecialty() {\n        return this.professionalSpecialty;\n    }\n\n    /**\n     * Sets the professionalSpecialty property value.\n     */\n    public void setProfessionalSpecialty(String newProfessionalSpecialty) {\n        this.professionalSpecialty = newProfessionalSpecialty;\n    }\n\n    /**\n     * Returns the phoneNumber property value.\n     */\n    public String getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber property value.\n     */\n    public void setPhoneNumber(String newPhoneNumber) {\n        this.phoneNumber = newPhoneNumber;\n    }\n\n    /**\n     * Returns the institutionName property value.\n     */\n    public String getInstitutionName() {\n        return this.institutionName;\n    }\n\n    /**\n     * Sets the institutionName property value.\n     */\n    public void setInstitutionName(String newInstitutionName) {\n        this.institutionName = newInstitutionName;\n    }\n\n    /**\n     * Returns the address1 property value.\n     */\n    public String getAddress1() {\n        return this.address1;\n    }\n\n    /**\n     * Sets the address1 property value.\n     */\n    public void setAddress1(String newAddress1) {\n        this.address1 = newAddress1;\n    }\n\n    /**\n     * Returns the address2 property value.\n     */\n    public String getAddress2() {\n        return this.address2;\n    }\n\n    /**\n     * Sets the address2 property value.\n     */\n    public void setAddress2(String newAddress2) {\n        this.address2 = newAddress2;\n    }\n\n    /**\n     * Returns the city property value.\n     */\n    public String getCity() {\n        return this.city;\n    }\n\n    /**\n     * Sets the city property value.\n     */\n    public void setCity(String newCity) {\n        this.city = newCity;\n    }\n\n    /**\n     * Returns the state property value.\n     */\n    public String getState() {\n        return this.state;\n    }\n\n    /**\n     * Sets the state property value.\n     */\n    public void setState(String newState) {\n        this.state = newState;\n    }\n\n    /**\n     * Returns the zipCode property value.\n     */\n    public String getZipCode() {\n        return this.zipCode;\n    }\n\n    /**\n     * Sets the zipCode property value.\n     */\n    public void setZipCode(String newZipCode) {\n        this.zipCode = newZipCode;\n    }\n\n    /**\n     * Returns the country property value.\n     */\n    public String getCountry() {\n        return this.country;\n    }\n\n    /**\n     * Sets the country property value.\n     */\n    public void setCountry(String newCountry) {\n        this.country = newCountry;\n    }\n\n    /**\n     * Returns the mailingList property value.\n     */\n    public boolean getMailingList() {\n        return this.mailingList;\n    }\n\n    /**\n     * Sets the mailingList property value.\n     */\n    public void setMailingList(boolean newMailingList) {\n        this.mailingList = newMailingList;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isLoginModified() {\n        return this.loginModified;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setLoginModified(boolean newLoginModified) {\n        this.loginModified = newLoginModified;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isEmailValidated() {\n        return this.emailValidated;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setEmailValidated(boolean newEmailValidated) {\n        this.emailValidated = newEmailValidated;\n    }\n\n    public boolean isIAMSEMember() {\n        return this.IAMSEMember;\n    }\n\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserBeanTest4.java",
		"test_prompt": "// UserBeanTest4.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserBean}.\n* It contains ten unit test cases for the {@link UserBean#isLoginModified()} method.\n*/\nclass UserBeanTest4 {"
	},
	{
		"original_code": "// UserBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about heal users.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserBean implements Serializable {\n\n    // Properties\n    private String userId = \"\";\n\n    private String userName = \"\";\n\n    private String password = \"\";\n\n    private boolean minor = true;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private String firstName = \"\";\n\n    private String lastName = \"\";\n\n    private String middleInitial = \"\";\n\n    private String email = \"\";\n\n    ArrayList professionalRole = new ArrayList();\n\n    String professionalSpecialty = \"\";\n\n    ArrayList instructionalLevel = new ArrayList();\n\n    private String phoneNumber = \"\";\n\n    private String institutionName = \"\";\n\n    private String address1 = \"\";\n\n    private String address2 = \"\";\n\n    private String city = \"\";\n\n    private String state = \"\";\n\n    private String zipCode = \"\";\n\n    private String country = \"\";\n\n    private boolean mailingList = true;\n\n    private boolean loginModified = false;\n\n    private boolean emailValidated = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns the bean's data in encoded in XML format.\n     */\n    public String getXML() {\n        //XXX implement this later.\n        return \"not implemented\";\n    }\n\n    /**\n     * Parses the XML string and stores the data in the bean.\n     */\n    public void parseXML(String xmlData) {\n        //XXX not implemented.\n    }\n\n    /**\n     * Returns the UserId property value.\n     */\n    public String getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setUserId(String newUserId) {\n        this.userId = newUserId;\n    }\n\n    /**\n     * Returns the userName property value.\n     */\n    public String getUserName() {\n        return userName;\n    }\n\n    /**\n     * Sets the userName property value.\n     */\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    /**\n     * Returns the password property value.\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password property value.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    /**\n     * Returns the firstName property value.\n     */\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    /**\n     * Sets the firstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.firstName = newFirstName;\n    }\n\n    /**\n     * Returns the lastName property value.\n     */\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    /**\n     * Sets the lastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.lastName = newLastName;\n    }\n\n    /**\n     * Returns the middleInitial property value.\n     */\n    public String getMiddleInitial() {\n        return this.middleInitial;\n    }\n\n    /**\n     * Sets the middleInitial property value.\n     */\n    public void setMiddleInitial(String newMiddleInitial) {\n        this.middleInitial = newMiddleInitial;\n    }\n\n    /**\n     * Returns the email property value.\n     */\n    public String getEmail() {\n        return this.email;\n    }\n\n    /**\n     * Sets the email property value.\n     */\n    public void setEmail(String newEmail) {\n        this.email = newEmail;\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getInstructionalLevel() {\n        return instructionalLevel;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setInstructionalLevel(ArrayList newInstructionalLevel) {\n        instructionalLevel = newInstructionalLevel;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addInstructionalLevel(InstructionalLevelBean newInstructionalLevel) {\n        instructionalLevel.add(newInstructionalLevel);\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getProfessionalRole() {\n        return professionalRole;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setProfessionalRole(ArrayList newProfessionalRole) {\n        professionalRole = newProfessionalRole;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addProfessionalRole(ProfessionalRoleBean newProfessionalRole) {\n        professionalRole.add(newProfessionalRole);\n    }\n\n    /**\n     * Returns the professionalSpecialty property value.\n     */\n    public String getProfessionalSpecialty() {\n        return this.professionalSpecialty;\n    }\n\n    /**\n     * Sets the professionalSpecialty property value.\n     */\n    public void setProfessionalSpecialty(String newProfessionalSpecialty) {\n        this.professionalSpecialty = newProfessionalSpecialty;\n    }\n\n    /**\n     * Returns the phoneNumber property value.\n     */\n    public String getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber property value.\n     */\n    public void setPhoneNumber(String newPhoneNumber) {\n        this.phoneNumber = newPhoneNumber;\n    }\n\n    /**\n     * Returns the institutionName property value.\n     */\n    public String getInstitutionName() {\n        return this.institutionName;\n    }\n\n    /**\n     * Sets the institutionName property value.\n     */\n    public void setInstitutionName(String newInstitutionName) {\n        this.institutionName = newInstitutionName;\n    }\n\n    /**\n     * Returns the address1 property value.\n     */\n    public String getAddress1() {\n        return this.address1;\n    }\n\n    /**\n     * Sets the address1 property value.\n     */\n    public void setAddress1(String newAddress1) {\n        this.address1 = newAddress1;\n    }\n\n    /**\n     * Returns the address2 property value.\n     */\n    public String getAddress2() {\n        return this.address2;\n    }\n\n    /**\n     * Sets the address2 property value.\n     */\n    public void setAddress2(String newAddress2) {\n        this.address2 = newAddress2;\n    }\n\n    /**\n     * Returns the city property value.\n     */\n    public String getCity() {\n        return this.city;\n    }\n\n    /**\n     * Sets the city property value.\n     */\n    public void setCity(String newCity) {\n        this.city = newCity;\n    }\n\n    /**\n     * Returns the state property value.\n     */\n    public String getState() {\n        return this.state;\n    }\n\n    /**\n     * Sets the state property value.\n     */\n    public void setState(String newState) {\n        this.state = newState;\n    }\n\n    /**\n     * Returns the zipCode property value.\n     */\n    public String getZipCode() {\n        return this.zipCode;\n    }\n\n    /**\n     * Sets the zipCode property value.\n     */\n    public void setZipCode(String newZipCode) {\n        this.zipCode = newZipCode;\n    }\n\n    /**\n     * Returns the country property value.\n     */\n    public String getCountry() {\n        return this.country;\n    }\n\n    /**\n     * Sets the country property value.\n     */\n    public void setCountry(String newCountry) {\n        this.country = newCountry;\n    }\n\n    /**\n     * Returns the mailingList property value.\n     */\n    public boolean getMailingList() {\n        return this.mailingList;\n    }\n\n    /**\n     * Sets the mailingList property value.\n     */\n    public void setMailingList(boolean newMailingList) {\n        this.mailingList = newMailingList;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isLoginModified() {\n        return this.loginModified;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setLoginModified(boolean newLoginModified) {\n        this.loginModified = newLoginModified;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isEmailValidated() {\n        return this.emailValidated;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setEmailValidated(boolean newEmailValidated) {\n        this.emailValidated = newEmailValidated;\n    }\n\n    public boolean isIAMSEMember() {\n        return this.IAMSEMember;\n    }\n\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserBeanTest5.java",
		"test_prompt": "// UserBeanTest5.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserBean}.\n* It contains ten unit test cases for the {@link UserBean#isEmailValidated()} method.\n*/\nclass UserBeanTest5 {"
	},
	{
		"original_code": "// UserBean.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about heal users.\n *\n * @author Seth Wright\n * @modify Jason Varghese\n * @version 0.1\n */\npublic class UserBean implements Serializable {\n\n    // Properties\n    private String userId = \"\";\n\n    private String userName = \"\";\n\n    private String password = \"\";\n\n    private boolean minor = true;\n\n    private boolean administrator = false;\n\n    private boolean cataloger = false;\n\n    private boolean approver = false;\n\n    private String firstName = \"\";\n\n    private String lastName = \"\";\n\n    private String middleInitial = \"\";\n\n    private String email = \"\";\n\n    ArrayList professionalRole = new ArrayList();\n\n    String professionalSpecialty = \"\";\n\n    ArrayList instructionalLevel = new ArrayList();\n\n    private String phoneNumber = \"\";\n\n    private String institutionName = \"\";\n\n    private String address1 = \"\";\n\n    private String address2 = \"\";\n\n    private String city = \"\";\n\n    private String state = \"\";\n\n    private String zipCode = \"\";\n\n    private String country = \"\";\n\n    private boolean mailingList = true;\n\n    private boolean loginModified = false;\n\n    private boolean emailValidated = false;\n\n    private boolean IAMSEMember = false;\n\n    /**\n     * Returns the bean's data in encoded in XML format.\n     */\n    public String getXML() {\n        //XXX implement this later.\n        return \"not implemented\";\n    }\n\n    /**\n     * Parses the XML string and stores the data in the bean.\n     */\n    public void parseXML(String xmlData) {\n        //XXX not implemented.\n    }\n\n    /**\n     * Returns the UserId property value.\n     */\n    public String getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setUserId(String newUserId) {\n        this.userId = newUserId;\n    }\n\n    /**\n     * Returns the userName property value.\n     */\n    public String getUserName() {\n        return userName;\n    }\n\n    /**\n     * Sets the userName property value.\n     */\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    /**\n     * Returns the password property value.\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * Sets the password property value.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * Returns whether or not the user is a minor.\n     */\n    public boolean isMinor() {\n        return minor;\n    }\n\n    /**\n     * Sets whether or not the user is a minor.\n     */\n    public void setMinor(boolean newMinor) {\n        this.minor = newMinor;\n    }\n\n    /**\n     * Returns whether or not the user is a administrator.\n     */\n    public boolean isAdministrator() {\n        return administrator;\n    }\n\n    /**\n     * Sets whether or not the user is a administrator.\n     */\n    public void setAdministrator(boolean newAdministrator) {\n        this.administrator = newAdministrator;\n    }\n\n    /**\n     * Returns whether or not the user is a cataloger.\n     */\n    public boolean isCataloger() {\n        return cataloger;\n    }\n\n    /**\n     * Sets whether or not the user is a cataloger.\n     */\n    public void setCataloger(boolean newCataloger) {\n        this.cataloger = newCataloger;\n    }\n\n    /**\n     * Returns whether or not the user is a approver.\n     */\n    public boolean isApprover() {\n        return approver;\n    }\n\n    /**\n     * Sets whether or not the user is a approver.\n     */\n    public void setApprover(boolean newApprover) {\n        this.approver = newApprover;\n    }\n\n    /**\n     * Returns the firstName property value.\n     */\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    /**\n     * Sets the firstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.firstName = newFirstName;\n    }\n\n    /**\n     * Returns the lastName property value.\n     */\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    /**\n     * Sets the lastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.lastName = newLastName;\n    }\n\n    /**\n     * Returns the middleInitial property value.\n     */\n    public String getMiddleInitial() {\n        return this.middleInitial;\n    }\n\n    /**\n     * Sets the middleInitial property value.\n     */\n    public void setMiddleInitial(String newMiddleInitial) {\n        this.middleInitial = newMiddleInitial;\n    }\n\n    /**\n     * Returns the email property value.\n     */\n    public String getEmail() {\n        return this.email;\n    }\n\n    /**\n     * Sets the email property value.\n     */\n    public void setEmail(String newEmail) {\n        this.email = newEmail;\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getInstructionalLevel() {\n        return instructionalLevel;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setInstructionalLevel(ArrayList newInstructionalLevel) {\n        instructionalLevel = newInstructionalLevel;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addInstructionalLevel(InstructionalLevelBean newInstructionalLevel) {\n        instructionalLevel.add(newInstructionalLevel);\n    }\n\n    /**\n     * Returns a vector of CopyrightBean objects each containing\n     * a CopyrightTextBean for this metadata.\n     */\n    public ArrayList getProfessionalRole() {\n        return professionalRole;\n    }\n\n    /**\n     * Sets the copyright property value.\n     * DO NOT use NULL as a parameter.\n     */\n    public void setProfessionalRole(ArrayList newProfessionalRole) {\n        professionalRole = newProfessionalRole;\n    }\n\n    /**\n     * Adds a copyright to the set of copyrights for\n     * this metadata object.\n     */\n    public void addProfessionalRole(ProfessionalRoleBean newProfessionalRole) {\n        professionalRole.add(newProfessionalRole);\n    }\n\n    /**\n     * Returns the professionalSpecialty property value.\n     */\n    public String getProfessionalSpecialty() {\n        return this.professionalSpecialty;\n    }\n\n    /**\n     * Sets the professionalSpecialty property value.\n     */\n    public void setProfessionalSpecialty(String newProfessionalSpecialty) {\n        this.professionalSpecialty = newProfessionalSpecialty;\n    }\n\n    /**\n     * Returns the phoneNumber property value.\n     */\n    public String getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber property value.\n     */\n    public void setPhoneNumber(String newPhoneNumber) {\n        this.phoneNumber = newPhoneNumber;\n    }\n\n    /**\n     * Returns the institutionName property value.\n     */\n    public String getInstitutionName() {\n        return this.institutionName;\n    }\n\n    /**\n     * Sets the institutionName property value.\n     */\n    public void setInstitutionName(String newInstitutionName) {\n        this.institutionName = newInstitutionName;\n    }\n\n    /**\n     * Returns the address1 property value.\n     */\n    public String getAddress1() {\n        return this.address1;\n    }\n\n    /**\n     * Sets the address1 property value.\n     */\n    public void setAddress1(String newAddress1) {\n        this.address1 = newAddress1;\n    }\n\n    /**\n     * Returns the address2 property value.\n     */\n    public String getAddress2() {\n        return this.address2;\n    }\n\n    /**\n     * Sets the address2 property value.\n     */\n    public void setAddress2(String newAddress2) {\n        this.address2 = newAddress2;\n    }\n\n    /**\n     * Returns the city property value.\n     */\n    public String getCity() {\n        return this.city;\n    }\n\n    /**\n     * Sets the city property value.\n     */\n    public void setCity(String newCity) {\n        this.city = newCity;\n    }\n\n    /**\n     * Returns the state property value.\n     */\n    public String getState() {\n        return this.state;\n    }\n\n    /**\n     * Sets the state property value.\n     */\n    public void setState(String newState) {\n        this.state = newState;\n    }\n\n    /**\n     * Returns the zipCode property value.\n     */\n    public String getZipCode() {\n        return this.zipCode;\n    }\n\n    /**\n     * Sets the zipCode property value.\n     */\n    public void setZipCode(String newZipCode) {\n        this.zipCode = newZipCode;\n    }\n\n    /**\n     * Returns the country property value.\n     */\n    public String getCountry() {\n        return this.country;\n    }\n\n    /**\n     * Sets the country property value.\n     */\n    public void setCountry(String newCountry) {\n        this.country = newCountry;\n    }\n\n    /**\n     * Returns the mailingList property value.\n     */\n    public boolean getMailingList() {\n        return this.mailingList;\n    }\n\n    /**\n     * Sets the mailingList property value.\n     */\n    public void setMailingList(boolean newMailingList) {\n        this.mailingList = newMailingList;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isLoginModified() {\n        return this.loginModified;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setLoginModified(boolean newLoginModified) {\n        this.loginModified = newLoginModified;\n    }\n\n    /**\n     * Returns the isUserNameChanged changed property value.\n     */\n    public boolean isEmailValidated() {\n        return this.emailValidated;\n    }\n\n    /**\n     * Sets the userNameChanged changed property value.\n     */\n    public void setEmailValidated(boolean newEmailValidated) {\n        this.emailValidated = newEmailValidated;\n    }\n\n    public boolean isIAMSEMember() {\n        return this.IAMSEMember;\n    }\n\n    public void setIAMSEMember(boolean newIAMSEMember) {\n        this.IAMSEMember = newIAMSEMember;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/user/UserBeanTest6.java",
		"test_prompt": "// UserBeanTest6.java\npackage org.heal.module.user;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UserBean}.\n* It contains ten unit test cases for the {@link UserBean#isIAMSEMember()} method.\n*/\nclass UserBeanTest6 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest0.java",
		"test_prompt": "// NotificationServicesBeanTest0.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendEmailToUsers(String[], String)} method.\n*/\nclass NotificationServicesBeanTest0 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest1.java",
		"test_prompt": "// NotificationServicesBeanTest1.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendUserNotice(String, String)} method.\n*/\nclass NotificationServicesBeanTest1 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest2.java",
		"test_prompt": "// NotificationServicesBeanTest2.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendAdminNotice(String)} method.\n*/\nclass NotificationServicesBeanTest2 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest3.java",
		"test_prompt": "// NotificationServicesBeanTest3.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendToList(String)} method.\n*/\nclass NotificationServicesBeanTest3 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest4.java",
		"test_prompt": "// NotificationServicesBeanTest4.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendToList(ArrayList, String)} method.\n*/\nclass NotificationServicesBeanTest4 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest5.java",
		"test_prompt": "// NotificationServicesBeanTest5.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendPasswordReminder(UserBean, String)} method.\n*/\nclass NotificationServicesBeanTest5 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest6.java",
		"test_prompt": "// NotificationServicesBeanTest6.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendUsernameValidationEmail(UserBean, String)} method.\n*/\nclass NotificationServicesBeanTest6 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest7.java",
		"test_prompt": "// NotificationServicesBeanTest7.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendWelcomeMessage(String, String)} method.\n*/\nclass NotificationServicesBeanTest7 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest8.java",
		"test_prompt": "// NotificationServicesBeanTest8.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#sendEmail(InternetAddress[], String, String)} method.\n*/\nclass NotificationServicesBeanTest8 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest9.java",
		"test_prompt": "// NotificationServicesBeanTest9.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#addUserToList(String)} method.\n*/\nclass NotificationServicesBeanTest9 {"
	},
	{
		"original_code": "// NotificationServicesBean.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * @author Seth Wright\n * @version 0.1\n * @modify Jason Varghese\n */\npublic class NotificationServicesBean implements Serializable {\n\n    //The subject header for all outgoing messages generated by the system\n    private static final String MAILER = \"Health Education Assets Library Notification System\";\n\n    //the address to use when sending messages\n    private InternetAddress healAddress = null;\n\n    //array containing one element - the above healAddress;\n    private InternetAddress[] healAddressArray = new InternetAddress[1];\n\n    //the address of the smtp host, if null, localhost is used\n    private String mailhost = null;\n\n    //the username to use when attempting to log into the smtp server to send\n    private String mailuser = null;\n\n    //the password to use when attempting to log into the smtp server to send\n    private String mailpassword = null;\n\n    //The session to use for generating all of our outgoing messages\n    private Session session = null;\n\n    //The java bean/module used for getting the user information\n    UserRegistryBean userRegistry = null;\n\n    /**\n     * Sets the mailhost setting and also gets a new Session object.\n     * The mailhost setting is used to determine what server to connect to\n     * in order to send our mail.\n     */\n    public void setMailhost(String newMailhost) {\n        mailhost = newMailhost;\n        Properties props = System.getProperties();\n        // XXX - could use Session.getTransport() and Transport.connect()\n        // XXX - assume we're using SMTP\n        if (mailhost != null) {\n            props.put(\"mail.smtp.host\", mailhost);\n        }\n        session = Session.getDefaultInstance(props, null);\n        session.setDebug(false);\n    }\n\n    /**\n     * Sets the mail user name of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailUser(String newUserName) {\n        mailuser = newUserName;\n    }\n\n    /**\n     * Sets the mail password of the account used to send emails from the\n     * heal notification system.\n     */\n    public void setMailPassword(String newMailPassword) {\n        mailpassword = newMailPassword;\n    }\n\n    /**\n     * Sets the module used by the notification services to get user\n     * information such as the list of admin users and the list of\n     * subscribers for receiving HEAL notices.\n     */\n    public void setUserRegistry(UserRegistryBean newRegistry) {\n        userRegistry = newRegistry;\n    }\n\n    /**\n     * Returns the mailhost setting\n     */\n    public String getMailhost() {\n        return mailhost;\n    }\n\n    /**\n     * Sets the address used as the \"From\" header for all outgoing messages.\n     */\n    public void setHealAddress(InternetAddress address) {\n        healAddress = address;\n        healAddressArray[0] = healAddress;\n    }\n\n    /**\n     * Returns the address used as the from header for outgoing messages.\n     */\n    public InternetAddress getHealAddress() {\n        return healAddress;\n    }\n\n    /**\n     * Given an array of user <B>names</B>, sends the given message text to\n     * each user's email address if one is found in the user database.\n     * Returns true if no errors occur (even if none of the users have email\n     * addresses in the database).\n     */\n    public boolean sendEmailToUsers(String[] userNames, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userNames == null || messageBody == null) {\n            return false;\n        }\n        StringBuffer addressBuffer = null;\n        String currAddress;\n        ArrayList emailAddresses = userRegistry.getEmailAddresses(userNames);\n        if (emailAddresses != null) {\n            Iterator emailIterator = emailAddresses.iterator();\n            while (emailIterator.hasNext()) {\n                currAddress = (String) emailIterator.next();\n                if (addressBuffer != null) {\n                    addressBuffer.append(\",\" + currAddress);\n                } else {\n                    addressBuffer = new StringBuffer(currAddress);\n                }\n            }\n        }\n        if (addressBuffer != null) {\n            result = sendUserNotice(addressBuffer.toString(), messageBody);\n        }\n        return result;\n    }\n\n    /**\n     * Given a comma-delimited list of <B>addresses</B> and a message body,\n     * sends the given message to all users specified in the list.\n     * If the message is successfully sent true is returned.  If an\n     * error occurs, false is returned.\n     */\n    public boolean sendUserNotice(String userAddresses, String messageBody) throws MessagingException {\n        boolean result = false;\n        if (userAddresses == null || messageBody == null) {\n            return false;\n        }\n        try {\n            InternetAddress[] addrs = InternetAddress.parse(userAddresses, false);\n            if (addrs != null) {\n                result = sendEmail(addrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n            result = false;\n        }\n        return result;\n    }\n\n    /**\n     * Looks up the list of all admin users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendAdminNotice(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getAdminEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Looks up the list of all subscribed users in the database (via the\n     * user registry bean) and then sends a message with the given\n     * body to all of them.\n     */\n    public boolean sendToList(String messageBody) throws MessagingException {\n        if (messageBody == null || userRegistry == null) {\n            return false;\n        }\n        ArrayList addressList = userRegistry.getSubscriberEmailAddresses();\n        return sendToList(addressList, messageBody);\n    }\n\n    /**\n     * Given an ArrayList of Strings containing email addresses, this\n     * method sends an email with the given body to each address in\n     * the list.  If an error occurs, this returns false, otherwise\n     * it returns true.\n     */\n    public boolean sendToList(ArrayList addressList, String messageBody) throws MessagingException {\n        boolean result = false;\n        try {\n            if (addressList == null || addressList.size() == 0) {\n                /* Well, we didn't need to send it to anyone, \n                * so we succeeded - sort of.\n                */\n                result = true;\n            } else {\n                Iterator addressIterator = addressList.iterator();\n                StringBuffer addressBuffer = new StringBuffer();\n                String addressString = (String) addressIterator.next();\n                addressBuffer.append(addressString);\n                while (addressIterator.hasNext()) {\n                    addressString = (String) addressIterator.next();\n                    addressBuffer.append(\",\" + addressString);\n                }\n                addressString = addressBuffer.toString();\n                InternetAddress[] toAddrs = InternetAddress.parse(addressString, false);\n                result = sendEmail(toAddrs, messageBody, MAILER);\n            }\n        } catch (AddressException adex) {\n            adex.printStackTrace();\n        }\n        return result;\n    }\n\n    public Vector sendPasswordReminder(UserBean user, String baseURL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        if (user.isLoginModified())\n            username = user.getEmail();\n        else\n            username = user.getUserName();\n        password = user.getPassword();\n        message = \"The following is the registration information you requested.\" + \"\\n\";\n        message = message + \"username: \" + username + '\\n' + \"password: \" + password + \"\\n\";\n        message = message + \"Logon at: \" + baseURL + \"/user/login.jsp\" + \"\\n\\n\";\n        String emailValidationPath = \"\";\n        emailValidationPath = baseURL + \"/healapp/emailValidation?emailId=\" + user.getUserId() + \"&email=\" + user.getEmail();\n        if (user.isLoginModified() && !user.isEmailValidated())\n            message = message + \"Your registration has not been completed yet.  Please confirm your account by clicking on this link \\n\" + emailValidationPath + \"\\n\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Password Reminder from www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendUsernameValidationEmail(UserBean user, String URL) throws MessagingException {\n        String username = null;\n        String password = null;\n        String message = null;\n        Vector errorMessage = new Vector();\n        username = user.getUserName();\n        password = user.getPassword();\n        message = \"We require one final step to confirm your registration with www.healcentral.org.\" + \"\\n\";\n        message = message + \"To activate your registration click the following link:\\n\" + URL + \"\\n\\n\\n\";\n        message = message + \"Please note: It is important that you follow through with this final step of confirming your registration.  \";\n        message = message + \"By not doing so, your status will remain pending and registration with healcentral.org will not be activated.  \";\n        message = message + \"If you experience problems with the provided link, simply copy the listed link and paste it into the address field within your browser.  \";\n        message = message + \"For all other questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(user.getEmail());\n            sendEmail(address, message, \"Confirm your account at www.healcentral.org\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    public Vector sendWelcomeMessage(String email, String URL) throws MessagingException {\n        String message = null;\n        Vector errorMessage = new Vector();\n        message = \"Your registration is complete.  Welcome to the Health Education Assets Library.  \" + \"\\n\";\n        message = message + \"To join the HEAL mailing list, please access the following URL:\\n\" + URL + \"\\n\\n\";\n        message = message + \"If you have any questions or concerns please email: info@healcentral.org\";\n        try {\n            InternetAddress[] address = new InternetAddress[1];\n            address[0] = new InternetAddress(email);\n            sendEmail(address, message, \"Welcome to the Health Education Assets Library\");\n        } catch (AddressException adex) {\n            errorMessage.addElement(\"Invalid Email Address\");\n        }\n        return errorMessage;\n    }\n\n    /**\n     * Given an array of  email addresses and the message\n     * body, sends an email containing that body to the specified recipients.\n     * The sender is assumed to be the HEAL account specified during\n     * initialization (healAddress)\n     * Note:\n     * If he have no addresses, we generate an error and return false.\n     * If we only have one address, then we simply set that as the TO address.\n     * If we have multiple addresses, then we want to hide the\n     * addresses from everyone else.  The easiest way to do this\n     * is to do a blind carbon copy.  In this case, though we need\n     * an initial TO Address still, so we send a copy to ourselves.\n     * If this behavior is not desireable, then simply call this\n     * method multiple times with only one address as the parameter.\n     */\n    public boolean sendEmail(InternetAddress[] toAddresses, String text, String subject) throws MessagingException {\n        try {\n            if (session == null) {\n                throw new MessagingException(\"No session to use to send a \" + \"message (session was null)\");\n            }\n            Message msg = new MimeMessage(session);\n            /* See method note above. */\n            if (toAddresses != null) {\n                if (toAddresses.length > 1) {\n                    msg.setRecipients(Message.RecipientType.TO, healAddressArray);\n                    msg.setRecipients(Message.RecipientType.BCC, toAddresses);\n                } else {\n                    msg.setRecipients(Message.RecipientType.TO, toAddresses);\n                }\n            } else {\n                throw new MessagingException(\"No \\\"To\\\" address specified\");\n            }\n            //msg.setSubject(MAILSUBJECT);\n            msg.setSubject(subject);\n            msg.setFrom(healAddress);\n            msg.setSentDate(new Date());\n            msg.setHeader(\"X-Mailer\", MAILER);\n            if (text != null) {\n                msg.setText(text);\n            } else {\n                throw new MessagingException(\"No message text specified\");\n            }\n            // implicit with send()\n            msg.saveChanges();\n            Transport transport = session.getTransport(\"smtp\");\n            transport.connect(mailhost, mailuser, mailpassword);\n            transport.sendMessage(msg, msg.getAllRecipients());\n            transport.close();\n        } catch (MessagingException ex) {\n            ex.printStackTrace();\n            throw new MessagingException(ex.toString());\n            //return false;\n        }\n        return true;\n    }\n\n    /**\n     * Adds the user to the HEAL mailing list.  If an error occurs, this method\n     * returns false.  If the user was successfully added, true is returned.\n     */\n    public boolean addUserToList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.addUserToSubscribers(userName);\n        }\n    }\n\n    /**\n     * Removes the user from the HEAL mailing list.  If an error occurs,\n     * this method returns false.  If the user was successfully removed,\n     * true is returned.\n     */\n    public boolean removeUserFromList(String userName) {\n        if (userRegistry == null) {\n            return false;\n        } else {\n            return userRegistry.removeUserFromSubscribers(userName);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/notice/NotificationServicesBeanTest10.java",
		"test_prompt": "// NotificationServicesBeanTest10.java\npackage org.heal.module.notice;\n\nimport org.heal.module.user.UserBean;\nimport org.heal.module.user.UserRegistryBean;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NotificationServicesBean}.\n* It contains ten unit test cases for the {@link NotificationServicesBean#removeUserFromList(String)} method.\n*/\nclass NotificationServicesBeanTest10 {"
	},
	{
		"original_code": "// AdvSearchDAO.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class AdvSearchDAO implements Serializable {\n\n    public AdvSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a set of parameters and a list of filters, performs a search\n     * for all metadata that match all of the criteria set out in the\n     * parameters and also have a format in the presented list.\n     * The results are returned in a SearchResultBean.\n     * It should be noted that unless a metadata matches _ALL_ of the\n     * parameters laid out in the search paremters, it will not be in the\n     * result set.\n     *\n     * @param param\n     *\n     * @return results\n     */\n    public SearchResultBean AdvSearch(ParameterBean param) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        Connection conn = dataSource.getConnection();\n        try {\n            List metaIDs = new ArrayList();\n            Vector rows = getQueryMetaID(param, conn);\n            ShortMetadataResultBean[] metadata = null;\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int currentRowIndex = 0;\n                for (Iterator rowIterator = rows.iterator(); rowIterator.hasNext(); ) {\n                    Row row = (Row) rowIterator.next();\n                    try {\n                        String metadataId = row.getString(\"ID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[currentRowIndex] = smb;\n                        currentRowIndex++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     *\n     * @param param\n     * @param conn\n     *\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeQuery(param);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        //System.out.println(query);\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String getMultiSelection(String[] values, String column) {\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i < values.length; i++) {\n            if (i == 0) {\n                buffer.append(column + \" like '%\" + values[i] + \"%' \");\n            } else {\n                buffer.append(\"OR \" + column + \" like '%\" + values[i] + \"%' \");\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the advanced search action page, and builds a single sql query from the\n     * information in the Bean. for OR relation, the function uses UNION to\n     * combine the select statements, for AND relation, the funcion uses\n     * \"and metadataid in\" statement. For the multi-selection and drop down windows\n     * that has fixed AND relation, they are parsed before the boolean keyword\n     * selections, and the results will be attached at the begining for every\n     * Union boolean relation.\n     * @param param\n     * @return String\n     */\n    public String makeQuery(ParameterBean param) {\n        String[] filter = param.getFilterArray();\n        String[] source = param.getSourceCollection();\n        String[] publicationNames = param.getPublicationNames();\n        String[] publicationIds = param.getPublicationIds();\n        //String[] rights=param.getRightsArray();\n        String[] primary = param.getPrimaryArray();\n        String[] imaging = param.getImaging();\n        String[] diseasep = param.getDisease();\n        //stores the AND, OR relation\n        String relat = null;\n        //stores relation segments needed in the query\n        String in_relat = null;\n        //stores the begining select statements and multi-selection\n        String start;\n        //conditions needed at the begining of the query and\n        //at the begining of every Union selection\n        //counter\n        int i = 0;\n        StringBuffer sql = new StringBuffer();\n        StringBuffer union = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID) AS ID, Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        sql.append(\") \\n\");\n        if (filter != null && (filter[0].compareTo(\"all\") != 0)) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(filter, \"LearningResourceType\"));\n            sql.append(\")\\n\");\n        }\n        if (imaging != null && imaging[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(imaging, \"RadiographType\"));\n            sql.append(\")\\n\");\n        }\n        if (diseasep != null && diseasep[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(diseasep, \"DiseaseProcess\"));\n            sql.append(\")\\n\");\n        }\n        //parse out the multi-selection arrays, and combine them into the query\n        if (source != null && source[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(source, \"SourceCollection\"));\n            sql.append(\" )\\n\");\n        }\n        if (null != publicationNames && !\"all\".equals(publicationNames[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationNames.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId IN (SELECT Publications.PublicationId FROM Publications WHERE PublicationName LIKE '\" + publicationNames[counter] + \"%')\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (null != publicationIds && !\"all\".equals(publicationIds[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationIds.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId = '\" + publicationIds[counter] + \"'\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (primary != null && primary[0].compareTo(\"all\") != 0 && primary[0].compareTo(\"notall\") != 0) {\n            sql.append(\"AND Metadata.MetadataID IN (SELECT TargetUserGroups.MetadataID from TargetUserGroups WHERE\");\n            sql.append(\" \" + getMultiSelection(primary, \"TargetUserGroup\"));\n            sql.append(\") \\n\");\n        } else if (primary[0].compareTo(\"notall\") == 0) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12') AND MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup = 'Higher Education' or TargetUserGroup ='Health Profession Education'))\");\n        } else {\n        }\n        //The statement parsed above are saved in the start parameter\n        start = sql.toString();\n        //string and attached at the beginning of the Union statement\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            String column = tempNode.getColumnName();\n            String table = tempNode.getTableName();\n            boolean exact = tempNode.getExact();\n            //skip nodes with the three column below, because they have been taken care of\n            if (column.compareTo(\"SpecimenType\") != 0 && column.compareTo(\"RadiographType\") != 0 && column.compareTo(\"DiseaseProcess\") != 0) {\n                //attach segments correspondingly\n                if (//if AND relation\n                relat.compareTo(\"AND\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                } else if (//if not relation\n                relat.compareTo(\"NOT\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n                } else if (//if or relation\n                relat.compareTo(\"OR\") == 0 && i != 0) {\n                    sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n                } else if (//if the first node, attach default segment\n                i == 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                    in_relat = \"\";\n                }\n                //attach segments according to different table name\n                if (table.compareTo(\"Metadata\") == 0) {\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \" )\\n\");\n                }\n                if (table.compareTo(\"Keywords\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                // added by Zhen 6/12/08 for searching tags table.\n                if (table.compareTo(\"Tags\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                if (table.compareTo(\"CopyrightHolders\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"Contributors\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"TaxonPaths\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"taxonpathID\", table, \"taxons\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"ALL\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                    sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                    sql.append(\")\\n\");\n                }\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(\"query: \" + output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/AdvSearchDAOTest0.java",
		"test_prompt": "// AdvSearchDAOTest0.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdvSearchDAO}.\n* It contains ten unit test cases for the {@link AdvSearchDAO#AdvSearch(ParameterBean)} method.\n*/\nclass AdvSearchDAOTest0 {"
	},
	{
		"original_code": "// AdvSearchDAO.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class AdvSearchDAO implements Serializable {\n\n    public AdvSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a set of parameters and a list of filters, performs a search\n     * for all metadata that match all of the criteria set out in the\n     * parameters and also have a format in the presented list.\n     * The results are returned in a SearchResultBean.\n     * It should be noted that unless a metadata matches _ALL_ of the\n     * parameters laid out in the search paremters, it will not be in the\n     * result set.\n     *\n     * @param param\n     *\n     * @return results\n     */\n    public SearchResultBean AdvSearch(ParameterBean param) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        Connection conn = dataSource.getConnection();\n        try {\n            List metaIDs = new ArrayList();\n            Vector rows = getQueryMetaID(param, conn);\n            ShortMetadataResultBean[] metadata = null;\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int currentRowIndex = 0;\n                for (Iterator rowIterator = rows.iterator(); rowIterator.hasNext(); ) {\n                    Row row = (Row) rowIterator.next();\n                    try {\n                        String metadataId = row.getString(\"ID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[currentRowIndex] = smb;\n                        currentRowIndex++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     *\n     * @param param\n     * @param conn\n     *\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeQuery(param);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        //System.out.println(query);\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String getMultiSelection(String[] values, String column) {\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i < values.length; i++) {\n            if (i == 0) {\n                buffer.append(column + \" like '%\" + values[i] + \"%' \");\n            } else {\n                buffer.append(\"OR \" + column + \" like '%\" + values[i] + \"%' \");\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the advanced search action page, and builds a single sql query from the\n     * information in the Bean. for OR relation, the function uses UNION to\n     * combine the select statements, for AND relation, the funcion uses\n     * \"and metadataid in\" statement. For the multi-selection and drop down windows\n     * that has fixed AND relation, they are parsed before the boolean keyword\n     * selections, and the results will be attached at the begining for every\n     * Union boolean relation.\n     * @param param\n     * @return String\n     */\n    public String makeQuery(ParameterBean param) {\n        String[] filter = param.getFilterArray();\n        String[] source = param.getSourceCollection();\n        String[] publicationNames = param.getPublicationNames();\n        String[] publicationIds = param.getPublicationIds();\n        //String[] rights=param.getRightsArray();\n        String[] primary = param.getPrimaryArray();\n        String[] imaging = param.getImaging();\n        String[] diseasep = param.getDisease();\n        //stores the AND, OR relation\n        String relat = null;\n        //stores relation segments needed in the query\n        String in_relat = null;\n        //stores the begining select statements and multi-selection\n        String start;\n        //conditions needed at the begining of the query and\n        //at the begining of every Union selection\n        //counter\n        int i = 0;\n        StringBuffer sql = new StringBuffer();\n        StringBuffer union = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID) AS ID, Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        sql.append(\") \\n\");\n        if (filter != null && (filter[0].compareTo(\"all\") != 0)) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(filter, \"LearningResourceType\"));\n            sql.append(\")\\n\");\n        }\n        if (imaging != null && imaging[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(imaging, \"RadiographType\"));\n            sql.append(\")\\n\");\n        }\n        if (diseasep != null && diseasep[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(diseasep, \"DiseaseProcess\"));\n            sql.append(\")\\n\");\n        }\n        //parse out the multi-selection arrays, and combine them into the query\n        if (source != null && source[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(source, \"SourceCollection\"));\n            sql.append(\" )\\n\");\n        }\n        if (null != publicationNames && !\"all\".equals(publicationNames[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationNames.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId IN (SELECT Publications.PublicationId FROM Publications WHERE PublicationName LIKE '\" + publicationNames[counter] + \"%')\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (null != publicationIds && !\"all\".equals(publicationIds[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationIds.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId = '\" + publicationIds[counter] + \"'\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (primary != null && primary[0].compareTo(\"all\") != 0 && primary[0].compareTo(\"notall\") != 0) {\n            sql.append(\"AND Metadata.MetadataID IN (SELECT TargetUserGroups.MetadataID from TargetUserGroups WHERE\");\n            sql.append(\" \" + getMultiSelection(primary, \"TargetUserGroup\"));\n            sql.append(\") \\n\");\n        } else if (primary[0].compareTo(\"notall\") == 0) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12') AND MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup = 'Higher Education' or TargetUserGroup ='Health Profession Education'))\");\n        } else {\n        }\n        //The statement parsed above are saved in the start parameter\n        start = sql.toString();\n        //string and attached at the beginning of the Union statement\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            String column = tempNode.getColumnName();\n            String table = tempNode.getTableName();\n            boolean exact = tempNode.getExact();\n            //skip nodes with the three column below, because they have been taken care of\n            if (column.compareTo(\"SpecimenType\") != 0 && column.compareTo(\"RadiographType\") != 0 && column.compareTo(\"DiseaseProcess\") != 0) {\n                //attach segments correspondingly\n                if (//if AND relation\n                relat.compareTo(\"AND\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                } else if (//if not relation\n                relat.compareTo(\"NOT\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n                } else if (//if or relation\n                relat.compareTo(\"OR\") == 0 && i != 0) {\n                    sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n                } else if (//if the first node, attach default segment\n                i == 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                    in_relat = \"\";\n                }\n                //attach segments according to different table name\n                if (table.compareTo(\"Metadata\") == 0) {\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \" )\\n\");\n                }\n                if (table.compareTo(\"Keywords\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                // added by Zhen 6/12/08 for searching tags table.\n                if (table.compareTo(\"Tags\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                if (table.compareTo(\"CopyrightHolders\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"Contributors\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"TaxonPaths\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"taxonpathID\", table, \"taxons\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"ALL\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                    sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                    sql.append(\")\\n\");\n                }\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(\"query: \" + output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/AdvSearchDAOTest1.java",
		"test_prompt": "// AdvSearchDAOTest1.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdvSearchDAO}.\n* It contains ten unit test cases for the {@link AdvSearchDAO#addDefaultConnectives(String)} method.\n*/\nclass AdvSearchDAOTest1 {"
	},
	{
		"original_code": "// AdvSearchDAO.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class AdvSearchDAO implements Serializable {\n\n    public AdvSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a set of parameters and a list of filters, performs a search\n     * for all metadata that match all of the criteria set out in the\n     * parameters and also have a format in the presented list.\n     * The results are returned in a SearchResultBean.\n     * It should be noted that unless a metadata matches _ALL_ of the\n     * parameters laid out in the search paremters, it will not be in the\n     * result set.\n     *\n     * @param param\n     *\n     * @return results\n     */\n    public SearchResultBean AdvSearch(ParameterBean param) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        Connection conn = dataSource.getConnection();\n        try {\n            List metaIDs = new ArrayList();\n            Vector rows = getQueryMetaID(param, conn);\n            ShortMetadataResultBean[] metadata = null;\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int currentRowIndex = 0;\n                for (Iterator rowIterator = rows.iterator(); rowIterator.hasNext(); ) {\n                    Row row = (Row) rowIterator.next();\n                    try {\n                        String metadataId = row.getString(\"ID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[currentRowIndex] = smb;\n                        currentRowIndex++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     *\n     * @param param\n     * @param conn\n     *\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeQuery(param);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        //System.out.println(query);\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String getMultiSelection(String[] values, String column) {\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i < values.length; i++) {\n            if (i == 0) {\n                buffer.append(column + \" like '%\" + values[i] + \"%' \");\n            } else {\n                buffer.append(\"OR \" + column + \" like '%\" + values[i] + \"%' \");\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the advanced search action page, and builds a single sql query from the\n     * information in the Bean. for OR relation, the function uses UNION to\n     * combine the select statements, for AND relation, the funcion uses\n     * \"and metadataid in\" statement. For the multi-selection and drop down windows\n     * that has fixed AND relation, they are parsed before the boolean keyword\n     * selections, and the results will be attached at the begining for every\n     * Union boolean relation.\n     * @param param\n     * @return String\n     */\n    public String makeQuery(ParameterBean param) {\n        String[] filter = param.getFilterArray();\n        String[] source = param.getSourceCollection();\n        String[] publicationNames = param.getPublicationNames();\n        String[] publicationIds = param.getPublicationIds();\n        //String[] rights=param.getRightsArray();\n        String[] primary = param.getPrimaryArray();\n        String[] imaging = param.getImaging();\n        String[] diseasep = param.getDisease();\n        //stores the AND, OR relation\n        String relat = null;\n        //stores relation segments needed in the query\n        String in_relat = null;\n        //stores the begining select statements and multi-selection\n        String start;\n        //conditions needed at the begining of the query and\n        //at the begining of every Union selection\n        //counter\n        int i = 0;\n        StringBuffer sql = new StringBuffer();\n        StringBuffer union = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID) AS ID, Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        sql.append(\") \\n\");\n        if (filter != null && (filter[0].compareTo(\"all\") != 0)) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(filter, \"LearningResourceType\"));\n            sql.append(\")\\n\");\n        }\n        if (imaging != null && imaging[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(imaging, \"RadiographType\"));\n            sql.append(\")\\n\");\n        }\n        if (diseasep != null && diseasep[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(diseasep, \"DiseaseProcess\"));\n            sql.append(\")\\n\");\n        }\n        //parse out the multi-selection arrays, and combine them into the query\n        if (source != null && source[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(source, \"SourceCollection\"));\n            sql.append(\" )\\n\");\n        }\n        if (null != publicationNames && !\"all\".equals(publicationNames[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationNames.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId IN (SELECT Publications.PublicationId FROM Publications WHERE PublicationName LIKE '\" + publicationNames[counter] + \"%')\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (null != publicationIds && !\"all\".equals(publicationIds[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationIds.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId = '\" + publicationIds[counter] + \"'\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (primary != null && primary[0].compareTo(\"all\") != 0 && primary[0].compareTo(\"notall\") != 0) {\n            sql.append(\"AND Metadata.MetadataID IN (SELECT TargetUserGroups.MetadataID from TargetUserGroups WHERE\");\n            sql.append(\" \" + getMultiSelection(primary, \"TargetUserGroup\"));\n            sql.append(\") \\n\");\n        } else if (primary[0].compareTo(\"notall\") == 0) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12') AND MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup = 'Higher Education' or TargetUserGroup ='Health Profession Education'))\");\n        } else {\n        }\n        //The statement parsed above are saved in the start parameter\n        start = sql.toString();\n        //string and attached at the beginning of the Union statement\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            String column = tempNode.getColumnName();\n            String table = tempNode.getTableName();\n            boolean exact = tempNode.getExact();\n            //skip nodes with the three column below, because they have been taken care of\n            if (column.compareTo(\"SpecimenType\") != 0 && column.compareTo(\"RadiographType\") != 0 && column.compareTo(\"DiseaseProcess\") != 0) {\n                //attach segments correspondingly\n                if (//if AND relation\n                relat.compareTo(\"AND\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                } else if (//if not relation\n                relat.compareTo(\"NOT\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n                } else if (//if or relation\n                relat.compareTo(\"OR\") == 0 && i != 0) {\n                    sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n                } else if (//if the first node, attach default segment\n                i == 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                    in_relat = \"\";\n                }\n                //attach segments according to different table name\n                if (table.compareTo(\"Metadata\") == 0) {\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \" )\\n\");\n                }\n                if (table.compareTo(\"Keywords\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                // added by Zhen 6/12/08 for searching tags table.\n                if (table.compareTo(\"Tags\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                if (table.compareTo(\"CopyrightHolders\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"Contributors\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"TaxonPaths\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"taxonpathID\", table, \"taxons\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"ALL\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                    sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                    sql.append(\")\\n\");\n                }\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(\"query: \" + output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/AdvSearchDAOTest2.java",
		"test_prompt": "// AdvSearchDAOTest2.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdvSearchDAO}.\n* It contains ten unit test cases for the {@link AdvSearchDAO#buildCommonQuery(String, String, String)} method.\n*/\nclass AdvSearchDAOTest2 {"
	},
	{
		"original_code": "// AdvSearchDAO.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class AdvSearchDAO implements Serializable {\n\n    public AdvSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a set of parameters and a list of filters, performs a search\n     * for all metadata that match all of the criteria set out in the\n     * parameters and also have a format in the presented list.\n     * The results are returned in a SearchResultBean.\n     * It should be noted that unless a metadata matches _ALL_ of the\n     * parameters laid out in the search paremters, it will not be in the\n     * result set.\n     *\n     * @param param\n     *\n     * @return results\n     */\n    public SearchResultBean AdvSearch(ParameterBean param) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        Connection conn = dataSource.getConnection();\n        try {\n            List metaIDs = new ArrayList();\n            Vector rows = getQueryMetaID(param, conn);\n            ShortMetadataResultBean[] metadata = null;\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int currentRowIndex = 0;\n                for (Iterator rowIterator = rows.iterator(); rowIterator.hasNext(); ) {\n                    Row row = (Row) rowIterator.next();\n                    try {\n                        String metadataId = row.getString(\"ID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[currentRowIndex] = smb;\n                        currentRowIndex++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     *\n     * @param param\n     * @param conn\n     *\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeQuery(param);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        //System.out.println(query);\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String getMultiSelection(String[] values, String column) {\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i < values.length; i++) {\n            if (i == 0) {\n                buffer.append(column + \" like '%\" + values[i] + \"%' \");\n            } else {\n                buffer.append(\"OR \" + column + \" like '%\" + values[i] + \"%' \");\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the advanced search action page, and builds a single sql query from the\n     * information in the Bean. for OR relation, the function uses UNION to\n     * combine the select statements, for AND relation, the funcion uses\n     * \"and metadataid in\" statement. For the multi-selection and drop down windows\n     * that has fixed AND relation, they are parsed before the boolean keyword\n     * selections, and the results will be attached at the begining for every\n     * Union boolean relation.\n     * @param param\n     * @return String\n     */\n    public String makeQuery(ParameterBean param) {\n        String[] filter = param.getFilterArray();\n        String[] source = param.getSourceCollection();\n        String[] publicationNames = param.getPublicationNames();\n        String[] publicationIds = param.getPublicationIds();\n        //String[] rights=param.getRightsArray();\n        String[] primary = param.getPrimaryArray();\n        String[] imaging = param.getImaging();\n        String[] diseasep = param.getDisease();\n        //stores the AND, OR relation\n        String relat = null;\n        //stores relation segments needed in the query\n        String in_relat = null;\n        //stores the begining select statements and multi-selection\n        String start;\n        //conditions needed at the begining of the query and\n        //at the begining of every Union selection\n        //counter\n        int i = 0;\n        StringBuffer sql = new StringBuffer();\n        StringBuffer union = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID) AS ID, Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        sql.append(\") \\n\");\n        if (filter != null && (filter[0].compareTo(\"all\") != 0)) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(filter, \"LearningResourceType\"));\n            sql.append(\")\\n\");\n        }\n        if (imaging != null && imaging[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(imaging, \"RadiographType\"));\n            sql.append(\")\\n\");\n        }\n        if (diseasep != null && diseasep[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(diseasep, \"DiseaseProcess\"));\n            sql.append(\")\\n\");\n        }\n        //parse out the multi-selection arrays, and combine them into the query\n        if (source != null && source[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(source, \"SourceCollection\"));\n            sql.append(\" )\\n\");\n        }\n        if (null != publicationNames && !\"all\".equals(publicationNames[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationNames.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId IN (SELECT Publications.PublicationId FROM Publications WHERE PublicationName LIKE '\" + publicationNames[counter] + \"%')\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (null != publicationIds && !\"all\".equals(publicationIds[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationIds.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId = '\" + publicationIds[counter] + \"'\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (primary != null && primary[0].compareTo(\"all\") != 0 && primary[0].compareTo(\"notall\") != 0) {\n            sql.append(\"AND Metadata.MetadataID IN (SELECT TargetUserGroups.MetadataID from TargetUserGroups WHERE\");\n            sql.append(\" \" + getMultiSelection(primary, \"TargetUserGroup\"));\n            sql.append(\") \\n\");\n        } else if (primary[0].compareTo(\"notall\") == 0) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12') AND MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup = 'Higher Education' or TargetUserGroup ='Health Profession Education'))\");\n        } else {\n        }\n        //The statement parsed above are saved in the start parameter\n        start = sql.toString();\n        //string and attached at the beginning of the Union statement\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            String column = tempNode.getColumnName();\n            String table = tempNode.getTableName();\n            boolean exact = tempNode.getExact();\n            //skip nodes with the three column below, because they have been taken care of\n            if (column.compareTo(\"SpecimenType\") != 0 && column.compareTo(\"RadiographType\") != 0 && column.compareTo(\"DiseaseProcess\") != 0) {\n                //attach segments correspondingly\n                if (//if AND relation\n                relat.compareTo(\"AND\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                } else if (//if not relation\n                relat.compareTo(\"NOT\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n                } else if (//if or relation\n                relat.compareTo(\"OR\") == 0 && i != 0) {\n                    sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n                } else if (//if the first node, attach default segment\n                i == 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                    in_relat = \"\";\n                }\n                //attach segments according to different table name\n                if (table.compareTo(\"Metadata\") == 0) {\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \" )\\n\");\n                }\n                if (table.compareTo(\"Keywords\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                // added by Zhen 6/12/08 for searching tags table.\n                if (table.compareTo(\"Tags\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                if (table.compareTo(\"CopyrightHolders\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"Contributors\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"TaxonPaths\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"taxonpathID\", table, \"taxons\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"ALL\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                    sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                    sql.append(\")\\n\");\n                }\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(\"query: \" + output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/AdvSearchDAOTest3.java",
		"test_prompt": "// AdvSearchDAOTest3.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdvSearchDAO}.\n* It contains ten unit test cases for the {@link AdvSearchDAO#buildMutiQuery(String, String, String, String, String)} method.\n*/\nclass AdvSearchDAOTest3 {"
	},
	{
		"original_code": "// AdvSearchDAO.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class AdvSearchDAO implements Serializable {\n\n    public AdvSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Given a set of parameters and a list of filters, performs a search\n     * for all metadata that match all of the criteria set out in the\n     * parameters and also have a format in the presented list.\n     * The results are returned in a SearchResultBean.\n     * It should be noted that unless a metadata matches _ALL_ of the\n     * parameters laid out in the search paremters, it will not be in the\n     * result set.\n     *\n     * @param param\n     *\n     * @return results\n     */\n    public SearchResultBean AdvSearch(ParameterBean param) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        Connection conn = dataSource.getConnection();\n        try {\n            List metaIDs = new ArrayList();\n            Vector rows = getQueryMetaID(param, conn);\n            ShortMetadataResultBean[] metadata = null;\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int currentRowIndex = 0;\n                for (Iterator rowIterator = rows.iterator(); rowIterator.hasNext(); ) {\n                    Row row = (Row) rowIterator.next();\n                    try {\n                        String metadataId = row.getString(\"ID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[currentRowIndex] = smb;\n                        currentRowIndex++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     *\n     * @param param\n     * @param conn\n     *\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeQuery(param);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        //System.out.println(query);\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        //System.out.println(bf.toString());\n        return bf.toString();\n    }\n\n    public String getMultiSelection(String[] values, String column) {\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i < values.length; i++) {\n            if (i == 0) {\n                buffer.append(column + \" like '%\" + values[i] + \"%' \");\n            } else {\n                buffer.append(\"OR \" + column + \" like '%\" + values[i] + \"%' \");\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the advanced search action page, and builds a single sql query from the\n     * information in the Bean. for OR relation, the function uses UNION to\n     * combine the select statements, for AND relation, the funcion uses\n     * \"and metadataid in\" statement. For the multi-selection and drop down windows\n     * that has fixed AND relation, they are parsed before the boolean keyword\n     * selections, and the results will be attached at the begining for every\n     * Union boolean relation.\n     * @param param\n     * @return String\n     */\n    public String makeQuery(ParameterBean param) {\n        String[] filter = param.getFilterArray();\n        String[] source = param.getSourceCollection();\n        String[] publicationNames = param.getPublicationNames();\n        String[] publicationIds = param.getPublicationIds();\n        //String[] rights=param.getRightsArray();\n        String[] primary = param.getPrimaryArray();\n        String[] imaging = param.getImaging();\n        String[] diseasep = param.getDisease();\n        //stores the AND, OR relation\n        String relat = null;\n        //stores relation segments needed in the query\n        String in_relat = null;\n        //stores the begining select statements and multi-selection\n        String start;\n        //conditions needed at the begining of the query and\n        //at the begining of every Union selection\n        //counter\n        int i = 0;\n        StringBuffer sql = new StringBuffer();\n        StringBuffer union = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID) AS ID, Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        sql.append(\") \\n\");\n        if (filter != null && (filter[0].compareTo(\"all\") != 0)) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(filter, \"LearningResourceType\"));\n            sql.append(\")\\n\");\n        }\n        if (imaging != null && imaging[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(imaging, \"RadiographType\"));\n            sql.append(\")\\n\");\n        }\n        if (diseasep != null && diseasep[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(diseasep, \"DiseaseProcess\"));\n            sql.append(\")\\n\");\n        }\n        //parse out the multi-selection arrays, and combine them into the query\n        if (source != null && source[0].compareTo(\"all\") != 0) {\n            sql.append(\" AND (\");\n            sql.append(\" \" + getMultiSelection(source, \"SourceCollection\"));\n            sql.append(\" )\\n\");\n        }\n        if (null != publicationNames && !\"all\".equals(publicationNames[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationNames.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId IN (SELECT Publications.PublicationId FROM Publications WHERE PublicationName LIKE '\" + publicationNames[counter] + \"%')\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (null != publicationIds && !\"all\".equals(publicationIds[0])) {\n            sql.append(\" AND (\");\n            for (int counter = 0; counter < publicationIds.length; ++counter) {\n                if (0 != counter) {\n                    sql.append(\" OR \");\n                }\n                sql.append(\"Metadata.PublicationId = '\" + publicationIds[counter] + \"'\");\n            }\n            sql.append(\")\\n\");\n        }\n        if (primary != null && primary[0].compareTo(\"all\") != 0 && primary[0].compareTo(\"notall\") != 0) {\n            sql.append(\"AND Metadata.MetadataID IN (SELECT TargetUserGroups.MetadataID from TargetUserGroups WHERE\");\n            sql.append(\" \" + getMultiSelection(primary, \"TargetUserGroup\"));\n            sql.append(\") \\n\");\n        } else if (primary[0].compareTo(\"notall\") == 0) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12') AND MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup = 'Higher Education' or TargetUserGroup ='Health Profession Education'))\");\n        } else {\n        }\n        //The statement parsed above are saved in the start parameter\n        start = sql.toString();\n        //string and attached at the beginning of the Union statement\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            String column = tempNode.getColumnName();\n            String table = tempNode.getTableName();\n            boolean exact = tempNode.getExact();\n            //skip nodes with the three column below, because they have been taken care of\n            if (column.compareTo(\"SpecimenType\") != 0 && column.compareTo(\"RadiographType\") != 0 && column.compareTo(\"DiseaseProcess\") != 0) {\n                //attach segments correspondingly\n                if (//if AND relation\n                relat.compareTo(\"AND\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                } else if (//if not relation\n                relat.compareTo(\"NOT\") == 0 && i != 0) {\n                    sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n                } else if (//if or relation\n                relat.compareTo(\"OR\") == 0 && i != 0) {\n                    sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n                } else if (//if the first node, attach default segment\n                i == 0) {\n                    sql.append(\"AND Metadata.MetadataID IN \\n\");\n                    in_relat = \"\";\n                }\n                //attach segments according to different table name\n                if (table.compareTo(\"Metadata\") == 0) {\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \" )\\n\");\n                }\n                if (table.compareTo(\"Keywords\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                // added by Zhen 6/12/08 for searching tags table.\n                if (table.compareTo(\"Tags\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, column, table) + \")\\n\");\n                }\n                if (table.compareTo(\"CopyrightHolders\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"Contributors\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"vcardID\", table, \"vcards\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"TaxonPaths\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"( \" + buildMutiQuery(key, \"taxonpathID\", table, \"taxons\", column) + \" )\\n\");\n                }\n                if (table.compareTo(\"ALL\") == 0) {\n                    sql.append(in_relat);\n                    sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                    sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                    sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                    sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                    sql.append(\")\\n\");\n                }\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(\"query: \" + output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/AdvSearchDAOTest4.java",
		"test_prompt": "// AdvSearchDAOTest4.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdvSearchDAO}.\n* It contains ten unit test cases for the {@link AdvSearchDAO#makeQuery(ParameterBean)} method.\n*/\nclass AdvSearchDAOTest4 {"
	},
	{
		"original_code": "// SimpleSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class SimpleSearchDAO implements Serializable {\n\n    public SimpleSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the simple search works.\n     * First, traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. Than we search the following table and fields.\n     * Metadata Table: Title, Description, SourceCollection, and MetadataID\n     * Keywords Table: Keyword\n     * Formats Table: Format\n     * Copyrights and CopyrightTexts Tables: CopyrightTextID and CopyrightText\n     * CopyrightHolders and Vcards Tables: VcardID and Vcard\n     * Contributors and Vcards Tables: VcardID and Vcard\n     * TaxonPaths and Taxons Tables: TaxonPathID and Entry\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If filterHidden is set to true, then the results will not contain\n     * any metadata that is marked as hidden.\n     * @param param\n     * @return results\n     */\n    public SearchResultBean simpleSearch(ParameterBean param, String consumer) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        List metaIDs = new ArrayList();\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getQueryMetaID(param, consumer, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     * @param param,conn\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, String consumer, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeSimpleQuery(param, consumer);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. The query building process follows the following\n     * steps: 1.Select MetadataID from each table\n     *        2.UNION all the result\n     *        3.If search more than one word, put the relation between each union.\n     *          if relation is \"AND\", put \"AND MetadataID IN\" between two words statement.\n     *          if relation is \"OR\", put \"AND MetadataID NOT IN\" between two statement.\n     *          if relation is \"NOT\", put \"UNION\" between two union statement.\n     * @param param\n     * @return String\n     */\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        return bf.toString();\n    }\n\n    public String makeSimpleQuery(ParameterBean param, String consumer) {\n        StringBuffer sql = new StringBuffer();\n        boolean exact = false;\n        //stores the AND, OR relation\n        String relat = null;\n        //counter\n        int i = 0;\n        sql.append(\"select distinct(Metadata.metadataID), Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        if (param.getUsageRight() == null) {\n            sql.append(\" AND Metadata.SourceCollection <> 'PEIR - University of Alabama at Birmingham Department of Radiology' AND Metadata.SourceCollection<> 'PEIR - University of Alabama at Birmingham Department of Pathology'\");\n        }\n        if (consumer == null) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12'))\");\n        }\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            exact = tempNode.getExact();\n            if (//if AND or OR relation\n            relat.compareTo(\"AND\") == 0 || relat.compareTo(\"\") == 0) {\n                sql.append(\"AND Metadata.MetadataID IN \\n\");\n            } else if (relat.compareTo(\"NOT\") == 0) {\n                sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n            } else if (relat.compareTo(\"OR\") == 0) {\n                sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n            }\n            if (!exact) {\n                sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                sql.append(\")\\n\");\n            } else //if it is exact search\n            {\n                sql.append(\" (Select Metadata.MetadataID from Metadata where\");\n                sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n                sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n                sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n                sql.append(\"OR LearningResourceType like '\" + key + \"' OR LearningResourceType like '% \" + key + \" %' OR LearningResourceType like '% \" + key + \"' OR LearningResourceType like '\" + key + \" %' OR LearningResourceType like '% \" + key + \".%' OR LearningResourceType like '% \" + key + \",%'\\n\");\n                sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n                sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n                sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n                sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n                //  sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n                //  sql.append(\"Entry like '\"+key+\"' OR Entry LIKE '% \"+key+\" %' OR Entry like '\"+key+\" %' OR Entry like '% \"+key+\"' OR Entry like '% \"+key+\".%' OR Entry like '% \"+key+\",%')\\n\");\n                sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n                sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%') )\\n\");\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/SimpleSearchDAOTest0.java",
		"test_prompt": "// SimpleSearchDAOTest0.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSearchDAO}.\n* It contains ten unit test cases for the {@link SimpleSearchDAO#simpleSearch(ParameterBean, String)} method.\n*/\nclass SimpleSearchDAOTest0 {"
	},
	{
		"original_code": "// SimpleSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class SimpleSearchDAO implements Serializable {\n\n    public SimpleSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the simple search works.\n     * First, traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. Than we search the following table and fields.\n     * Metadata Table: Title, Description, SourceCollection, and MetadataID\n     * Keywords Table: Keyword\n     * Formats Table: Format\n     * Copyrights and CopyrightTexts Tables: CopyrightTextID and CopyrightText\n     * CopyrightHolders and Vcards Tables: VcardID and Vcard\n     * Contributors and Vcards Tables: VcardID and Vcard\n     * TaxonPaths and Taxons Tables: TaxonPathID and Entry\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If filterHidden is set to true, then the results will not contain\n     * any metadata that is marked as hidden.\n     * @param param\n     * @return results\n     */\n    public SearchResultBean simpleSearch(ParameterBean param, String consumer) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        List metaIDs = new ArrayList();\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getQueryMetaID(param, consumer, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     * @param param,conn\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, String consumer, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeSimpleQuery(param, consumer);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. The query building process follows the following\n     * steps: 1.Select MetadataID from each table\n     *        2.UNION all the result\n     *        3.If search more than one word, put the relation between each union.\n     *          if relation is \"AND\", put \"AND MetadataID IN\" between two words statement.\n     *          if relation is \"OR\", put \"AND MetadataID NOT IN\" between two statement.\n     *          if relation is \"NOT\", put \"UNION\" between two union statement.\n     * @param param\n     * @return String\n     */\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        return bf.toString();\n    }\n\n    public String makeSimpleQuery(ParameterBean param, String consumer) {\n        StringBuffer sql = new StringBuffer();\n        boolean exact = false;\n        //stores the AND, OR relation\n        String relat = null;\n        //counter\n        int i = 0;\n        sql.append(\"select distinct(Metadata.metadataID), Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        if (param.getUsageRight() == null) {\n            sql.append(\" AND Metadata.SourceCollection <> 'PEIR - University of Alabama at Birmingham Department of Radiology' AND Metadata.SourceCollection<> 'PEIR - University of Alabama at Birmingham Department of Pathology'\");\n        }\n        if (consumer == null) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12'))\");\n        }\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            exact = tempNode.getExact();\n            if (//if AND or OR relation\n            relat.compareTo(\"AND\") == 0 || relat.compareTo(\"\") == 0) {\n                sql.append(\"AND Metadata.MetadataID IN \\n\");\n            } else if (relat.compareTo(\"NOT\") == 0) {\n                sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n            } else if (relat.compareTo(\"OR\") == 0) {\n                sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n            }\n            if (!exact) {\n                sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                sql.append(\")\\n\");\n            } else //if it is exact search\n            {\n                sql.append(\" (Select Metadata.MetadataID from Metadata where\");\n                sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n                sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n                sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n                sql.append(\"OR LearningResourceType like '\" + key + \"' OR LearningResourceType like '% \" + key + \" %' OR LearningResourceType like '% \" + key + \"' OR LearningResourceType like '\" + key + \" %' OR LearningResourceType like '% \" + key + \".%' OR LearningResourceType like '% \" + key + \",%'\\n\");\n                sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n                sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n                sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n                sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n                //  sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n                //  sql.append(\"Entry like '\"+key+\"' OR Entry LIKE '% \"+key+\" %' OR Entry like '\"+key+\" %' OR Entry like '% \"+key+\"' OR Entry like '% \"+key+\".%' OR Entry like '% \"+key+\",%')\\n\");\n                sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n                sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%') )\\n\");\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/SimpleSearchDAOTest1.java",
		"test_prompt": "// SimpleSearchDAOTest1.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSearchDAO}.\n* It contains ten unit test cases for the {@link SimpleSearchDAO#addDefaultConnectives(String)} method.\n*/\nclass SimpleSearchDAOTest1 {"
	},
	{
		"original_code": "// SimpleSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class SimpleSearchDAO implements Serializable {\n\n    public SimpleSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the simple search works.\n     * First, traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. Than we search the following table and fields.\n     * Metadata Table: Title, Description, SourceCollection, and MetadataID\n     * Keywords Table: Keyword\n     * Formats Table: Format\n     * Copyrights and CopyrightTexts Tables: CopyrightTextID and CopyrightText\n     * CopyrightHolders and Vcards Tables: VcardID and Vcard\n     * Contributors and Vcards Tables: VcardID and Vcard\n     * TaxonPaths and Taxons Tables: TaxonPathID and Entry\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If filterHidden is set to true, then the results will not contain\n     * any metadata that is marked as hidden.\n     * @param param\n     * @return results\n     */\n    public SearchResultBean simpleSearch(ParameterBean param, String consumer) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        List metaIDs = new ArrayList();\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getQueryMetaID(param, consumer, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     * @param param,conn\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, String consumer, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeSimpleQuery(param, consumer);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. The query building process follows the following\n     * steps: 1.Select MetadataID from each table\n     *        2.UNION all the result\n     *        3.If search more than one word, put the relation between each union.\n     *          if relation is \"AND\", put \"AND MetadataID IN\" between two words statement.\n     *          if relation is \"OR\", put \"AND MetadataID NOT IN\" between two statement.\n     *          if relation is \"NOT\", put \"UNION\" between two union statement.\n     * @param param\n     * @return String\n     */\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        return bf.toString();\n    }\n\n    public String makeSimpleQuery(ParameterBean param, String consumer) {\n        StringBuffer sql = new StringBuffer();\n        boolean exact = false;\n        //stores the AND, OR relation\n        String relat = null;\n        //counter\n        int i = 0;\n        sql.append(\"select distinct(Metadata.metadataID), Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        if (param.getUsageRight() == null) {\n            sql.append(\" AND Metadata.SourceCollection <> 'PEIR - University of Alabama at Birmingham Department of Radiology' AND Metadata.SourceCollection<> 'PEIR - University of Alabama at Birmingham Department of Pathology'\");\n        }\n        if (consumer == null) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12'))\");\n        }\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            exact = tempNode.getExact();\n            if (//if AND or OR relation\n            relat.compareTo(\"AND\") == 0 || relat.compareTo(\"\") == 0) {\n                sql.append(\"AND Metadata.MetadataID IN \\n\");\n            } else if (relat.compareTo(\"NOT\") == 0) {\n                sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n            } else if (relat.compareTo(\"OR\") == 0) {\n                sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n            }\n            if (!exact) {\n                sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                sql.append(\")\\n\");\n            } else //if it is exact search\n            {\n                sql.append(\" (Select Metadata.MetadataID from Metadata where\");\n                sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n                sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n                sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n                sql.append(\"OR LearningResourceType like '\" + key + \"' OR LearningResourceType like '% \" + key + \" %' OR LearningResourceType like '% \" + key + \"' OR LearningResourceType like '\" + key + \" %' OR LearningResourceType like '% \" + key + \".%' OR LearningResourceType like '% \" + key + \",%'\\n\");\n                sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n                sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n                sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n                sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n                //  sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n                //  sql.append(\"Entry like '\"+key+\"' OR Entry LIKE '% \"+key+\" %' OR Entry like '\"+key+\" %' OR Entry like '% \"+key+\"' OR Entry like '% \"+key+\".%' OR Entry like '% \"+key+\",%')\\n\");\n                sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n                sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%') )\\n\");\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/SimpleSearchDAOTest2.java",
		"test_prompt": "// SimpleSearchDAOTest2.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSearchDAO}.\n* It contains ten unit test cases for the {@link SimpleSearchDAO#buildCommonQuery(String, String, String)} method.\n*/\nclass SimpleSearchDAOTest2 {"
	},
	{
		"original_code": "// SimpleSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class SimpleSearchDAO implements Serializable {\n\n    public SimpleSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the simple search works.\n     * First, traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. Than we search the following table and fields.\n     * Metadata Table: Title, Description, SourceCollection, and MetadataID\n     * Keywords Table: Keyword\n     * Formats Table: Format\n     * Copyrights and CopyrightTexts Tables: CopyrightTextID and CopyrightText\n     * CopyrightHolders and Vcards Tables: VcardID and Vcard\n     * Contributors and Vcards Tables: VcardID and Vcard\n     * TaxonPaths and Taxons Tables: TaxonPathID and Entry\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If filterHidden is set to true, then the results will not contain\n     * any metadata that is marked as hidden.\n     * @param param\n     * @return results\n     */\n    public SearchResultBean simpleSearch(ParameterBean param, String consumer) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        List metaIDs = new ArrayList();\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getQueryMetaID(param, consumer, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     * @param param,conn\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, String consumer, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeSimpleQuery(param, consumer);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. The query building process follows the following\n     * steps: 1.Select MetadataID from each table\n     *        2.UNION all the result\n     *        3.If search more than one word, put the relation between each union.\n     *          if relation is \"AND\", put \"AND MetadataID IN\" between two words statement.\n     *          if relation is \"OR\", put \"AND MetadataID NOT IN\" between two statement.\n     *          if relation is \"NOT\", put \"UNION\" between two union statement.\n     * @param param\n     * @return String\n     */\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        return bf.toString();\n    }\n\n    public String makeSimpleQuery(ParameterBean param, String consumer) {\n        StringBuffer sql = new StringBuffer();\n        boolean exact = false;\n        //stores the AND, OR relation\n        String relat = null;\n        //counter\n        int i = 0;\n        sql.append(\"select distinct(Metadata.metadataID), Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        if (param.getUsageRight() == null) {\n            sql.append(\" AND Metadata.SourceCollection <> 'PEIR - University of Alabama at Birmingham Department of Radiology' AND Metadata.SourceCollection<> 'PEIR - University of Alabama at Birmingham Department of Pathology'\");\n        }\n        if (consumer == null) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12'))\");\n        }\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            exact = tempNode.getExact();\n            if (//if AND or OR relation\n            relat.compareTo(\"AND\") == 0 || relat.compareTo(\"\") == 0) {\n                sql.append(\"AND Metadata.MetadataID IN \\n\");\n            } else if (relat.compareTo(\"NOT\") == 0) {\n                sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n            } else if (relat.compareTo(\"OR\") == 0) {\n                sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n            }\n            if (!exact) {\n                sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                sql.append(\")\\n\");\n            } else //if it is exact search\n            {\n                sql.append(\" (Select Metadata.MetadataID from Metadata where\");\n                sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n                sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n                sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n                sql.append(\"OR LearningResourceType like '\" + key + \"' OR LearningResourceType like '% \" + key + \" %' OR LearningResourceType like '% \" + key + \"' OR LearningResourceType like '\" + key + \" %' OR LearningResourceType like '% \" + key + \".%' OR LearningResourceType like '% \" + key + \",%'\\n\");\n                sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n                sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n                sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n                sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n                //  sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n                //  sql.append(\"Entry like '\"+key+\"' OR Entry LIKE '% \"+key+\" %' OR Entry like '\"+key+\" %' OR Entry like '% \"+key+\"' OR Entry like '% \"+key+\".%' OR Entry like '% \"+key+\",%')\\n\");\n                sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n                sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%') )\\n\");\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/SimpleSearchDAOTest3.java",
		"test_prompt": "// SimpleSearchDAOTest3.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSearchDAO}.\n* It contains ten unit test cases for the {@link SimpleSearchDAO#buildMutiQuery(String, String, String, String, String)} method.\n*/\nclass SimpleSearchDAOTest3 {"
	},
	{
		"original_code": "// SimpleSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace/Julie\n * @version 0.1\n */\npublic class SimpleSearchDAO implements Serializable {\n\n    public SimpleSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the simple search works.\n     * First, traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. Than we search the following table and fields.\n     * Metadata Table: Title, Description, SourceCollection, and MetadataID\n     * Keywords Table: Keyword\n     * Formats Table: Format\n     * Copyrights and CopyrightTexts Tables: CopyrightTextID and CopyrightText\n     * CopyrightHolders and Vcards Tables: VcardID and Vcard\n     * Contributors and Vcards Tables: VcardID and Vcard\n     * TaxonPaths and Taxons Tables: TaxonPathID and Entry\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If filterHidden is set to true, then the results will not contain\n     * any metadata that is marked as hidden.\n     * @param param\n     * @return results\n     */\n    public SearchResultBean simpleSearch(ParameterBean param, String consumer) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        List metaIDs = new ArrayList();\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getQueryMetaID(param, consumer, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Excute the SQL statement and return the set of rows\n     * @param param,conn\n     * @return rows\n     */\n    private Vector getQueryMetaID(ParameterBean param, String consumer, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        String sqls = makeSimpleQuery(param, consumer);\n        sqlCommandBean.setSqlValue(sqls);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * This is the function that traverses through the ParameterBean passed from\n     * the search action page, and builds a single sql query from the\n     * information in the Bean. The query building process follows the following\n     * steps: 1.Select MetadataID from each table\n     *        2.UNION all the result\n     *        3.If search more than one word, put the relation between each union.\n     *          if relation is \"AND\", put \"AND MetadataID IN\" between two words statement.\n     *          if relation is \"OR\", put \"AND MetadataID NOT IN\" between two statement.\n     *          if relation is \"NOT\", put \"UNION\" between two union statement.\n     * @param param\n     * @return String\n     */\n    /**\n     * This method takes in a string and adds default connetives \"or\" into\n     * necessary positions.\n     */\n    public String addDefaultConnectives(String query) {\n        StringTokenizer tk = new StringTokenizer(query);\n        String previouskey = \"\";\n        String key;\n        StringBuffer buff = new StringBuffer();\n        boolean connect = false;\n        while (tk.hasMoreTokens()) {\n            key = tk.nextToken();\n            if (key.compareTo(\"not\") == 0 || key.compareTo(\"or\") == 0 || key.compareTo(\"and\") == 0) {\n                buff.append(key + \" \");\n                previouskey = key;\n            } else if (previouskey.compareTo(\"(\") != 0 && previouskey.compareTo(\"\") != 0 && key.compareTo(\")\") != 0 && previouskey.compareTo(\"not\") != 0 && previouskey.compareTo(\"and\") != 0 && previouskey.compareTo(\"or\") != 0) {\n                buff.append(\" and \" + key + \" \");\n                previouskey = key;\n            } else {\n                buff.append(key + \" \");\n                previouskey = key;\n            }\n        }\n        return buff.toString();\n    }\n\n    /**\n     * This method forms the query sentence for zero or one level of join.\n     * That is, for searches on metadata table and keyword tables.\n     * It assumes that query string is in the correct acceptance format:\n     * keyword \" keyword AND keyword \" NOT ( keyword OR keyword )\n     * The final sql statement should be in the following format:\n     * SELECT metadataID FROM tablename WHERE column like '%keyword%' AND\n     * metadatID IN (Select metadataID from tablename WHERE column like '%keyword%'\n     * @param query\n     * @param column\n     * @param table\n     * @return bf.toString()\n     */\n    public String buildCommonQuery(String query, String column, String table) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND Metadata.metadataID NOT IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND Metadata.metadataID IN (SELECT \" + table + \".MetadataID from \" + table + \" where \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isFirst = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %'\");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '\" + searchKey + \"%' OR \" + column + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND Metadata.metadataID IN (SELECT Metadata.MetadataID from metadata where \" + column + \" like '% \" + searchKey + \" %' OR \" + column + \" like '% \" + searchKey + \"%' OR \" + column + \" like '%\" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isFirst = false;\n                    isExact = false;\n                }\n            }\n        }\n        return bf.toString();\n    }\n\n    public String buildMutiQuery(String query, String column, String table, String subTable, String subColumn) {\n        String origQuery = null;\n        origQuery = addDefaultConnectives(query);\n        StringTokenizer tk = new StringTokenizer(origQuery);\n        String searchKey = null;\n        StringBuffer bf = new StringBuffer();\n        boolean isNOT = false;\n        boolean isOR = false;\n        boolean isAND = false;\n        boolean isFirst = true;\n        boolean isExact = false;\n        bf.append(\"SELECT \" + table + \".metadataID from \" + table + \" WHERE \" + column + \" IN (Select \" + column + \" from \" + subTable + \" WHERE \");\n        while (tk.hasMoreTokens()) {\n            searchKey = tk.nextToken();\n            if (searchKey.compareTo(\"\\\"\") == 0) {\n                StringBuffer exact = new StringBuffer();\n                searchKey = tk.nextToken();\n                while (tk.hasMoreTokens() && searchKey.compareTo(\"\\\"\") != 0) {\n                    exact.append(searchKey + \" \");\n                    searchKey = tk.nextToken();\n                }\n                searchKey = exact.toString();\n                searchKey = searchKey.trim();\n                isExact = true;\n            }\n            if (searchKey.compareTo(\"(\") == 0 || searchKey.compareTo(\")\") == 0) {\n                bf.append(searchKey + \" \");\n            } else if (searchKey.compareTo(\"or\") == 0) {\n                bf.append(searchKey + \" \");\n                isOR = true;\n            } else if (searchKey.compareTo(\"not\") == 0) {\n                bf.append(\" AND \" + column + \" NOT IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isNOT = true;\n            } else if (searchKey.compareTo(\"and\") == 0) {\n                bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \");\n                isAND = true;\n            } else {\n                if (isAND || isNOT) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                    isAND = false;\n                    isNOT = false;\n                    isExact = false;\n                } else if (isOR || isFirst) {\n                    if (!isExact) {\n                        bf.append(subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' \");\n                    } else {\n                        bf.append(subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %' \");\n                    }\n                    isFirst = false;\n                    isOR = false;\n                    isExact = false;\n                } else {\n                    if (!isExact) {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '\" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \"%' )\");\n                    } else {\n                        bf.append(\" AND \" + column + \" IN (SELECT \" + column + \" FROM \" + subTable + \" WHERE \" + subColumn + \" like '% \" + searchKey + \" %' OR \" + subColumn + \" like '% \" + searchKey + \"%' OR \" + subColumn + \" like '% \" + searchKey + \" %')\");\n                    }\n                }\n            }\n        }\n        bf.append(\")\");\n        return bf.toString();\n    }\n\n    public String makeSimpleQuery(ParameterBean param, String consumer) {\n        StringBuffer sql = new StringBuffer();\n        boolean exact = false;\n        //stores the AND, OR relation\n        String relat = null;\n        //counter\n        int i = 0;\n        sql.append(\"select distinct(Metadata.metadataID), Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL AND \");\n        if (param.getHidden() == false) {\n            sql.append(\" Metadata.Private='0'\");\n        }\n        if (param.getUsageRight() == null) {\n            sql.append(\" AND Metadata.SourceCollection <> 'PEIR - University of Alabama at Birmingham Department of Radiology' AND Metadata.SourceCollection<> 'PEIR - University of Alabama at Birmingham Department of Pathology'\");\n        }\n        if (consumer == null) {\n            sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where (TargetUserGroup = 'Consumer Health/Patient Education' or TargetUserGroup = 'K-12'))\");\n        }\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (i = 0; i < param.size(); i++) {\n            ParameterNode tempNode = param.getParameters(i);\n            String key = tempNode.getKeyWord();\n            relat = tempNode.getRelation();\n            exact = tempNode.getExact();\n            if (//if AND or OR relation\n            relat.compareTo(\"AND\") == 0 || relat.compareTo(\"\") == 0) {\n                sql.append(\"AND Metadata.MetadataID IN \\n\");\n            } else if (relat.compareTo(\"NOT\") == 0) {\n                sql.append(\"AND Metadata.MetadataID NOT IN \\n\");\n            } else if (relat.compareTo(\"OR\") == 0) {\n                sql.append(\"UNION \\n\" + start + \"AND Metadata.MetadataID IN \\n \");\n            }\n            if (!exact) {\n                sql.append(\"(\" + buildCommonQuery(key, \"title\", \"Metadata\"));\n                sql.append(\"\\nUNION \" + buildCommonQuery(key, \"description\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"SourceCollection\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"metadataID\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"LearningResourceType\", \"Metadata\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"keyword\", \"Keywords\"));\n                sql.append(\" \\nUNION \" + buildCommonQuery(key, \"tag\", \"Tags\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"CopyrightTextID\", \"CopyRights\", \"CopyrightTexts\", \"CopyrightText\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"TaxonPathID\", \"TaxonPaths\", \"Taxons\", \"Entry\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"Contributors\", \"Vcards\", \"vcard\"));\n                sql.append(\" \\nUNION \" + buildMutiQuery(key, \"vcardID\", \"CopyrightHolders\", \"Vcards\", \"vcard\"));\n                sql.append(\")\\n\");\n            } else //if it is exact search\n            {\n                sql.append(\" (Select Metadata.MetadataID from Metadata where\");\n                sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n                sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n                sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n                sql.append(\"OR LearningResourceType like '\" + key + \"' OR LearningResourceType like '% \" + key + \" %' OR LearningResourceType like '% \" + key + \"' OR LearningResourceType like '\" + key + \" %' OR LearningResourceType like '% \" + key + \".%' OR LearningResourceType like '% \" + key + \",%'\\n\");\n                sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n                sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n                sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n                sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n                //  sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n                //  sql.append(\"Entry like '\"+key+\"' OR Entry LIKE '% \"+key+\" %' OR Entry like '\"+key+\" %' OR Entry like '% \"+key+\"' OR Entry like '% \"+key+\".%' OR Entry like '% \"+key+\",%')\\n\");\n                sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n                sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n                sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%') )\\n\");\n            }\n        }\n        sql.append(\" order by Title\");\n        String output = sql.toString();\n        System.out.println(output);\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/SimpleSearchDAOTest4.java",
		"test_prompt": "// SimpleSearchDAOTest4.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleSearchDAO}.\n* It contains ten unit test cases for the {@link SimpleSearchDAO#makeSimpleQuery(ParameterBean, String)} method.\n*/\nclass SimpleSearchDAOTest4 {"
	},
	{
		"original_code": "// SimpleMerlotSearch.java\npackage org.heal.module.search.MerlotWS;\n\nimport java.rmi.RemoteException;\nimport javax.xml.rpc.ServiceException;\nimport org.merlot.fedsearch.wsdl.*;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.module.search.ShortMetadataResultBean;\n\n/**\n * This class is used to call Merlot's search web services.\n * @author Jason Varghese\n */\npublic class SimpleMerlotSearch {\n\n    private final static int MAX_RESULTS = 10;\n\n    public SearchResultBean doSimpleMerlotSearch(String keywords, int start, int stop) {\n        SearchResultBean srb = new SearchResultBean();\n        try {\n            org.merlot.fedsearch.type.SearchResult searchResult = new org.merlot.fedsearch.type.SearchResult();\n            org.merlot.fedsearch.type.SearchResultElement[] sre = new org.merlot.fedsearch.type.SearchResultElement[MAX_RESULTS];\n            MerlotSearch ims2 = new MerlotSearchLocator();\n            SearchService ims = ims2.getSearchServicePort();\n            //searchResult = ims.doSearch(\"ulOPDbfh0RN6PWKw\",keywords,1,25);\n            searchResult = ims.doSearch(\"YoFt9llu056hvtZC\", keywords, 1, 25);\n            sre = searchResult.getResultElements();\n            int count = searchResult.getTotalResultsCount();\n            if (count < stop)\n                stop = count;\n            ShortMetadataResultBean[] smrb = new ShortMetadataResultBean[stop - start + 1];\n            srb.setKeywords(keywords);\n            srb.setSimple(true);\n            ShortMetadataBean currentMeta = null;\n            if (sre == null) {\n                return null;\n            }\n            for (int a = 0; a < sre.length; a++) {\n                if (smrb[a] == null)\n                    smrb[a] = new ShortMetadataResultBean();\n                currentMeta = smrb[a].getShortMetadata();\n                if (currentMeta == null)\n                    currentMeta = new ShortMetadataBean();\n                currentMeta.setTitle(sre[a].getTitle());\n                currentMeta.setDescription(sre[a].getDescription());\n                currentMeta.setLocation(sre[a].getDetailURL());\n                currentMeta.setSourceCollection(\"MERLOT\");\n                currentMeta.setFormat(sre[a].getItemType());\n                currentMeta.setThumbnail(currentMeta.getThumbnail());\n                smrb[a].setShortMetadata(currentMeta);\n            }\n            srb.setShortRecords(smrb);\n        } catch (RemoteException re) {\n            re.printStackTrace();\n        } catch (ServiceException se) {\n            se.printStackTrace();\n        }\n        return srb;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/MerlotWS/SimpleMerlotSearchTest.java",
		"test_prompt": "// SimpleMerlotSearchTest.java\npackage org.heal.module.search.MerlotWS;\n\nimport java.rmi.RemoteException;\nimport javax.xml.rpc.ServiceException;\nimport org.merlot.fedsearch.wsdl.*;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.module.search.SearchResultBean;\nimport org.heal.module.search.ShortMetadataResultBean;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleMerlotSearch}.\n* It contains ten unit test cases for the {@link SimpleMerlotSearch#doSimpleMerlotSearch(String, int, int)} method.\n*/\nclass SimpleMerlotSearchTest {"
	},
	{
		"original_code": "// ReSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\n// This DAO is for users to edit their search results\npublic class ReSearchDAO implements Serializable {\n\n    public ReSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the edit search works.\n     * First, we get all of the metadata IDs from the Previous search.\n     * If you select search within result, The new search scope will be in\n     * the previous search. Otherwise this search like a new search.\n     * Second we take keyword, media file type and search type  to search in database.\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If the search type is 1, it means search any keywords in the database.\n     * the keywords list is split (using space as the delimiter) and each\n     * keyword is searched for independently.(like OR)\n     * If the search type is 2, it means search all keywords in the database.\n     * the keywords list is split (using space as the delimiter) and all the\n     * keywords are searched in database.(like AND)\n     * If the search type is 3, it means exact search.\n     * @param metaids, keywordlist, filterArray, searchtype, filterHidden\n     * @return results\n     */\n    public SearchResultBean editSearch(String metaids, String keywordList, String[] filterArray, String searchtype, boolean filterHidden) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        results.setFilterList(filterArray);\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        List metaIDs = new ArrayList();\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            if (searchtype.equals(\"Exact\")) {\n                rows = getExactMatches(metaids, keywordList, filterArray, filterHidden, conn);\n            } else {\n                rows = getTypeMatches(metaids, keywordList, filterArray, searchtype, filterHidden, conn);\n            }\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Get MetadataIDs that exact match the keyword and selected media types.\n     * If prevoious metadata ids not equal \"no\",\n     * all the new search will be in the previous search results.\n     * Else the search will be new.\n     * If media type is not \"All\", then call getFilterString(String[]) to get the media type.\n     * Checks for the given keyword and type in the given table and column name using\n     * the provided database connection.  If the match is found, a vector of\n     * com.ora.jsp.sql.Row is returned. Else return null.\n     * @param mids, keyword, filterArray, hidd, conn\n     * @return rows\n     */\n    private Vector getExactMatches(String mids, String key, String[] filterAry, boolean hidd, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT distinct(Metadata.metadataID),Metadata.Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL\");\n        if (hidd == false) {\n            sql.append(\" AND Metadata.Private=0 \");\n        }\n        sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup LIKE 'consumer Health%' or TargetUserGroup LIKE 'K-12%')\");\n        sql.append(\") AND (Metadata.MetadataID IN (SELECT Metadata.MetadataID FROM Metadata WHERE\");\n        sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n        sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n        sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n        sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n        sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n        sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n        sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n        sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n        sql.append(\"Entry like '\" + key + \"' OR Entry LIKE '% \" + key + \" %' OR Entry like '\" + key + \" %' OR Entry like '% \" + key + \"' OR Entry like '% \" + key + \".%' OR Entry like '% \" + key + \",%')\\n\");\n        sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n        sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n        sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n        sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')))\\n\");\n        if (filterAry != null) {\n            String format = getFilterString(filterAry);\n            sql.append(\" AND (\" + format + \")\");\n        }\n        if (mids.equals(\"no\")) {\n        } else {\n            sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n        }\n        sql.append(\" order by Title\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Get MetadataIDs that match all or any words that user input and selected media types.\n     * If prevoious metadata ids not equal \"no\", all the new search will be in the previous search results.\n     * Else the search will be new.\n     * Tokenizer the keywords and get each of word.\n     * If search type equal \"All\", add \"AND\" relation between the word.\n     * If search type equal \"Any\", add \"UNION\" relation between the word.\n     * If media type is not \"All\", call getFilterString(String[]) to get the media type.\n     * Checks each keyword of the list and type in the given table and column name using\n     * the provided database connection.  If the match is found, a vector of\n     * com.ora.jsp.sql.Row is returned. Else return null.\n     * @param mids, keywords, filterAry, type, hidd, conn\n     * @return rows\n     */\n    private Vector getTypeMatches(String mids, String keywords, String[] filterAry, String type, boolean hidd, Connection conn) throws SQLException {\n        List keys = new ArrayList();\n        String key = null;\n        StringTokenizer tokenizer = new StringTokenizer(keywords, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            keys.add(tokenizer.nextToken());\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID),Metadata.Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL\");\n        if (hidd == false) {\n            sql.append(\" AND Metadata.Private=0 \");\n        }\n        sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup LIKE 'consumer Health%' or TargetUserGroup LIKE 'K-12%')\");\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (int i = 0; i < keys.size(); i++) {\n            key = (String) keys.get(i);\n            if (type.equals(\"All\") || i == 0) {\n                sql.append(\"AND (Metadata.MetadataID IN \\n\");\n            } else if (type.equals(\"Any\") && i >= 1) {\n                if (filterAry != null) {\n                    String format = getFilterString(filterAry);\n                    sql.append(\" AND (\" + format + \")\");\n                }\n                if (mids.equals(\"no\")) {\n                } else {\n                    sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n                }\n                sql.append(\" UNION \\n\" + start + \"AND (Metadata.MetadataID IN \\n \");\n            }\n            sql.append(\" (Select Metadata.MetadataID from metadata where\");\n            sql.append(\" (title like '%\" + key + \"%' \\n\");\n            sql.append(\"OR description like '%\" + key + \"%' \\n\");\n            sql.append(\"OR SourceCollection like '%\" + key + \"%' \\n\");\n            sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n            sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '%\" + key + \"%'\\n\");\n            sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n            sql.append(\"copyrightText LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n            sql.append(\" Entry LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n            sql.append(\" vCard LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n            sql.append(\" vCard LIKE '%\" + key + \"%')))\\n\");\n        }\n        if (filterAry != null) {\n            String format = getFilterString(filterAry);\n            sql.append(\" AND (\" + format + \")\");\n        }\n        if (mids.equals(\"no\")) {\n        } else {\n            sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n        }\n        sql.append(\" order by Title\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Combine some string with each element of filterarray to make SQL statement.\n     * @param mids, keywords, filterAry, type, hidd, conn\n     * @return rows\n     */\n    public String getFilterString(String[] filterAry) {\n        String format = \"\";\n        String f = \" OR Metadata.LearningResourceType like '\";\n        int t1 = 0;\n        for (int i = 0; i < filterAry.length; i++) {\n            if (filterAry.length == 1) {\n                format = \"Metadata.LearningResourceType like '\" + filterAry[0] + \"%'\";\n                t1 = format.length();\n            } else {\n                format = format + f + filterAry[i] + \"%'\";\n            }\n        }\n        if (t1 == 0) {\n            format = format.replaceFirst(\"OR\", \"\");\n        }\n        return format;\n    }\n\n    /**\n     * make a String to contain all the metadateIDs that found in search.\n     * @param metaID\n     * @return inStr\n     */\n    public String makeInString(List metaID) {\n        StringBuffer inStrs = new StringBuffer();\n        int msize = metaID.size();\n        int i = 0;\n        while (msize > i) {\n            inStrs.append(metaID.get(i));\n            if (i != metaID.size() - 1) {\n                inStrs.append(\", \");\n            }\n            i++;\n        }\n        String inStr = inStrs.toString();\n        return inStr;\n    }\n\n    /**\n     * Sort the search results as required field.\n     * @param filed, mids\n     * @return results\n     */\n    public SearchResultBean sortResult(String filed, String mids) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        List metaIDs = new ArrayList();\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getSortMetadataID(filed, mids, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Get a sort field and sort in database using order by.\n     * Return the sorted rows.\n     * @param fd, ids, conn\n     * @return rows\n     */\n    private Vector getSortMetadataID(String fd, String ids, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        if (fd.equals(\"Format\")) {\n            sql.append(\"SELECT MetadataID, LearningResourceType FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY LearningResourceType\");\n        } else if (fd.equals(\"FileSize\")) {\n            sql.append(\"SELECT MetadataID,FileSize FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY CASE when FileSize=0 then CONVERT(int, 99999999) ELSE fileSize END ASC\");\n        } else if (fd.equals(\"SourceCollection\")) {\n            sql.append(\"SELECT MetadataID,SourceCollection FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY SourceCollection\");\n        } else {\n            sql.append(\"SELECT MetadataID, Title FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY Title\");\n        }\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ReSearchDAOTest0.java",
		"test_prompt": "// ReSearchDAOTest0.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReSearchDAO}.\n* It contains ten unit test cases for the {@link ReSearchDAO#editSearch(String, String, String[], String, boolean)} method.\n*/\nclass ReSearchDAOTest0 {"
	},
	{
		"original_code": "// ReSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\n// This DAO is for users to edit their search results\npublic class ReSearchDAO implements Serializable {\n\n    public ReSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the edit search works.\n     * First, we get all of the metadata IDs from the Previous search.\n     * If you select search within result, The new search scope will be in\n     * the previous search. Otherwise this search like a new search.\n     * Second we take keyword, media file type and search type  to search in database.\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If the search type is 1, it means search any keywords in the database.\n     * the keywords list is split (using space as the delimiter) and each\n     * keyword is searched for independently.(like OR)\n     * If the search type is 2, it means search all keywords in the database.\n     * the keywords list is split (using space as the delimiter) and all the\n     * keywords are searched in database.(like AND)\n     * If the search type is 3, it means exact search.\n     * @param metaids, keywordlist, filterArray, searchtype, filterHidden\n     * @return results\n     */\n    public SearchResultBean editSearch(String metaids, String keywordList, String[] filterArray, String searchtype, boolean filterHidden) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        results.setFilterList(filterArray);\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        List metaIDs = new ArrayList();\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            if (searchtype.equals(\"Exact\")) {\n                rows = getExactMatches(metaids, keywordList, filterArray, filterHidden, conn);\n            } else {\n                rows = getTypeMatches(metaids, keywordList, filterArray, searchtype, filterHidden, conn);\n            }\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Get MetadataIDs that exact match the keyword and selected media types.\n     * If prevoious metadata ids not equal \"no\",\n     * all the new search will be in the previous search results.\n     * Else the search will be new.\n     * If media type is not \"All\", then call getFilterString(String[]) to get the media type.\n     * Checks for the given keyword and type in the given table and column name using\n     * the provided database connection.  If the match is found, a vector of\n     * com.ora.jsp.sql.Row is returned. Else return null.\n     * @param mids, keyword, filterArray, hidd, conn\n     * @return rows\n     */\n    private Vector getExactMatches(String mids, String key, String[] filterAry, boolean hidd, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT distinct(Metadata.metadataID),Metadata.Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL\");\n        if (hidd == false) {\n            sql.append(\" AND Metadata.Private=0 \");\n        }\n        sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup LIKE 'consumer Health%' or TargetUserGroup LIKE 'K-12%')\");\n        sql.append(\") AND (Metadata.MetadataID IN (SELECT Metadata.MetadataID FROM Metadata WHERE\");\n        sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n        sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n        sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n        sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n        sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n        sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n        sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n        sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n        sql.append(\"Entry like '\" + key + \"' OR Entry LIKE '% \" + key + \" %' OR Entry like '\" + key + \" %' OR Entry like '% \" + key + \"' OR Entry like '% \" + key + \".%' OR Entry like '% \" + key + \",%')\\n\");\n        sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n        sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n        sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n        sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')))\\n\");\n        if (filterAry != null) {\n            String format = getFilterString(filterAry);\n            sql.append(\" AND (\" + format + \")\");\n        }\n        if (mids.equals(\"no\")) {\n        } else {\n            sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n        }\n        sql.append(\" order by Title\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Get MetadataIDs that match all or any words that user input and selected media types.\n     * If prevoious metadata ids not equal \"no\", all the new search will be in the previous search results.\n     * Else the search will be new.\n     * Tokenizer the keywords and get each of word.\n     * If search type equal \"All\", add \"AND\" relation between the word.\n     * If search type equal \"Any\", add \"UNION\" relation between the word.\n     * If media type is not \"All\", call getFilterString(String[]) to get the media type.\n     * Checks each keyword of the list and type in the given table and column name using\n     * the provided database connection.  If the match is found, a vector of\n     * com.ora.jsp.sql.Row is returned. Else return null.\n     * @param mids, keywords, filterAry, type, hidd, conn\n     * @return rows\n     */\n    private Vector getTypeMatches(String mids, String keywords, String[] filterAry, String type, boolean hidd, Connection conn) throws SQLException {\n        List keys = new ArrayList();\n        String key = null;\n        StringTokenizer tokenizer = new StringTokenizer(keywords, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            keys.add(tokenizer.nextToken());\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID),Metadata.Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL\");\n        if (hidd == false) {\n            sql.append(\" AND Metadata.Private=0 \");\n        }\n        sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup LIKE 'consumer Health%' or TargetUserGroup LIKE 'K-12%')\");\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (int i = 0; i < keys.size(); i++) {\n            key = (String) keys.get(i);\n            if (type.equals(\"All\") || i == 0) {\n                sql.append(\"AND (Metadata.MetadataID IN \\n\");\n            } else if (type.equals(\"Any\") && i >= 1) {\n                if (filterAry != null) {\n                    String format = getFilterString(filterAry);\n                    sql.append(\" AND (\" + format + \")\");\n                }\n                if (mids.equals(\"no\")) {\n                } else {\n                    sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n                }\n                sql.append(\" UNION \\n\" + start + \"AND (Metadata.MetadataID IN \\n \");\n            }\n            sql.append(\" (Select Metadata.MetadataID from metadata where\");\n            sql.append(\" (title like '%\" + key + \"%' \\n\");\n            sql.append(\"OR description like '%\" + key + \"%' \\n\");\n            sql.append(\"OR SourceCollection like '%\" + key + \"%' \\n\");\n            sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n            sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '%\" + key + \"%'\\n\");\n            sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n            sql.append(\"copyrightText LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n            sql.append(\" Entry LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n            sql.append(\" vCard LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n            sql.append(\" vCard LIKE '%\" + key + \"%')))\\n\");\n        }\n        if (filterAry != null) {\n            String format = getFilterString(filterAry);\n            sql.append(\" AND (\" + format + \")\");\n        }\n        if (mids.equals(\"no\")) {\n        } else {\n            sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n        }\n        sql.append(\" order by Title\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Combine some string with each element of filterarray to make SQL statement.\n     * @param mids, keywords, filterAry, type, hidd, conn\n     * @return rows\n     */\n    public String getFilterString(String[] filterAry) {\n        String format = \"\";\n        String f = \" OR Metadata.LearningResourceType like '\";\n        int t1 = 0;\n        for (int i = 0; i < filterAry.length; i++) {\n            if (filterAry.length == 1) {\n                format = \"Metadata.LearningResourceType like '\" + filterAry[0] + \"%'\";\n                t1 = format.length();\n            } else {\n                format = format + f + filterAry[i] + \"%'\";\n            }\n        }\n        if (t1 == 0) {\n            format = format.replaceFirst(\"OR\", \"\");\n        }\n        return format;\n    }\n\n    /**\n     * make a String to contain all the metadateIDs that found in search.\n     * @param metaID\n     * @return inStr\n     */\n    public String makeInString(List metaID) {\n        StringBuffer inStrs = new StringBuffer();\n        int msize = metaID.size();\n        int i = 0;\n        while (msize > i) {\n            inStrs.append(metaID.get(i));\n            if (i != metaID.size() - 1) {\n                inStrs.append(\", \");\n            }\n            i++;\n        }\n        String inStr = inStrs.toString();\n        return inStr;\n    }\n\n    /**\n     * Sort the search results as required field.\n     * @param filed, mids\n     * @return results\n     */\n    public SearchResultBean sortResult(String filed, String mids) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        List metaIDs = new ArrayList();\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getSortMetadataID(filed, mids, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Get a sort field and sort in database using order by.\n     * Return the sorted rows.\n     * @param fd, ids, conn\n     * @return rows\n     */\n    private Vector getSortMetadataID(String fd, String ids, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        if (fd.equals(\"Format\")) {\n            sql.append(\"SELECT MetadataID, LearningResourceType FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY LearningResourceType\");\n        } else if (fd.equals(\"FileSize\")) {\n            sql.append(\"SELECT MetadataID,FileSize FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY CASE when FileSize=0 then CONVERT(int, 99999999) ELSE fileSize END ASC\");\n        } else if (fd.equals(\"SourceCollection\")) {\n            sql.append(\"SELECT MetadataID,SourceCollection FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY SourceCollection\");\n        } else {\n            sql.append(\"SELECT MetadataID, Title FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY Title\");\n        }\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ReSearchDAOTest1.java",
		"test_prompt": "// ReSearchDAOTest1.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReSearchDAO}.\n* It contains ten unit test cases for the {@link ReSearchDAO#makeInString(List)} method.\n*/\nclass ReSearchDAOTest1 {"
	},
	{
		"original_code": "// ReSearchDAO.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\n\n/**\n * @author Grace\n * @version 0.1\n */\n// This DAO is for users to edit their search results\npublic class ReSearchDAO implements Serializable {\n\n    public ReSearchDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Here is the process by which the edit search works.\n     * First, we get all of the metadata IDs from the Previous search.\n     * If you select search within result, The new search scope will be in\n     * the previous search. Otherwise this search like a new search.\n     * Second we take keyword, media file type and search type  to search in database.\n     * The results that are left are packaged into a SearchResultBean and returned.\n     * If the search type is 1, it means search any keywords in the database.\n     * the keywords list is split (using space as the delimiter) and each\n     * keyword is searched for independently.(like OR)\n     * If the search type is 2, it means search all keywords in the database.\n     * the keywords list is split (using space as the delimiter) and all the\n     * keywords are searched in database.(like AND)\n     * If the search type is 3, it means exact search.\n     * @param metaids, keywordlist, filterArray, searchtype, filterHidden\n     * @return results\n     */\n    public SearchResultBean editSearch(String metaids, String keywordList, String[] filterArray, String searchtype, boolean filterHidden) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        results.setFilterList(filterArray);\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        List metaIDs = new ArrayList();\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            if (searchtype.equals(\"Exact\")) {\n                rows = getExactMatches(metaids, keywordList, filterArray, filterHidden, conn);\n            } else {\n                rows = getTypeMatches(metaids, keywordList, filterArray, searchtype, filterHidden, conn);\n            }\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Get MetadataIDs that exact match the keyword and selected media types.\n     * If prevoious metadata ids not equal \"no\",\n     * all the new search will be in the previous search results.\n     * Else the search will be new.\n     * If media type is not \"All\", then call getFilterString(String[]) to get the media type.\n     * Checks for the given keyword and type in the given table and column name using\n     * the provided database connection.  If the match is found, a vector of\n     * com.ora.jsp.sql.Row is returned. Else return null.\n     * @param mids, keyword, filterArray, hidd, conn\n     * @return rows\n     */\n    private Vector getExactMatches(String mids, String key, String[] filterAry, boolean hidd, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT distinct(Metadata.metadataID),Metadata.Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL\");\n        if (hidd == false) {\n            sql.append(\" AND Metadata.Private=0 \");\n        }\n        sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup LIKE 'consumer Health%' or TargetUserGroup LIKE 'K-12%')\");\n        sql.append(\") AND (Metadata.MetadataID IN (SELECT Metadata.MetadataID FROM Metadata WHERE\");\n        sql.append(\" (title like '\" + key + \"' OR title like '% \" + key + \" %' OR title like '\" + key + \" %' OR title like '% \" + key + \"' OR title like '% \" + key + \".%' OR title like '% \" + key + \",%'\\n\");\n        sql.append(\"OR description like '\" + key + \"' OR description like '% \" + key + \" %' OR description like '\" + key + \" %' OR description like '% \" + key + \"' OR description like '% \" + key + \".%' OR description like '% \" + key + \",%'\\n\");\n        sql.append(\"OR SourceCollection like '\" + key + \"' OR SourceCollection like '% \" + key + \" %' OR SourceCollection like '% \" + key + \"' OR SourceCollection like '\" + key + \" %' OR SourceCollection like '% \" + key + \".%' OR SourceCollection like '% \" + key + \",%'\\n\");\n        sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n        sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '\" + key + \"' OR keyword LIKE '% \" + key + \" %' OR keyword like '\" + key + \" %' OR keyword like '% \" + key + \"' OR keyword like '% \" + key + \".%' OR keyword like '% \" + key + \",%'\\n\");\n        sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n        sql.append(\"copyrightText like '\" + key + \"' OR copyrightText LIKE '% \" + key + \" %' OR copyrightText like '\" + key + \" %' OR copyrightText like '% \" + key + \"' OR copyrightText like '% \" + key + \".%')\\n\");\n        sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n        sql.append(\"Entry like '\" + key + \"' OR Entry LIKE '% \" + key + \" %' OR Entry like '\" + key + \" %' OR Entry like '% \" + key + \"' OR Entry like '% \" + key + \".%' OR Entry like '% \" + key + \",%')\\n\");\n        sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n        sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')\\n\");\n        sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n        sql.append(\"vCard like '\" + key + \"' OR vCard LIKE '% \" + key + \" %' OR vCard like '\" + key + \" %' OR vCard like '% \" + key + \"' OR vCard like '% \" + key + \".%' OR vCard like '% \" + key + \",%')))\\n\");\n        if (filterAry != null) {\n            String format = getFilterString(filterAry);\n            sql.append(\" AND (\" + format + \")\");\n        }\n        if (mids.equals(\"no\")) {\n        } else {\n            sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n        }\n        sql.append(\" order by Title\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Get MetadataIDs that match all or any words that user input and selected media types.\n     * If prevoious metadata ids not equal \"no\", all the new search will be in the previous search results.\n     * Else the search will be new.\n     * Tokenizer the keywords and get each of word.\n     * If search type equal \"All\", add \"AND\" relation between the word.\n     * If search type equal \"Any\", add \"UNION\" relation between the word.\n     * If media type is not \"All\", call getFilterString(String[]) to get the media type.\n     * Checks each keyword of the list and type in the given table and column name using\n     * the provided database connection.  If the match is found, a vector of\n     * com.ora.jsp.sql.Row is returned. Else return null.\n     * @param mids, keywords, filterAry, type, hidd, conn\n     * @return rows\n     */\n    private Vector getTypeMatches(String mids, String keywords, String[] filterAry, String type, boolean hidd, Connection conn) throws SQLException {\n        List keys = new ArrayList();\n        String key = null;\n        StringTokenizer tokenizer = new StringTokenizer(keywords, \" \");\n        while (tokenizer.hasMoreTokens()) {\n            keys.add(tokenizer.nextToken());\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"select distinct(Metadata.metadataID),Metadata.Title FROM Metadata WHERE \");\n        sql.append(\"(Metadata.CatalogDate IS NOT NULL AND Metadata.ApproveDate IS NOT NULL\");\n        if (hidd == false) {\n            sql.append(\" AND Metadata.Private=0 \");\n        }\n        sql.append(\" AND Metadata.MetadataID NOT IN (select MetadataID from TargetUserGroups where TargetUserGroup LIKE 'consumer Health%' or TargetUserGroup LIKE 'K-12%')\");\n        sql.append(\") \\n\");\n        String start = sql.toString();\n        for (int i = 0; i < keys.size(); i++) {\n            key = (String) keys.get(i);\n            if (type.equals(\"All\") || i == 0) {\n                sql.append(\"AND (Metadata.MetadataID IN \\n\");\n            } else if (type.equals(\"Any\") && i >= 1) {\n                if (filterAry != null) {\n                    String format = getFilterString(filterAry);\n                    sql.append(\" AND (\" + format + \")\");\n                }\n                if (mids.equals(\"no\")) {\n                } else {\n                    sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n                }\n                sql.append(\" UNION \\n\" + start + \"AND (Metadata.MetadataID IN \\n \");\n            }\n            sql.append(\" (Select Metadata.MetadataID from metadata where\");\n            sql.append(\" (title like '%\" + key + \"%' \\n\");\n            sql.append(\"OR description like '%\" + key + \"%' \\n\");\n            sql.append(\"OR SourceCollection like '%\" + key + \"%' \\n\");\n            sql.append(\"OR metadataID like '\" + key + \"' )\\n\");\n            sql.append(\"UNION Select keywords.metadataID FROM keywords where keyword like '%\" + key + \"%'\\n\");\n            sql.append(\"UNION Select Copyrights.metadataID from Copyrights WHERE copyrightTextID IN (Select copyrightTextID from CopyrightTexts WHERE \");\n            sql.append(\"copyrightText LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION Select TaxonPaths.metadataID from TaxonPaths where taxonpathid in (select taxonpathid from taxons where \");\n            sql.append(\" Entry LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION select copyrightHolders.metadataID from copyrightHolders where vcardID in (select vcardID from vcards where \");\n            sql.append(\" vCard LIKE '%\" + key + \"%')\\n\");\n            sql.append(\"UNION select Contributors.metadataID from Contributors where vcardID in (select vcardID from vcards where \");\n            sql.append(\" vCard LIKE '%\" + key + \"%')))\\n\");\n        }\n        if (filterAry != null) {\n            String format = getFilterString(filterAry);\n            sql.append(\" AND (\" + format + \")\");\n        }\n        if (mids.equals(\"no\")) {\n        } else {\n            sql.append(\" AND Metadata.MetadataID IN (\" + mids + \")\");\n        }\n        sql.append(\" order by Title\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n\n    /**\n     * Combine some string with each element of filterarray to make SQL statement.\n     * @param mids, keywords, filterAry, type, hidd, conn\n     * @return rows\n     */\n    public String getFilterString(String[] filterAry) {\n        String format = \"\";\n        String f = \" OR Metadata.LearningResourceType like '\";\n        int t1 = 0;\n        for (int i = 0; i < filterAry.length; i++) {\n            if (filterAry.length == 1) {\n                format = \"Metadata.LearningResourceType like '\" + filterAry[0] + \"%'\";\n                t1 = format.length();\n            } else {\n                format = format + f + filterAry[i] + \"%'\";\n            }\n        }\n        if (t1 == 0) {\n            format = format.replaceFirst(\"OR\", \"\");\n        }\n        return format;\n    }\n\n    /**\n     * make a String to contain all the metadateIDs that found in search.\n     * @param metaID\n     * @return inStr\n     */\n    public String makeInString(List metaID) {\n        StringBuffer inStrs = new StringBuffer();\n        int msize = metaID.size();\n        int i = 0;\n        while (msize > i) {\n            inStrs.append(metaID.get(i));\n            if (i != metaID.size() - 1) {\n                inStrs.append(\", \");\n            }\n            i++;\n        }\n        String inStr = inStrs.toString();\n        return inStr;\n    }\n\n    /**\n     * Sort the search results as required field.\n     * @param filed, mids\n     * @return results\n     */\n    public SearchResultBean sortResult(String filed, String mids) throws SQLException {\n        SearchResultBean results = new SearchResultBean();\n        results.setShortRecords(null);\n        Vector rows = null;\n        Row row = null;\n        String metadataId = \"\";\n        List metaIDs = new ArrayList();\n        ShortMetadataResultBean[] metadata = null;\n        Connection conn = dataSource.getConnection();\n        try {\n            rows = getSortMetadataID(filed, mids, conn);\n            // get the MetadataID and set it to the ShortMetadataBean and ShortMetadataResultBean\n            if (rows != null && rows.size() > 0) {\n                // found matches...\n                Iterator rowIterator = rows.iterator();\n                metadata = new ShortMetadataResultBean[rows.size()];\n                int i = 0;\n                while (rowIterator.hasNext() && i < metadata.length) {\n                    row = (Row) rowIterator.next();\n                    try {\n                        metadataId = row.getString(\"MetadataID\");\n                        metaIDs.add(metadataId);\n                        ShortMetadataBean shortMetadata = new ShortMetadataBean();\n                        shortMetadata.setMetadataId(metadataId);\n                        ShortMetadataResultBean smb = new ShortMetadataResultBean();\n                        smb.setMetadataId(metadataId);\n                        metadata[i] = smb;\n                        i++;\n                    } catch (NoSuchColumnException ex) {\n                        throw new SQLException(ex.toString());\n                    }\n                }\n            }\n            results.setShortRecords(metadata);\n            results.setMetaIDs(metaIDs);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Get a sort field and sort in database using order by.\n     * Return the sorted rows.\n     * @param fd, ids, conn\n     * @return rows\n     */\n    private Vector getSortMetadataID(String fd, String ids, Connection conn) throws SQLException {\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        if (fd.equals(\"Format\")) {\n            sql.append(\"SELECT MetadataID, LearningResourceType FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY LearningResourceType\");\n        } else if (fd.equals(\"FileSize\")) {\n            sql.append(\"SELECT MetadataID,FileSize FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY CASE when FileSize=0 then CONVERT(int, 99999999) ELSE fileSize END ASC\");\n        } else if (fd.equals(\"SourceCollection\")) {\n            sql.append(\"SELECT MetadataID,SourceCollection FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY SourceCollection\");\n        } else {\n            sql.append(\"SELECT MetadataID, Title FROM Metadata WHERE metadataID IN (\" + ids + \") \").append(\"ORDER BY Title\");\n        }\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        return rows;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ReSearchDAOTest2.java",
		"test_prompt": "// ReSearchDAOTest2.java\npackage org.heal.module.search;\n\nimport java.io.*;\nimport java.sql.*;\nimport java.util.*;\nimport javax.sql.*;\nimport com.ora.jsp.sql.*;\nimport org.heal.module.metadata.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReSearchDAO}.\n* It contains ten unit test cases for the {@link ReSearchDAO#sortResult(String, String)} method.\n*/\nclass ReSearchDAOTest2 {"
	},
	{
		"original_code": "// ShortMetadataResultBean.java\npackage org.heal.module.search;\n\nimport org.heal.module.metadata.ShortMetadataBean;\nimport java.io.Serializable;\n\n/**\n * This class contains information about the results of a Metadata search.\n * The SearchResultBean contains an ordered list of\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class ShortMetadataResultBean implements Serializable, Comparable {\n\n    //the greater the match string, the better the match\n    private int matchStrength = 0;\n\n    private int keywordsMatched = 0;\n\n    private String lastKeywordMatched = null;\n\n    private String metadataId = null;\n\n    private ShortMetadataBean shortMetadata = null;\n\n    public void setMatchStrength(int newStrength) {\n        matchStrength = newStrength;\n    }\n\n    public int getMatchStrength() {\n        return matchStrength;\n    }\n\n    public void incrementMatchStrength(int incrementAmount) {\n        matchStrength += incrementAmount;\n    }\n\n    public void setKeywordsMatched(int newKeywordsMatched) {\n        keywordsMatched = newKeywordsMatched;\n    }\n\n    public void incrementKeywordsMatched(int incrementAmount) {\n        keywordsMatched += incrementAmount;\n    }\n\n    public int getKeywordsMatched() {\n        return keywordsMatched;\n    }\n\n    public void setLastKeywordMatched(String newLastKeywordMatched) {\n        lastKeywordMatched = newLastKeywordMatched;\n    }\n\n    public String getLastKeywordMatched() {\n        return lastKeywordMatched;\n    }\n\n    public void setMetadataId(String newMetadataId) {\n        metadataId = newMetadataId;\n    }\n\n    public String getMetadataId() {\n        return metadataId;\n    }\n\n    public void setShortMetadata(ShortMetadataBean newShortMetadata) {\n        shortMetadata = newShortMetadata;\n    }\n\n    public ShortMetadataBean getShortMetadata() {\n        return shortMetadata;\n    }\n\n    /* compare the metadataIds of the objects\n     * It only makes sense to compare ShortMetadataResultBeans from the _same_\n     * search, so in theory the matchStrength of two results with the same\n     * metadataId should be identical.  Thus we only need to compare the\n     * metadataIds.\n     */\n    public boolean equals(Object obj) {\n        boolean equal = false;\n        if (obj instanceof ShortMetadataResultBean) {\n            ShortMetadataResultBean sr = (ShortMetadataResultBean) obj;\n            if (metadataId.equals(sr.metadataId)) {\n                equal = true;\n            }\n        }\n        return equal;\n    }\n\n    /**\n     * Compares two ShortMetadataResultBeans.  The comparison is done upon\n     * the strength of the match.  If the passed in object has a stronger\n     * match a negative value will be returned, if the strengths are equal\n     * zero is returned, and if this object has a greater match strength\n     * than the passed in object, a positive value is returned.\n     *\n     * Note: We don't check the type of the object because if we detect that\n     * the types don't match, there is no valid/logical return value we\n     * can give to indicate this.  Therefore we rely upon a\n     * ClassCastException to be thrown.\n     *\n     * We switch the order of the comparisons here because we want the first\n     * elements in a sorted collection to be those with the largest\n     * matchStrengths.\n     */\n    public int compareTo(Object obj) throws ClassCastException {\n        ShortMetadataResultBean smr = (ShortMetadataResultBean) obj;\n        if (smr.matchStrength > matchStrength) {\n            return 1;\n        } else if (smr.matchStrength == matchStrength) {\n            try {\n                int smrId = Integer.parseInt(smr.metadataId);\n                int id = Integer.parseInt(metadataId);\n                if (id > smrId) {\n                    return 1;\n                } else if (id == smrId) {\n                    return 0;\n                } else {\n                    return -1;\n                }\n            } catch (NumberFormatException ex) {\n                //should not happen\n                //??? - do some logging\n                return 0;\n            }\n        } else {\n            return -1;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ShortMetadataResultBeanTest0.java",
		"test_prompt": "// ShortMetadataResultBeanTest0.java\npackage org.heal.module.search;\n\nimport org.heal.module.metadata.ShortMetadataBean;\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShortMetadataResultBean}.\n* It contains ten unit test cases for the {@link ShortMetadataResultBean#equals(Object)} method.\n*/\nclass ShortMetadataResultBeanTest0 {"
	},
	{
		"original_code": "// ShortMetadataResultBean.java\npackage org.heal.module.search;\n\nimport org.heal.module.metadata.ShortMetadataBean;\nimport java.io.Serializable;\n\n/**\n * This class contains information about the results of a Metadata search.\n * The SearchResultBean contains an ordered list of\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class ShortMetadataResultBean implements Serializable, Comparable {\n\n    //the greater the match string, the better the match\n    private int matchStrength = 0;\n\n    private int keywordsMatched = 0;\n\n    private String lastKeywordMatched = null;\n\n    private String metadataId = null;\n\n    private ShortMetadataBean shortMetadata = null;\n\n    public void setMatchStrength(int newStrength) {\n        matchStrength = newStrength;\n    }\n\n    public int getMatchStrength() {\n        return matchStrength;\n    }\n\n    public void incrementMatchStrength(int incrementAmount) {\n        matchStrength += incrementAmount;\n    }\n\n    public void setKeywordsMatched(int newKeywordsMatched) {\n        keywordsMatched = newKeywordsMatched;\n    }\n\n    public void incrementKeywordsMatched(int incrementAmount) {\n        keywordsMatched += incrementAmount;\n    }\n\n    public int getKeywordsMatched() {\n        return keywordsMatched;\n    }\n\n    public void setLastKeywordMatched(String newLastKeywordMatched) {\n        lastKeywordMatched = newLastKeywordMatched;\n    }\n\n    public String getLastKeywordMatched() {\n        return lastKeywordMatched;\n    }\n\n    public void setMetadataId(String newMetadataId) {\n        metadataId = newMetadataId;\n    }\n\n    public String getMetadataId() {\n        return metadataId;\n    }\n\n    public void setShortMetadata(ShortMetadataBean newShortMetadata) {\n        shortMetadata = newShortMetadata;\n    }\n\n    public ShortMetadataBean getShortMetadata() {\n        return shortMetadata;\n    }\n\n    /* compare the metadataIds of the objects\n     * It only makes sense to compare ShortMetadataResultBeans from the _same_\n     * search, so in theory the matchStrength of two results with the same\n     * metadataId should be identical.  Thus we only need to compare the\n     * metadataIds.\n     */\n    public boolean equals(Object obj) {\n        boolean equal = false;\n        if (obj instanceof ShortMetadataResultBean) {\n            ShortMetadataResultBean sr = (ShortMetadataResultBean) obj;\n            if (metadataId.equals(sr.metadataId)) {\n                equal = true;\n            }\n        }\n        return equal;\n    }\n\n    /**\n     * Compares two ShortMetadataResultBeans.  The comparison is done upon\n     * the strength of the match.  If the passed in object has a stronger\n     * match a negative value will be returned, if the strengths are equal\n     * zero is returned, and if this object has a greater match strength\n     * than the passed in object, a positive value is returned.\n     *\n     * Note: We don't check the type of the object because if we detect that\n     * the types don't match, there is no valid/logical return value we\n     * can give to indicate this.  Therefore we rely upon a\n     * ClassCastException to be thrown.\n     *\n     * We switch the order of the comparisons here because we want the first\n     * elements in a sorted collection to be those with the largest\n     * matchStrengths.\n     */\n    public int compareTo(Object obj) throws ClassCastException {\n        ShortMetadataResultBean smr = (ShortMetadataResultBean) obj;\n        if (smr.matchStrength > matchStrength) {\n            return 1;\n        } else if (smr.matchStrength == matchStrength) {\n            try {\n                int smrId = Integer.parseInt(smr.metadataId);\n                int id = Integer.parseInt(metadataId);\n                if (id > smrId) {\n                    return 1;\n                } else if (id == smrId) {\n                    return 0;\n                } else {\n                    return -1;\n                }\n            } catch (NumberFormatException ex) {\n                //should not happen\n                //??? - do some logging\n                return 0;\n            }\n        } else {\n            return -1;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ShortMetadataResultBeanTest1.java",
		"test_prompt": "// ShortMetadataResultBeanTest1.java\npackage org.heal.module.search;\n\nimport org.heal.module.metadata.ShortMetadataBean;\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShortMetadataResultBean}.\n* It contains ten unit test cases for the {@link ShortMetadataResultBean#compareTo(Object)} method.\n*/\nclass ShortMetadataResultBeanTest1 {"
	},
	{
		"original_code": "// SearchResultBean.java\npackage org.heal.module.search;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n * This class contains information about the results of a Metadata search.\n * The SearchResultBean contains an ordered list of\n *\n * @author Seth Wright\n * Modify by Grace: Added setMetaIDs() and getMetaIDs()\n *                  Added setKeywords() and getKeywords()\n * @version 0.1\n */\npublic class SearchResultBean implements Serializable {\n\n    //an ordered set of ShortMetadataBeans\n    private ShortMetadataResultBean[] shortRecords = null;\n\n    //whether or not this was a simple keyword search\n    private boolean simple = false;\n\n    //the list of data types filtered against\n    private String[] filterList = null;\n\n    //an ordered set of MetadatIDs\n    private List metaIDs = null;\n\n    private String keywords = null;\n\n    public ShortMetadataResultBean[] getShortRecords() {\n        return shortRecords;\n    }\n\n    public void setShortRecords(ShortMetadataResultBean[] newRecords) {\n        shortRecords = newRecords;\n    }\n\n    public boolean isSimple() {\n        return simple;\n    }\n\n    public void setSimple(boolean newSimple) {\n        simple = newSimple;\n    }\n\n    public String[] getFilterList() {\n        return filterList;\n    }\n\n    public void setFilterList(String[] newFilterList) {\n        filterList = newFilterList;\n    }\n\n    public void setMetaIDs(List mids) {\n        metaIDs = mids;\n    }\n\n    public List getMetaIDs() {\n        return metaIDs;\n    }\n\n    public void setKeywords(String kwds) {\n        keywords = kwds;\n    }\n\n    public String getKeywords() {\n        return keywords;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/SearchResultBeanTest.java",
		"test_prompt": "// SearchResultBeanTest.java\npackage org.heal.module.search;\n\nimport java.io.Serializable;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultBean}.\n* It contains ten unit test cases for the {@link SearchResultBean#isSimple()} method.\n*/\nclass SearchResultBeanTest {"
	},
	{
		"original_code": "// ConceptMappingDAO.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.StringValue;\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport java.lang.String;\n\n/**\n * @author Grace\n * @version 0.1\n */\npublic class ConceptMappingDAO {\n\n    public ConceptMappingDAO() {\n    }\n\n    private DataSource dataSource;\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public ConceptMappingBean ConceptMapping(String term) throws SQLException {\n        ConceptMappingBean result = null;\n        Connection conn = dataSource.getConnection();\n        if (term != null) {\n            if (term.indexOf(\"'s\") > 0) {\n                term = term.replaceAll(\"'s\", \"\");\n            }\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT * FROM ConceptMapping WHERE InputTerms = ?\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(term));\n            sqlCommandBean.setValues(values);\n            Vector rows = null;\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                try {\n                    //just take the first row, there shouldn't be\n                    //multiple matches...\n                    Row row = (Row) rows.firstElement();\n                    result = new ConceptMappingBean();\n                    result.setConceptId(row.getString(\"ConceptId\"));\n                    result.setInputTerms(\"InputTerms\");\n                    result.setConcept(row.getString(\"Concept\"));\n                    result.setMapping(row.getString(\"Mapping\"));\n                } catch (NoSuchColumnException ex) {\n                    throw new SQLException(ex.toString());\n                }\n            } else\n                result = null;\n        }\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ConceptMappingDAOTest.java",
		"test_prompt": "// ConceptMappingDAOTest.java\npackage org.heal.module.search;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.StringValue;\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport java.lang.String;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConceptMappingDAO}.\n* It contains ten unit test cases for the {@link ConceptMappingDAO#ConceptMapping(String)} method.\n*/\nclass ConceptMappingDAOTest {"
	},
	{
		"original_code": "// ParameterBean.java\npackage org.heal.module.search;\n\nimport java.util.*;\n\n/**\n * This ParameterBean class stores an ArrayList of searchParameters and\n * tableList The search Parameters stores a array of ParameterNode that contains\n * information on user input in the format of columnInfo, value and relation to\n * next ParameterNode.\n * The tableList stores a list of tables that are needed to form the query. It\n * is parsed from the searchParameters.\n *\n * @author Julie Zhu\n *         Modify by Grace: Added String[] sourceCollection, rights and PrimaryArray\n *         Modified by Julie: Added Boolean variable for Hidden;\n */\npublic class ParameterBean {\n\n    private ArrayList searchParameters = null;\n\n    private ArrayList tableList = null;\n\n    private String[] filterArray = null;\n\n    private String[] sourceCollection = null;\n\n    private String[] publicationNames = null;\n\n    private String[] publicationIds = null;\n\n    private String rights = null;\n\n    private String[] primaryArray = null;\n\n    private boolean hidden = false;\n\n    private String[] imaging = null;\n\n    private String[] disease = null;\n\n    /**\n     * Constructor\n     */\n    public ParameterBean() {\n        searchParameters = new ArrayList();\n        tableList = new ArrayList();\n    }\n\n    /**\n     * New constructor\n     */\n    public ParameterBean(String keywordString) {\n        searchParameters = new ArrayList();\n        tableList = new ArrayList();\n        makeParameterBean(keywordString);\n    }\n\n    /**\n     * Accessor method, returns the parameterNode at specified position\n     *\n     * @param position\n     *\n     * @return ParameterNode\n     */\n    public ParameterNode getParameters(int position) {\n        return (ParameterNode) searchParameters.get(position);\n    }\n\n    /**\n     * Accessor method, returns the searchParameter size\n     *\n     * @return int\n     */\n    public int size() {\n        return searchParameters.size();\n    }\n\n    /**\n     * return the filterArray\n     *\n     * @return\n     */\n    public String[] getFilterArray() {\n        return filterArray;\n    }\n\n    /**\n     * return the diseasePrecess array\n     * @return disease\n     */\n    public String[] getDisease() {\n        return disease;\n    }\n\n    /**\n     * return the imaging technique Array\n     * @return imaging\n     */\n    public String[] getImaging() {\n        return imaging;\n    }\n\n    /**\n     * return the Source collection Array\n     *\n     * @return sourceCollection\n     */\n    public String[] getSourceCollection() {\n        return sourceCollection;\n    }\n\n    /**\n     * return the usage rights array\n     *\n     * @return rights\n     */\n    public String getUsageRight() {\n        return rights;\n    }\n\n    /**\n     * return the primary audience Array\n     *\n     * @return primary\n     */\n    public String[] getPrimaryArray() {\n        return primaryArray;\n    }\n\n    /**\n     * Return the value for hidden\n     *\n     * @return\n     */\n    public boolean getHidden() {\n        return hidden;\n    }\n\n    /**\n     * Adds parameterNode into the ArrayList\n     *\n     * @param input\n     */\n    public void addParameters(ParameterNode input) {\n        searchParameters.add(input);\n    }\n\n    /**\n     * Adds filter array into the parameterBean\n     *\n     * @param filter\n     */\n    public void setFilterArray(String[] filter) {\n        filterArray = filter;\n    }\n\n    /**\n     * Adds source collection array into the parameterBean\n     *\n     * @param source\n     */\n    public void setSourceCollection(String[] source) {\n        sourceCollection = source;\n    }\n\n    /**\n     * Adds usage rights array into the parameterBean\n     *\n     * @param rts\n     */\n    public void setUsageRights(String rts) {\n        rights = rts;\n    }\n\n    /**\n     * Adds primary audience array into the parameterBean\n     *\n     * @param primary\n     */\n    public void setPrimaryArray(String[] primary) {\n        primaryArray = primary;\n    }\n\n    /**\n     * Adds imaging technique array into the parameterBean\n     * @param source\n     */\n    public void setImaging(String[] imgs) {\n        imaging = imgs;\n    }\n\n    /**\n     * Adds disease precess array into the parameterBean\n     * @param rts\n     */\n    public void setDisease(String[] dis) {\n        disease = dis;\n    }\n\n    /**\n     * sets the value for hidden\n     *\n     * @param value\n     */\n    public void setHidden(boolean value) {\n        hidden = value;\n    }\n\n    /**\n     * This is a wrapper that calls for functions to parse the table name.\n     * If the tableList is empty, it calls for function to create the tableList,\n     * else it returns the tableList as ArrayList.\n     *\n     * @return ArrayList of tableName\n     */\n    public ArrayList getTableList() {\n        if (tableList.isEmpty()) {\n            makeTableList();\n        }\n        return tableList;\n    }\n\n    /**\n     * Checks if the table name already exists in the tableList. If not, adds the\n     * table name into the tableList.\n     *\n     * @param table\n     *\n     * @return boolean\n     */\n    private boolean tableNotFound(String table) {\n        int temp = tableList.size();\n        int i = 0;\n        boolean notFound = true;\n        while ((i < temp) && (notFound)) {\n            if (((String) tableList.get(i)).compareTo(table) == 0) {\n                notFound = false;\n            } else {\n                i++;\n            }\n        }\n        return notFound;\n    }\n\n    /**\n     * main function to create the tableList. Parses through the searchParameter\n     * one by one and checks for the table name.\n     */\n    private void makeTableList() {\n        int temp = searchParameters.size();\n        for (int i = 0; i < temp; i++) {\n            ParameterNode input = (ParameterNode) searchParameters.get(i);\n            String table = input.getTableName();\n            if (tableNotFound(table)) {\n                tableList.add(input.getTableName());\n            }\n        }\n    }\n\n    public void setPublicationNames(String[] names) {\n        publicationNames = names;\n    }\n\n    public String[] getPublicationNames() {\n        return publicationNames;\n    }\n\n    public void setPublicationIds(String[] publicationIds) {\n        this.publicationIds = publicationIds;\n    }\n\n    public String[] getPublicationIds() {\n        return publicationIds;\n    }\n\n    public ParameterBean makeParameterBean(String keywordString) {\n        ParameterBean param = new ParameterBean();\n        ParameterNode pam = new ParameterNode();\n        String keywords = \"\";\n        boolean stype = false;\n        if (keywordString.equals(\"\")) {\n            keywordString = \"%\";\n            //System.out.print(keywordString);\n        }\n        String relation = \"AND\";\n        //dummy variable\n        String columInfo = \"ALL.ALL\";\n        this.setHidden(false);\n        keywordString = keywordString.trim();\n        //mapping the terms from the interface to the database tablename and columns\n        if (keywordString.length() > 0) {\n            //switch to lower case\n            keywordString = keywordString.toLowerCase();\n            //make ' into two 's so that it does not cause error for database\n            keywordString = keywordString.replaceAll(\"\\'\", \"''\");\n            //System.out.println(keywordString);\n            //make \" separate so that it becomes a token\n            keywordString = keywordString.replaceAll(\"\\\"\", \" \\\" \");\n            StringBuffer buf = new StringBuffer();\n            StringTokenizer tk = new StringTokenizer(keywordString);\n            String key;\n            while (tk.hasMoreTokens()) {\n                key = tk.nextToken();\n                if (//if \" means exact match\n                key.compareTo(\"\\\"\") == 0) {\n                    buf.delete(0, buf.length());\n                    boolean end = false;\n                    while (//attach the string until the ending \" is found\n                    tk.hasMoreTokens() && end == false) {\n                        key = tk.nextToken();\n                        if (key.compareTo(\"\\\"\") == 0) {\n                            end = true;\n                            key = buf.toString();\n                            stype = true;\n                        } else\n                            buf.append(key + \" \");\n                    }\n                    key = buf.toString();\n                    key = key.trim();\n                    if (//if there is ending \", take as exact match\n                    end) {\n                        pam = new ParameterNode(columInfo, key, relation, stype);\n                        this.addParameters(pam);\n                    } else //if there is no ending \", take as default \"and\" and parse the word\n                    {\n                        StringTokenizer token = new StringTokenizer(key);\n                        while (token.hasMoreTokens()) {\n                            key = token.nextToken();\n                            if (key.compareTo(\"or\") == 0) {\n                                relation = \"OR\";\n                            } else if (key.compareTo(\"and\") == 0) {\n                                relation = \"AND\";\n                            } else if (key.compareTo(\"NOT\") == 0) {\n                                relation = \"NOT\";\n                            } else {\n                                pam = new ParameterNode(columInfo, key, relation);\n                                this.addParameters(pam);\n                                relation = \"AND\";\n                            }\n                        }\n                    }\n                } else if (key.compareTo(\"or\") == 0) {\n                    relation = \"OR\";\n                } else if (key.compareTo(\"and\") == 0) {\n                    relation = \"AND\";\n                } else if (key.compareTo(\"not\") == 0) {\n                    relation = \"NOT\";\n                } else //treat as individual keyword and passes it into the parameterbean\n                {\n                    pam = new ParameterNode(columInfo, key, relation);\n                    this.addParameters(pam);\n                    relation = \"AND\";\n                }\n                //end of if else\n            }\n            //end of while\n        }\n        return param;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ParameterBeanTest0.java",
		"test_prompt": "// ParameterBeanTest0.java\npackage org.heal.module.search;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterBean}.\n* It contains ten unit test cases for the {@link ParameterBean#size()} method.\n*/\nclass ParameterBeanTest0 {"
	},
	{
		"original_code": "// ParameterBean.java\npackage org.heal.module.search;\n\nimport java.util.*;\n\n/**\n * This ParameterBean class stores an ArrayList of searchParameters and\n * tableList The search Parameters stores a array of ParameterNode that contains\n * information on user input in the format of columnInfo, value and relation to\n * next ParameterNode.\n * The tableList stores a list of tables that are needed to form the query. It\n * is parsed from the searchParameters.\n *\n * @author Julie Zhu\n *         Modify by Grace: Added String[] sourceCollection, rights and PrimaryArray\n *         Modified by Julie: Added Boolean variable for Hidden;\n */\npublic class ParameterBean {\n\n    private ArrayList searchParameters = null;\n\n    private ArrayList tableList = null;\n\n    private String[] filterArray = null;\n\n    private String[] sourceCollection = null;\n\n    private String[] publicationNames = null;\n\n    private String[] publicationIds = null;\n\n    private String rights = null;\n\n    private String[] primaryArray = null;\n\n    private boolean hidden = false;\n\n    private String[] imaging = null;\n\n    private String[] disease = null;\n\n    /**\n     * Constructor\n     */\n    public ParameterBean() {\n        searchParameters = new ArrayList();\n        tableList = new ArrayList();\n    }\n\n    /**\n     * New constructor\n     */\n    public ParameterBean(String keywordString) {\n        searchParameters = new ArrayList();\n        tableList = new ArrayList();\n        makeParameterBean(keywordString);\n    }\n\n    /**\n     * Accessor method, returns the parameterNode at specified position\n     *\n     * @param position\n     *\n     * @return ParameterNode\n     */\n    public ParameterNode getParameters(int position) {\n        return (ParameterNode) searchParameters.get(position);\n    }\n\n    /**\n     * Accessor method, returns the searchParameter size\n     *\n     * @return int\n     */\n    public int size() {\n        return searchParameters.size();\n    }\n\n    /**\n     * return the filterArray\n     *\n     * @return\n     */\n    public String[] getFilterArray() {\n        return filterArray;\n    }\n\n    /**\n     * return the diseasePrecess array\n     * @return disease\n     */\n    public String[] getDisease() {\n        return disease;\n    }\n\n    /**\n     * return the imaging technique Array\n     * @return imaging\n     */\n    public String[] getImaging() {\n        return imaging;\n    }\n\n    /**\n     * return the Source collection Array\n     *\n     * @return sourceCollection\n     */\n    public String[] getSourceCollection() {\n        return sourceCollection;\n    }\n\n    /**\n     * return the usage rights array\n     *\n     * @return rights\n     */\n    public String getUsageRight() {\n        return rights;\n    }\n\n    /**\n     * return the primary audience Array\n     *\n     * @return primary\n     */\n    public String[] getPrimaryArray() {\n        return primaryArray;\n    }\n\n    /**\n     * Return the value for hidden\n     *\n     * @return\n     */\n    public boolean getHidden() {\n        return hidden;\n    }\n\n    /**\n     * Adds parameterNode into the ArrayList\n     *\n     * @param input\n     */\n    public void addParameters(ParameterNode input) {\n        searchParameters.add(input);\n    }\n\n    /**\n     * Adds filter array into the parameterBean\n     *\n     * @param filter\n     */\n    public void setFilterArray(String[] filter) {\n        filterArray = filter;\n    }\n\n    /**\n     * Adds source collection array into the parameterBean\n     *\n     * @param source\n     */\n    public void setSourceCollection(String[] source) {\n        sourceCollection = source;\n    }\n\n    /**\n     * Adds usage rights array into the parameterBean\n     *\n     * @param rts\n     */\n    public void setUsageRights(String rts) {\n        rights = rts;\n    }\n\n    /**\n     * Adds primary audience array into the parameterBean\n     *\n     * @param primary\n     */\n    public void setPrimaryArray(String[] primary) {\n        primaryArray = primary;\n    }\n\n    /**\n     * Adds imaging technique array into the parameterBean\n     * @param source\n     */\n    public void setImaging(String[] imgs) {\n        imaging = imgs;\n    }\n\n    /**\n     * Adds disease precess array into the parameterBean\n     * @param rts\n     */\n    public void setDisease(String[] dis) {\n        disease = dis;\n    }\n\n    /**\n     * sets the value for hidden\n     *\n     * @param value\n     */\n    public void setHidden(boolean value) {\n        hidden = value;\n    }\n\n    /**\n     * This is a wrapper that calls for functions to parse the table name.\n     * If the tableList is empty, it calls for function to create the tableList,\n     * else it returns the tableList as ArrayList.\n     *\n     * @return ArrayList of tableName\n     */\n    public ArrayList getTableList() {\n        if (tableList.isEmpty()) {\n            makeTableList();\n        }\n        return tableList;\n    }\n\n    /**\n     * Checks if the table name already exists in the tableList. If not, adds the\n     * table name into the tableList.\n     *\n     * @param table\n     *\n     * @return boolean\n     */\n    private boolean tableNotFound(String table) {\n        int temp = tableList.size();\n        int i = 0;\n        boolean notFound = true;\n        while ((i < temp) && (notFound)) {\n            if (((String) tableList.get(i)).compareTo(table) == 0) {\n                notFound = false;\n            } else {\n                i++;\n            }\n        }\n        return notFound;\n    }\n\n    /**\n     * main function to create the tableList. Parses through the searchParameter\n     * one by one and checks for the table name.\n     */\n    private void makeTableList() {\n        int temp = searchParameters.size();\n        for (int i = 0; i < temp; i++) {\n            ParameterNode input = (ParameterNode) searchParameters.get(i);\n            String table = input.getTableName();\n            if (tableNotFound(table)) {\n                tableList.add(input.getTableName());\n            }\n        }\n    }\n\n    public void setPublicationNames(String[] names) {\n        publicationNames = names;\n    }\n\n    public String[] getPublicationNames() {\n        return publicationNames;\n    }\n\n    public void setPublicationIds(String[] publicationIds) {\n        this.publicationIds = publicationIds;\n    }\n\n    public String[] getPublicationIds() {\n        return publicationIds;\n    }\n\n    public ParameterBean makeParameterBean(String keywordString) {\n        ParameterBean param = new ParameterBean();\n        ParameterNode pam = new ParameterNode();\n        String keywords = \"\";\n        boolean stype = false;\n        if (keywordString.equals(\"\")) {\n            keywordString = \"%\";\n            //System.out.print(keywordString);\n        }\n        String relation = \"AND\";\n        //dummy variable\n        String columInfo = \"ALL.ALL\";\n        this.setHidden(false);\n        keywordString = keywordString.trim();\n        //mapping the terms from the interface to the database tablename and columns\n        if (keywordString.length() > 0) {\n            //switch to lower case\n            keywordString = keywordString.toLowerCase();\n            //make ' into two 's so that it does not cause error for database\n            keywordString = keywordString.replaceAll(\"\\'\", \"''\");\n            //System.out.println(keywordString);\n            //make \" separate so that it becomes a token\n            keywordString = keywordString.replaceAll(\"\\\"\", \" \\\" \");\n            StringBuffer buf = new StringBuffer();\n            StringTokenizer tk = new StringTokenizer(keywordString);\n            String key;\n            while (tk.hasMoreTokens()) {\n                key = tk.nextToken();\n                if (//if \" means exact match\n                key.compareTo(\"\\\"\") == 0) {\n                    buf.delete(0, buf.length());\n                    boolean end = false;\n                    while (//attach the string until the ending \" is found\n                    tk.hasMoreTokens() && end == false) {\n                        key = tk.nextToken();\n                        if (key.compareTo(\"\\\"\") == 0) {\n                            end = true;\n                            key = buf.toString();\n                            stype = true;\n                        } else\n                            buf.append(key + \" \");\n                    }\n                    key = buf.toString();\n                    key = key.trim();\n                    if (//if there is ending \", take as exact match\n                    end) {\n                        pam = new ParameterNode(columInfo, key, relation, stype);\n                        this.addParameters(pam);\n                    } else //if there is no ending \", take as default \"and\" and parse the word\n                    {\n                        StringTokenizer token = new StringTokenizer(key);\n                        while (token.hasMoreTokens()) {\n                            key = token.nextToken();\n                            if (key.compareTo(\"or\") == 0) {\n                                relation = \"OR\";\n                            } else if (key.compareTo(\"and\") == 0) {\n                                relation = \"AND\";\n                            } else if (key.compareTo(\"NOT\") == 0) {\n                                relation = \"NOT\";\n                            } else {\n                                pam = new ParameterNode(columInfo, key, relation);\n                                this.addParameters(pam);\n                                relation = \"AND\";\n                            }\n                        }\n                    }\n                } else if (key.compareTo(\"or\") == 0) {\n                    relation = \"OR\";\n                } else if (key.compareTo(\"and\") == 0) {\n                    relation = \"AND\";\n                } else if (key.compareTo(\"not\") == 0) {\n                    relation = \"NOT\";\n                } else //treat as individual keyword and passes it into the parameterbean\n                {\n                    pam = new ParameterNode(columInfo, key, relation);\n                    this.addParameters(pam);\n                    relation = \"AND\";\n                }\n                //end of if else\n            }\n            //end of while\n        }\n        return param;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/search/ParameterBeanTest1.java",
		"test_prompt": "// ParameterBeanTest1.java\npackage org.heal.module.search;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterBean}.\n* It contains ten unit test cases for the {@link ParameterBean#makeParameterBean(String)} method.\n*/\nclass ParameterBeanTest1 {"
	},
	{
		"original_code": "// BasicResumptionToken.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\n\n/**\n * @author Seth Wright\n * This is a default implementation of the OAIResumptionToken\n */\npublic class BasicResumptionToken implements OAIResumptionToken {\n\n    private static String delimiter = \"|\";\n\n    /*\n\t * If your repository uses the default delimiter for some other purpose\n\t * and it may show up in say, the metadataPrefix, or some other field\n\t * used to generate the content string, you may wish to change the delimiter.\n\t */\n    public static void setDelimiter(String newDelimiter) {\n        delimiter = newDelimiter;\n    }\n\n    public static BasicResumptionToken parseResumptionToken(final String token, final OAIGranularity granularity) {\n        if (token == null)\n            return null;\n        StringTokenizer tokenizer = new StringTokenizer(token, delimiter);\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        long cursor;\n        try {\n            cursor = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String from = tokenizer.nextToken();\n        Date fromDate = null;\n        if (!\"null\".equals(from)) {\n            try {\n                fromDate = granularity.parse(from);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String until = tokenizer.nextToken();\n        Date untilDate = null;\n        if (!\"null\".equals(until)) {\n            try {\n                untilDate = granularity.parse(until);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String set = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String nextID = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String expires = tokenizer.nextToken();\n        Date expirationDate = null;\n        if (!\"null\".equals(expires)) {\n            try {\n                //expiration dates are in the full 8601 format (spec says so)\n                expirationDate = OAIGranularity.yearMonthDayHourMinuteSecond.parse(expires);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        long listSize;\n        try {\n            listSize = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String metadataPrefix = tokenizer.nextToken();\n        if (\"null\".equals(metadataPrefix)) {\n            metadataPrefix = null;\n        }\n        if (tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        return new BasicResumptionToken(metadataPrefix, fromDate, untilDate, set, nextID, expirationDate, listSize, cursor, granularity);\n    }\n\n    //generates a resumption token to denote the end of a query that was resumed from a resumption token\n    public static BasicResumptionToken generateQueryCompleteToken() {\n        return new BasicResumptionToken();\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final OAIGranularity repositoryGranularity) {\n        return generateResumptionToken(metadataPrefix, from, until, set, nextID, null, 0, -1, repositoryGranularity);\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        return new BasicResumptionToken(metadataPrefix, from, until, set, nextID, expirationDate, listSize, cursor, repositoryGranularity);\n    }\n\n    private long listSize = 0;\n\n    private long cursor = -1;\n\n    private Date expirationDate = null;\n\n    private String content = null;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    //this doesn't have to be the same as the cursor, but can be.\n    private String nextID = null;\n\n    private boolean completedQuery = false;\n\n    private OAIGranularity granularity = null;\n\n    private BasicResumptionToken() {\n        this.completedQuery = true;\n    }\n\n    private BasicResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        //this doesn't have to be the same as the cursor, but can be.\n        this.nextID = nextID;\n        this.expirationDate = expirationDate;\n        this.listSize = listSize;\n        this.cursor = cursor;\n        this.content = null;\n        this.completedQuery = false;\n        this.granularity = repositoryGranularity;\n    }\n\n    public String getMetadataPrefix() {\n        return metadataPrefix;\n    }\n\n    public Date getFrom() {\n        return from;\n    }\n\n    public Date getUntil() {\n        return until;\n    }\n\n    public String getSet() {\n        return set;\n    }\n\n    public String getNextID() {\n        return nextID;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getContent()\n\t */\n    public String getContent() {\n        if (content == null) {\n            content = generateContentString();\n        }\n        return content;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getExpirationDate()\n\t */\n    public Date getExpirationDate() {\n        return expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCompleteListSize()\n\t */\n    public long getCompleteListSize() {\n        return listSize;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCursor()\n\t */\n    public long getCursor() {\n        return cursor;\n    }\n\n    public void setCursor(long cursor) {\n        this.cursor = cursor;\n    }\n\n    public void setExpirationDate(final Date expirationDate) {\n        this.expirationDate = expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#queryCompleted()\n\t */\n    public boolean queryCompleted() {\n        return completedQuery;\n    }\n\n    private String generateContentString() {\n        StringBuffer contentBuff = new StringBuffer();\n        contentBuff.append(cursor);\n        contentBuff.append(delimiter);\n        if (from != null) {\n            contentBuff.append(granularity.format(from));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (until != null) {\n            contentBuff.append(granularity.format(until));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (set != null) {\n            contentBuff.append(set);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (nextID != null) {\n            contentBuff.append(nextID);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (expirationDate != null) {\n            contentBuff.append(granularity.format(expirationDate));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        contentBuff.append(listSize);\n        contentBuff.append(delimiter);\n        if (metadataPrefix != null) {\n            contentBuff.append(metadataPrefix);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        return contentBuff.toString();\n    }\n\n    public String toString() {\n        StringBuffer retval = new StringBuffer();\n        retval.append(\"[metadataPrefix=\");\n        retval.append(metadataPrefix);\n        retval.append(\"] [from=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(from));\n        retval.append(\"] [until=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(until));\n        retval.append(\"] [set=\");\n        retval.append(set);\n        retval.append(\"] [nextID=\");\n        retval.append(nextID);\n        retval.append(\"] [content=\");\n        if (content != null) {\n            retval.append(content);\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [expirationDate=\");\n        if (expirationDate != null) {\n            //expirationdates are in the full 8601 format\n            retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(expirationDate));\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [listSize=\");\n        retval.append(listSize);\n        retval.append(\"] [cursor=\");\n        retval.append(cursor);\n        retval.append(\"]\");\n        return retval.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/basic/BasicResumptionTokenTest0.java",
		"test_prompt": "// BasicResumptionTokenTest0.java\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicResumptionToken}.\n* It contains ten unit test cases for the {@link BasicResumptionToken#parseResumptionToken(String, OAIGranularity)} method.\n*/\nclass BasicResumptionTokenTest0 {"
	},
	{
		"original_code": "// BasicResumptionToken.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\n\n/**\n * @author Seth Wright\n * This is a default implementation of the OAIResumptionToken\n */\npublic class BasicResumptionToken implements OAIResumptionToken {\n\n    private static String delimiter = \"|\";\n\n    /*\n\t * If your repository uses the default delimiter for some other purpose\n\t * and it may show up in say, the metadataPrefix, or some other field\n\t * used to generate the content string, you may wish to change the delimiter.\n\t */\n    public static void setDelimiter(String newDelimiter) {\n        delimiter = newDelimiter;\n    }\n\n    public static BasicResumptionToken parseResumptionToken(final String token, final OAIGranularity granularity) {\n        if (token == null)\n            return null;\n        StringTokenizer tokenizer = new StringTokenizer(token, delimiter);\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        long cursor;\n        try {\n            cursor = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String from = tokenizer.nextToken();\n        Date fromDate = null;\n        if (!\"null\".equals(from)) {\n            try {\n                fromDate = granularity.parse(from);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String until = tokenizer.nextToken();\n        Date untilDate = null;\n        if (!\"null\".equals(until)) {\n            try {\n                untilDate = granularity.parse(until);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String set = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String nextID = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String expires = tokenizer.nextToken();\n        Date expirationDate = null;\n        if (!\"null\".equals(expires)) {\n            try {\n                //expiration dates are in the full 8601 format (spec says so)\n                expirationDate = OAIGranularity.yearMonthDayHourMinuteSecond.parse(expires);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        long listSize;\n        try {\n            listSize = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String metadataPrefix = tokenizer.nextToken();\n        if (\"null\".equals(metadataPrefix)) {\n            metadataPrefix = null;\n        }\n        if (tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        return new BasicResumptionToken(metadataPrefix, fromDate, untilDate, set, nextID, expirationDate, listSize, cursor, granularity);\n    }\n\n    //generates a resumption token to denote the end of a query that was resumed from a resumption token\n    public static BasicResumptionToken generateQueryCompleteToken() {\n        return new BasicResumptionToken();\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final OAIGranularity repositoryGranularity) {\n        return generateResumptionToken(metadataPrefix, from, until, set, nextID, null, 0, -1, repositoryGranularity);\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        return new BasicResumptionToken(metadataPrefix, from, until, set, nextID, expirationDate, listSize, cursor, repositoryGranularity);\n    }\n\n    private long listSize = 0;\n\n    private long cursor = -1;\n\n    private Date expirationDate = null;\n\n    private String content = null;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    //this doesn't have to be the same as the cursor, but can be.\n    private String nextID = null;\n\n    private boolean completedQuery = false;\n\n    private OAIGranularity granularity = null;\n\n    private BasicResumptionToken() {\n        this.completedQuery = true;\n    }\n\n    private BasicResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        //this doesn't have to be the same as the cursor, but can be.\n        this.nextID = nextID;\n        this.expirationDate = expirationDate;\n        this.listSize = listSize;\n        this.cursor = cursor;\n        this.content = null;\n        this.completedQuery = false;\n        this.granularity = repositoryGranularity;\n    }\n\n    public String getMetadataPrefix() {\n        return metadataPrefix;\n    }\n\n    public Date getFrom() {\n        return from;\n    }\n\n    public Date getUntil() {\n        return until;\n    }\n\n    public String getSet() {\n        return set;\n    }\n\n    public String getNextID() {\n        return nextID;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getContent()\n\t */\n    public String getContent() {\n        if (content == null) {\n            content = generateContentString();\n        }\n        return content;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getExpirationDate()\n\t */\n    public Date getExpirationDate() {\n        return expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCompleteListSize()\n\t */\n    public long getCompleteListSize() {\n        return listSize;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCursor()\n\t */\n    public long getCursor() {\n        return cursor;\n    }\n\n    public void setCursor(long cursor) {\n        this.cursor = cursor;\n    }\n\n    public void setExpirationDate(final Date expirationDate) {\n        this.expirationDate = expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#queryCompleted()\n\t */\n    public boolean queryCompleted() {\n        return completedQuery;\n    }\n\n    private String generateContentString() {\n        StringBuffer contentBuff = new StringBuffer();\n        contentBuff.append(cursor);\n        contentBuff.append(delimiter);\n        if (from != null) {\n            contentBuff.append(granularity.format(from));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (until != null) {\n            contentBuff.append(granularity.format(until));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (set != null) {\n            contentBuff.append(set);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (nextID != null) {\n            contentBuff.append(nextID);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (expirationDate != null) {\n            contentBuff.append(granularity.format(expirationDate));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        contentBuff.append(listSize);\n        contentBuff.append(delimiter);\n        if (metadataPrefix != null) {\n            contentBuff.append(metadataPrefix);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        return contentBuff.toString();\n    }\n\n    public String toString() {\n        StringBuffer retval = new StringBuffer();\n        retval.append(\"[metadataPrefix=\");\n        retval.append(metadataPrefix);\n        retval.append(\"] [from=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(from));\n        retval.append(\"] [until=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(until));\n        retval.append(\"] [set=\");\n        retval.append(set);\n        retval.append(\"] [nextID=\");\n        retval.append(nextID);\n        retval.append(\"] [content=\");\n        if (content != null) {\n            retval.append(content);\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [expirationDate=\");\n        if (expirationDate != null) {\n            //expirationdates are in the full 8601 format\n            retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(expirationDate));\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [listSize=\");\n        retval.append(listSize);\n        retval.append(\"] [cursor=\");\n        retval.append(cursor);\n        retval.append(\"]\");\n        return retval.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/basic/BasicResumptionTokenTest1.java",
		"test_prompt": "// BasicResumptionTokenTest1.java\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicResumptionToken}.\n* It contains ten unit test cases for the {@link BasicResumptionToken#generateQueryCompleteToken()} method.\n*/\nclass BasicResumptionTokenTest1 {"
	},
	{
		"original_code": "// BasicResumptionToken.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\n\n/**\n * @author Seth Wright\n * This is a default implementation of the OAIResumptionToken\n */\npublic class BasicResumptionToken implements OAIResumptionToken {\n\n    private static String delimiter = \"|\";\n\n    /*\n\t * If your repository uses the default delimiter for some other purpose\n\t * and it may show up in say, the metadataPrefix, or some other field\n\t * used to generate the content string, you may wish to change the delimiter.\n\t */\n    public static void setDelimiter(String newDelimiter) {\n        delimiter = newDelimiter;\n    }\n\n    public static BasicResumptionToken parseResumptionToken(final String token, final OAIGranularity granularity) {\n        if (token == null)\n            return null;\n        StringTokenizer tokenizer = new StringTokenizer(token, delimiter);\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        long cursor;\n        try {\n            cursor = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String from = tokenizer.nextToken();\n        Date fromDate = null;\n        if (!\"null\".equals(from)) {\n            try {\n                fromDate = granularity.parse(from);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String until = tokenizer.nextToken();\n        Date untilDate = null;\n        if (!\"null\".equals(until)) {\n            try {\n                untilDate = granularity.parse(until);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String set = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String nextID = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String expires = tokenizer.nextToken();\n        Date expirationDate = null;\n        if (!\"null\".equals(expires)) {\n            try {\n                //expiration dates are in the full 8601 format (spec says so)\n                expirationDate = OAIGranularity.yearMonthDayHourMinuteSecond.parse(expires);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        long listSize;\n        try {\n            listSize = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String metadataPrefix = tokenizer.nextToken();\n        if (\"null\".equals(metadataPrefix)) {\n            metadataPrefix = null;\n        }\n        if (tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        return new BasicResumptionToken(metadataPrefix, fromDate, untilDate, set, nextID, expirationDate, listSize, cursor, granularity);\n    }\n\n    //generates a resumption token to denote the end of a query that was resumed from a resumption token\n    public static BasicResumptionToken generateQueryCompleteToken() {\n        return new BasicResumptionToken();\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final OAIGranularity repositoryGranularity) {\n        return generateResumptionToken(metadataPrefix, from, until, set, nextID, null, 0, -1, repositoryGranularity);\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        return new BasicResumptionToken(metadataPrefix, from, until, set, nextID, expirationDate, listSize, cursor, repositoryGranularity);\n    }\n\n    private long listSize = 0;\n\n    private long cursor = -1;\n\n    private Date expirationDate = null;\n\n    private String content = null;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    //this doesn't have to be the same as the cursor, but can be.\n    private String nextID = null;\n\n    private boolean completedQuery = false;\n\n    private OAIGranularity granularity = null;\n\n    private BasicResumptionToken() {\n        this.completedQuery = true;\n    }\n\n    private BasicResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        //this doesn't have to be the same as the cursor, but can be.\n        this.nextID = nextID;\n        this.expirationDate = expirationDate;\n        this.listSize = listSize;\n        this.cursor = cursor;\n        this.content = null;\n        this.completedQuery = false;\n        this.granularity = repositoryGranularity;\n    }\n\n    public String getMetadataPrefix() {\n        return metadataPrefix;\n    }\n\n    public Date getFrom() {\n        return from;\n    }\n\n    public Date getUntil() {\n        return until;\n    }\n\n    public String getSet() {\n        return set;\n    }\n\n    public String getNextID() {\n        return nextID;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getContent()\n\t */\n    public String getContent() {\n        if (content == null) {\n            content = generateContentString();\n        }\n        return content;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getExpirationDate()\n\t */\n    public Date getExpirationDate() {\n        return expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCompleteListSize()\n\t */\n    public long getCompleteListSize() {\n        return listSize;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCursor()\n\t */\n    public long getCursor() {\n        return cursor;\n    }\n\n    public void setCursor(long cursor) {\n        this.cursor = cursor;\n    }\n\n    public void setExpirationDate(final Date expirationDate) {\n        this.expirationDate = expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#queryCompleted()\n\t */\n    public boolean queryCompleted() {\n        return completedQuery;\n    }\n\n    private String generateContentString() {\n        StringBuffer contentBuff = new StringBuffer();\n        contentBuff.append(cursor);\n        contentBuff.append(delimiter);\n        if (from != null) {\n            contentBuff.append(granularity.format(from));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (until != null) {\n            contentBuff.append(granularity.format(until));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (set != null) {\n            contentBuff.append(set);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (nextID != null) {\n            contentBuff.append(nextID);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (expirationDate != null) {\n            contentBuff.append(granularity.format(expirationDate));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        contentBuff.append(listSize);\n        contentBuff.append(delimiter);\n        if (metadataPrefix != null) {\n            contentBuff.append(metadataPrefix);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        return contentBuff.toString();\n    }\n\n    public String toString() {\n        StringBuffer retval = new StringBuffer();\n        retval.append(\"[metadataPrefix=\");\n        retval.append(metadataPrefix);\n        retval.append(\"] [from=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(from));\n        retval.append(\"] [until=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(until));\n        retval.append(\"] [set=\");\n        retval.append(set);\n        retval.append(\"] [nextID=\");\n        retval.append(nextID);\n        retval.append(\"] [content=\");\n        if (content != null) {\n            retval.append(content);\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [expirationDate=\");\n        if (expirationDate != null) {\n            //expirationdates are in the full 8601 format\n            retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(expirationDate));\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [listSize=\");\n        retval.append(listSize);\n        retval.append(\"] [cursor=\");\n        retval.append(cursor);\n        retval.append(\"]\");\n        return retval.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/basic/BasicResumptionTokenTest2.java",
		"test_prompt": "// BasicResumptionTokenTest2.java\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicResumptionToken}.\n* It contains ten unit test cases for the {@link BasicResumptionToken#generateResumptionToken(String, Date, Date, String, String, OAIGranularity)} method.\n*/\nclass BasicResumptionTokenTest2 {"
	},
	{
		"original_code": "// BasicResumptionToken.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\n\n/**\n * @author Seth Wright\n * This is a default implementation of the OAIResumptionToken\n */\npublic class BasicResumptionToken implements OAIResumptionToken {\n\n    private static String delimiter = \"|\";\n\n    /*\n\t * If your repository uses the default delimiter for some other purpose\n\t * and it may show up in say, the metadataPrefix, or some other field\n\t * used to generate the content string, you may wish to change the delimiter.\n\t */\n    public static void setDelimiter(String newDelimiter) {\n        delimiter = newDelimiter;\n    }\n\n    public static BasicResumptionToken parseResumptionToken(final String token, final OAIGranularity granularity) {\n        if (token == null)\n            return null;\n        StringTokenizer tokenizer = new StringTokenizer(token, delimiter);\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        long cursor;\n        try {\n            cursor = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String from = tokenizer.nextToken();\n        Date fromDate = null;\n        if (!\"null\".equals(from)) {\n            try {\n                fromDate = granularity.parse(from);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String until = tokenizer.nextToken();\n        Date untilDate = null;\n        if (!\"null\".equals(until)) {\n            try {\n                untilDate = granularity.parse(until);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String set = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String nextID = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String expires = tokenizer.nextToken();\n        Date expirationDate = null;\n        if (!\"null\".equals(expires)) {\n            try {\n                //expiration dates are in the full 8601 format (spec says so)\n                expirationDate = OAIGranularity.yearMonthDayHourMinuteSecond.parse(expires);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        long listSize;\n        try {\n            listSize = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String metadataPrefix = tokenizer.nextToken();\n        if (\"null\".equals(metadataPrefix)) {\n            metadataPrefix = null;\n        }\n        if (tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        return new BasicResumptionToken(metadataPrefix, fromDate, untilDate, set, nextID, expirationDate, listSize, cursor, granularity);\n    }\n\n    //generates a resumption token to denote the end of a query that was resumed from a resumption token\n    public static BasicResumptionToken generateQueryCompleteToken() {\n        return new BasicResumptionToken();\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final OAIGranularity repositoryGranularity) {\n        return generateResumptionToken(metadataPrefix, from, until, set, nextID, null, 0, -1, repositoryGranularity);\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        return new BasicResumptionToken(metadataPrefix, from, until, set, nextID, expirationDate, listSize, cursor, repositoryGranularity);\n    }\n\n    private long listSize = 0;\n\n    private long cursor = -1;\n\n    private Date expirationDate = null;\n\n    private String content = null;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    //this doesn't have to be the same as the cursor, but can be.\n    private String nextID = null;\n\n    private boolean completedQuery = false;\n\n    private OAIGranularity granularity = null;\n\n    private BasicResumptionToken() {\n        this.completedQuery = true;\n    }\n\n    private BasicResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        //this doesn't have to be the same as the cursor, but can be.\n        this.nextID = nextID;\n        this.expirationDate = expirationDate;\n        this.listSize = listSize;\n        this.cursor = cursor;\n        this.content = null;\n        this.completedQuery = false;\n        this.granularity = repositoryGranularity;\n    }\n\n    public String getMetadataPrefix() {\n        return metadataPrefix;\n    }\n\n    public Date getFrom() {\n        return from;\n    }\n\n    public Date getUntil() {\n        return until;\n    }\n\n    public String getSet() {\n        return set;\n    }\n\n    public String getNextID() {\n        return nextID;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getContent()\n\t */\n    public String getContent() {\n        if (content == null) {\n            content = generateContentString();\n        }\n        return content;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getExpirationDate()\n\t */\n    public Date getExpirationDate() {\n        return expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCompleteListSize()\n\t */\n    public long getCompleteListSize() {\n        return listSize;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCursor()\n\t */\n    public long getCursor() {\n        return cursor;\n    }\n\n    public void setCursor(long cursor) {\n        this.cursor = cursor;\n    }\n\n    public void setExpirationDate(final Date expirationDate) {\n        this.expirationDate = expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#queryCompleted()\n\t */\n    public boolean queryCompleted() {\n        return completedQuery;\n    }\n\n    private String generateContentString() {\n        StringBuffer contentBuff = new StringBuffer();\n        contentBuff.append(cursor);\n        contentBuff.append(delimiter);\n        if (from != null) {\n            contentBuff.append(granularity.format(from));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (until != null) {\n            contentBuff.append(granularity.format(until));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (set != null) {\n            contentBuff.append(set);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (nextID != null) {\n            contentBuff.append(nextID);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (expirationDate != null) {\n            contentBuff.append(granularity.format(expirationDate));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        contentBuff.append(listSize);\n        contentBuff.append(delimiter);\n        if (metadataPrefix != null) {\n            contentBuff.append(metadataPrefix);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        return contentBuff.toString();\n    }\n\n    public String toString() {\n        StringBuffer retval = new StringBuffer();\n        retval.append(\"[metadataPrefix=\");\n        retval.append(metadataPrefix);\n        retval.append(\"] [from=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(from));\n        retval.append(\"] [until=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(until));\n        retval.append(\"] [set=\");\n        retval.append(set);\n        retval.append(\"] [nextID=\");\n        retval.append(nextID);\n        retval.append(\"] [content=\");\n        if (content != null) {\n            retval.append(content);\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [expirationDate=\");\n        if (expirationDate != null) {\n            //expirationdates are in the full 8601 format\n            retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(expirationDate));\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [listSize=\");\n        retval.append(listSize);\n        retval.append(\"] [cursor=\");\n        retval.append(cursor);\n        retval.append(\"]\");\n        return retval.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/basic/BasicResumptionTokenTest3.java",
		"test_prompt": "// BasicResumptionTokenTest3.java\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicResumptionToken}.\n* It contains ten unit test cases for the {@link BasicResumptionToken#generateResumptionToken(String, Date, Date, String, String, Date, long, long, OAIGranularity)} method.\n*/\nclass BasicResumptionTokenTest3 {"
	},
	{
		"original_code": "// BasicResumptionToken.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\n\n/**\n * @author Seth Wright\n * This is a default implementation of the OAIResumptionToken\n */\npublic class BasicResumptionToken implements OAIResumptionToken {\n\n    private static String delimiter = \"|\";\n\n    /*\n\t * If your repository uses the default delimiter for some other purpose\n\t * and it may show up in say, the metadataPrefix, or some other field\n\t * used to generate the content string, you may wish to change the delimiter.\n\t */\n    public static void setDelimiter(String newDelimiter) {\n        delimiter = newDelimiter;\n    }\n\n    public static BasicResumptionToken parseResumptionToken(final String token, final OAIGranularity granularity) {\n        if (token == null)\n            return null;\n        StringTokenizer tokenizer = new StringTokenizer(token, delimiter);\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        long cursor;\n        try {\n            cursor = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String from = tokenizer.nextToken();\n        Date fromDate = null;\n        if (!\"null\".equals(from)) {\n            try {\n                fromDate = granularity.parse(from);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String until = tokenizer.nextToken();\n        Date untilDate = null;\n        if (!\"null\".equals(until)) {\n            try {\n                untilDate = granularity.parse(until);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String set = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token\n            return null;\n        }\n        String nextID = tokenizer.nextToken();\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String expires = tokenizer.nextToken();\n        Date expirationDate = null;\n        if (!\"null\".equals(expires)) {\n            try {\n                //expiration dates are in the full 8601 format (spec says so)\n                expirationDate = OAIGranularity.yearMonthDayHourMinuteSecond.parse(expires);\n            } catch (ParseException ex) {\n                return null;\n            }\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        long listSize;\n        try {\n            listSize = Long.parseLong(tokenizer.nextToken());\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n        if (!tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        String metadataPrefix = tokenizer.nextToken();\n        if (\"null\".equals(metadataPrefix)) {\n            metadataPrefix = null;\n        }\n        if (tokenizer.hasMoreTokens()) {\n            //ACK! invalid token, we have too many elements\n            return null;\n        }\n        return new BasicResumptionToken(metadataPrefix, fromDate, untilDate, set, nextID, expirationDate, listSize, cursor, granularity);\n    }\n\n    //generates a resumption token to denote the end of a query that was resumed from a resumption token\n    public static BasicResumptionToken generateQueryCompleteToken() {\n        return new BasicResumptionToken();\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final OAIGranularity repositoryGranularity) {\n        return generateResumptionToken(metadataPrefix, from, until, set, nextID, null, 0, -1, repositoryGranularity);\n    }\n\n    public static BasicResumptionToken generateResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        return new BasicResumptionToken(metadataPrefix, from, until, set, nextID, expirationDate, listSize, cursor, repositoryGranularity);\n    }\n\n    private long listSize = 0;\n\n    private long cursor = -1;\n\n    private Date expirationDate = null;\n\n    private String content = null;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    //this doesn't have to be the same as the cursor, but can be.\n    private String nextID = null;\n\n    private boolean completedQuery = false;\n\n    private OAIGranularity granularity = null;\n\n    private BasicResumptionToken() {\n        this.completedQuery = true;\n    }\n\n    private BasicResumptionToken(final String metadataPrefix, final Date from, final Date until, final String set, final String nextID, final Date expirationDate, final long listSize, final long cursor, final OAIGranularity repositoryGranularity) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        //this doesn't have to be the same as the cursor, but can be.\n        this.nextID = nextID;\n        this.expirationDate = expirationDate;\n        this.listSize = listSize;\n        this.cursor = cursor;\n        this.content = null;\n        this.completedQuery = false;\n        this.granularity = repositoryGranularity;\n    }\n\n    public String getMetadataPrefix() {\n        return metadataPrefix;\n    }\n\n    public Date getFrom() {\n        return from;\n    }\n\n    public Date getUntil() {\n        return until;\n    }\n\n    public String getSet() {\n        return set;\n    }\n\n    public String getNextID() {\n        return nextID;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getContent()\n\t */\n    public String getContent() {\n        if (content == null) {\n            content = generateContentString();\n        }\n        return content;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getExpirationDate()\n\t */\n    public Date getExpirationDate() {\n        return expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCompleteListSize()\n\t */\n    public long getCompleteListSize() {\n        return listSize;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#getCursor()\n\t */\n    public long getCursor() {\n        return cursor;\n    }\n\n    public void setCursor(long cursor) {\n        this.cursor = cursor;\n    }\n\n    public void setExpirationDate(final Date expirationDate) {\n        this.expirationDate = expirationDate;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIResumptionToken#queryCompleted()\n\t */\n    public boolean queryCompleted() {\n        return completedQuery;\n    }\n\n    private String generateContentString() {\n        StringBuffer contentBuff = new StringBuffer();\n        contentBuff.append(cursor);\n        contentBuff.append(delimiter);\n        if (from != null) {\n            contentBuff.append(granularity.format(from));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (until != null) {\n            contentBuff.append(granularity.format(until));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (set != null) {\n            contentBuff.append(set);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (nextID != null) {\n            contentBuff.append(nextID);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        if (expirationDate != null) {\n            contentBuff.append(granularity.format(expirationDate));\n        } else {\n            contentBuff.append(\"null\");\n        }\n        contentBuff.append(delimiter);\n        contentBuff.append(listSize);\n        contentBuff.append(delimiter);\n        if (metadataPrefix != null) {\n            contentBuff.append(metadataPrefix);\n        } else {\n            contentBuff.append(\"null\");\n        }\n        return contentBuff.toString();\n    }\n\n    public String toString() {\n        StringBuffer retval = new StringBuffer();\n        retval.append(\"[metadataPrefix=\");\n        retval.append(metadataPrefix);\n        retval.append(\"] [from=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(from));\n        retval.append(\"] [until=\");\n        retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(until));\n        retval.append(\"] [set=\");\n        retval.append(set);\n        retval.append(\"] [nextID=\");\n        retval.append(nextID);\n        retval.append(\"] [content=\");\n        if (content != null) {\n            retval.append(content);\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [expirationDate=\");\n        if (expirationDate != null) {\n            //expirationdates are in the full 8601 format\n            retval.append(OAIGranularity.yearMonthDayHourMinuteSecond.format(expirationDate));\n        } else {\n            retval.append(\"null\");\n        }\n        retval.append(\"] [listSize=\");\n        retval.append(listSize);\n        retval.append(\"] [cursor=\");\n        retval.append(cursor);\n        retval.append(\"]\");\n        return retval.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/basic/BasicResumptionTokenTest4.java",
		"test_prompt": "// BasicResumptionTokenTest4.java\npackage org.heal.module.oai.provider.basic;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.StringTokenizer;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicResumptionToken}.\n* It contains ten unit test cases for the {@link BasicResumptionToken#queryCompleted()} method.\n*/\nclass BasicResumptionTokenTest4 {"
	},
	{
		"original_code": "// OAIProvider.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.provider;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Map;\nimport org.heal.module.oai.provider.verb.OAIVerb;\n\n/**\n * @author Seth Wright\n */\npublic class OAIProvider {\n\n    public static final boolean debug = false;\n\n    private static OAIProviderConfig config = null;\n\n    public static void init(final OAIProviderConfig config) {\n        OAIProvider.config = config;\n    }\n\n    //NOTE: the parameters Map contains String arrays (String[])\n    //This is required because we have to detect duplicate parameters and\n    //give a badArgument error\n    public static void processRequest(final String requestURL, final DataAccessor dataAccessor, final Map parameters, final PrintWriter out) throws IOException {\n        out.println(\"<?xml version='1.0' encoding='UTF-8'?>\");\n        out.print(\"<OAI-PMH xmlns=\\\"http://www.openarchives.org/OAI/2.0/\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \");\n        out.println(\"xsi:schemaLocation=\\\"http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd\\\">\");\n        //these should be ordered by which is most likely to occur\n        ValidatedInput input = validateInput(dataAccessor, parameters, out);\n        writeOAIResponseHeader(input, parameters, dataAccessor, requestURL, out);\n        if (input.errorList.size() == 0) {\n            input.verb.execute(input, config, dataAccessor, out);\n            dataAccessor.closeQuery();\n        } else {\n            Iterator iter = input.errorList.iterator();\n            while (iter.hasNext()) {\n                out.println((String) iter.next());\n            }\n        }\n        out.println(\"</OAI-PMH>\");\n    }\n\n    private static void writeOAIResponseHeader(final ValidatedInput input, final Map parameters, final DataAccessor accessor, final String requestURL, final PrintWriter writer) {\n        //get nowUTC from the database because that's the relevant time.\n        Date responseDate = accessor.getNow();\n        String now = OAIGranularity.yearMonthDayHourMinuteSecond.format(responseDate);\n        writer.print(\"<responseDate>\");\n        writer.print(now);\n        writer.println(\"</responseDate>\");\n        writer.print(\"<request\");\n        if (input.verb != null) {\n            writer.print(\" verb=\\\"\");\n            writer.print(input.verb.getName());\n            writer.print(\"\\\"\");\n        }\n        if (input.identifier != null) {\n            writer.print(\" identifier=\\\"\");\n            writer.print(input.identifier);\n            writer.print(\"\\\"\");\n        }\n        if (input.format != null) {\n            writer.print(\" metadataPrefix=\\\"\");\n            writer.print(input.format.getPrefix());\n            writer.print(\"\\\"\");\n        }\n        if (input.from != null) {\n            writer.print(\" from=\\\"\");\n            writer.print(((String[]) parameters.get(\"from\"))[0]);\n            writer.print(\"\\\"\");\n        }\n        if (input.until != null) {\n            writer.print(\" until=\\\"\");\n            writer.print(((String[]) parameters.get(\"until\"))[0]);\n            writer.print(\"\\\"\");\n        }\n        if (input.resumptionToken != null) {\n            writer.print(\" resumptionToken=\\\"\");\n            writer.print(((String[]) parameters.get(\"resumptionToken\"))[0]);\n            writer.print(\"\\\"\");\n        }\n        if (input.set != null) {\n            writer.print(\" set=\\\"\");\n            writer.print(((String[]) parameters.get(\"set\"))[0]);\n            writer.print(\"\\\"\");\n        }\n        writer.print(\">\");\n        writer.print(requestURL);\n        writer.println(\"</request>\");\n    }\n\n    public static void writeString(final String tagName, final String value, final PrintWriter writer) {\n        writer.print(\"<\" + tagName + \">\");\n        writer.print(value);\n        writer.println(\"</\" + tagName + \">\");\n    }\n\n    public static void writeStrings(final String[] strings, final String tagName, final PrintWriter writer) {\n        if (strings == null)\n            return;\n        for (int i = 0; i < strings.length; i++) {\n            writeString(tagName, strings[i], writer);\n        }\n    }\n\n    public static String getErrorString(final OAIErrorCode code, final String description) {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"<error code=\\\"\");\n        buf.append(code.getName());\n        buf.append(\"\\\">\");\n        if (description != null) {\n            buf.append(description);\n        }\n        buf.append(\"</error>\");\n        return buf.toString();\n    }\n\n    public static void writeResumptionToken(final OAIResumptionToken token, final PrintWriter writer) {\n        if (token == null) {\n            writer.println(\"<resumptionToken></resumptionToken>\");\n            return;\n        }\n        long size = token.getCompleteListSize();\n        long cursor = token.getCursor();\n        boolean queryCompleted = token.queryCompleted();\n        writer.print(\"<resumptionToken\");\n        if (!queryCompleted) {\n            Date expirationDate = token.getExpirationDate();\n            if (expirationDate != null) {\n                writer.print(\" expirationDate=\\\"\" + OAIGranularity.yearMonthDayHourMinuteSecond.format(expirationDate) + \"\\\"\");\n            }\n        }\n        if (size > 0) {\n            writer.print(\" completeListSize=\\\"\" + size + \"\\\"\");\n        }\n        if (cursor >= 0) {\n            writer.print(\" cursor=\\\"\" + cursor + \"\\\"\");\n        }\n        if (queryCompleted) {\n            writer.println(\"/>\");\n        } else {\n            writer.print(\">\");\n            writer.print(token.getContent());\n            writer.println(\"</resumptionToken>\");\n        }\n    }\n\n    public static void writeRecord(final OAIRecord record, final OAIMetadataHandler handler, PrintWriter writer) throws IOException {\n        writer.println(\"<record>\");\n        writeRecordHeader(record, writer);\n        if (!record.isDeleted()) {\n            OAIRecordAdapter adapter = record.getRecordAdapter(handler.getFormat());\n            //if the record was deleted, only the header is returned because there is no record\n            //(if there was a record, it wouldn't have been deleted, would it?\n            writer.print(\"<metadata>\");\n            handler.writeMetadata(adapter, writer);\n            writer.println(\"</metadata>\");\n            if (adapter.hasOAIAbout() || adapter.hasCustomAbout()) {\n                writer.print(\"<about>\");\n                if (adapter.hasOAIAbout()) {\n                    handler.writeOAIAbout(adapter, writer);\n                }\n                if (adapter.hasCustomAbout()) {\n                    handler.writeCustomAbout(adapter, writer);\n                }\n                writer.println(\"</about>\");\n            }\n        }\n        writer.println(\"</record>\");\n    }\n\n    public static void writeRecordHeader(final OAIRecord record, final PrintWriter writer) {\n        if (record.isDeleted()) {\n            writer.println(\"<header status=\\\"deleted\\\">\");\n        } else {\n            writer.println(\"<header>\");\n        }\n        writer.print(\"<identifier>\");\n        writer.print(record.getOAIIdentifier());\n        writer.println(\"</identifier>\");\n        writer.print(\"<datestamp>\");\n        writer.print(OAIGranularity.yearMonthDayHourMinuteSecond.format(record.getDateStamp()));\n        writer.println(\"</datestamp>\");\n        OAISet[] sets = record.getSets();\n        if (sets != null && sets.length > 0) {\n            for (int i = 0; i < sets.length; i++) {\n                writer.print(\"<setSpec>\");\n                writer.print(sets[i].getSpec());\n                writer.println(\"</setSpec>\");\n            }\n        }\n        writer.println(\"</header>\");\n    }\n\n    private static String getParameterUnique(String paramName, Map parameters, ValidatedInput validated) {\n        String retval = null;\n        String[] paramArr = (String[]) parameters.get(paramName);\n        if (paramArr != null) {\n            if (paramArr.length > 1) {\n                validated.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, \"Unexpected duplicate paramater '\" + paramName + \"'.  Please resubmit the request with only one.\"));\n            }\n            //we still only validate the first one.\n            retval = paramArr[0];\n        }\n        return retval;\n    }\n\n    /* Return null if an error occurs, otherwise it returns a DateHolder\n\t * with the from and until set to the Date versions of the input strings\n\t * \n\t * If the input strings are null, the corresponding Date will also be\n\t * set to null.\n\t */\n    private static ValidatedInput validateInput(final DataAccessor dataAccessor, final Map parameters, final PrintWriter writer) {\n        ValidatedInput retval = new ValidatedInput();\n        //verb,identifier,metadataPrefix,from,until,resumptionToken,set,\n        String verbStr = getParameterUnique(\"verb\", parameters, retval);\n        String resumptionToken = getParameterUnique(\"resumptionToken\", parameters, retval);\n        String identifier = getParameterUnique(\"identifier\", parameters, retval);\n        String metadataPrefix = getParameterUnique(\"metadataPrefix\", parameters, retval);\n        String set = getParameterUnique(\"set\", parameters, retval);\n        String from = getParameterUnique(\"from\", parameters, retval);\n        String until = getParameterUnique(\"until\", parameters, retval);\n        System.out.println(\"OAI request = [verb=\" + verbStr + \", identifier=\" + identifier + \", metadataPrefix=\" + metadataPrefix + \", from=\" + from + \", until=\" + until + \", resumptionToken=\" + resumptionToken + \", set=\" + set + \"]\");\n        parameters.remove(\"verb\");\n        retval.verb = (verbStr != null) ? OAIVerb.getVerb(verbStr) : null;\n        if (verbStr == null) {\n            retval.errorList.add(getErrorString(OAIErrorCode.BAD_VERB, \"The request was missing a verb.\"));\n        } else if (retval.verb == null) {\n            retval.errorList.add(getErrorString(OAIErrorCode.BAD_VERB, \"Illegal OAI verb '\" + verbStr + \"'\"));\n        }\n        if (resumptionToken != null) {\n            retval.resumptionToken = dataAccessor.parseResumptionToken(resumptionToken);\n            if (retval.resumptionToken == null) {\n                retval.errorList.add(getErrorString(OAIErrorCode.BAD_RESUMPTION_TOKEN, resumptionToken + \" does not conform to the resumption token format of this provider.\"));\n            } else if (dataAccessor.isExpired(retval.resumptionToken)) {\n                retval.errorList.add(getErrorString(OAIErrorCode.BAD_RESUMPTION_TOKEN, \"resumptionToken '\" + resumptionToken + \"' has expired.\"));\n            }\n            if (identifier != null || metadataPrefix != null || from != null || until != null || set != null) {\n                retval.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The resumptionToken argument is an exclusive argument but other parameters were included in this request.\"));\n            }\n            if (retval.resumptionToken != null) {\n                if (retval.resumptionToken.getMetadataPrefix() != null) {\n                    retval.format = config.getMetadataFormat(retval.resumptionToken.getMetadataPrefix());\n                } else {\n                    System.out.println(\"resumptiontoken prefix was null\");\n                }\n            }\n        }\n        if (identifier != null) {\n            if (!dataAccessor.validateIdentifier(identifier)) {\n                retval.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, identifier + \" does not conform to the identifier format of this provider.\"));\n                retval.identifier = null;\n            } else {\n                retval.identifier = identifier;\n            }\n        }\n        //validate that the metadataPrefix is supported\n        if (metadataPrefix != null) {\n            OAIMetadataFormat format = config.getMetadataFormat(metadataPrefix);\n            if (format == null || format.getHandler() == null) {\n                retval.errorList.add(getErrorString(OAIErrorCode.CANNOT_DISSEMINATE_FORMAT, \"The metadataPrefix '\" + metadataPrefix + \"' is not recognized by this provider.\"));\n                retval.format = null;\n            } else {\n                retval.format = format;\n            }\n        }\n        //set validation\n        if (set != null) {\n            //we don't check for no set heirarchy here, that gets pushed to the later responses\n            if (!dataAccessor.validateSet(set)) {\n                retval.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, set + \" does not conform to the set token format of this provider.\"));\n                retval.set = null;\n            } else if (!dataAccessor.setExists(set)) {\n                retval.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, set + \" is not a valid set for this repository.\"));\n                retval.set = null;\n            } else {\n                retval.set = set;\n            }\n        }\n        //now we check the dates\n        if (until != null || from != null) {\n            //we only care about this if we have dates to parse...\n            //the parsing should be based on the granularity we support\n            OAIGranularity granularity = config.getGranularity();\n            if (until != null) {\n                try {\n                    retval.until = granularity.parse(until);\n                } catch (ParseException ex) {\n                    retval.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The until date '\" + until + \"' is not in the expected format of \" + granularity));\n                    retval.until = null;\n                }\n            }\n            if (from != null) {\n                try {\n                    retval.from = granularity.parse(from);\n                } catch (ParseException ex) {\n                    retval.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The from date '\" + from + \"' is not in the expected format of \" + granularity));\n                    retval.from = null;\n                }\n            }\n            if (retval.from != null && retval.until != null) {\n                if (retval.from.getTime() > retval.until.getTime()) {\n                    retval.errorList.add(getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The from date '\" + from + \"' cannot be later than the until date '\" + until + \"'\"));\n                }\n            }\n            //\t\t\tif (retval.until != null) {\n            //\t\t\t\tDate earliestDate = config.getEarliestDatestamp();\n            //\t\t\t\tif (retval.until.getTime() < earliestDate.getTime()) {\n            //\t\t\t\t\tString earliestAvailable = granularity.format(earliestDate);\n            //\t\t\t\t\twriteError(OAIErrorCode.BAD_ARGUMENT,\"The until date '\"+until+\"' is earlier than this repository's earliest available date '\"+earliestAvailable+\"'\",writer);\n            //\t\t\t\t\terrorOccurred = true;\n            //\t\t\t\t}\n            //\t\t\t}\n        }\n        if (retval.verb != null) {\n            retval.verb.validateInput(retval, parameters);\n        }\n        return retval;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/OAIProviderTest.java",
		"test_prompt": "// OAIProviderTest.java\npackage org.heal.module.oai.provider;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Map;\nimport org.heal.module.oai.provider.verb.OAIVerb;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIProvider}.\n* It contains ten unit test cases for the {@link OAIProvider#getErrorString(OAIErrorCode, String)} method.\n*/\nclass OAIProviderTest {"
	},
	{
		"original_code": "// OAIVerb.java\n/*\n * Created on Mar 13, 2005\n *\n * To change the template for this generated file go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\n\n/**\n * @author Seth Wright\n *\n * To change the template for this generated type comment go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npublic abstract class OAIVerb {\n\n    private static final HashMap verbs = new HashMap();\n\n    public static final OAIVerb GET_RECORD = new GetRecord();\n\n    public static final OAIVerb IDENTIFY = new Identify();\n\n    public static final OAIVerb LIST_IDENTIFIERS = new ListIdentifiers();\n\n    public static final OAIVerb LIST_METADATA_FORMATS = new ListMetadataFormats();\n\n    public static final OAIVerb LIST_RECORDS = new ListRecords();\n\n    public static final OAIVerb LIST_SETS = new ListSets();\n\n    private final String name;\n\n    protected OAIVerb(final String name) {\n        if (verbs.get(name) != null) {\n            throw new IllegalArgumentException(\"Duplicate declaration of OAIVerb '\" + name + \"'\");\n        }\n        this.name = name;\n        verbs.put(this.name, this);\n    }\n\n    public static OAIVerb getVerb(final String verbName) {\n        return (OAIVerb) verbs.get(verbName);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String toString() {\n        return name;\n    }\n\n    public int hashCode() {\n        return name.hashCode();\n    }\n\n    public boolean equals(Object obj) {\n        return (obj instanceof OAIVerb && name.equals(((OAIVerb) obj).name));\n    }\n\n    public int compareTo(Object obj) {\n        return (name.compareTo(((OAIVerb) obj).name));\n    }\n\n    public abstract void execute(final ValidatedInput input, final OAIProviderConfig config, final DataAccessor dataAccessor, final PrintWriter writer) throws IOException;\n\n    public abstract void validateInput(final ValidatedInput input, final Map parameters);\n\n    public String getExtraArgumentError(final String argumentName, final String argumentValue) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The parameter '\" + argumentName + \"' (value='\" + argumentValue + \"') is not allowed in \" + getName() + \" requests.\");\n    }\n\n    public String getMissingArgumentError(final String argumentName) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"OAI \" + getName() + \" requests require the \" + argumentName + \" parameter but it was missing from this request.\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/verb/OAIVerbTest0.java",
		"test_prompt": "// OAIVerbTest0.java\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIVerb}.\n* It contains ten unit test cases for the {@link OAIVerb#getVerb(String)} method.\n*/\nclass OAIVerbTest0 {"
	},
	{
		"original_code": "// OAIVerb.java\n/*\n * Created on Mar 13, 2005\n *\n * To change the template for this generated file go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\n\n/**\n * @author Seth Wright\n *\n * To change the template for this generated type comment go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npublic abstract class OAIVerb {\n\n    private static final HashMap verbs = new HashMap();\n\n    public static final OAIVerb GET_RECORD = new GetRecord();\n\n    public static final OAIVerb IDENTIFY = new Identify();\n\n    public static final OAIVerb LIST_IDENTIFIERS = new ListIdentifiers();\n\n    public static final OAIVerb LIST_METADATA_FORMATS = new ListMetadataFormats();\n\n    public static final OAIVerb LIST_RECORDS = new ListRecords();\n\n    public static final OAIVerb LIST_SETS = new ListSets();\n\n    private final String name;\n\n    protected OAIVerb(final String name) {\n        if (verbs.get(name) != null) {\n            throw new IllegalArgumentException(\"Duplicate declaration of OAIVerb '\" + name + \"'\");\n        }\n        this.name = name;\n        verbs.put(this.name, this);\n    }\n\n    public static OAIVerb getVerb(final String verbName) {\n        return (OAIVerb) verbs.get(verbName);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String toString() {\n        return name;\n    }\n\n    public int hashCode() {\n        return name.hashCode();\n    }\n\n    public boolean equals(Object obj) {\n        return (obj instanceof OAIVerb && name.equals(((OAIVerb) obj).name));\n    }\n\n    public int compareTo(Object obj) {\n        return (name.compareTo(((OAIVerb) obj).name));\n    }\n\n    public abstract void execute(final ValidatedInput input, final OAIProviderConfig config, final DataAccessor dataAccessor, final PrintWriter writer) throws IOException;\n\n    public abstract void validateInput(final ValidatedInput input, final Map parameters);\n\n    public String getExtraArgumentError(final String argumentName, final String argumentValue) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The parameter '\" + argumentName + \"' (value='\" + argumentValue + \"') is not allowed in \" + getName() + \" requests.\");\n    }\n\n    public String getMissingArgumentError(final String argumentName) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"OAI \" + getName() + \" requests require the \" + argumentName + \" parameter but it was missing from this request.\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/verb/OAIVerbTest1.java",
		"test_prompt": "// OAIVerbTest1.java\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIVerb}.\n* It contains ten unit test cases for the {@link OAIVerb#hashCode()} method.\n*/\nclass OAIVerbTest1 {"
	},
	{
		"original_code": "// OAIVerb.java\n/*\n * Created on Mar 13, 2005\n *\n * To change the template for this generated file go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\n\n/**\n * @author Seth Wright\n *\n * To change the template for this generated type comment go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npublic abstract class OAIVerb {\n\n    private static final HashMap verbs = new HashMap();\n\n    public static final OAIVerb GET_RECORD = new GetRecord();\n\n    public static final OAIVerb IDENTIFY = new Identify();\n\n    public static final OAIVerb LIST_IDENTIFIERS = new ListIdentifiers();\n\n    public static final OAIVerb LIST_METADATA_FORMATS = new ListMetadataFormats();\n\n    public static final OAIVerb LIST_RECORDS = new ListRecords();\n\n    public static final OAIVerb LIST_SETS = new ListSets();\n\n    private final String name;\n\n    protected OAIVerb(final String name) {\n        if (verbs.get(name) != null) {\n            throw new IllegalArgumentException(\"Duplicate declaration of OAIVerb '\" + name + \"'\");\n        }\n        this.name = name;\n        verbs.put(this.name, this);\n    }\n\n    public static OAIVerb getVerb(final String verbName) {\n        return (OAIVerb) verbs.get(verbName);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String toString() {\n        return name;\n    }\n\n    public int hashCode() {\n        return name.hashCode();\n    }\n\n    public boolean equals(Object obj) {\n        return (obj instanceof OAIVerb && name.equals(((OAIVerb) obj).name));\n    }\n\n    public int compareTo(Object obj) {\n        return (name.compareTo(((OAIVerb) obj).name));\n    }\n\n    public abstract void execute(final ValidatedInput input, final OAIProviderConfig config, final DataAccessor dataAccessor, final PrintWriter writer) throws IOException;\n\n    public abstract void validateInput(final ValidatedInput input, final Map parameters);\n\n    public String getExtraArgumentError(final String argumentName, final String argumentValue) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The parameter '\" + argumentName + \"' (value='\" + argumentValue + \"') is not allowed in \" + getName() + \" requests.\");\n    }\n\n    public String getMissingArgumentError(final String argumentName) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"OAI \" + getName() + \" requests require the \" + argumentName + \" parameter but it was missing from this request.\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/verb/OAIVerbTest2.java",
		"test_prompt": "// OAIVerbTest2.java\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIVerb}.\n* It contains ten unit test cases for the {@link OAIVerb#equals(Object)} method.\n*/\nclass OAIVerbTest2 {"
	},
	{
		"original_code": "// OAIVerb.java\n/*\n * Created on Mar 13, 2005\n *\n * To change the template for this generated file go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\n\n/**\n * @author Seth Wright\n *\n * To change the template for this generated type comment go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npublic abstract class OAIVerb {\n\n    private static final HashMap verbs = new HashMap();\n\n    public static final OAIVerb GET_RECORD = new GetRecord();\n\n    public static final OAIVerb IDENTIFY = new Identify();\n\n    public static final OAIVerb LIST_IDENTIFIERS = new ListIdentifiers();\n\n    public static final OAIVerb LIST_METADATA_FORMATS = new ListMetadataFormats();\n\n    public static final OAIVerb LIST_RECORDS = new ListRecords();\n\n    public static final OAIVerb LIST_SETS = new ListSets();\n\n    private final String name;\n\n    protected OAIVerb(final String name) {\n        if (verbs.get(name) != null) {\n            throw new IllegalArgumentException(\"Duplicate declaration of OAIVerb '\" + name + \"'\");\n        }\n        this.name = name;\n        verbs.put(this.name, this);\n    }\n\n    public static OAIVerb getVerb(final String verbName) {\n        return (OAIVerb) verbs.get(verbName);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String toString() {\n        return name;\n    }\n\n    public int hashCode() {\n        return name.hashCode();\n    }\n\n    public boolean equals(Object obj) {\n        return (obj instanceof OAIVerb && name.equals(((OAIVerb) obj).name));\n    }\n\n    public int compareTo(Object obj) {\n        return (name.compareTo(((OAIVerb) obj).name));\n    }\n\n    public abstract void execute(final ValidatedInput input, final OAIProviderConfig config, final DataAccessor dataAccessor, final PrintWriter writer) throws IOException;\n\n    public abstract void validateInput(final ValidatedInput input, final Map parameters);\n\n    public String getExtraArgumentError(final String argumentName, final String argumentValue) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"The parameter '\" + argumentName + \"' (value='\" + argumentValue + \"') is not allowed in \" + getName() + \" requests.\");\n    }\n\n    public String getMissingArgumentError(final String argumentName) {\n        return OAIProvider.getErrorString(OAIErrorCode.BAD_ARGUMENT, \"OAI \" + getName() + \" requests require the \" + argumentName + \" parameter but it was missing from this request.\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/verb/OAIVerbTest3.java",
		"test_prompt": "// OAIVerbTest3.java\npackage org.heal.module.oai.provider.verb;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIErrorCode;\nimport org.heal.module.oai.provider.OAIProvider;\nimport org.heal.module.oai.provider.OAIProviderConfig;\nimport org.heal.module.oai.provider.ValidatedInput;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIVerb}.\n* It contains ten unit test cases for the {@link OAIVerb#compareTo(Object)} method.\n*/\nclass OAIVerbTest3 {"
	},
	{
		"original_code": "// OAIGranularity.java\n/*\n * Created on Mar 19, 2005\n *\n * Window - Preferences - Java - Code Style - Code Templates\n */\npackage org.heal.module.oai.provider;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.TimeZone;\n\n/**\n * @author swright\n *\n * Window - Preferences - Java - Code Style - Code Templates\n */\npublic class OAIGranularity {\n\n    private static final HashMap granularities = new HashMap();\n\n    public static final OAIGranularity yearMonthDay = new OAIGranularity(\"YYYY-MM-DD\", \"yyyy-MM-dd\");\n\n    public static final OAIGranularity yearMonthDayHourMinuteSecond = new OAIGranularity(\"YYYY-MM-DDThh:mm:ssZ\", \"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\n    private final String display;\n\n    private final SimpleDateFormat dateFormatter;\n\n    protected OAIGranularity(final String display, final String javaFormat) {\n        this.display = display;\n        dateFormatter = new SimpleDateFormat(javaFormat);\n        dateFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        granularities.put(display, this);\n    }\n\n    public static OAIGranularity getGranularity(String display) {\n        return (OAIGranularity) granularities.get(display);\n    }\n\n    public String getDisplay() {\n        return display;\n    }\n\n    public Date parse(String str) throws ParseException {\n        return dateFormatter.parse(str);\n    }\n\n    public String format(Date aDate) {\n        return dateFormatter.format(aDate);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/OAIGranularityTest0.java",
		"test_prompt": "// OAIGranularityTest0.java\npackage org.heal.module.oai.provider;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIGranularity}.\n* It contains ten unit test cases for the {@link OAIGranularity#getGranularity(String)} method.\n*/\nclass OAIGranularityTest0 {"
	},
	{
		"original_code": "// OAIGranularity.java\n/*\n * Created on Mar 19, 2005\n *\n * Window - Preferences - Java - Code Style - Code Templates\n */\npackage org.heal.module.oai.provider;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.TimeZone;\n\n/**\n * @author swright\n *\n * Window - Preferences - Java - Code Style - Code Templates\n */\npublic class OAIGranularity {\n\n    private static final HashMap granularities = new HashMap();\n\n    public static final OAIGranularity yearMonthDay = new OAIGranularity(\"YYYY-MM-DD\", \"yyyy-MM-dd\");\n\n    public static final OAIGranularity yearMonthDayHourMinuteSecond = new OAIGranularity(\"YYYY-MM-DDThh:mm:ssZ\", \"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\n    private final String display;\n\n    private final SimpleDateFormat dateFormatter;\n\n    protected OAIGranularity(final String display, final String javaFormat) {\n        this.display = display;\n        dateFormatter = new SimpleDateFormat(javaFormat);\n        dateFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        granularities.put(display, this);\n    }\n\n    public static OAIGranularity getGranularity(String display) {\n        return (OAIGranularity) granularities.get(display);\n    }\n\n    public String getDisplay() {\n        return display;\n    }\n\n    public Date parse(String str) throws ParseException {\n        return dateFormatter.parse(str);\n    }\n\n    public String format(Date aDate) {\n        return dateFormatter.format(aDate);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/OAIGranularityTest1.java",
		"test_prompt": "// OAIGranularityTest1.java\npackage org.heal.module.oai.provider;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIGranularity}.\n* It contains ten unit test cases for the {@link OAIGranularity#parse(String)} method.\n*/\nclass OAIGranularityTest1 {"
	},
	{
		"original_code": "// OAIGranularity.java\n/*\n * Created on Mar 19, 2005\n *\n * Window - Preferences - Java - Code Style - Code Templates\n */\npackage org.heal.module.oai.provider;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.TimeZone;\n\n/**\n * @author swright\n *\n * Window - Preferences - Java - Code Style - Code Templates\n */\npublic class OAIGranularity {\n\n    private static final HashMap granularities = new HashMap();\n\n    public static final OAIGranularity yearMonthDay = new OAIGranularity(\"YYYY-MM-DD\", \"yyyy-MM-dd\");\n\n    public static final OAIGranularity yearMonthDayHourMinuteSecond = new OAIGranularity(\"YYYY-MM-DDThh:mm:ssZ\", \"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\n    private final String display;\n\n    private final SimpleDateFormat dateFormatter;\n\n    protected OAIGranularity(final String display, final String javaFormat) {\n        this.display = display;\n        dateFormatter = new SimpleDateFormat(javaFormat);\n        dateFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        granularities.put(display, this);\n    }\n\n    public static OAIGranularity getGranularity(String display) {\n        return (OAIGranularity) granularities.get(display);\n    }\n\n    public String getDisplay() {\n        return display;\n    }\n\n    public Date parse(String str) throws ParseException {\n        return dateFormatter.parse(str);\n    }\n\n    public String format(Date aDate) {\n        return dateFormatter.format(aDate);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/OAIGranularityTest2.java",
		"test_prompt": "// OAIGranularityTest2.java\npackage org.heal.module.oai.provider;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIGranularity}.\n* It contains ten unit test cases for the {@link OAIGranularity#format(Date)} method.\n*/\nclass OAIGranularityTest2 {"
	},
	{
		"original_code": "// OAIErrorCode.java\n/*\n * Created on Mar 13, 2005\n *\n * To change the template for this generated file go to\n * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments\n */\npackage org.heal.module.oai.provider;\n\nimport java.util.HashMap;\n\n/**\n * badArgument  \tThe request includes illegal arguments, is missing required arguments, includes a repeated argument, or values for arguments have an illegal syntax\n * badResumptionToken \tThe value of the resumptionToken argument is invalid or expired.\n * badVerb \tValue of the verb argument is not a legal OAI-PMH verb, the verb argument is missing, or the verb argument is repeated.\n * cannotDisseminateFormat \tThe metadata format identified by the value given for the metadataPrefix argument is not supported by the item or by the repository.\n * idDoesNotExist \tThe value of the identifier argument is unknown or illegal in this repository.\n * noRecordsMatch \tThe combination of the values of the from, until, set and metadataPrefix arguments results in an empty list.\n * noMetadataFormats \tThere are no metadata formats available for the specified item.\n * noSetHierarchy \tThe repository does not support sets.\n * @author Seth Wright\n */\npublic class OAIErrorCode {\n\n    private static final HashMap errorCodes = new HashMap();\n\n    public static final OAIErrorCode BAD_ARGUMENT = new OAIErrorCode(\"badArgument\");\n\n    public static final OAIErrorCode BAD_RESUMPTION_TOKEN = new OAIErrorCode(\"badResumptionToken\");\n\n    public static final OAIErrorCode BAD_VERB = new OAIErrorCode(\"badVerb\");\n\n    public static final OAIErrorCode CANNOT_DISSEMINATE_FORMAT = new OAIErrorCode(\"cannotDisseminateFormat\");\n\n    public static final OAIErrorCode ID_DOES_NOT_EXIST = new OAIErrorCode(\"idDoesNotExist\");\n\n    public static final OAIErrorCode NO_RECORDS_MATCH = new OAIErrorCode(\"noRecordsMatch\");\n\n    public static final OAIErrorCode NO_METADATA_FORMATS = new OAIErrorCode(\"noMetadataFormats\");\n\n    public static final OAIErrorCode NO_SET_HEIRARCHY = new OAIErrorCode(\"noSetHierarchy\");\n\n    private final String name;\n\n    private OAIErrorCode(final String name) {\n        this.name = name;\n        errorCodes.put(this.name, this);\n    }\n\n    public static OAIErrorCode getErrorCode(final String name) {\n        return (OAIErrorCode) errorCodes.get(name);\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/provider/OAIErrorCodeTest.java",
		"test_prompt": "// OAIErrorCodeTest.java\npackage org.heal.module.oai.provider;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAIErrorCode}.\n* It contains ten unit test cases for the {@link OAIErrorCode#getErrorCode(String)} method.\n*/\nclass OAIErrorCodeTest {"
	},
	{
		"original_code": "// HEALXMLHelper.java\n/*\n * Created on Apr 10, 2005\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCHandler;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Text;\n\n/**\n * @author swright\n */\npublic class HEALXMLHelper {\n\n    public static final String HEALNS = \"heal\";\n\n    public static final String IMSNS = \"ims\";\n\n    public static final String IMSLOC = \"http://www.imsproject.org/metadata\";\n\n    public static final String HEALLOC = \"http://www.healcentral.org/xsd/healmd_v1p5\";\n\n    public static final String HEALSCHEMA = \"http://www.healcentral.org/xsd/healmd_v1p5 http://www.healcentral.org/services/schema/HEALmdSchemaXMLv1p5050329.xsd\";\n\n    public static void addCustomAbout(CompleteMetadataBean metadataBean, HEALProviderConfig config, Document doc) {\n        Element metaElement = doc.createElement(HEALNS + \":metametadata\");\n        metaElement.setAttribute(\"xmlns:\" + HEALNS, HEALLOC);\n        metaElement.setAttribute(\"xmlns:\" + IMSNS, IMSLOC);\n        metaElement.setAttribute(\"xmlns:\" + OAI_DCHandler.SIMPLEDC_PREFIX, \"http://purl.org/dc/elements/1.1/\");\n        metaElement.setAttribute(\"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\");\n        metaElement.setAttribute(\"xsi:schemaLocation\", HEALSCHEMA);\n        Element catalogEntryElem = doc.createElement(HEALNS + \":catalogentry\");\n        appendTextElem(HEALNS + \":catalogue\", \"http://www.healcentral.org\", catalogEntryElem, doc);\n        appendTextElemWithLangstring(HEALNS + \":entry\", HEALNS, metadataBean.getGlobalId(), null, catalogEntryElem, doc);\n        metaElement.appendChild(catalogEntryElem);\n        Element contributorElem = doc.createElement(HEALNS + \":contribute\");\n        Element roleElem = doc.createElement(HEALNS + \":role\");\n        //TODO: make source setting part of the configuration to externalize it\n        appendTextElemWithLangstring(HEALNS + \":source\", HEALNS, \"HEALv1.5\", null, roleElem, doc);\n        //<source><langstring>HEALv1.5</langstring></source>\n        appendTextElemWithLangstring(HEALNS + \":value\", HEALNS, config.getMetametadataRole(), null, roleElem, doc);\n        contributorElem.appendChild(roleElem);\n        Element centityElem = doc.createElement(HEALNS + \":centity\");\n        Element vCardElem = doc.createElement(HEALNS + \":vcard\");\n        vCardElem.appendChild(doc.createTextNode(config.getHEALVCard()));\n        centityElem.appendChild(vCardElem);\n        contributorElem.appendChild(centityElem);\n        Date contributeDate = metadataBean.getContributeDate();\n        if (contributeDate != null) {\n            Element dateElem = doc.createElement(HEALNS + \":date\");\n            Element dateTimeElem = doc.createElement(HEALNS + \":datetime\");\n            String dateStr = OAIGranularity.yearMonthDayHourMinuteSecond.format(contributeDate);\n            dateTimeElem.appendChild(doc.createTextNode(dateStr));\n            dateElem.appendChild(dateTimeElem);\n            contributorElem.appendChild(dateElem);\n        }\n        metaElement.appendChild(contributorElem);\n        Element extensionElem = doc.createElement(HEALNS + \":extension\");\n        appendTextElem(HEALNS + \":healmetadatascheme\", \"HEAL:1.5\", extensionElem, doc);\n        metaElement.appendChild(extensionElem);\n        appendTextElem(HEALNS + \":metadatascheme\", \"IMS:1.2\", metaElement, doc);\n        appendTextElem(HEALNS + \":language\", \"en\", metaElement, doc);\n        doc.appendChild(metaElement);\n    }\n\n    public static String getFullNameFromVCard(String vcard) {\n        if (vcard != null) {\n            int fnIndex = vcard.indexOf(\"fn:\");\n            if (fnIndex >= 0) {\n                int len = vcard.length();\n                int stopIndex = fnIndex + 3;\n                boolean endOfLine = false;\n                char here;\n                while (stopIndex < len && !endOfLine) {\n                    here = vcard.charAt(stopIndex);\n                    if (here == '\\n' || here == '\\r') {\n                        endOfLine = true;\n                    }\n                    stopIndex++;\n                }\n                return vcard.substring(fnIndex + 3, stopIndex);\n            }\n        }\n        return null;\n    }\n\n    public static void appendTextElemWithLangstring(String prefix, String namespace, String value, String language, Element parentElem, Document doc) {\n        if (value == null)\n            return;\n        String real = value.trim();\n        if (real.length() > 0) {\n            Element outerElement = doc.createElement(prefix);\n            Element langStrElement = doc.createElement(namespace + \":langstring\");\n            if (language != null) {\n                langStrElement.setAttribute(\"lang\", language);\n            }\n            Text textElement = doc.createTextNode(real);\n            langStrElement.appendChild(textElement);\n            outerElement.appendChild(langStrElement);\n            parentElem.appendChild(outerElement);\n        }\n    }\n\n    public static void appendTextElemWithDescriptor(String prefix, String descriptor, String value, Element parentElem, Document doc) {\n        if (value == null)\n            return;\n        appendTextElem(prefix, descriptor + \": \" + value, parentElem, doc);\n    }\n\n    public static void appendTextElem(String prefix, String value, Element parentElem, Document doc) {\n        if (value == null)\n            return;\n        String real = value.trim();\n        if (real.length() > 0) {\n            Element outerElement = doc.createElement(prefix);\n            Text textElement = doc.createTextNode(real);\n            outerElement.appendChild(textElement);\n            parentElem.appendChild(outerElement);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALXMLHelperTest.java",
		"test_prompt": "// HEALXMLHelperTest.java\npackage org.heal.module.oai.heal;\n\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCHandler;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Text;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALXMLHelper}.\n* It contains ten unit test cases for the {@link HEALXMLHelper#getFullNameFromVCard(String)} method.\n*/\nclass HEALXMLHelperTest {"
	},
	{
		"original_code": "// HEALOAIDCRecordAdapter.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCHandler;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\n/**\n * @author Seth Wright\n */\npublic class HEALOAIDCRecordAdapter implements OAI_DCRecordAdapter, OAIRecordAdapter {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    public HEALOAIDCRecordAdapter(final CompleteMetadataBean metadataBean, final HEALProviderConfig config) {\n        this.metadataBean = metadataBean;\n        this.config = config;\n    }\n\n    public boolean hasOAIAbout() {\n        return false;\n    }\n\n    public boolean hasCustomAbout() {\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter#addAttributes(org.w3c.dom.Element)\n\t */\n    public void addRecordAttributes(Element recordElement, Document doc) {\n        recordElement.setAttribute(\"xmlns:\" + HEALXMLHelper.HEALNS, HEALXMLHelper.HEALLOC);\n    }\n\n    public void addCustomAbout(Document doc) {\n        HEALXMLHelper.addCustomAbout(metadataBean, config, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter#addAttributes(org.w3c.dom.Element)\n\t */\n    public void addOAIAboutAttributes(Element recordElement, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendAboutElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendOAIAboutElements(Element recordElement, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendTitleElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendTitleElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":title\", metadataBean.getTitle(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendSubjectElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendSubjectElements(Element recordElement, Document doc) {\n        Collection taxonpaths = metadataBean.getTaxonPaths();\n        Iterator iter = taxonpaths.iterator();\n        TaxonPathBean tpb;\n        TaxonBean tb;\n        while (iter.hasNext()) {\n            tpb = (TaxonPathBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", tpb.getSource(), recordElement, doc);\n            Collection taxons = tpb.getTaxons();\n            Iterator taxonIter = taxons.iterator();\n            while (taxonIter.hasNext()) {\n                tb = (TaxonBean) taxonIter.next();\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", tb.getId(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", tb.getEntry(), recordElement, doc);\n            }\n        }\n        Collection keywords = metadataBean.getKeywords();\n        iter = keywords.iterator();\n        KeywordBean kb;\n        while (iter.hasNext()) {\n            kb = (KeywordBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", kb.getKeyword(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendDescrpitionElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendDescriptionElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", metadataBean.getDescription(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Specimen Type\", metadataBean.getSpecimenType(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Orientation\", metadataBean.getOrientation(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Magnification\", metadataBean.getMagnification(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Annotated\", metadataBean.getAnnotated(), recordElement, doc);\n        Collection diagnoses = metadataBean.getDiseaseDiagnoses();\n        if (diagnoses != null) {\n            DiseaseDiagnosisBean value = null;\n            Iterator iter = diagnoses.iterator();\n            while (iter.hasNext()) {\n                value = (DiseaseDiagnosisBean) iter.next();\n                HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Disease diagnosis\", value.getDiseaseDiagnosis(), recordElement, doc);\n            }\n        }\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Clinical history\", metadataBean.getClinicalHistory(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Radiograph type\", metadataBean.getRadiographType(), recordElement, doc);\n        Collection urls = metadataBean.getContextURLs();\n        if (urls != null) {\n            Iterator iter = urls.iterator();\n            ContextURLBean value = null;\n            while (iter.hasNext()) {\n                value = (ContextURLBean) iter.next();\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", value.getContextURL(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", value.getContextURLDescription(), recordElement, doc);\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendPublisherElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendPublisherElements(Element recordElement, Document doc) {\n        //XXX we don't do anything here because we already appended them in\n        //the appendContributorElements method\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendCreatorElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendCreatorElements(Element recordElement, Document doc) {\n        //XXX we don't do anything here because we already appended them in\n        //the appendContributorElements method\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendContributorElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendContributorElements(Element recordElement, Document doc) {\n        Collection contributors = metadataBean.getContributorList();\n        Iterator iter = contributors.iterator();\n        ContributorBean contributor;\n        String role, type = null;\n        while (iter.hasNext()) {\n            contributor = (ContributorBean) iter.next();\n            role = contributor.getRole();\n            type = null;\n            if (\"primary\".equals(role)) {\n                type = \":creator\";\n            } else if (\"secondary\".equals(role)) {\n                type = \":contributor\";\n            } else if (\"Content Provider\".equals(role)) {\n                type = \":publisher\";\n            }\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + type, \"Role: \" + role, recordElement, doc);\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + type, contributor.getVCard(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendDateElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendDateElements(Element recordElement, Document doc) {\n        Date contributeDate = metadataBean.getContributeDate();\n        if (contributeDate != null) {\n            String dateStr = OAIGranularity.yearMonthDayHourMinuteSecond.format(contributeDate);\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":date\", dateStr, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendTypeElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendTypeElements(Element recordElement, Document doc) {\n        Collection formats = metadataBean.getFormats();\n        Iterator iter = formats.iterator();\n        FormatBean fb;\n        while (iter.hasNext()) {\n            fb = (FormatBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":type\", fb.getFormat(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendFormatElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendFormatElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", metadataBean.getFileExtension(), recordElement, doc);\n        String dimensions = \"\";\n        String width = metadataBean.getFileWidth();\n        String height = metadataBean.getFileHeight();\n        if (width != null && !\"0\".equals(width) && height != null && !\"0\".equals(height)) {\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", width + \" x \" + height + \" pixels\", recordElement, doc);\n        }\n        String fileSize = metadataBean.getFileSize();\n        if (fileSize != null && !\"0\".equals(fileSize)) {\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", fileSize + \" bytes\", recordElement, doc);\n        }\n        String duration = metadataBean.getDuration();\n        if (duration != null && !\"0\".equals(duration)) {\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", duration + \" seconds\", recordElement, doc);\n        }\n        Collection list = metadataBean.getRequirements();\n        Iterator iter = list.iterator();\n        RequirementBean rb;\n        while (iter.hasNext()) {\n            rb = (RequirementBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", rb.getRequirementType() + \": \" + rb.getRequirementName(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendIdentifierElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendIdentifierElements(Element recordElement, Document doc) {\n        String location = metadataBean.getLocation();\n        if (location != null && !location.startsWith(\"http://\")) {\n            location = config.getContentPrefix() + '/' + location;\n        }\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":identifier\", location, recordElement, doc);\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":identifier\", metadataBean.getGlobalId(), recordElement, doc);\n        /*\n\t\tGeneral CatalogEntry Catalogue = Location in the Metadata table; the default is http://www.healcentral.org; but some resources                                         have other URLs, such as http://medstat.med.utah.edu/kw or http://www.nlm.nih.gov/medlineplus\n\t\tGeneral CatalogEntry Entry = GlobalID from the Metadata table; this isn't technically accurate, but we haven't used IDs from the local catalogs\n*/\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendSourceElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendSourceElements(Element recordElement, Document doc) {\n        //Do nothing here because these elements are appended in\n        //the relation portion\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendLanguageElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendLanguageElements(Element recordElement, Document doc) {\n        //we don't have any language entries yet\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendRelationElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendRelationElements(Element recordElement, Document doc) {\n        Collection relations = metadataBean.getRelations();\n        Iterator iter = relations.iterator();\n        RelationBean rb;\n        while (iter.hasNext()) {\n            rb = (RelationBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":relation\", rb.getKind(), recordElement, doc);\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":relation\", rb.getDescription(), recordElement, doc);\n            //XXX TODO this next line needs to have the relation lookup tweaked to include the GlobalID of\n            //the resource...and to lookup the resource's catalog entries and catalog\n            //\t\t\tHEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX+\":relation\",rb.getResource(),recordElement,doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendCoverageElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendCoverageElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":coverage\", config.getCoverage(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendRightsElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendRightsElements(Element recordElement, Document doc) {\n        Collection col = metadataBean.getCopyrights();\n        Iterator iter = col.iterator();\n        CopyrightBean cb;\n        CopyrightTextBean ctb;\n        while (iter.hasNext()) {\n            cb = (CopyrightBean) iter.next();\n            ctb = cb.getCopyrightText();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":rights\", ctb.getCopyrightText(), recordElement, doc);\n        }\n        col = metadataBean.getCopyrightHolders();\n        iter = col.iterator();\n        CopyrightHolderBean chb;\n        String fullName;\n        while (iter.hasNext()) {\n            chb = (CopyrightHolderBean) iter.next();\n            fullName = HEALXMLHelper.getFullNameFromVCard(chb.getVCard());\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":rights\", fullName, recordElement, doc);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALOAIDCRecordAdapterTest0.java",
		"test_prompt": "// HEALOAIDCRecordAdapterTest0.java\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCHandler;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALOAIDCRecordAdapter}.\n* It contains ten unit test cases for the {@link HEALOAIDCRecordAdapter#hasOAIAbout()} method.\n*/\nclass HEALOAIDCRecordAdapterTest0 {"
	},
	{
		"original_code": "// HEALOAIDCRecordAdapter.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCHandler;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\n/**\n * @author Seth Wright\n */\npublic class HEALOAIDCRecordAdapter implements OAI_DCRecordAdapter, OAIRecordAdapter {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    public HEALOAIDCRecordAdapter(final CompleteMetadataBean metadataBean, final HEALProviderConfig config) {\n        this.metadataBean = metadataBean;\n        this.config = config;\n    }\n\n    public boolean hasOAIAbout() {\n        return false;\n    }\n\n    public boolean hasCustomAbout() {\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter#addAttributes(org.w3c.dom.Element)\n\t */\n    public void addRecordAttributes(Element recordElement, Document doc) {\n        recordElement.setAttribute(\"xmlns:\" + HEALXMLHelper.HEALNS, HEALXMLHelper.HEALLOC);\n    }\n\n    public void addCustomAbout(Document doc) {\n        HEALXMLHelper.addCustomAbout(metadataBean, config, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter#addAttributes(org.w3c.dom.Element)\n\t */\n    public void addOAIAboutAttributes(Element recordElement, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendAboutElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendOAIAboutElements(Element recordElement, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendTitleElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendTitleElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":title\", metadataBean.getTitle(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendSubjectElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendSubjectElements(Element recordElement, Document doc) {\n        Collection taxonpaths = metadataBean.getTaxonPaths();\n        Iterator iter = taxonpaths.iterator();\n        TaxonPathBean tpb;\n        TaxonBean tb;\n        while (iter.hasNext()) {\n            tpb = (TaxonPathBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", tpb.getSource(), recordElement, doc);\n            Collection taxons = tpb.getTaxons();\n            Iterator taxonIter = taxons.iterator();\n            while (taxonIter.hasNext()) {\n                tb = (TaxonBean) taxonIter.next();\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", tb.getId(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", tb.getEntry(), recordElement, doc);\n            }\n        }\n        Collection keywords = metadataBean.getKeywords();\n        iter = keywords.iterator();\n        KeywordBean kb;\n        while (iter.hasNext()) {\n            kb = (KeywordBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":subject\", kb.getKeyword(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendDescrpitionElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendDescriptionElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", metadataBean.getDescription(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Specimen Type\", metadataBean.getSpecimenType(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Orientation\", metadataBean.getOrientation(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Magnification\", metadataBean.getMagnification(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Annotated\", metadataBean.getAnnotated(), recordElement, doc);\n        Collection diagnoses = metadataBean.getDiseaseDiagnoses();\n        if (diagnoses != null) {\n            DiseaseDiagnosisBean value = null;\n            Iterator iter = diagnoses.iterator();\n            while (iter.hasNext()) {\n                value = (DiseaseDiagnosisBean) iter.next();\n                HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Disease diagnosis\", value.getDiseaseDiagnosis(), recordElement, doc);\n            }\n        }\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Clinical history\", metadataBean.getClinicalHistory(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", \"Radiograph type\", metadataBean.getRadiographType(), recordElement, doc);\n        Collection urls = metadataBean.getContextURLs();\n        if (urls != null) {\n            Iterator iter = urls.iterator();\n            ContextURLBean value = null;\n            while (iter.hasNext()) {\n                value = (ContextURLBean) iter.next();\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", value.getContextURL(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":description\", value.getContextURLDescription(), recordElement, doc);\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendPublisherElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendPublisherElements(Element recordElement, Document doc) {\n        //XXX we don't do anything here because we already appended them in\n        //the appendContributorElements method\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendCreatorElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendCreatorElements(Element recordElement, Document doc) {\n        //XXX we don't do anything here because we already appended them in\n        //the appendContributorElements method\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendContributorElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendContributorElements(Element recordElement, Document doc) {\n        Collection contributors = metadataBean.getContributorList();\n        Iterator iter = contributors.iterator();\n        ContributorBean contributor;\n        String role, type = null;\n        while (iter.hasNext()) {\n            contributor = (ContributorBean) iter.next();\n            role = contributor.getRole();\n            type = null;\n            if (\"primary\".equals(role)) {\n                type = \":creator\";\n            } else if (\"secondary\".equals(role)) {\n                type = \":contributor\";\n            } else if (\"Content Provider\".equals(role)) {\n                type = \":publisher\";\n            }\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + type, \"Role: \" + role, recordElement, doc);\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + type, contributor.getVCard(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendDateElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendDateElements(Element recordElement, Document doc) {\n        Date contributeDate = metadataBean.getContributeDate();\n        if (contributeDate != null) {\n            String dateStr = OAIGranularity.yearMonthDayHourMinuteSecond.format(contributeDate);\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":date\", dateStr, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendTypeElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendTypeElements(Element recordElement, Document doc) {\n        Collection formats = metadataBean.getFormats();\n        Iterator iter = formats.iterator();\n        FormatBean fb;\n        while (iter.hasNext()) {\n            fb = (FormatBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":type\", fb.getFormat(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendFormatElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendFormatElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", metadataBean.getFileExtension(), recordElement, doc);\n        String dimensions = \"\";\n        String width = metadataBean.getFileWidth();\n        String height = metadataBean.getFileHeight();\n        if (width != null && !\"0\".equals(width) && height != null && !\"0\".equals(height)) {\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", width + \" x \" + height + \" pixels\", recordElement, doc);\n        }\n        String fileSize = metadataBean.getFileSize();\n        if (fileSize != null && !\"0\".equals(fileSize)) {\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", fileSize + \" bytes\", recordElement, doc);\n        }\n        String duration = metadataBean.getDuration();\n        if (duration != null && !\"0\".equals(duration)) {\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", duration + \" seconds\", recordElement, doc);\n        }\n        Collection list = metadataBean.getRequirements();\n        Iterator iter = list.iterator();\n        RequirementBean rb;\n        while (iter.hasNext()) {\n            rb = (RequirementBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":format\", rb.getRequirementType() + \": \" + rb.getRequirementName(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendIdentifierElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendIdentifierElements(Element recordElement, Document doc) {\n        String location = metadataBean.getLocation();\n        if (location != null && !location.startsWith(\"http://\")) {\n            location = config.getContentPrefix() + '/' + location;\n        }\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":identifier\", location, recordElement, doc);\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":identifier\", metadataBean.getGlobalId(), recordElement, doc);\n        /*\n\t\tGeneral CatalogEntry Catalogue = Location in the Metadata table; the default is http://www.healcentral.org; but some resources                                         have other URLs, such as http://medstat.med.utah.edu/kw or http://www.nlm.nih.gov/medlineplus\n\t\tGeneral CatalogEntry Entry = GlobalID from the Metadata table; this isn't technically accurate, but we haven't used IDs from the local catalogs\n*/\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendSourceElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendSourceElements(Element recordElement, Document doc) {\n        //Do nothing here because these elements are appended in\n        //the relation portion\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendLanguageElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendLanguageElements(Element recordElement, Document doc) {\n        //we don't have any language entries yet\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendRelationElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendRelationElements(Element recordElement, Document doc) {\n        Collection relations = metadataBean.getRelations();\n        Iterator iter = relations.iterator();\n        RelationBean rb;\n        while (iter.hasNext()) {\n            rb = (RelationBean) iter.next();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":relation\", rb.getKind(), recordElement, doc);\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":relation\", rb.getDescription(), recordElement, doc);\n            //XXX TODO this next line needs to have the relation lookup tweaked to include the GlobalID of\n            //the resource...and to lookup the resource's catalog entries and catalog\n            //\t\t\tHEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX+\":relation\",rb.getResource(),recordElement,doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendCoverageElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendCoverageElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":coverage\", config.getCoverage(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAI_DCRecordAdapter#appendRightsElements(org.heal.module.oai.provider.OAIRecord, org.w3c.dom.Element)\n\t */\n    public void appendRightsElements(Element recordElement, Document doc) {\n        Collection col = metadataBean.getCopyrights();\n        Iterator iter = col.iterator();\n        CopyrightBean cb;\n        CopyrightTextBean ctb;\n        while (iter.hasNext()) {\n            cb = (CopyrightBean) iter.next();\n            ctb = cb.getCopyrightText();\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":rights\", ctb.getCopyrightText(), recordElement, doc);\n        }\n        col = metadataBean.getCopyrightHolders();\n        iter = col.iterator();\n        CopyrightHolderBean chb;\n        String fullName;\n        while (iter.hasNext()) {\n            chb = (CopyrightHolderBean) iter.next();\n            fullName = HEALXMLHelper.getFullNameFromVCard(chb.getVCard());\n            HEALXMLHelper.appendTextElem(OAI_DCHandler.SIMPLEDC_PREFIX + \":rights\", fullName, recordElement, doc);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALOAIDCRecordAdapterTest1.java",
		"test_prompt": "// HEALOAIDCRecordAdapterTest1.java\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCHandler;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALOAIDCRecordAdapter}.\n* It contains ten unit test cases for the {@link HEALOAIDCRecordAdapter#hasCustomAbout()} method.\n*/\nclass HEALOAIDCRecordAdapterTest1 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest0.java",
		"test_prompt": "// HEALDataAccessorTest0.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#parseResumptionToken(String)} method.\n*/\nclass HEALDataAccessorTest0 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest1.java",
		"test_prompt": "// HEALDataAccessorTest1.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#resumeRecordQuery(OAIResumptionToken)} method.\n*/\nclass HEALDataAccessorTest1 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest2.java",
		"test_prompt": "// HEALDataAccessorTest2.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#resumeSetQuery(OAIResumptionToken)} method.\n*/\nclass HEALDataAccessorTest2 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest3.java",
		"test_prompt": "// HEALDataAccessorTest3.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#resumeIdentifierQuery(OAIResumptionToken)} method.\n*/\nclass HEALDataAccessorTest3 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest4.java",
		"test_prompt": "// HEALDataAccessorTest4.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#hasMoreElements()} method.\n*/\nclass HEALDataAccessorTest4 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest5.java",
		"test_prompt": "// HEALDataAccessorTest5.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#validateIdentifier(String)} method.\n*/\nclass HEALDataAccessorTest5 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest6.java",
		"test_prompt": "// HEALDataAccessorTest6.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#validateSet(String)} method.\n*/\nclass HEALDataAccessorTest6 {"
	},
	{
		"original_code": "// HEALDataAccessor.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\n\n/**\n * @author Seth Wright\n */\npublic class HEALDataAccessor implements DataAccessor {\n\n    private static final boolean debug = false;\n\n    private SimpleDateFormat catalogFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    private static final int QUERY_RECORD = 0;\n\n    private static final int QUERY_IDENTIFIER = 1;\n\n    private static final int QUERY_SET = 2;\n\n    private final HEALProviderConfig config;\n\n    private final DataSource dataSource;\n\n    private Connection conn = null;\n\n    private ResultSet resultSet = null;\n\n    private PreparedStatement stmt = null;\n\n    private long recordsReturned;\n\n    private MetadataDAO metadataDAO = null;\n\n    private int queryType = -1;\n\n    private String metadataPrefix = null;\n\n    private Date from = null;\n\n    private Date until = null;\n\n    private String set = null;\n\n    private String nextID = null;\n\n    private boolean hasRows = false;\n\n    private boolean moveForwardOnNext = true;\n\n    //set to true if this query was resumed via a resumptionToken\n    //in this case an empty resumptionToken MUST be returned at\n    //the end of the query\n    private boolean resumedQuery = false;\n\n    private static final String BASE_RECORD_QUERY = \"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String RESUMPTION_QUERY = \" AND MetadataID > ?\";\n\n    private static final String FROM_QUERY = \" AND CatalogDate >= ?\";\n\n    private static final String UNTIL_QUERY = \" AND CatalogDate <= ?\";\n\n    private static final String FROM_UNTIL_QUERY = \" AND CatalogDate >= ? AND CatalogDate <= ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_START = \" AND (SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_MIDDLE = \" OR SourceCollection = ?\";\n\n    private static final String SOURCE_COLLECTION_FILTER_END = \")\";\n\n    private static final String BASE_IDENTIFIER_QUERY = \"SELECT MetadataID,GlobalID,CatalogDate from Metadata WHERE Private=0 AND GlobalID is not null AND CatalogDate is not null\";\n\n    private static final String ORDER_QUERY = \" ORDER BY MetadataID\";\n\n    public HEALDataAccessor(final HEALProviderConfig config, final DataSource dataSource) {\n        this.config = config;\n        this.dataSource = dataSource;\n        catalogFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        metadataDAO = new MetadataDAO();\n        metadataDAO.setDataSource(this.dataSource);\n    }\n\n    public OAIResumptionToken parseResumptionToken(final String resumptionToken) {\n        //returns null if the token is poorly formatted\n        return BasicResumptionToken.parseResumptionToken(resumptionToken, config.getGranularity());\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openRecordsQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        //right now we don't differentiate on metadataPrefix. the prefixes we do support, we support for\n        //all records\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_RECORD_QUERY);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#openRecordsQuery(java.lang.String)\n\t */\n    public void openRecordsQuery(final String identifier) {\n        queryType = HEALDataAccessor.QUERY_RECORD;\n        //XXX this is an ugly hack, need to get better aquainted with\n        //working with HEAL infrastructure to avoid having to do two queries\n        String idPrefix = config.getIDPrefix();\n        int prefixIndex = identifier.indexOf(idPrefix);\n        if (prefixIndex >= 0) {\n            String globalId = identifier.substring(prefixIndex + idPrefix.length());\n            try {\n                conn = dataSource.getConnection();\n                stmt = conn.prepareStatement(\"SELECT MetadataID from Metadata WHERE Private=0 AND GlobalID=?\", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setString(1, globalId);\n                resultSet = stmt.executeQuery();\n                hasRows = resultSet.next();\n                moveForwardOnNext = false;\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"OpenRecordsQuery (id) ResultSet returned=\" + hasRows);\n                    System.out.println(\"*******************************************\");\n                }\n                recordsReturned = 0;\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting single record query:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getIdentifiersQuery(java.util.Date, java.util.Date, java.lang.String)\n\t */\n    public void openIdentifiersQuery(final String metadataPrefix, final Date from, final Date until, final String set) {\n        this.metadataPrefix = metadataPrefix;\n        this.from = from;\n        this.until = until;\n        this.set = set;\n        nextID = null;\n        queryType = HEALDataAccessor.QUERY_IDENTIFIER;\n        // -1 means that we are doing a new query, not a resumption\n        openQuery(BASE_IDENTIFIER_QUERY);\n    }\n\n    public void openSetQuery() {\n        //does nothing since we don't support sets\n        queryType = HEALDataAccessor.QUERY_SET;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeRecordQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_RECORD;\n        openQuery(BASE_RECORD_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeSetQuery(final OAIResumptionToken resumptionToken) {\n        //HEALDataAccessor does not support sets.\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean resumeIdentifierQuery(final OAIResumptionToken resumptionToken) {\n        resumeQuery(resumptionToken);\n        queryType = QUERY_IDENTIFIER;\n        openQuery(BASE_IDENTIFIER_QUERY);\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#resumeQuery(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    private void resumeQuery(final OAIResumptionToken resumptionToken) {\n        resumedQuery = true;\n        BasicResumptionToken brt = (BasicResumptionToken) resumptionToken;\n        int resumptionID = Integer.parseInt(brt.getNextID());\n        metadataPrefix = brt.getMetadataPrefix();\n        from = brt.getFrom();\n        until = brt.getUntil();\n        set = brt.getSet();\n        nextID = brt.getNextID();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentIdentifier()\n\t */\n    public OAIRecord getNextIdentifier() {\n        OAIRecord result = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String oaiid = null;\n                    if (isIdentifierValid(resultSet.getString(\"GlobalD\"))) {\n                        oaiid = config.getIDPrefix() + resultSet.getString(\"GlobalID\");\n                    }\n                    Date dateDate = catalogFormatter.parse(resultSet.getString(\"CatalogDate\"));\n                    result = new HEALRecord(oaiid, dateDate, config);\n                    if (result.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next identifier:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured getting next identifier:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getCurrentRecord()\n\t */\n    public OAIRecord getNextRecord() {\n        OAIRecord retval = null;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD)) {\n            try {\n                if (!moveForwardOnNext) {\n                    //we just do this for the first row to see if we have any rows\n                    //in order to be able to return the appropriate value for\n                    //hasMoreElements\n                    moveForwardOnNext = true;\n                } else {\n                    hasRows = resultSet.next();\n                }\n                if (hasRows) {\n                    String metadataId = resultSet.getString(\"MetadataID\");\n                    CompleteMetadataBean metadata = metadataDAO.getCompleteMetadata(metadataId);\n                    Date dateStamp = metadata.getCatalogDate();\n                    String identifier = null;\n                    if (isIdentifierValid(metadata.getGlobalId())) {\n                        identifier = config.getIDPrefix() + metadata.getGlobalId();\n                    }\n                    retval = new HEALRecord(metadata, config, identifier, dateStamp);\n                    if (retval.checkIsValid()) {\n                        recordsReturned++;\n                    }\n                }\n            } catch (ParseException ex2) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured parsing date for next record:\");\n                    ex2.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            } catch (SQLException ex) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured getting next record:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n                cleanupAfterQuery();\n            }\n        }\n        return retval;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#hasMoreElements()\n\t */\n    public boolean hasMoreElements() {\n        boolean result = false;\n        if (resultSet != null && hasRows && (queryType == HEALDataAccessor.QUERY_RECORD || queryType == HEALDataAccessor.QUERY_IDENTIFIER)) {\n            try {\n                if (moveForwardOnNext) {\n                    result = !resultSet.isAfterLast();\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements !ResultSet.isAfterLast returned=\" + result);\n                        System.out.println(\"*******************************************\");\n                    }\n                } else {\n                    //we know this is true because we just performed\n                    //the query (moveForwardOnNext == false),\n                    // and we have results (hasRows == true)\n                    result = true;\n                    if (HEALDataAccessor.debug) {\n                        System.out.println(\"*******************************************\");\n                        System.out.println(\"hasMoreElements moveForwardOnNext was false\");\n                        System.out.println(\"*******************************************\");\n                    }\n                }\n            } catch (SQLException ex) {\n                if (HEALDataAccessor.debug) {\n                    System.out.println(\"*******************************************\");\n                    System.out.println(\"Error occured checking afterLast:\");\n                    ex.printStackTrace();\n                    System.out.println(\"*******************************************\");\n                }\n                cleanupAfterQuery();\n            }\n        }\n        return result;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getResumptionToken()\n\t */\n    public OAIResumptionToken getResumptionToken() {\n        try {\n            if (queryType != HEALDataAccessor.QUERY_SET) {\n                int threshold = config.getResumptionThreshold();\n                if ((threshold > 0) && (recordsReturned >= threshold) && !resultSet.isAfterLast()) {\n                    nextID = Integer.toString(resultSet.getInt(\"MetadataID\"));\n                    BasicResumptionToken resumptionToken = BasicResumptionToken.generateResumptionToken(metadataPrefix, from, until, set, nextID, config.getGranularity());\n                    resumptionToken.setCursor(recordsReturned);\n                    return resumptionToken;\n                }\n            }\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured while creating resumption token:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#closeQuery()\n\t */\n    public void closeQuery() {\n        //no work to do yet\n        cleanupAfterQuery();\n    }\n\n    public Date getNow() {\n        // TODO HEALDataAccessor.getNow\n        return new Date();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getMetadataFormats(java.lang.String)\n\t */\n    public OAIMetadataFormat[] getMetadataFormats(final String identifier) {\n        //first check to see if the id exists...\n        if (identifier != null) {\n            openRecordsQuery(identifier);\n            if (!hasMoreElements()) {\n                //can't find the record\n                closeQuery();\n                return null;\n            }\n            closeQuery();\n        }\n        //if it doesn't exist, return null\n        //otherwise, return all formats (we're not selective yet)\n        return config.getAllMetadataFormats();\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateIdentifier(java.lang.String)\n\t * we check to see if it starts correctly and whether or not there is a space or a paren\n\t * either of which would be necessary to insert a malicious SQL query\n\t */\n    public boolean validateIdentifier(final String identifier) {\n        return (identifier.startsWith(config.getIDPrefix()) && (identifier.indexOf(' ') == -1) && (identifier.indexOf('(') == -1));\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#validateSet(java.lang.String)\n\t */\n    public boolean validateSet(final String set) {\n        //HEAL does not currently support sets, so there should never be a set parameter to validate\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#isExpired(org.heal.module.oai.provider.OAIResumptionToken)\n\t */\n    public boolean isExpired(final OAIResumptionToken resumptionToken) {\n        Date resumptionDate = resumptionToken.getExpirationDate();\n        if (resumptionDate != null) {\n            if (getNow().getTime() < resumptionDate.getTime()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#getNextSet()\n\t */\n    public OAISet getNextSet() {\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.DataAccessor#setExists(java.lang.String)\n\t */\n    public boolean setExists(final String set) {\n        //we don't support sets\n        return false;\n    }\n\n    /*\n\t * uses the base select statement and a potential resumptionID (should be\n\t * -1 if we aren't resuming) to generate and dispatch the sql query\n\t */\n    private void openQuery(final String baseQuery) {\n        try {\n            conn = dataSource.getConnection();\n            String resumptionString = \"\";\n            int numArguments = 0;\n            int resumptionID = -1;\n            if (nextID != null) {\n                resumptionString = RESUMPTION_QUERY;\n                resumptionID = Integer.parseInt(nextID);\n            }\n            String finalQuery;\n            String[] sourceCollections = config.getAllowedCollections();\n            String sourceCollectionFilter = \"\";\n            if (sourceCollections != null) {\n                StringBuffer colls = new StringBuffer();\n                colls.append(SOURCE_COLLECTION_FILTER_START);\n                //we already had one for the first element, so\n                //we start with the second\n                for (int i = 1; i < sourceCollections.length; i++) {\n                    colls.append(SOURCE_COLLECTION_FILTER_MIDDLE);\n                }\n                colls.append(SOURCE_COLLECTION_FILTER_END);\n                sourceCollectionFilter = colls.toString();\n            }\n            if (from != null && until != null) {\n                finalQuery = baseQuery + FROM_UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                stmt.setDate(2, new java.sql.Date(until.getTime()));\n                numArguments = 2;\n            } else if (from != null) {\n                finalQuery = baseQuery + FROM_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(from.getTime()));\n                numArguments = 1;\n            } else if (until != null) {\n                finalQuery = baseQuery + UNTIL_QUERY + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                stmt.setDate(1, new java.sql.Date(until.getTime()));\n                numArguments = 1;\n            } else {\n                finalQuery = baseQuery + resumptionString + sourceCollectionFilter + ORDER_QUERY;\n                stmt = conn.prepareStatement(finalQuery, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n                numArguments = 0;\n            }\n            if (resumptionID >= 0) {\n                numArguments++;\n                stmt.setInt(numArguments, resumptionID);\n            }\n            if (sourceCollections != null) {\n                for (int i = 0; i < sourceCollections.length; i++) {\n                    //okay, so we've already added one past the num of args, so\n                    //we need to add two plus the index here\n                    numArguments++;\n                    stmt.setString(numArguments, sourceCollections[i]);\n                }\n            }\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Executing SQL query [\" + finalQuery + \"], metadata id=\" + resumptionID);\n            }\n            resultSet = stmt.executeQuery();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"Query returned\");\n            }\n            hasRows = resultSet.next();\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"hasRows=\" + hasRows);\n            }\n            moveForwardOnNext = false;\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"openQuery(base) ResultSet returned=\" + hasRows);\n                System.out.println(\"*******************************************\");\n            }\n            recordsReturned = 0;\n        } catch (SQLException ex) {\n            if (HEALDataAccessor.debug) {\n                System.out.println(\"*******************************************\");\n                System.out.println(\"Error occured opening query:\");\n                ex.printStackTrace();\n                System.out.println(\"*******************************************\");\n            }\n            cleanupAfterQuery();\n        }\n    }\n\n    private boolean isIdentifierValid(String identifier) {\n        return !(identifier == null || \"null\".equalsIgnoreCase(identifier) || \"<null>\".equalsIgnoreCase(identifier));\n    }\n\n    private void cleanupAfterQuery() {\n        hasRows = false;\n        recordsReturned = 0;\n        moveForwardOnNext = true;\n        nextID = null;\n        from = null;\n        until = null;\n        metadataPrefix = null;\n        set = null;\n        queryType = -1;\n        if (resultSet != null) {\n            try {\n                resultSet.close();\n                resultSet = null;\n            } catch (SQLException ex3) {\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n                stmt = null;\n            } catch (SQLException ex2) {\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n                conn = null;\n            } catch (SQLException ex2) {\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALDataAccessorTest7.java",
		"test_prompt": "// HEALDataAccessorTest7.java\npackage org.heal.module.oai.heal;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport javax.sql.DataSource;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.module.oai.provider.DataAccessor;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIResumptionToken;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.basic.BasicResumptionToken;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALDataAccessor}.\n* It contains ten unit test cases for the {@link HEALDataAccessor#isExpired(OAIResumptionToken)} method.\n*/\nclass HEALDataAccessorTest7 {"
	},
	{
		"original_code": "// HEALNSDLQDCRecordAdapter.java\n/*\n * Created on Apr 10, 2005\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCHandler;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\n/**\n * @author swright\n */\npublic class HEALNSDLQDCRecordAdapter implements NSDL_QDCRecordAdapter {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    public HEALNSDLQDCRecordAdapter(final CompleteMetadataBean metadataBean, final HEALProviderConfig config) {\n        this.metadataBean = metadataBean;\n        this.config = config;\n    }\n\n    public boolean hasOAIAbout() {\n        return false;\n    }\n\n    public boolean hasCustomAbout() {\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#hasNSDLAbout()\n\t */\n    public boolean hasNSDLAbout() {\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#addRecordAttributes(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void addRecordAttributes(Element recordElem, Document doc) {\n        recordElem.setAttribute(\"xmlns:\" + HEALXMLHelper.HEALNS, HEALXMLHelper.HEALLOC);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecordAdapter#addCustomAbout(org.w3c.dom.Document)\n\t */\n    public void addCustomAbout(Document doc) {\n        HEALXMLHelper.addCustomAbout(metadataBean, config, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#addOAIAboutAttributes(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void addOAIAboutAttributes(Element recordElem, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendOAIAboutElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendOAIAboutElements(Element recordElement, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendIdentifierElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendIdentifierElements(Element recordElement, Document doc) {\n        String location = metadataBean.getLocation();\n        if (location != null && !location.startsWith(\"http://\")) {\n            location = config.getContentPrefix() + '/' + location;\n        }\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":identifier\", location, recordElement, doc);\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":identifier\", metadataBean.getGlobalId(), recordElement, doc);\n        /*\nXXX TODO: fill in catalog and entry\n\t\tGeneral CatalogEntry Catalogue = Location in the Metadata table; the default is http://www.healcentral.org; but some resources have other URLs, such as http://medstat.med.utah.edu/kw or http://www.nlm.nih.gov/medlineplus\n\t\tGeneral CatalogEntry Entry = GlobalID from the Metadata table; this isn't technically accurate, but we haven't used IDs from the local catalogs\n*/\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTitleElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTitleElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":title\", metadataBean.getTitle(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendSubjectElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendSubjectElements(Element recordElement, Document doc) {\n        Collection taxonpaths = metadataBean.getTaxonPaths();\n        Iterator iter = taxonpaths.iterator();\n        TaxonPathBean tpb;\n        TaxonBean tb;\n        while (iter.hasNext()) {\n            tpb = (TaxonPathBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tpb.getSource(), recordElement, doc);\n            Collection taxons = tpb.getTaxons();\n            Iterator titer = taxons.iterator();\n            while (titer.hasNext()) {\n                tb = (TaxonBean) titer.next();\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tb.getId(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tb.getEntry(), recordElement, doc);\n            }\n        }\n        Collection keywords = metadataBean.getKeywords();\n        iter = keywords.iterator();\n        KeywordBean kb;\n        while (iter.hasNext()) {\n            kb = (KeywordBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", kb.getKeyword(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendEducationLevelElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendEducationLevelElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //context\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendInteractivityTypeElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendInteractivityTypeElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //interactivity type\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendInteractivityLevelElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendInteractivityLevelElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //interactivity level\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTypicalLearningTimeElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTypicalLearningTimeElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //typical learning time\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendContributorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendContributorElements(Element recordElement, Document doc) {\n        Collection contributors = metadataBean.getContributorList();\n        Iterator iter = contributors.iterator();\n        ContributorBean contributor;\n        String role, type = null;\n        while (iter.hasNext()) {\n            contributor = (ContributorBean) iter.next();\n            role = contributor.getRole();\n            type = null;\n            if (\"primary\".equals(role)) {\n                type = \":creator\";\n            } else if (\"secondary\".equals(role)) {\n                type = \":contributor\";\n            } else if (\"Content Provider\".equals(role)) {\n                type = \":publisher\";\n            }\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + type, \"Role: \" + role, recordElement, doc);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + type, contributor.getVCard(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendCoverageElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendCoverageElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":coverage\", config.getCoverage(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendCreateorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendCreateorElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //lifecycle contribute role\n        //if role is primary, then also lifecycle contribute centity\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDateElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDateElements(Element recordElement, Document doc) {\n        Date contributeDate = metadataBean.getContributeDate();\n        if (contributeDate != null) {\n            String dateStr = OAIGranularity.yearMonthDayHourMinuteSecond.format(contributeDate);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":date\", dateStr, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDescriptionElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDescriptionElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", metadataBean.getDescription(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Specimen Type\", metadataBean.getSpecimenType(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Orientation\", metadataBean.getOrientation(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Magnification\", metadataBean.getMagnification(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Annotated\", metadataBean.getAnnotated(), recordElement, doc);\n        Collection diagnoses = metadataBean.getDiseaseDiagnoses();\n        if (diagnoses != null) {\n            DiseaseDiagnosisBean value = null;\n            Iterator iter = diagnoses.iterator();\n            while (iter.hasNext()) {\n                value = (DiseaseDiagnosisBean) iter.next();\n                HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Disease diagnosis\", value.getDiseaseDiagnosis(), recordElement, doc);\n            }\n        }\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Clinical history\", metadataBean.getClinicalHistory(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Radiograph type\", metadataBean.getRadiographType(), recordElement, doc);\n        Collection urls = metadataBean.getContextURLs();\n        if (urls != null) {\n            Iterator iter = urls.iterator();\n            ContextURLBean value = null;\n            while (iter.hasNext()) {\n                value = (ContextURLBean) iter.next();\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", value.getContextURL(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", value.getContextURLDescription(), recordElement, doc);\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendFormatElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendFormatElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", metadataBean.getFileExtension(), recordElement, doc);\n        String width = metadataBean.getFileWidth();\n        String height = metadataBean.getFileHeight();\n        if (width != null && !\"0\".equals(width) && height != null && !\"0\".equals(height)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", width + \" x \" + height + \" pixels\", recordElement, doc);\n        }\n        String fileSize = metadataBean.getFileSize();\n        if (fileSize != null && !\"0\".equals(fileSize)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", fileSize + \" bytes\", recordElement, doc);\n        }\n        String duration = metadataBean.getDuration();\n        if (duration != null && !\"0\".equals(duration)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", duration + \" seconds\", recordElement, doc);\n        }\n        Collection list = metadataBean.getRequirements();\n        Iterator iter = list.iterator();\n        RequirementBean rb;\n        while (iter.hasNext()) {\n            rb = (RequirementBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", rb.getRequirementType() + \": \" + rb.getRequirementName(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendLanguageElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendLanguageElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendPublisherElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendPublisherElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendRelationElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendRelationElements(Element recordElement, Document doc) {\n        Collection relations = metadataBean.getRelations();\n        Iterator iter = relations.iterator();\n        RelationBean rb;\n        while (iter.hasNext()) {\n            rb = (RelationBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":relation\", rb.getKind(), recordElement, doc);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":relation\", rb.getDescription(), recordElement, doc);\n            //XXX TODO this next line needs to have the relation lookup tweaked to include the GlobalID of\n            //the resource...and to lookup the resource's catalog entries and catalog\n            //\t\t\tHEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS+\":relation\",rb.getResource(),recordElement,doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendRightsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendRightsElements(Element recordElement, Document doc) {\n        Collection col = metadataBean.getCopyrights();\n        Iterator iter = col.iterator();\n        CopyrightBean cb;\n        CopyrightTextBean ctb;\n        while (iter.hasNext()) {\n            cb = (CopyrightBean) iter.next();\n            ctb = cb.getCopyrightText();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":rights\", ctb.getCopyrightText(), recordElement, doc);\n        }\n        col = metadataBean.getCopyrightHolders();\n        iter = col.iterator();\n        CopyrightHolderBean chb;\n        String fullName;\n        while (iter.hasNext()) {\n            chb = (CopyrightHolderBean) iter.next();\n            fullName = HEALXMLHelper.getFullNameFromVCard(chb.getVCard());\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":rights\", fullName, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendSourceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendSourceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTypeElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTypeElements(Element recordElement, Document doc) {\n        Collection formats = metadataBean.getFormats();\n        Iterator iter = formats.iterator();\n        FormatBean fb;\n        while (iter.hasNext()) {\n            fb = (FormatBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":type\", fb.getFormat(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccessibilityElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccessibilityElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualMethodElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualMethodElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualPeriodicityElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualPeriodicityElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualPolicyElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualPolicyElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAudienceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAudienceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTMediatorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTMediatorElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTEducationLevelElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTEducationLevelElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTSpatialElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTSpatialElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTTemporalElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTTemporalElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAvailableElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAvailableElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTCreatedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTCreatedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateAcceptedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateAcceptedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateCopyrightedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateCopyrightedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateSubmittedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateSubmittedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIssuedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIssuedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTModifiedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTModifiedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTValidElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTValidElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAbstractElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAbstractElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTTableOfContentsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTTableOfContentsElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTExtentElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTExtentElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTMediumElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTMediumElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTBibliograhicCitationElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTBibliograhicCitationElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTInstructionalMethodElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTInstructionalMethodElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTProvenanceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTProvenanceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTConformsToElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTConformsToElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsFormatOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsFormatOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasFormatElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasFormatElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsPartOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsPartOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasPartElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasPartElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsReferencedByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsReferencedByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTReferencesElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTReferencesElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsReplacedByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsReplacedByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTReplacesElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTReplacesElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsRequiredByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsRequiredByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTRequiresElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTRequiresElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsVersionOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsVersionOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasVersionElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasVersionElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccessRightsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccessRightsElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTLicenseElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTLicenseElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTRightsHolderElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTRightsHolderElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAlternativeElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAlternativeElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALNSDLQDCRecordAdapterTest0.java",
		"test_prompt": "// HEALNSDLQDCRecordAdapterTest0.java\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCHandler;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALNSDLQDCRecordAdapter}.\n* It contains ten unit test cases for the {@link HEALNSDLQDCRecordAdapter#hasOAIAbout()} method.\n*/\nclass HEALNSDLQDCRecordAdapterTest0 {"
	},
	{
		"original_code": "// HEALNSDLQDCRecordAdapter.java\n/*\n * Created on Apr 10, 2005\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCHandler;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\n/**\n * @author swright\n */\npublic class HEALNSDLQDCRecordAdapter implements NSDL_QDCRecordAdapter {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    public HEALNSDLQDCRecordAdapter(final CompleteMetadataBean metadataBean, final HEALProviderConfig config) {\n        this.metadataBean = metadataBean;\n        this.config = config;\n    }\n\n    public boolean hasOAIAbout() {\n        return false;\n    }\n\n    public boolean hasCustomAbout() {\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#hasNSDLAbout()\n\t */\n    public boolean hasNSDLAbout() {\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#addRecordAttributes(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void addRecordAttributes(Element recordElem, Document doc) {\n        recordElem.setAttribute(\"xmlns:\" + HEALXMLHelper.HEALNS, HEALXMLHelper.HEALLOC);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecordAdapter#addCustomAbout(org.w3c.dom.Document)\n\t */\n    public void addCustomAbout(Document doc) {\n        HEALXMLHelper.addCustomAbout(metadataBean, config, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#addOAIAboutAttributes(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void addOAIAboutAttributes(Element recordElem, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendOAIAboutElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendOAIAboutElements(Element recordElement, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendIdentifierElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendIdentifierElements(Element recordElement, Document doc) {\n        String location = metadataBean.getLocation();\n        if (location != null && !location.startsWith(\"http://\")) {\n            location = config.getContentPrefix() + '/' + location;\n        }\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":identifier\", location, recordElement, doc);\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":identifier\", metadataBean.getGlobalId(), recordElement, doc);\n        /*\nXXX TODO: fill in catalog and entry\n\t\tGeneral CatalogEntry Catalogue = Location in the Metadata table; the default is http://www.healcentral.org; but some resources have other URLs, such as http://medstat.med.utah.edu/kw or http://www.nlm.nih.gov/medlineplus\n\t\tGeneral CatalogEntry Entry = GlobalID from the Metadata table; this isn't technically accurate, but we haven't used IDs from the local catalogs\n*/\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTitleElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTitleElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":title\", metadataBean.getTitle(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendSubjectElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendSubjectElements(Element recordElement, Document doc) {\n        Collection taxonpaths = metadataBean.getTaxonPaths();\n        Iterator iter = taxonpaths.iterator();\n        TaxonPathBean tpb;\n        TaxonBean tb;\n        while (iter.hasNext()) {\n            tpb = (TaxonPathBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tpb.getSource(), recordElement, doc);\n            Collection taxons = tpb.getTaxons();\n            Iterator titer = taxons.iterator();\n            while (titer.hasNext()) {\n                tb = (TaxonBean) titer.next();\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tb.getId(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tb.getEntry(), recordElement, doc);\n            }\n        }\n        Collection keywords = metadataBean.getKeywords();\n        iter = keywords.iterator();\n        KeywordBean kb;\n        while (iter.hasNext()) {\n            kb = (KeywordBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", kb.getKeyword(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendEducationLevelElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendEducationLevelElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //context\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendInteractivityTypeElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendInteractivityTypeElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //interactivity type\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendInteractivityLevelElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendInteractivityLevelElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //interactivity level\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTypicalLearningTimeElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTypicalLearningTimeElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //typical learning time\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendContributorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendContributorElements(Element recordElement, Document doc) {\n        Collection contributors = metadataBean.getContributorList();\n        Iterator iter = contributors.iterator();\n        ContributorBean contributor;\n        String role, type = null;\n        while (iter.hasNext()) {\n            contributor = (ContributorBean) iter.next();\n            role = contributor.getRole();\n            type = null;\n            if (\"primary\".equals(role)) {\n                type = \":creator\";\n            } else if (\"secondary\".equals(role)) {\n                type = \":contributor\";\n            } else if (\"Content Provider\".equals(role)) {\n                type = \":publisher\";\n            }\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + type, \"Role: \" + role, recordElement, doc);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + type, contributor.getVCard(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendCoverageElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendCoverageElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":coverage\", config.getCoverage(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendCreateorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendCreateorElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //lifecycle contribute role\n        //if role is primary, then also lifecycle contribute centity\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDateElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDateElements(Element recordElement, Document doc) {\n        Date contributeDate = metadataBean.getContributeDate();\n        if (contributeDate != null) {\n            String dateStr = OAIGranularity.yearMonthDayHourMinuteSecond.format(contributeDate);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":date\", dateStr, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDescriptionElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDescriptionElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", metadataBean.getDescription(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Specimen Type\", metadataBean.getSpecimenType(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Orientation\", metadataBean.getOrientation(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Magnification\", metadataBean.getMagnification(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Annotated\", metadataBean.getAnnotated(), recordElement, doc);\n        Collection diagnoses = metadataBean.getDiseaseDiagnoses();\n        if (diagnoses != null) {\n            DiseaseDiagnosisBean value = null;\n            Iterator iter = diagnoses.iterator();\n            while (iter.hasNext()) {\n                value = (DiseaseDiagnosisBean) iter.next();\n                HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Disease diagnosis\", value.getDiseaseDiagnosis(), recordElement, doc);\n            }\n        }\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Clinical history\", metadataBean.getClinicalHistory(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Radiograph type\", metadataBean.getRadiographType(), recordElement, doc);\n        Collection urls = metadataBean.getContextURLs();\n        if (urls != null) {\n            Iterator iter = urls.iterator();\n            ContextURLBean value = null;\n            while (iter.hasNext()) {\n                value = (ContextURLBean) iter.next();\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", value.getContextURL(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", value.getContextURLDescription(), recordElement, doc);\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendFormatElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendFormatElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", metadataBean.getFileExtension(), recordElement, doc);\n        String width = metadataBean.getFileWidth();\n        String height = metadataBean.getFileHeight();\n        if (width != null && !\"0\".equals(width) && height != null && !\"0\".equals(height)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", width + \" x \" + height + \" pixels\", recordElement, doc);\n        }\n        String fileSize = metadataBean.getFileSize();\n        if (fileSize != null && !\"0\".equals(fileSize)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", fileSize + \" bytes\", recordElement, doc);\n        }\n        String duration = metadataBean.getDuration();\n        if (duration != null && !\"0\".equals(duration)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", duration + \" seconds\", recordElement, doc);\n        }\n        Collection list = metadataBean.getRequirements();\n        Iterator iter = list.iterator();\n        RequirementBean rb;\n        while (iter.hasNext()) {\n            rb = (RequirementBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", rb.getRequirementType() + \": \" + rb.getRequirementName(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendLanguageElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendLanguageElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendPublisherElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendPublisherElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendRelationElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendRelationElements(Element recordElement, Document doc) {\n        Collection relations = metadataBean.getRelations();\n        Iterator iter = relations.iterator();\n        RelationBean rb;\n        while (iter.hasNext()) {\n            rb = (RelationBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":relation\", rb.getKind(), recordElement, doc);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":relation\", rb.getDescription(), recordElement, doc);\n            //XXX TODO this next line needs to have the relation lookup tweaked to include the GlobalID of\n            //the resource...and to lookup the resource's catalog entries and catalog\n            //\t\t\tHEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS+\":relation\",rb.getResource(),recordElement,doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendRightsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendRightsElements(Element recordElement, Document doc) {\n        Collection col = metadataBean.getCopyrights();\n        Iterator iter = col.iterator();\n        CopyrightBean cb;\n        CopyrightTextBean ctb;\n        while (iter.hasNext()) {\n            cb = (CopyrightBean) iter.next();\n            ctb = cb.getCopyrightText();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":rights\", ctb.getCopyrightText(), recordElement, doc);\n        }\n        col = metadataBean.getCopyrightHolders();\n        iter = col.iterator();\n        CopyrightHolderBean chb;\n        String fullName;\n        while (iter.hasNext()) {\n            chb = (CopyrightHolderBean) iter.next();\n            fullName = HEALXMLHelper.getFullNameFromVCard(chb.getVCard());\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":rights\", fullName, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendSourceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendSourceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTypeElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTypeElements(Element recordElement, Document doc) {\n        Collection formats = metadataBean.getFormats();\n        Iterator iter = formats.iterator();\n        FormatBean fb;\n        while (iter.hasNext()) {\n            fb = (FormatBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":type\", fb.getFormat(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccessibilityElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccessibilityElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualMethodElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualMethodElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualPeriodicityElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualPeriodicityElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualPolicyElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualPolicyElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAudienceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAudienceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTMediatorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTMediatorElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTEducationLevelElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTEducationLevelElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTSpatialElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTSpatialElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTTemporalElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTTemporalElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAvailableElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAvailableElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTCreatedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTCreatedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateAcceptedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateAcceptedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateCopyrightedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateCopyrightedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateSubmittedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateSubmittedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIssuedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIssuedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTModifiedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTModifiedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTValidElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTValidElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAbstractElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAbstractElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTTableOfContentsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTTableOfContentsElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTExtentElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTExtentElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTMediumElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTMediumElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTBibliograhicCitationElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTBibliograhicCitationElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTInstructionalMethodElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTInstructionalMethodElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTProvenanceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTProvenanceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTConformsToElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTConformsToElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsFormatOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsFormatOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasFormatElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasFormatElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsPartOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsPartOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasPartElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasPartElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsReferencedByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsReferencedByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTReferencesElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTReferencesElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsReplacedByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsReplacedByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTReplacesElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTReplacesElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsRequiredByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsRequiredByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTRequiresElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTRequiresElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsVersionOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsVersionOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasVersionElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasVersionElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccessRightsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccessRightsElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTLicenseElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTLicenseElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTRightsHolderElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTRightsHolderElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAlternativeElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAlternativeElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALNSDLQDCRecordAdapterTest1.java",
		"test_prompt": "// HEALNSDLQDCRecordAdapterTest1.java\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCHandler;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALNSDLQDCRecordAdapter}.\n* It contains ten unit test cases for the {@link HEALNSDLQDCRecordAdapter#hasCustomAbout()} method.\n*/\nclass HEALNSDLQDCRecordAdapterTest1 {"
	},
	{
		"original_code": "// HEALNSDLQDCRecordAdapter.java\n/*\n * Created on Apr 10, 2005\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCHandler;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\n/**\n * @author swright\n */\npublic class HEALNSDLQDCRecordAdapter implements NSDL_QDCRecordAdapter {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    public HEALNSDLQDCRecordAdapter(final CompleteMetadataBean metadataBean, final HEALProviderConfig config) {\n        this.metadataBean = metadataBean;\n        this.config = config;\n    }\n\n    public boolean hasOAIAbout() {\n        return false;\n    }\n\n    public boolean hasCustomAbout() {\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#hasNSDLAbout()\n\t */\n    public boolean hasNSDLAbout() {\n        return false;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#addRecordAttributes(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void addRecordAttributes(Element recordElem, Document doc) {\n        recordElem.setAttribute(\"xmlns:\" + HEALXMLHelper.HEALNS, HEALXMLHelper.HEALLOC);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecordAdapter#addCustomAbout(org.w3c.dom.Document)\n\t */\n    public void addCustomAbout(Document doc) {\n        HEALXMLHelper.addCustomAbout(metadataBean, config, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#addOAIAboutAttributes(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void addOAIAboutAttributes(Element recordElem, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendOAIAboutElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendOAIAboutElements(Element recordElement, Document doc) {\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendIdentifierElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendIdentifierElements(Element recordElement, Document doc) {\n        String location = metadataBean.getLocation();\n        if (location != null && !location.startsWith(\"http://\")) {\n            location = config.getContentPrefix() + '/' + location;\n        }\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":identifier\", location, recordElement, doc);\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":identifier\", metadataBean.getGlobalId(), recordElement, doc);\n        /*\nXXX TODO: fill in catalog and entry\n\t\tGeneral CatalogEntry Catalogue = Location in the Metadata table; the default is http://www.healcentral.org; but some resources have other URLs, such as http://medstat.med.utah.edu/kw or http://www.nlm.nih.gov/medlineplus\n\t\tGeneral CatalogEntry Entry = GlobalID from the Metadata table; this isn't technically accurate, but we haven't used IDs from the local catalogs\n*/\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTitleElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTitleElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":title\", metadataBean.getTitle(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendSubjectElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendSubjectElements(Element recordElement, Document doc) {\n        Collection taxonpaths = metadataBean.getTaxonPaths();\n        Iterator iter = taxonpaths.iterator();\n        TaxonPathBean tpb;\n        TaxonBean tb;\n        while (iter.hasNext()) {\n            tpb = (TaxonPathBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tpb.getSource(), recordElement, doc);\n            Collection taxons = tpb.getTaxons();\n            Iterator titer = taxons.iterator();\n            while (titer.hasNext()) {\n                tb = (TaxonBean) titer.next();\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tb.getId(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", tb.getEntry(), recordElement, doc);\n            }\n        }\n        Collection keywords = metadataBean.getKeywords();\n        iter = keywords.iterator();\n        KeywordBean kb;\n        while (iter.hasNext()) {\n            kb = (KeywordBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":subject\", kb.getKeyword(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendEducationLevelElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendEducationLevelElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //context\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendInteractivityTypeElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendInteractivityTypeElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //interactivity type\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendInteractivityLevelElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendInteractivityLevelElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //interactivity level\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTypicalLearningTimeElement(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTypicalLearningTimeElement(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //typical learning time\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendContributorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendContributorElements(Element recordElement, Document doc) {\n        Collection contributors = metadataBean.getContributorList();\n        Iterator iter = contributors.iterator();\n        ContributorBean contributor;\n        String role, type = null;\n        while (iter.hasNext()) {\n            contributor = (ContributorBean) iter.next();\n            role = contributor.getRole();\n            type = null;\n            if (\"primary\".equals(role)) {\n                type = \":creator\";\n            } else if (\"secondary\".equals(role)) {\n                type = \":contributor\";\n            } else if (\"Content Provider\".equals(role)) {\n                type = \":publisher\";\n            }\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + type, \"Role: \" + role, recordElement, doc);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + type, contributor.getVCard(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendCoverageElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendCoverageElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":coverage\", config.getCoverage(), recordElement, doc);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendCreateorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendCreateorElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n        //lifecycle contribute role\n        //if role is primary, then also lifecycle contribute centity\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDateElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDateElements(Element recordElement, Document doc) {\n        Date contributeDate = metadataBean.getContributeDate();\n        if (contributeDate != null) {\n            String dateStr = OAIGranularity.yearMonthDayHourMinuteSecond.format(contributeDate);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":date\", dateStr, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDescriptionElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDescriptionElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", metadataBean.getDescription(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Specimen Type\", metadataBean.getSpecimenType(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Orientation\", metadataBean.getOrientation(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Magnification\", metadataBean.getMagnification(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Annotated\", metadataBean.getAnnotated(), recordElement, doc);\n        Collection diagnoses = metadataBean.getDiseaseDiagnoses();\n        if (diagnoses != null) {\n            DiseaseDiagnosisBean value = null;\n            Iterator iter = diagnoses.iterator();\n            while (iter.hasNext()) {\n                value = (DiseaseDiagnosisBean) iter.next();\n                HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Disease diagnosis\", value.getDiseaseDiagnosis(), recordElement, doc);\n            }\n        }\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Clinical history\", metadataBean.getClinicalHistory(), recordElement, doc);\n        HEALXMLHelper.appendTextElemWithDescriptor(NSDL_DCHandler.QDC_NS + \":description\", \"Radiograph type\", metadataBean.getRadiographType(), recordElement, doc);\n        Collection urls = metadataBean.getContextURLs();\n        if (urls != null) {\n            Iterator iter = urls.iterator();\n            ContextURLBean value = null;\n            while (iter.hasNext()) {\n                value = (ContextURLBean) iter.next();\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", value.getContextURL(), recordElement, doc);\n                HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":description\", value.getContextURLDescription(), recordElement, doc);\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendFormatElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendFormatElements(Element recordElement, Document doc) {\n        HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", metadataBean.getFileExtension(), recordElement, doc);\n        String width = metadataBean.getFileWidth();\n        String height = metadataBean.getFileHeight();\n        if (width != null && !\"0\".equals(width) && height != null && !\"0\".equals(height)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", width + \" x \" + height + \" pixels\", recordElement, doc);\n        }\n        String fileSize = metadataBean.getFileSize();\n        if (fileSize != null && !\"0\".equals(fileSize)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", fileSize + \" bytes\", recordElement, doc);\n        }\n        String duration = metadataBean.getDuration();\n        if (duration != null && !\"0\".equals(duration)) {\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", duration + \" seconds\", recordElement, doc);\n        }\n        Collection list = metadataBean.getRequirements();\n        Iterator iter = list.iterator();\n        RequirementBean rb;\n        while (iter.hasNext()) {\n            rb = (RequirementBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":format\", rb.getRequirementType() + \": \" + rb.getRequirementName(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendLanguageElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendLanguageElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendPublisherElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendPublisherElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendRelationElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendRelationElements(Element recordElement, Document doc) {\n        Collection relations = metadataBean.getRelations();\n        Iterator iter = relations.iterator();\n        RelationBean rb;\n        while (iter.hasNext()) {\n            rb = (RelationBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":relation\", rb.getKind(), recordElement, doc);\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":relation\", rb.getDescription(), recordElement, doc);\n            //XXX TODO this next line needs to have the relation lookup tweaked to include the GlobalID of\n            //the resource...and to lookup the resource's catalog entries and catalog\n            //\t\t\tHEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS+\":relation\",rb.getResource(),recordElement,doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendRightsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendRightsElements(Element recordElement, Document doc) {\n        Collection col = metadataBean.getCopyrights();\n        Iterator iter = col.iterator();\n        CopyrightBean cb;\n        CopyrightTextBean ctb;\n        while (iter.hasNext()) {\n            cb = (CopyrightBean) iter.next();\n            ctb = cb.getCopyrightText();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":rights\", ctb.getCopyrightText(), recordElement, doc);\n        }\n        col = metadataBean.getCopyrightHolders();\n        iter = col.iterator();\n        CopyrightHolderBean chb;\n        String fullName;\n        while (iter.hasNext()) {\n            chb = (CopyrightHolderBean) iter.next();\n            fullName = HEALXMLHelper.getFullNameFromVCard(chb.getVCard());\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":rights\", fullName, recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendSourceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendSourceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendTypeElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendTypeElements(Element recordElement, Document doc) {\n        Collection formats = metadataBean.getFormats();\n        Iterator iter = formats.iterator();\n        FormatBean fb;\n        while (iter.hasNext()) {\n            fb = (FormatBean) iter.next();\n            HEALXMLHelper.appendTextElem(NSDL_DCHandler.QDC_NS + \":type\", fb.getFormat(), recordElement, doc);\n        }\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccessibilityElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccessibilityElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualMethodElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualMethodElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualPeriodicityElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualPeriodicityElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccrualPolicyElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccrualPolicyElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAudienceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAudienceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTMediatorElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTMediatorElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTEducationLevelElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTEducationLevelElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTSpatialElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTSpatialElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTTemporalElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTTemporalElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAvailableElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAvailableElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTCreatedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTCreatedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateAcceptedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateAcceptedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateCopyrightedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateCopyrightedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTDateSubmittedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTDateSubmittedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIssuedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIssuedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTModifiedElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTModifiedElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTValidElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTValidElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAbstractElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAbstractElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTTableOfContentsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTTableOfContentsElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTExtentElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTExtentElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTMediumElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTMediumElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTBibliograhicCitationElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTBibliograhicCitationElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTInstructionalMethodElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTInstructionalMethodElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTProvenanceElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTProvenanceElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTConformsToElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTConformsToElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsFormatOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsFormatOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasFormatElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasFormatElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsPartOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsPartOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasPartElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasPartElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsReferencedByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsReferencedByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTReferencesElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTReferencesElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsReplacedByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsReplacedByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTReplacesElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTReplacesElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsRequiredByElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsRequiredByElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTRequiresElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTRequiresElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTIsVersionOfElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTIsVersionOfElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTHasVersionElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTHasVersionElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAccessRightsElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAccessRightsElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTLicenseElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTLicenseElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTRightsHolderElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTRightsHolderElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter#appendDCTAlternativeElements(org.w3c.dom.Element, org.w3c.dom.Document)\n\t */\n    public void appendDCTAlternativeElements(Element recordElement, Document doc) {\n        // TODO Auto-generated method stub\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALNSDLQDCRecordAdapterTest2.java",
		"test_prompt": "// HEALNSDLQDCRecordAdapterTest2.java\npackage org.heal.module.oai.heal;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.ContextURLBean;\nimport org.heal.module.metadata.ContributorBean;\nimport org.heal.module.metadata.CopyrightBean;\nimport org.heal.module.metadata.CopyrightHolderBean;\nimport org.heal.module.metadata.CopyrightTextBean;\nimport org.heal.module.metadata.DiseaseDiagnosisBean;\nimport org.heal.module.metadata.FormatBean;\nimport org.heal.module.metadata.KeywordBean;\nimport org.heal.module.metadata.RelationBean;\nimport org.heal.module.metadata.RequirementBean;\nimport org.heal.module.metadata.TaxonBean;\nimport org.heal.module.metadata.TaxonPathBean;\nimport org.heal.module.oai.provider.OAIGranularity;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCHandler;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_QDCRecordAdapter;\nimport org.heal.util.FileLocator;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALNSDLQDCRecordAdapter}.\n* It contains ten unit test cases for the {@link HEALNSDLQDCRecordAdapter#hasNSDLAbout()} method.\n*/\nclass HEALNSDLQDCRecordAdapterTest2 {"
	},
	{
		"original_code": "// HEALRecord.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCMetadataFormat;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCMetadataFormat;\n\n/**\n * @author Seth Wright\n */\npublic class HEALRecord implements OAIRecord {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    private final Date dateStamp;\n\n    private final String identifier;\n\n    /*\n\t * Throws a parse exception if the catalogdate is invalid \n\t */\n    public HEALRecord(final CompleteMetadataBean metadataBean, final HEALProviderConfig config, String oaiid, Date dateStamp) throws ParseException {\n        this.metadataBean = metadataBean;\n        this.config = config;\n        this.dateStamp = dateStamp;\n        this.identifier = oaiid;\n    }\n\n    public HEALRecord(final String oaiid, final Date dateStamp, final HEALProviderConfig config) throws ParseException {\n        this(null, config, oaiid, dateStamp);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#supportsMetadataFormat(java.lang.String)\n\t */\n    public boolean supportsMetadataFormat(final OAIMetadataFormat format) {\n        //HEAL supports all formats for all records\n        boolean result = false;\n        //as long as we have only a few formats, not hundreds, this is\n        //efficient enough\n        String metadataPrefix = format.getPrefix();\n        OAIMetadataFormat[] formats = config.getAllMetadataFormats();\n        for (int i = 0; i < formats.length && !result; i++) {\n            result = formats[i].getPrefix().equals(metadataPrefix);\n        }\n        return result;\n    }\n\n    /* This is where we evaluate whether or not this record is valid to be returned to the\n\t * end user in the XML.  For instance, we should return false if the identifier is null\n\t * or invalid or whatever future sanity checks need to be put in place.  This filter is\n\t * very slow in comparison to the SQL selects, so preferably such checks would be put there\n\t * but this is a safeguard.\n\t * @see org.heal.module.oai.provider.OAIRecord#checkIsValid()\n\t */\n    public boolean checkIsValid() {\n        if (identifier == null)\n            return false;\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getOAIIdentifier()\n\t */\n    public String getOAIIdentifier() {\n        return identifier;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getDateStamp()\n\t */\n    public Date getDateStamp() {\n        return dateStamp;\n    }\n\n    public OAIRecordAdapter getRecordAdapter(final OAIMetadataFormat format) {\n        if (metadataBean != null) {\n            if (format instanceof OAI_DCMetadataFormat) {\n                //pass in the complete metadata\n                return new HEALOAIDCRecordAdapter(metadataBean, config);\n            } else if (format instanceof NSDL_DCMetadataFormat) {\n                return new HEALNSDLQDCRecordAdapter(metadataBean, config);\n            }\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getSets()\n\t */\n    public OAISet[] getSets() {\n        //we don't support sets yet\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#isDeleted()\n\t */\n    public boolean isDeleted() {\n        //HEAL doesn't support deleted metadata\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALRecordTest0.java",
		"test_prompt": "// HEALRecordTest0.java\npackage org.heal.module.oai.heal;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCMetadataFormat;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCMetadataFormat;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALRecord}.\n* It contains ten unit test cases for the {@link HEALRecord#supportsMetadataFormat(OAIMetadataFormat)} method.\n*/\nclass HEALRecordTest0 {"
	},
	{
		"original_code": "// HEALRecord.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCMetadataFormat;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCMetadataFormat;\n\n/**\n * @author Seth Wright\n */\npublic class HEALRecord implements OAIRecord {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    private final Date dateStamp;\n\n    private final String identifier;\n\n    /*\n\t * Throws a parse exception if the catalogdate is invalid \n\t */\n    public HEALRecord(final CompleteMetadataBean metadataBean, final HEALProviderConfig config, String oaiid, Date dateStamp) throws ParseException {\n        this.metadataBean = metadataBean;\n        this.config = config;\n        this.dateStamp = dateStamp;\n        this.identifier = oaiid;\n    }\n\n    public HEALRecord(final String oaiid, final Date dateStamp, final HEALProviderConfig config) throws ParseException {\n        this(null, config, oaiid, dateStamp);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#supportsMetadataFormat(java.lang.String)\n\t */\n    public boolean supportsMetadataFormat(final OAIMetadataFormat format) {\n        //HEAL supports all formats for all records\n        boolean result = false;\n        //as long as we have only a few formats, not hundreds, this is\n        //efficient enough\n        String metadataPrefix = format.getPrefix();\n        OAIMetadataFormat[] formats = config.getAllMetadataFormats();\n        for (int i = 0; i < formats.length && !result; i++) {\n            result = formats[i].getPrefix().equals(metadataPrefix);\n        }\n        return result;\n    }\n\n    /* This is where we evaluate whether or not this record is valid to be returned to the\n\t * end user in the XML.  For instance, we should return false if the identifier is null\n\t * or invalid or whatever future sanity checks need to be put in place.  This filter is\n\t * very slow in comparison to the SQL selects, so preferably such checks would be put there\n\t * but this is a safeguard.\n\t * @see org.heal.module.oai.provider.OAIRecord#checkIsValid()\n\t */\n    public boolean checkIsValid() {\n        if (identifier == null)\n            return false;\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getOAIIdentifier()\n\t */\n    public String getOAIIdentifier() {\n        return identifier;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getDateStamp()\n\t */\n    public Date getDateStamp() {\n        return dateStamp;\n    }\n\n    public OAIRecordAdapter getRecordAdapter(final OAIMetadataFormat format) {\n        if (metadataBean != null) {\n            if (format instanceof OAI_DCMetadataFormat) {\n                //pass in the complete metadata\n                return new HEALOAIDCRecordAdapter(metadataBean, config);\n            } else if (format instanceof NSDL_DCMetadataFormat) {\n                return new HEALNSDLQDCRecordAdapter(metadataBean, config);\n            }\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getSets()\n\t */\n    public OAISet[] getSets() {\n        //we don't support sets yet\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#isDeleted()\n\t */\n    public boolean isDeleted() {\n        //HEAL doesn't support deleted metadata\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALRecordTest1.java",
		"test_prompt": "// HEALRecordTest1.java\npackage org.heal.module.oai.heal;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCMetadataFormat;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCMetadataFormat;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALRecord}.\n* It contains ten unit test cases for the {@link HEALRecord#checkIsValid()} method.\n*/\nclass HEALRecordTest1 {"
	},
	{
		"original_code": "// HEALRecord.java\n/*\n * Created on Dec 1, 2004\n *\n */\npackage org.heal.module.oai.heal;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCMetadataFormat;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCMetadataFormat;\n\n/**\n * @author Seth Wright\n */\npublic class HEALRecord implements OAIRecord {\n\n    private final CompleteMetadataBean metadataBean;\n\n    private final HEALProviderConfig config;\n\n    private final Date dateStamp;\n\n    private final String identifier;\n\n    /*\n\t * Throws a parse exception if the catalogdate is invalid \n\t */\n    public HEALRecord(final CompleteMetadataBean metadataBean, final HEALProviderConfig config, String oaiid, Date dateStamp) throws ParseException {\n        this.metadataBean = metadataBean;\n        this.config = config;\n        this.dateStamp = dateStamp;\n        this.identifier = oaiid;\n    }\n\n    public HEALRecord(final String oaiid, final Date dateStamp, final HEALProviderConfig config) throws ParseException {\n        this(null, config, oaiid, dateStamp);\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#supportsMetadataFormat(java.lang.String)\n\t */\n    public boolean supportsMetadataFormat(final OAIMetadataFormat format) {\n        //HEAL supports all formats for all records\n        boolean result = false;\n        //as long as we have only a few formats, not hundreds, this is\n        //efficient enough\n        String metadataPrefix = format.getPrefix();\n        OAIMetadataFormat[] formats = config.getAllMetadataFormats();\n        for (int i = 0; i < formats.length && !result; i++) {\n            result = formats[i].getPrefix().equals(metadataPrefix);\n        }\n        return result;\n    }\n\n    /* This is where we evaluate whether or not this record is valid to be returned to the\n\t * end user in the XML.  For instance, we should return false if the identifier is null\n\t * or invalid or whatever future sanity checks need to be put in place.  This filter is\n\t * very slow in comparison to the SQL selects, so preferably such checks would be put there\n\t * but this is a safeguard.\n\t * @see org.heal.module.oai.provider.OAIRecord#checkIsValid()\n\t */\n    public boolean checkIsValid() {\n        if (identifier == null)\n            return false;\n        return true;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getOAIIdentifier()\n\t */\n    public String getOAIIdentifier() {\n        return identifier;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getDateStamp()\n\t */\n    public Date getDateStamp() {\n        return dateStamp;\n    }\n\n    public OAIRecordAdapter getRecordAdapter(final OAIMetadataFormat format) {\n        if (metadataBean != null) {\n            if (format instanceof OAI_DCMetadataFormat) {\n                //pass in the complete metadata\n                return new HEALOAIDCRecordAdapter(metadataBean, config);\n            } else if (format instanceof NSDL_DCMetadataFormat) {\n                return new HEALNSDLQDCRecordAdapter(metadataBean, config);\n            }\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#getSets()\n\t */\n    public OAISet[] getSets() {\n        //we don't support sets yet\n        return null;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.heal.module.oai.provider.OAIRecord#isDeleted()\n\t */\n    public boolean isDeleted() {\n        //HEAL doesn't support deleted metadata\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/oai/heal/HEALRecordTest2.java",
		"test_prompt": "// HEALRecordTest2.java\npackage org.heal.module.oai.heal;\n\nimport java.text.ParseException;\nimport java.util.Date;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.oai.provider.OAIMetadataFormat;\nimport org.heal.module.oai.provider.OAIRecord;\nimport org.heal.module.oai.provider.OAIRecordAdapter;\nimport org.heal.module.oai.provider.OAISet;\nimport org.heal.module.oai.provider.nsdl_dc.NSDL_DCMetadataFormat;\nimport org.heal.module.oai.provider.oai_dc.OAI_DCMetadataFormat;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HEALRecord}.\n* It contains ten unit test cases for the {@link HEALRecord#isDeleted()} method.\n*/\nclass HEALRecordTest2 {"
	},
	{
		"original_code": "// DownloadDAO.java\npackage org.heal.module.download;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.HealMetadataXMLConverter;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * This DAO was created by Grace, its content came from original DownloadServicesBean.java.\n *\n * @author Seth Wright\n * @version 0.1\n * @modify by Grace Yang\n */\npublic class DownloadDAO implements Serializable {\n\n    public static final int ZIPTYPE = 0;\n\n    public static final int GZIPTYPE = 1;\n\n    public static final String ZIPFORMAT = \"application/zip\";\n\n    public static final String GZIPFORMAT = \"application/x-gzip\";\n\n    public static final String ZIPEXTENSION = \".zip\";\n\n    public static final String GZIPEXTENSION = \".gz\";\n\n    public static final String HEALPREFIX = \"heal\";\n\n    //The database to use in order to access the metadata info.\n    private DataSource dataSource;\n\n    private MetadataDAO metadatadao;\n\n    /* The file locator to use to determine where the package\n     * files should be placed.\n     */\n    private FileLocator fileLocator = null;\n\n    /**\n     * Sets the dataSource property value and metadataDAO.\n     * add by Grace\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Sets the utility class to use in determining where the package\n     * files should be placed.\n     */\n    public void setMetadataDAO(MetadataDAO metaDao) {\n        metadatadao = metaDao;\n    }\n\n    /**\n     * Sets the utility class to use in determining where the package\n     * files should be placed.\n     */\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Creates an IMS package of the given file format containing an ims\n     * manifest and the content specified by the download queue.\n     * Returns the url to be used to access the created package.\n     * Currently the only supported format is ZIP.\n     * Accepted fileFormat strings: \"application/zip\" and \"application/x-gzip\"\n     * or you can use the constants (recommended)\n     * DownloadServicesBean.ZIPFORMAT and DownloadServicesBean.GZIPFORMAT\n     * This method also sets the download queue's package file location and\n     * url.  Yes, the return value is slightly redundant.\n     */\n    /**\n     * Creates an IMS package of the given file format containing an ims\n     * manifest and the content specified by the download queue.\n     * Returns the url to be used to access the created package.\n     * Currently the only supported format is ZIP.\n     * Accepted fileFormat strings: \"application/zip\" and \"application/x-gzip\"\n     * or you can use the constants (recommended)\n     * DownloadServicesBean.ZIPFORMAT and DownloadServicesBean.GZIPFORMAT\n     * This method also sets the download queue's package file location and\n     * url.  Yes, the return value is slightly redundant.\n     */\n    public String createPackage(DownloadQueueBean queue, String fileFormat) throws IOException, SQLException {\n        int fileType;\n        if (queue == null || fileFormat == null) {\n            throw new SQLException(\"Missing DownloadQueue or FileFormat\");\n        }\n        if (fileFormat.equals(ZIPFORMAT)) {\n            fileType = ZIPTYPE;\n        } else if (fileFormat.equals(GZIPFORMAT)) {\n            fileType = GZIPTYPE;\n        } else {\n            throw new SQLException(\"Unrecognized package type\");\n        }\n        if (queue.isPackageFileUpToDate(fileType)) {\n            return queue.getPackageURL();\n        }\n        //if we are going to create a new file, then we need to delete\n        //the old one.\n        String packageFileStr = queue.getPackageFileLocation();\n        if (packageFileStr != null) {\n            File aFile = new File(packageFileStr);\n            if (aFile.exists()) {\n                aFile.delete();\n            }\n            queue.clearPackageFileSettings();\n        }\n        File packageFile = getNewPackageFile(queue, fileType);\n        if (packageFile == null) {\n            throw new SQLException(\"Could not create package file\");\n        }\n        CompleteMetadataBean[] metadata = getCompleteMetadata(queue);\n        if (metadata == null) {\n            return null;\n        }\n        FileOutputStream packageStream = new FileOutputStream(packageFile);\n        ZipOutputStream zipStream = new ZipOutputStream(packageStream);\n        zipStream.setMethod(ZipOutputStream.DEFLATED);\n        zipStream.setLevel(Deflater.BEST_COMPRESSION);\n        ZipEntry manifestEntry = new ZipEntry(\"imsmanifest.xml\");\n        manifestEntry.setTime(System.currentTimeMillis());\n        zipStream.putNextEntry(manifestEntry);\n        HealMetadataXMLConverter.getManifestIMSXML(metadata, fileLocator, zipStream);\n        zipStream.closeEntry();\n        String metaLocation;\n        String metaFile;\n        for (int i = 0; i < metadata.length; i++) {\n            metaLocation = metadata[i].getMetadata().getLocation();\n            metaFile = fileLocator.getContentFilePath(metaLocation);\n            addToZip(zipStream, metaFile);\n        }\n        zipStream.close();\n        queue.setPackageFileCreated();\n        return queue.getPackageURL();\n    }\n\n    /**\n     * Gathers all of the metadata ids from the download queue, looks them\n     * up in the database and returns an array of the associated metadata\n     * beans.  If a metadata entry is not found for a content id, then that\n     * that metadata will simply not be added to the return array.\n     */\n    private CompleteMetadataBean[] getCompleteMetadata(DownloadQueueBean queue) throws SQLException {\n        Collection ids = queue.getContentIds();\n        Iterator idsIterator = ids.iterator();\n        String contentId;\n        CompleteMetadataBean metadata;\n        ArrayList metaList = new ArrayList();\n        while (idsIterator.hasNext()) {\n            contentId = (String) idsIterator.next();\n            metadata = metadatadao.getCompleteMetadata(contentId);\n            if (metadata != null) {\n                metaList.add(metadata);\n            }\n        }\n        int numMetadata = metaList.size();\n        CompleteMetadataBean[] array = new CompleteMetadataBean[numMetadata];\n        metaList.toArray(array);\n        return array;\n    }\n\n    /**\n     * Deletes the given package.  The package location is determined from\n     * the url of the package using the FileLocator.\n     */\n    public boolean deletePackage(String packageURL) {\n        if (packageURL == null) {\n            return false;\n        }\n        boolean success = false;\n        String packageFileStr = fileLocator.getFilePathFromURL(packageURL);\n        if (packageFileStr != null) {\n            File packageFile = new File(packageFileStr);\n            success = packageFile.delete();\n        }\n        return success;\n    }\n\n    /**\n     * Returns a file extension for a given format.  The formats are defined\n     * at the beginning of this class.  (zip, gzip) If the format is not\n     * recognized, we return null.\n     */\n    private String getFileSuffix(int format) {\n        switch(format) {\n            case ZIPTYPE:\n                return ZIPEXTENSION;\n            case GZIPTYPE:\n                return GZIPEXTENSION;\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Returns a new temporary name for a package file based on the\n     * provided format.  Right now, the only supported format is ZIP and GZIP,\n     * so all returned filenames will be of the form: <packagepath>/name.zip\n     * or <packagepath>/name.gz\n     * Returns null on an error.\n     * NOTE: This method also sets the downloadQueue's package file location\n     * and URL.\n     */\n    private File getNewPackageFile(DownloadQueueBean queue, int format) throws IOException {\n        File packageDirectory = fileLocator.getPackageDirectoryFile();\n        if (packageDirectory == null) {\n            throw new IOException(\"Could not get File representation of package directory from FileLocator.\");\n        }\n        String suffix = getFileSuffix(format);\n        File packageFile = File.createTempFile(HEALPREFIX, suffix, packageDirectory);\n        String path = packageFile.getCanonicalPath();\n        queue.setPackageFileLocation(path);\n        queue.setPackageFormat(format);\n        queue.setPackageURL(fileLocator.getPackageURL() + packageFile.getName());\n        return packageFile;\n    }\n\n    /**\n     * Adds a file or directory (and its contents) to a zip file.  This\n     * method sets each file's entry in the zip file to have a filepath\n     * relative to the zip file rather than full path entries.  Also, the\n     * zip entry's time value is set to the last modified date of the\n     * file.  addToZip works recursively on a directory to include all of the\n     * files under that directory.\n     */\n    private void addToZip(ZipOutputStream zos, String fileOrFolderPathToBeZip) throws IOException {\n        File fd = new File(fileOrFolderPathToBeZip);\n        if (fd.exists() && fd.isFile()) {\n            // Create a file input stream and a buffered input stream.\n            FileInputStream fis = new FileInputStream(fd);\n            BufferedInputStream bis = new BufferedInputStream(fis);\n            // Create a Zip Entry and put it into the archive(no data yet).\n            // uses the relative path of the entry.\n            ZipEntry fileEntry = new ZipEntry(fileLocator.getRelativePath(fd.getPath()));\n            fileEntry.setTime(fd.lastModified());\n            zos.putNextEntry(fileEntry);\n            byte[] data = new byte[1024];\n            int byteCount;\n            while ((byteCount = bis.read(data, 0, 1024)) > -1) {\n                zos.write(data, 0, byteCount);\n            }\n            try {\n                fis.close();\n            } catch (IOException ex) {\n                //we just want it to close, so ignore the error\n            }\n        } else if (fd.exists() && fd.isDirectory()) {\n            File[] fileList = fd.listFiles();\n            // Loop through File array and display.\n            for (int i = 0; i < fileList.length; i++) {\n                addToZip(zos, fileList[i].getPath());\n            }\n            // for loop\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadDAOTest0.java",
		"test_prompt": "// DownloadDAOTest0.java\npackage org.heal.module.download;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.HealMetadataXMLConverter;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadDAO}.\n* It contains ten unit test cases for the {@link DownloadDAO#createPackage(DownloadQueueBean, String)} method.\n*/\nclass DownloadDAOTest0 {"
	},
	{
		"original_code": "// DownloadDAO.java\npackage org.heal.module.download;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.HealMetadataXMLConverter;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * This DAO was created by Grace, its content came from original DownloadServicesBean.java.\n *\n * @author Seth Wright\n * @version 0.1\n * @modify by Grace Yang\n */\npublic class DownloadDAO implements Serializable {\n\n    public static final int ZIPTYPE = 0;\n\n    public static final int GZIPTYPE = 1;\n\n    public static final String ZIPFORMAT = \"application/zip\";\n\n    public static final String GZIPFORMAT = \"application/x-gzip\";\n\n    public static final String ZIPEXTENSION = \".zip\";\n\n    public static final String GZIPEXTENSION = \".gz\";\n\n    public static final String HEALPREFIX = \"heal\";\n\n    //The database to use in order to access the metadata info.\n    private DataSource dataSource;\n\n    private MetadataDAO metadatadao;\n\n    /* The file locator to use to determine where the package\n     * files should be placed.\n     */\n    private FileLocator fileLocator = null;\n\n    /**\n     * Sets the dataSource property value and metadataDAO.\n     * add by Grace\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    /**\n     * Sets the utility class to use in determining where the package\n     * files should be placed.\n     */\n    public void setMetadataDAO(MetadataDAO metaDao) {\n        metadatadao = metaDao;\n    }\n\n    /**\n     * Sets the utility class to use in determining where the package\n     * files should be placed.\n     */\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Creates an IMS package of the given file format containing an ims\n     * manifest and the content specified by the download queue.\n     * Returns the url to be used to access the created package.\n     * Currently the only supported format is ZIP.\n     * Accepted fileFormat strings: \"application/zip\" and \"application/x-gzip\"\n     * or you can use the constants (recommended)\n     * DownloadServicesBean.ZIPFORMAT and DownloadServicesBean.GZIPFORMAT\n     * This method also sets the download queue's package file location and\n     * url.  Yes, the return value is slightly redundant.\n     */\n    /**\n     * Creates an IMS package of the given file format containing an ims\n     * manifest and the content specified by the download queue.\n     * Returns the url to be used to access the created package.\n     * Currently the only supported format is ZIP.\n     * Accepted fileFormat strings: \"application/zip\" and \"application/x-gzip\"\n     * or you can use the constants (recommended)\n     * DownloadServicesBean.ZIPFORMAT and DownloadServicesBean.GZIPFORMAT\n     * This method also sets the download queue's package file location and\n     * url.  Yes, the return value is slightly redundant.\n     */\n    public String createPackage(DownloadQueueBean queue, String fileFormat) throws IOException, SQLException {\n        int fileType;\n        if (queue == null || fileFormat == null) {\n            throw new SQLException(\"Missing DownloadQueue or FileFormat\");\n        }\n        if (fileFormat.equals(ZIPFORMAT)) {\n            fileType = ZIPTYPE;\n        } else if (fileFormat.equals(GZIPFORMAT)) {\n            fileType = GZIPTYPE;\n        } else {\n            throw new SQLException(\"Unrecognized package type\");\n        }\n        if (queue.isPackageFileUpToDate(fileType)) {\n            return queue.getPackageURL();\n        }\n        //if we are going to create a new file, then we need to delete\n        //the old one.\n        String packageFileStr = queue.getPackageFileLocation();\n        if (packageFileStr != null) {\n            File aFile = new File(packageFileStr);\n            if (aFile.exists()) {\n                aFile.delete();\n            }\n            queue.clearPackageFileSettings();\n        }\n        File packageFile = getNewPackageFile(queue, fileType);\n        if (packageFile == null) {\n            throw new SQLException(\"Could not create package file\");\n        }\n        CompleteMetadataBean[] metadata = getCompleteMetadata(queue);\n        if (metadata == null) {\n            return null;\n        }\n        FileOutputStream packageStream = new FileOutputStream(packageFile);\n        ZipOutputStream zipStream = new ZipOutputStream(packageStream);\n        zipStream.setMethod(ZipOutputStream.DEFLATED);\n        zipStream.setLevel(Deflater.BEST_COMPRESSION);\n        ZipEntry manifestEntry = new ZipEntry(\"imsmanifest.xml\");\n        manifestEntry.setTime(System.currentTimeMillis());\n        zipStream.putNextEntry(manifestEntry);\n        HealMetadataXMLConverter.getManifestIMSXML(metadata, fileLocator, zipStream);\n        zipStream.closeEntry();\n        String metaLocation;\n        String metaFile;\n        for (int i = 0; i < metadata.length; i++) {\n            metaLocation = metadata[i].getMetadata().getLocation();\n            metaFile = fileLocator.getContentFilePath(metaLocation);\n            addToZip(zipStream, metaFile);\n        }\n        zipStream.close();\n        queue.setPackageFileCreated();\n        return queue.getPackageURL();\n    }\n\n    /**\n     * Gathers all of the metadata ids from the download queue, looks them\n     * up in the database and returns an array of the associated metadata\n     * beans.  If a metadata entry is not found for a content id, then that\n     * that metadata will simply not be added to the return array.\n     */\n    private CompleteMetadataBean[] getCompleteMetadata(DownloadQueueBean queue) throws SQLException {\n        Collection ids = queue.getContentIds();\n        Iterator idsIterator = ids.iterator();\n        String contentId;\n        CompleteMetadataBean metadata;\n        ArrayList metaList = new ArrayList();\n        while (idsIterator.hasNext()) {\n            contentId = (String) idsIterator.next();\n            metadata = metadatadao.getCompleteMetadata(contentId);\n            if (metadata != null) {\n                metaList.add(metadata);\n            }\n        }\n        int numMetadata = metaList.size();\n        CompleteMetadataBean[] array = new CompleteMetadataBean[numMetadata];\n        metaList.toArray(array);\n        return array;\n    }\n\n    /**\n     * Deletes the given package.  The package location is determined from\n     * the url of the package using the FileLocator.\n     */\n    public boolean deletePackage(String packageURL) {\n        if (packageURL == null) {\n            return false;\n        }\n        boolean success = false;\n        String packageFileStr = fileLocator.getFilePathFromURL(packageURL);\n        if (packageFileStr != null) {\n            File packageFile = new File(packageFileStr);\n            success = packageFile.delete();\n        }\n        return success;\n    }\n\n    /**\n     * Returns a file extension for a given format.  The formats are defined\n     * at the beginning of this class.  (zip, gzip) If the format is not\n     * recognized, we return null.\n     */\n    private String getFileSuffix(int format) {\n        switch(format) {\n            case ZIPTYPE:\n                return ZIPEXTENSION;\n            case GZIPTYPE:\n                return GZIPEXTENSION;\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Returns a new temporary name for a package file based on the\n     * provided format.  Right now, the only supported format is ZIP and GZIP,\n     * so all returned filenames will be of the form: <packagepath>/name.zip\n     * or <packagepath>/name.gz\n     * Returns null on an error.\n     * NOTE: This method also sets the downloadQueue's package file location\n     * and URL.\n     */\n    private File getNewPackageFile(DownloadQueueBean queue, int format) throws IOException {\n        File packageDirectory = fileLocator.getPackageDirectoryFile();\n        if (packageDirectory == null) {\n            throw new IOException(\"Could not get File representation of package directory from FileLocator.\");\n        }\n        String suffix = getFileSuffix(format);\n        File packageFile = File.createTempFile(HEALPREFIX, suffix, packageDirectory);\n        String path = packageFile.getCanonicalPath();\n        queue.setPackageFileLocation(path);\n        queue.setPackageFormat(format);\n        queue.setPackageURL(fileLocator.getPackageURL() + packageFile.getName());\n        return packageFile;\n    }\n\n    /**\n     * Adds a file or directory (and its contents) to a zip file.  This\n     * method sets each file's entry in the zip file to have a filepath\n     * relative to the zip file rather than full path entries.  Also, the\n     * zip entry's time value is set to the last modified date of the\n     * file.  addToZip works recursively on a directory to include all of the\n     * files under that directory.\n     */\n    private void addToZip(ZipOutputStream zos, String fileOrFolderPathToBeZip) throws IOException {\n        File fd = new File(fileOrFolderPathToBeZip);\n        if (fd.exists() && fd.isFile()) {\n            // Create a file input stream and a buffered input stream.\n            FileInputStream fis = new FileInputStream(fd);\n            BufferedInputStream bis = new BufferedInputStream(fis);\n            // Create a Zip Entry and put it into the archive(no data yet).\n            // uses the relative path of the entry.\n            ZipEntry fileEntry = new ZipEntry(fileLocator.getRelativePath(fd.getPath()));\n            fileEntry.setTime(fd.lastModified());\n            zos.putNextEntry(fileEntry);\n            byte[] data = new byte[1024];\n            int byteCount;\n            while ((byteCount = bis.read(data, 0, 1024)) > -1) {\n                zos.write(data, 0, byteCount);\n            }\n            try {\n                fis.close();\n            } catch (IOException ex) {\n                //we just want it to close, so ignore the error\n            }\n        } else if (fd.exists() && fd.isDirectory()) {\n            File[] fileList = fd.listFiles();\n            // Loop through File array and display.\n            for (int i = 0; i < fileList.length; i++) {\n                addToZip(zos, fileList[i].getPath());\n            }\n            // for loop\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadDAOTest1.java",
		"test_prompt": "// DownloadDAOTest1.java\npackage org.heal.module.download;\n\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.HealMetadataXMLConverter;\nimport org.heal.module.metadata.MetadataDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadDAO}.\n* It contains ten unit test cases for the {@link DownloadDAO#deletePackage(String)} method.\n*/\nclass DownloadDAOTest1 {"
	},
	{
		"original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet = new TreeSet();\n\n    String packageFileLocation = null;\n\n    String packageURL = null;\n\n    boolean packageModifiedSinceFileCreated = true;\n\n    int packageFormat = -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation == null || packageURL == null || format != packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat = newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation = newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL = newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated = false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated = true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id's intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation = null;\n        packageURL = null;\n        packageModifiedSinceFileCreated = true;\n        packageFormat = -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadQueueBeanTest0.java",
		"test_prompt": "// DownloadQueueBeanTest0.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#isPackageFileUpToDate(int)} method.\n*/\nclass DownloadQueueBeanTest0 {"
	},
	{
		"original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet = new TreeSet();\n\n    String packageFileLocation = null;\n\n    String packageURL = null;\n\n    boolean packageModifiedSinceFileCreated = true;\n\n    int packageFormat = -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation == null || packageURL == null || format != packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat = newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation = newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL = newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated = false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated = true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id's intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation = null;\n        packageURL = null;\n        packageModifiedSinceFileCreated = true;\n        packageFormat = -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadQueueBeanTest1.java",
		"test_prompt": "// DownloadQueueBeanTest1.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#isPackageModified()} method.\n*/\nclass DownloadQueueBeanTest1 {"
	},
	{
		"original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet = new TreeSet();\n\n    String packageFileLocation = null;\n\n    String packageURL = null;\n\n    boolean packageModifiedSinceFileCreated = true;\n\n    int packageFormat = -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation == null || packageURL == null || format != packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat = newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation = newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL = newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated = false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated = true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id's intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation = null;\n        packageURL = null;\n        packageModifiedSinceFileCreated = true;\n        packageFormat = -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadQueueBeanTest2.java",
		"test_prompt": "// DownloadQueueBeanTest2.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#addToQueue(String)} method.\n*/\nclass DownloadQueueBeanTest2 {"
	},
	{
		"original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet = new TreeSet();\n\n    String packageFileLocation = null;\n\n    String packageURL = null;\n\n    boolean packageModifiedSinceFileCreated = true;\n\n    int packageFormat = -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation == null || packageURL == null || format != packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat = newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation = newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL = newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated = false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated = true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id's intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation = null;\n        packageURL = null;\n        packageModifiedSinceFileCreated = true;\n        packageFormat = -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadQueueBeanTest3.java",
		"test_prompt": "// DownloadQueueBeanTest3.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#removeFromQueue(String)} method.\n*/\nclass DownloadQueueBeanTest3 {"
	},
	{
		"original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet = new TreeSet();\n\n    String packageFileLocation = null;\n\n    String packageURL = null;\n\n    boolean packageModifiedSinceFileCreated = true;\n\n    int packageFormat = -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation == null || packageURL == null || format != packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat = newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation = newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL = newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated = false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated = true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id's intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation = null;\n        packageURL = null;\n        packageModifiedSinceFileCreated = true;\n        packageFormat = -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadQueueBeanTest4.java",
		"test_prompt": "// DownloadQueueBeanTest4.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#removeAllFromQueue()} method.\n*/\nclass DownloadQueueBeanTest4 {"
	},
	{
		"original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet = new TreeSet();\n\n    String packageFileLocation = null;\n\n    String packageURL = null;\n\n    boolean packageModifiedSinceFileCreated = true;\n\n    int packageFormat = -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation == null || packageURL == null || format != packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat = newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation = newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL = newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated = false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated = true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id's intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation = null;\n        packageURL = null;\n        packageModifiedSinceFileCreated = true;\n        packageFormat = -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadQueueBeanTest5.java",
		"test_prompt": "// DownloadQueueBeanTest5.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#clearPackageFileSettings()} method.\n*/\nclass DownloadQueueBeanTest5 {"
	},
	{
		"original_code": "// DownloadQueueBean.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/**\n * Stores a list of contentIds and a package file location and url.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class DownloadQueueBean implements Serializable {\n\n    TreeSet contentSet = new TreeSet();\n\n    String packageFileLocation = null;\n\n    String packageURL = null;\n\n    boolean packageModifiedSinceFileCreated = true;\n\n    int packageFormat = -1;\n\n    /**\n     * Get a collection of content Ids.\n     */\n    public Collection getContentIds() {\n        return contentSet;\n    }\n\n    /**\n     * Returns true if the package has not been modified,\n     * the package file location is not null, the\n     * package URL is set, and the format of the\n     * package is the same as that provided and\n     * the package file exists on disk.\n     */\n    public boolean isPackageFileUpToDate(int format) {\n        if (packageModifiedSinceFileCreated || packageFileLocation == null || packageURL == null || format != packageFormat || !(new File(packageFileLocation)).exists()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the format for the package associated with this queue.\n     * The value will be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public int getPackageFormat() {\n        return packageFormat;\n    }\n\n    /**\n     * Sets the format for the package associated with this queue.\n     * This value should be one of the static values defined in\n     * DownloadServicesBean (ZIPFORMAT, GZIPFORMAT), or -1 if there\n     * is no package associated with this queue.\n     */\n    public void setPackageFormat(int newPackageFormat) {\n        packageFormat = newPackageFormat;\n    }\n\n    /**\n     * Returns the file path to be used to access the package for this queue.\n     */\n    public String getPackageFileLocation() {\n        return packageFileLocation;\n    }\n\n    public void setPackageFileLocation(String newPackageFileLocation) {\n        packageFileLocation = newPackageFileLocation;\n    }\n\n    /**\n     * Returns the URL to be used to access the package for this queue.\n     */\n    public String getPackageURL() {\n        return packageURL;\n    }\n\n    /**\n     * Sets the url used to access this package file.\n     */\n    public void setPackageURL(String newPackageURL) {\n        packageURL = newPackageURL;\n    }\n\n    /**\n     * call this method right after the package file is created.\n     * This is used to track whether or not the queue has been modified\n     * since the last time the associated file was created.\n     */\n    public void setPackageFileCreated() {\n        packageModifiedSinceFileCreated = false;\n    }\n\n    /**\n     * Checks whether or not the queue has changed since the last time\n     * the package was generated.  If the queue has had metadata entries\n     * added or removed since the last time the package has been\n     * generated or the package has not yet been generated yet, then this\n     * method will return true\n     * otherwise, it will return false\n     */\n    public boolean isPackageModified() {\n        return packageModifiedSinceFileCreated;\n    }\n\n    /**\n     * Adds a metadata id to the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean addToQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        contentSet.add(contentId);\n        return true;\n    }\n\n    /**\n     * Removes a metadata id from the list of content to include in the package\n     * generated for this queue.\n     */\n    public boolean removeFromQueue(String contentId) {\n        packageModifiedSinceFileCreated = true;\n        return contentSet.remove(contentId);\n    }\n\n    /**\n     * Removes all metadata id from the list of content to include in the\n     * package generated for this queue.\n     */\n    public boolean removeAllFromQueue() {\n        packageModifiedSinceFileCreated = true;\n        contentSet.clear();\n        return true;\n    }\n\n    /**\n     * Deletes all package file settings (last modified, location, url)\n     * but leaves the queue of id's intact.\n     * Returns true on success.\n     */\n    public boolean clearPackageFileSettings() {\n        packageFileLocation = null;\n        packageURL = null;\n        packageModifiedSinceFileCreated = true;\n        packageFormat = -1;\n        return true;\n    }\n\n    /**\n     * Returns true if the specified metadataId is already in the queue.\n     * Otherwise, it returns false.\n     */\n    public boolean isQueuedAlready(String contentId) {\n        return contentSet.contains(contentId);\n    }\n\n    /**\n     * Returns the number of items queued for download.\n     */\n    public int getNumEntries() {\n        return contentSet.size();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/download/DownloadQueueBeanTest6.java",
		"test_prompt": "// DownloadQueueBeanTest6.java\npackage org.heal.module.download;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadQueueBean}.\n* It contains ten unit test cases for the {@link DownloadQueueBean#isQueuedAlready(String)} method.\n*/\nclass DownloadQueueBeanTest6 {"
	},
	{
		"original_code": "// BrowseDAO.java\npackage org.heal.module.browse;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This DAO was created by Grace, its content came from original BrowseServicesBean.java.\n * @author Jason Varghese\n * @modify by Grace Yang\n * @version 0.1\n */\npublic class BrowseDAO implements Serializable {\n\n    // Modified by grace, using DataSource and MetadataDAO instead of MetadataDB\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    /**\n     *  Sets the dataSource property value.\n     * *\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public int getCount(String Id) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Row row = null;\n        int count = 0;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT COUNT(DISTINCT TaxonPaths.MetadataID) AS Expr1 FROM Taxons INNER JOIN TaxonPaths ON TaxonPaths.TaxonPathID = Taxons.TaxonPathID \").append(\"INNER JOIN Metadata ON Metadata.MetadataID = TaxonPaths.MetadataID \").append(\"WHERE TaxonPaths.Source = 'Mesh' AND Metadata.ApproveDate IS NOT NULL \").append(\"AND Metadata.Private = '0' AND Taxons.ID LIKE '\" + Id + \"%';\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            Iterator rowIterator = rows.iterator();\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                count = row.getInt(\"Expr1\");\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return count;\n    }\n\n    public CategoryBean getCategory(String Id) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        String id = new String();\n        String category = new String();\n        Row row = null;\n        CategoryBean categoryBean = null;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT ID,Category FROM Headings \").append(\"WHERE ID = '\" + Id + \"';\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            Iterator rowIterator = rows.iterator();\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                id = row.getString(\"ID\");\n                category = row.getString(\"Category\");\n                categoryBean = new CategoryBean();\n                categoryBean.setCategoryName(category);\n                categoryBean.setCategoryId(id);\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return categoryBean;\n    }\n\n    public Vector getTrail(String Id) throws SQLException {\n        Vector a = new Vector();\n        StringTokenizer st = new StringTokenizer(Id, \".\", true);\n        String token = new String();\n        if (\"0\".equals(Id))\n            return null;\n        int count = 0;\n        String subToken1 = new String();\n        while (st.hasMoreTokens()) {\n            count++;\n            String nextToken = st.nextToken();\n            if ((count == 1) && (nextToken.length() > 1)) {\n                subToken1 = nextToken.substring(0, 1);\n                if (!\".\".equals(subToken1))\n                    a.add(subToken1);\n            }\n            token = token + nextToken;\n            if (!\".\".equals(nextToken))\n                a.add(token);\n        }\n        Vector b = new Vector();\n        for (int c = 0; c < (a.size()); c++) {\n            CategoryBean categoryBean = new CategoryBean();\n            categoryBean = getCategory((String) a.get(c));\n            b.add(categoryBean);\n        }\n        return b;\n    }\n\n    public Vector getChildrenCategories(String parentId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Vector categories = new Vector();\n        String childId = new String();\n        String category = new String();\n        Row row = null;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT ID,Category FROM Headings \").append(\"WHERE PID = '\" + parentId + \"';\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            Iterator rowIterator = rows.iterator();\n            int count = 0;\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                childId = row.getString(\"ID\");\n                category = row.getString(\"Category\");\n                CategoryBean categoryBean = new CategoryBean();\n                categoryBean.setCategoryName(category);\n                categoryBean.setCategoryId(childId);\n                count = getCount(childId);\n                categoryBean.setCount(count);\n                categories.add(categoryBean);\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return categories;\n    }\n\n    public Vector doSQLCommand(String sql) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Vector categories = new Vector();\n        String category = new String();\n        Row row = null;\n        CategoryBean categoryBean = null;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return rows;\n    }\n\n    public Vector doBrowse(String id) throws SQLException {\n        Vector results = new Vector();\n        Vector rows = null;\n        Row row = null;\n        String Id = null;\n        rows = doSQLCommand(\"SELECT DISTINCT Metadata.MetadataID FROM Metadata INNER JOIN TaxonPaths ON TaxonPaths.MetadataID = Metadata.MetadataID INNER JOIN Taxons ON Taxons.TaxonPathID = TaxonPaths.TaxonPathID \" + \"WHERE Metadata.ApproveDate IS NOT NULL AND Metadata.Private = '0' AND TaxonPaths.Source = 'Mesh' AND\" + \"(Taxons.ID LIKE '\" + id + \"%')\");\n        Iterator rowIterator = rows.iterator();\n        try {\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                Id = new String();\n                Id = row.getString(\"MetadataID\");\n                results.add(Id);\n            }\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n        return results;\n    }\n\n    public ShortMetadataBean getSmbById(String id) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Vector rows = null;\n        Row row = null;\n        ShortMetadataBean shortMetadataBean = new ShortMetadataBean();\n        rows = doSQLCommand(\"SELECT Metadata.MetadataID,Metadata.Title,Metadata.Location,Metadata.Description,Metadata.FileSize FROM Metadata  WHERE Metadata.MetadataID = '\" + id + \"'\");\n        Iterator rowIterator = rows.iterator();\n        try {\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                String Id = row.getString(\"MetadataID\");\n                String title = row.getString(\"Title\");\n                String Location = row.getString(\"Location\");\n                String description = row.getString(\"Description\");\n                String fileSize = row.getString(\"FileSize\");\n                shortMetadataBean.setMetadataId(Id);\n                shortMetadataBean.setTitle(title);\n                shortMetadataBean.setLocation(Location);\n                shortMetadataBean.setDescription(description);\n                shortMetadataBean.setFileSize(fileSize);\n                shortMetadataBean.setThumbnail(cd.getThumbnail(id, conn));\n            }\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n        return shortMetadataBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/browse/BrowseDAOTest0.java",
		"test_prompt": "// BrowseDAOTest0.java\npackage org.heal.module.browse;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BrowseDAO}.\n* It contains ten unit test cases for the {@link BrowseDAO#doSQLCommand(String)} method.\n*/\nclass BrowseDAOTest0 {"
	},
	{
		"original_code": "// BrowseDAO.java\npackage org.heal.module.browse;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This DAO was created by Grace, its content came from original BrowseServicesBean.java.\n * @author Jason Varghese\n * @modify by Grace Yang\n * @version 0.1\n */\npublic class BrowseDAO implements Serializable {\n\n    // Modified by grace, using DataSource and MetadataDAO instead of MetadataDB\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    /**\n     *  Sets the dataSource property value.\n     * *\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public int getCount(String Id) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Row row = null;\n        int count = 0;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT COUNT(DISTINCT TaxonPaths.MetadataID) AS Expr1 FROM Taxons INNER JOIN TaxonPaths ON TaxonPaths.TaxonPathID = Taxons.TaxonPathID \").append(\"INNER JOIN Metadata ON Metadata.MetadataID = TaxonPaths.MetadataID \").append(\"WHERE TaxonPaths.Source = 'Mesh' AND Metadata.ApproveDate IS NOT NULL \").append(\"AND Metadata.Private = '0' AND Taxons.ID LIKE '\" + Id + \"%';\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            Iterator rowIterator = rows.iterator();\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                count = row.getInt(\"Expr1\");\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        } catch (UnsupportedConversionException ex) {\n            throw new SQLException(ex.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return count;\n    }\n\n    public CategoryBean getCategory(String Id) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        String id = new String();\n        String category = new String();\n        Row row = null;\n        CategoryBean categoryBean = null;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT ID,Category FROM Headings \").append(\"WHERE ID = '\" + Id + \"';\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            Iterator rowIterator = rows.iterator();\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                id = row.getString(\"ID\");\n                category = row.getString(\"Category\");\n                categoryBean = new CategoryBean();\n                categoryBean.setCategoryName(category);\n                categoryBean.setCategoryId(id);\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return categoryBean;\n    }\n\n    public Vector getTrail(String Id) throws SQLException {\n        Vector a = new Vector();\n        StringTokenizer st = new StringTokenizer(Id, \".\", true);\n        String token = new String();\n        if (\"0\".equals(Id))\n            return null;\n        int count = 0;\n        String subToken1 = new String();\n        while (st.hasMoreTokens()) {\n            count++;\n            String nextToken = st.nextToken();\n            if ((count == 1) && (nextToken.length() > 1)) {\n                subToken1 = nextToken.substring(0, 1);\n                if (!\".\".equals(subToken1))\n                    a.add(subToken1);\n            }\n            token = token + nextToken;\n            if (!\".\".equals(nextToken))\n                a.add(token);\n        }\n        Vector b = new Vector();\n        for (int c = 0; c < (a.size()); c++) {\n            CategoryBean categoryBean = new CategoryBean();\n            categoryBean = getCategory((String) a.get(c));\n            b.add(categoryBean);\n        }\n        return b;\n    }\n\n    public Vector getChildrenCategories(String parentId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Vector categories = new Vector();\n        String childId = new String();\n        String category = new String();\n        Row row = null;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT ID,Category FROM Headings \").append(\"WHERE PID = '\" + parentId + \"';\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            Iterator rowIterator = rows.iterator();\n            int count = 0;\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                childId = row.getString(\"ID\");\n                category = row.getString(\"Category\");\n                CategoryBean categoryBean = new CategoryBean();\n                categoryBean.setCategoryName(category);\n                categoryBean.setCategoryId(childId);\n                count = getCount(childId);\n                categoryBean.setCount(count);\n                categories.add(categoryBean);\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return categories;\n    }\n\n    public Vector doSQLCommand(String sql) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Vector categories = new Vector();\n        String category = new String();\n        Row row = null;\n        CategoryBean categoryBean = null;\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                throw new SQLException(ex.toString());\n            }\n        }\n        return rows;\n    }\n\n    public Vector doBrowse(String id) throws SQLException {\n        Vector results = new Vector();\n        Vector rows = null;\n        Row row = null;\n        String Id = null;\n        rows = doSQLCommand(\"SELECT DISTINCT Metadata.MetadataID FROM Metadata INNER JOIN TaxonPaths ON TaxonPaths.MetadataID = Metadata.MetadataID INNER JOIN Taxons ON Taxons.TaxonPathID = TaxonPaths.TaxonPathID \" + \"WHERE Metadata.ApproveDate IS NOT NULL AND Metadata.Private = '0' AND TaxonPaths.Source = 'Mesh' AND\" + \"(Taxons.ID LIKE '\" + id + \"%')\");\n        Iterator rowIterator = rows.iterator();\n        try {\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                Id = new String();\n                Id = row.getString(\"MetadataID\");\n                results.add(Id);\n            }\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n        return results;\n    }\n\n    public ShortMetadataBean getSmbById(String id) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        Vector rows = null;\n        Row row = null;\n        ShortMetadataBean shortMetadataBean = new ShortMetadataBean();\n        rows = doSQLCommand(\"SELECT Metadata.MetadataID,Metadata.Title,Metadata.Location,Metadata.Description,Metadata.FileSize FROM Metadata  WHERE Metadata.MetadataID = '\" + id + \"'\");\n        Iterator rowIterator = rows.iterator();\n        try {\n            while (rowIterator.hasNext()) {\n                row = (Row) rowIterator.next();\n                String Id = row.getString(\"MetadataID\");\n                String title = row.getString(\"Title\");\n                String Location = row.getString(\"Location\");\n                String description = row.getString(\"Description\");\n                String fileSize = row.getString(\"FileSize\");\n                shortMetadataBean.setMetadataId(Id);\n                shortMetadataBean.setTitle(title);\n                shortMetadataBean.setLocation(Location);\n                shortMetadataBean.setDescription(description);\n                shortMetadataBean.setFileSize(fileSize);\n                shortMetadataBean.setThumbnail(cd.getThumbnail(id, conn));\n            }\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n        return shortMetadataBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/browse/BrowseDAOTest1.java",
		"test_prompt": "// BrowseDAOTest1.java\npackage org.heal.module.browse;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.CommonDAO;\nimport javax.sql.DataSource;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BrowseDAO}.\n* It contains ten unit test cases for the {@link BrowseDAO#doBrowse(String)} method.\n*/\nclass BrowseDAOTest1 {"
	},
	{
		"original_code": "// TaxonBean.java\npackage org.heal.module.metadata;\n\nimport java.io.Serializable;\n\n/**\n * This class contains information about a taxon.\n * This class implements the Comparable interface so that it can be stored\n * in a SortedSet in the TaxonPathBean.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class TaxonBean implements Serializable, Comparable {\n\n    // Properties\n    private String taxonId;\n\n    private String taxonPathId;\n\n    private String id;\n\n    private String entry;\n\n    /**\n     * Returns the taxonId property value.\n     */\n    public String getTaxonId() {\n        return this.taxonId;\n    }\n\n    /**\n     * Sets the taxonId property value.\n     */\n    public void setTaxonId(String newTaxonId) {\n        this.taxonId = newTaxonId;\n    }\n\n    /**\n     * Returns the taxonPathId property value.\n     */\n    public String getTaxonPathId() {\n        return this.taxonPathId;\n    }\n\n    /**\n     * Sets the taxonPathId property value.\n     */\n    public void setTaxonPathId(String newTaxonPathId) {\n        this.taxonPathId = newTaxonPathId;\n    }\n\n    /**\n     * Returns the id property value.\n     */\n    public String getId() {\n        return this.id;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setId(String newId) {\n        this.id = newId;\n    }\n\n    /**\n     * Returns the entry property value.\n     */\n    public String getEntry() {\n        return this.entry;\n    }\n\n    /**\n     * Sets the entry property value.\n     */\n    public void setEntry(String newEntry) {\n        this.entry = newEntry;\n    }\n\n    /* compare the IDs and paths of the objects\n     * It only makes sense to compare Taxons from the _same_ path.\n     */\n    public boolean equals(Object obj) {\n        boolean equal = false;\n        if (obj instanceof TaxonBean) {\n            TaxonBean tb = (TaxonBean) obj;\n            equal = stringEqual(id, tb.id) && stringEqual(taxonId, tb.taxonId) && stringEqual(entry, tb.entry) && stringEqual(taxonPathId, tb.taxonPathId);\n        }\n        return equal;\n    }\n\n    /**\n     * Compares two TaxonBeans.  The comparison is done upon\n     * the length of the ID field and simply rely's upon the java.lang.String\n     * compareTo method.\n     * <p/>\n     * Note: We don't check the type of the object because if we detect that\n     * the types don't match, there is no valid/logical return value we\n     * can give to indicate this.  Therefore we rely upon a\n     * ClassCastException to be thrown.\n     */\n    public int compareTo(Object obj) throws ClassCastException {\n        TaxonBean tb = (TaxonBean) obj;\n        int result;\n        if (equals(obj)) {\n            result = 0;\n        } else {\n            if (null == id) {\n                // Because this is in a TreeSet if !equals(obj), then compareTo cannot return 0\n                result = -1;\n            } else {\n                if (null == tb.id) {\n                    result = 1;\n                } else {\n                    result = id.compareTo(tb.id);\n                    if (0 == result) {\n                        // Because this is in a TreeSet if !equals(obj), then compareTo cannot return 0\n                        result = -1;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    public String toString() {\n        return \"Taxon: taxonID:\" + taxonId + \" taxonPathId:\" + taxonPathId + \" ID:\" + id + \" entry:\" + entry;\n    }\n\n    private static boolean stringEqual(String one, String two) {\n        return ((null == one && null == two) || (null != one && one.equals(two)));\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/TaxonBeanTest0.java",
		"test_prompt": "// TaxonBeanTest0.java\npackage org.heal.module.metadata;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TaxonBean}.\n* It contains ten unit test cases for the {@link TaxonBean#equals(Object)} method.\n*/\nclass TaxonBeanTest0 {"
	},
	{
		"original_code": "// TaxonBean.java\npackage org.heal.module.metadata;\n\nimport java.io.Serializable;\n\n/**\n * This class contains information about a taxon.\n * This class implements the Comparable interface so that it can be stored\n * in a SortedSet in the TaxonPathBean.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class TaxonBean implements Serializable, Comparable {\n\n    // Properties\n    private String taxonId;\n\n    private String taxonPathId;\n\n    private String id;\n\n    private String entry;\n\n    /**\n     * Returns the taxonId property value.\n     */\n    public String getTaxonId() {\n        return this.taxonId;\n    }\n\n    /**\n     * Sets the taxonId property value.\n     */\n    public void setTaxonId(String newTaxonId) {\n        this.taxonId = newTaxonId;\n    }\n\n    /**\n     * Returns the taxonPathId property value.\n     */\n    public String getTaxonPathId() {\n        return this.taxonPathId;\n    }\n\n    /**\n     * Sets the taxonPathId property value.\n     */\n    public void setTaxonPathId(String newTaxonPathId) {\n        this.taxonPathId = newTaxonPathId;\n    }\n\n    /**\n     * Returns the id property value.\n     */\n    public String getId() {\n        return this.id;\n    }\n\n    /**\n     * Sets the id property value.\n     */\n    public void setId(String newId) {\n        this.id = newId;\n    }\n\n    /**\n     * Returns the entry property value.\n     */\n    public String getEntry() {\n        return this.entry;\n    }\n\n    /**\n     * Sets the entry property value.\n     */\n    public void setEntry(String newEntry) {\n        this.entry = newEntry;\n    }\n\n    /* compare the IDs and paths of the objects\n     * It only makes sense to compare Taxons from the _same_ path.\n     */\n    public boolean equals(Object obj) {\n        boolean equal = false;\n        if (obj instanceof TaxonBean) {\n            TaxonBean tb = (TaxonBean) obj;\n            equal = stringEqual(id, tb.id) && stringEqual(taxonId, tb.taxonId) && stringEqual(entry, tb.entry) && stringEqual(taxonPathId, tb.taxonPathId);\n        }\n        return equal;\n    }\n\n    /**\n     * Compares two TaxonBeans.  The comparison is done upon\n     * the length of the ID field and simply rely's upon the java.lang.String\n     * compareTo method.\n     * <p/>\n     * Note: We don't check the type of the object because if we detect that\n     * the types don't match, there is no valid/logical return value we\n     * can give to indicate this.  Therefore we rely upon a\n     * ClassCastException to be thrown.\n     */\n    public int compareTo(Object obj) throws ClassCastException {\n        TaxonBean tb = (TaxonBean) obj;\n        int result;\n        if (equals(obj)) {\n            result = 0;\n        } else {\n            if (null == id) {\n                // Because this is in a TreeSet if !equals(obj), then compareTo cannot return 0\n                result = -1;\n            } else {\n                if (null == tb.id) {\n                    result = 1;\n                } else {\n                    result = id.compareTo(tb.id);\n                    if (0 == result) {\n                        // Because this is in a TreeSet if !equals(obj), then compareTo cannot return 0\n                        result = -1;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    public String toString() {\n        return \"Taxon: taxonID:\" + taxonId + \" taxonPathId:\" + taxonPathId + \" ID:\" + id + \" entry:\" + entry;\n    }\n\n    private static boolean stringEqual(String one, String two) {\n        return ((null == one && null == two) || (null != one && one.equals(two)));\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/TaxonBeanTest1.java",
		"test_prompt": "// TaxonBeanTest1.java\npackage org.heal.module.metadata;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TaxonBean}.\n* It contains ten unit test cases for the {@link TaxonBean#compareTo(Object)} method.\n*/\nclass TaxonBeanTest1 {"
	},
	{
		"original_code": "// SourceCollectionBean.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\n\n/**\n * This class contains information about a thumbnail image for\n * a metadata entry.\n *\n * @author Grace\n * @version 0.1\n */\npublic class SourceCollectionBean implements Serializable {\n\n    // Properties\n    private String sourceId = null;\n\n    private String name = null;\n\n    private String location = null;\n\n    private String fileWidth = null;\n\n    private String fileHeight = null;\n\n    private String link = null;\n\n    /**\n     * Returns the source collection property value.\n     */\n    public String getSourceId() {\n        return this.sourceId;\n    }\n\n    /**\n     * Sets the source collection property value.\n     */\n    public void setSourceId(String sId) {\n        this.sourceId = sId;\n    }\n\n    /**\n     * Returns the source collection property value.\n     */\n    public String getSourceName() {\n        return this.name;\n    }\n\n    /**\n     * Sets the source collection property value.\n     */\n    public void setSourceName(String sname) {\n        this.name = sname;\n    }\n\n    /**\n     * Returns the location property value.\n     */\n    public String getLocation() {\n        return this.location;\n    }\n\n    /**\n     * Sets the location property value.\n     */\n    public void setLocation(String newLocation) {\n        this.location = newLocation;\n    }\n\n    /**\n     * Returns the fileWidth property value.\n     */\n    public String getFileWidth() {\n        return this.fileWidth;\n    }\n\n    /**\n     * Sets the fileWidth property value.\n     */\n    public void setFileWidth(String newFileWidth) {\n        this.fileWidth = newFileWidth;\n    }\n\n    /**\n     * Returns the fileHeight property value.\n     */\n    public String getFileHeight() {\n        return this.fileHeight;\n    }\n\n    /**\n     * Returns the link property value.\n     */\n    public String getLink() {\n        return this.link;\n    }\n\n    /**\n     * Sets the link property value.\n     */\n    public void setLink(String newLink) {\n        this.link = newLink;\n    }\n\n    /**\n     * Sets the fileHeight property value.\n     */\n    public void setFileHeight(String newFileHeight) {\n        this.fileHeight = newFileHeight;\n    }\n\n    public String toString() {\n        return \"Source:SourceId:\" + sourceId + \" name:\" + name + \" location:\" + location + \" fileWidth:\" + fileWidth + \" fileHeight:\" + fileHeight + \" link:\" + link;\n    }\n\n    public Object clone() {\n        SourceCollectionBean result = new SourceCollectionBean();\n        result.sourceId = new String(sourceId);\n        result.name = new String(name);\n        result.location = new String(location);\n        result.fileWidth = new String(fileWidth);\n        result.fileHeight = new String(fileHeight);\n        result.link = new String(link);\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/SourceCollectionBeanTest.java",
		"test_prompt": "// SourceCollectionBeanTest.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SourceCollectionBean}.\n* It contains ten unit test cases for the {@link SourceCollectionBean#clone()} method.\n*/\nclass SourceCollectionBeanTest {"
	},
	{
		"original_code": "// ContributorBean.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about a contributor.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class ContributorBean implements Serializable, Comparable {\n\n    // Properties\n    private String contributorId = null;\n\n    private String LastName;\n\n    private String FirstName;\n\n    private String Title;\n\n    private String Organization;\n\n    private String Phone;\n\n    private String Email;\n\n    private boolean CopyrightHolder;\n\n    private String metadataId = null;\n\n    private String role = null;\n\n    private String vCard = null;\n\n    private Date date = null;\n\n    private String dateDescription = null;\n\n    private String version = null;\n\n    private String status = null;\n\n    /**\n     * Returns the contributorId property value.\n     */\n    public String getContributorId() {\n        return this.contributorId;\n    }\n\n    /**\n     * Sets the contributorId property value.\n     */\n    public void setContributorId(String newContributorId) {\n        this.contributorId = newContributorId;\n    }\n\n    /**\n     * Returns the metadataId property value.\n     */\n    public String getMetadataId() {\n        return this.metadataId;\n    }\n\n    /**\n     * Sets the metadataId property value.\n     */\n    public void setMetadataId(String newMetadataId) {\n        this.metadataId = newMetadataId;\n    }\n\n    /**\n     * Returns the role property value.\n     */\n    public String getRole() {\n        return this.role;\n    }\n\n    /**\n     * Sets the role property value.\n     */\n    public void setRole(String newRole) {\n        this.role = newRole;\n    }\n\n    /**\n     * Returns the vCard property value.\n     */\n    public String getVCard() {\n        return this.vCard;\n    }\n\n    /**\n     * Sets the vCard property value.\n     */\n    public void setVCard(String newVCard) {\n        this.vCard = newVCard;\n    }\n\n    /**\n     * Sets the LastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.LastName = newLastName;\n    }\n\n    /**\n     * Gets the LastName property value.\n     */\n    public String getLastName() {\n        return this.LastName;\n    }\n\n    /**\n     * Sets the FirstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.FirstName = newFirstName;\n    }\n\n    /**\n     * Gets the FirstName property value.\n     */\n    public String getFirstName() {\n        return this.FirstName;\n    }\n\n    /**\n     * Sets the Title property value.\n     */\n    public void setTitle(String newTitle) {\n        this.Title = newTitle;\n    }\n\n    /**\n     * Gets the Title property value.\n     */\n    public String getTitle() {\n        return this.Title;\n    }\n\n    /**\n     * Sets the Organization property value.\n     */\n    public void setOrganization(String newOrganization) {\n        this.Organization = newOrganization;\n    }\n\n    /**\n     * Gets the Organization property value.\n     */\n    public String getOrganization() {\n        return this.Organization;\n    }\n\n    /**\n     * Sets the Phoneproperty value.\n     */\n    public void setPhone(String newPhone) {\n        this.Phone = newPhone;\n    }\n\n    /**\n     * Gets the Phoneproperty value.\n     */\n    public String getPhone() {\n        return this.Phone;\n    }\n\n    /**\n     * Sets the Emailvalue.\n     */\n    public void setEmail(String newEmail) {\n        this.Email = newEmail;\n    }\n\n    /**\n     * Gets the Emailvalue.\n     */\n    public String getEmail() {\n        return this.Email;\n    }\n\n    /**\n     * Set the CopyrightHolder value.\n     */\n    public void setCopyrightHolderFlag(boolean flag) {\n        this.CopyrightHolder = flag;\n    }\n\n    /**\n     * Gets the CopyrightHolder flag.\n     */\n    public boolean getCopyrightHolderFlag() {\n        return this.CopyrightHolder;\n    }\n\n    /**\n     * compare the metadataId, role, and vCard of the contributors.\n     */\n    public boolean equals(Object obj) {\n        boolean equal = false;\n        if (obj instanceof ContributorBean) {\n            ContributorBean tb = (ContributorBean) obj;\n            if (metadataId.equals(tb.metadataId) && role.equals(tb.role) && vCard.equals(tb.vCard)) {\n                equal = true;\n            }\n        }\n        return equal;\n    }\n\n    /**\n     * Compares two ContributorBeans.  The comparison is done upon\n     * first the metadataId, then if those are equal, the role, and finally\n     * if those are equal, the vCard.\n     *\n     * Note: We don't check the type of the object because if we detect that\n     * the types don't match, there is no valid/logical return value we\n     * can give to indicate this.  Therefore we rely upon a\n     * ClassCastException to be thrown.\n     */\n    public int compareTo(Object obj) throws ClassCastException {\n        ContributorBean tb = (ContributorBean) obj;\n        int result;\n        result = metadataId.compareTo(tb.metadataId);\n        if (result == 0) {\n            result = role.compareTo(tb.role);\n            if (result == 0) {\n                result = vCard.compareTo(tb.vCard);\n            }\n        }\n        return result;\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n\n    public String getDateDescription() {\n        return dateDescription;\n    }\n\n    public void setDateDescription(String dateDescription) {\n        this.dateDescription = dateDescription;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public void setVersion(String version) {\n        this.version = version;\n    }\n\n    public String getStatus() {\n        return status;\n    }\n\n    public void setStatus(String status) {\n        this.status = status;\n    }\n\n    public String toString() {\n        return \"ContributorBean{\" + \"contributorId='\" + contributorId + \"'\" + \", vCard='\" + vCard + \"'\" + \", date=\" + date + \", dateDescription='\" + dateDescription + \"'\" + \", metadataId='\" + metadataId + \"'\" + \", role='\" + role + \"'\" + \", version='\" + version + \"'\" + \", status='\" + status + \"'\" + \"}\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/ContributorBeanTest0.java",
		"test_prompt": "// ContributorBeanTest0.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ContributorBean}.\n* It contains ten unit test cases for the {@link ContributorBean#equals(Object)} method.\n*/\nclass ContributorBeanTest0 {"
	},
	{
		"original_code": "// ContributorBean.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about a contributor.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class ContributorBean implements Serializable, Comparable {\n\n    // Properties\n    private String contributorId = null;\n\n    private String LastName;\n\n    private String FirstName;\n\n    private String Title;\n\n    private String Organization;\n\n    private String Phone;\n\n    private String Email;\n\n    private boolean CopyrightHolder;\n\n    private String metadataId = null;\n\n    private String role = null;\n\n    private String vCard = null;\n\n    private Date date = null;\n\n    private String dateDescription = null;\n\n    private String version = null;\n\n    private String status = null;\n\n    /**\n     * Returns the contributorId property value.\n     */\n    public String getContributorId() {\n        return this.contributorId;\n    }\n\n    /**\n     * Sets the contributorId property value.\n     */\n    public void setContributorId(String newContributorId) {\n        this.contributorId = newContributorId;\n    }\n\n    /**\n     * Returns the metadataId property value.\n     */\n    public String getMetadataId() {\n        return this.metadataId;\n    }\n\n    /**\n     * Sets the metadataId property value.\n     */\n    public void setMetadataId(String newMetadataId) {\n        this.metadataId = newMetadataId;\n    }\n\n    /**\n     * Returns the role property value.\n     */\n    public String getRole() {\n        return this.role;\n    }\n\n    /**\n     * Sets the role property value.\n     */\n    public void setRole(String newRole) {\n        this.role = newRole;\n    }\n\n    /**\n     * Returns the vCard property value.\n     */\n    public String getVCard() {\n        return this.vCard;\n    }\n\n    /**\n     * Sets the vCard property value.\n     */\n    public void setVCard(String newVCard) {\n        this.vCard = newVCard;\n    }\n\n    /**\n     * Sets the LastName property value.\n     */\n    public void setLastName(String newLastName) {\n        this.LastName = newLastName;\n    }\n\n    /**\n     * Gets the LastName property value.\n     */\n    public String getLastName() {\n        return this.LastName;\n    }\n\n    /**\n     * Sets the FirstName property value.\n     */\n    public void setFirstName(String newFirstName) {\n        this.FirstName = newFirstName;\n    }\n\n    /**\n     * Gets the FirstName property value.\n     */\n    public String getFirstName() {\n        return this.FirstName;\n    }\n\n    /**\n     * Sets the Title property value.\n     */\n    public void setTitle(String newTitle) {\n        this.Title = newTitle;\n    }\n\n    /**\n     * Gets the Title property value.\n     */\n    public String getTitle() {\n        return this.Title;\n    }\n\n    /**\n     * Sets the Organization property value.\n     */\n    public void setOrganization(String newOrganization) {\n        this.Organization = newOrganization;\n    }\n\n    /**\n     * Gets the Organization property value.\n     */\n    public String getOrganization() {\n        return this.Organization;\n    }\n\n    /**\n     * Sets the Phoneproperty value.\n     */\n    public void setPhone(String newPhone) {\n        this.Phone = newPhone;\n    }\n\n    /**\n     * Gets the Phoneproperty value.\n     */\n    public String getPhone() {\n        return this.Phone;\n    }\n\n    /**\n     * Sets the Emailvalue.\n     */\n    public void setEmail(String newEmail) {\n        this.Email = newEmail;\n    }\n\n    /**\n     * Gets the Emailvalue.\n     */\n    public String getEmail() {\n        return this.Email;\n    }\n\n    /**\n     * Set the CopyrightHolder value.\n     */\n    public void setCopyrightHolderFlag(boolean flag) {\n        this.CopyrightHolder = flag;\n    }\n\n    /**\n     * Gets the CopyrightHolder flag.\n     */\n    public boolean getCopyrightHolderFlag() {\n        return this.CopyrightHolder;\n    }\n\n    /**\n     * compare the metadataId, role, and vCard of the contributors.\n     */\n    public boolean equals(Object obj) {\n        boolean equal = false;\n        if (obj instanceof ContributorBean) {\n            ContributorBean tb = (ContributorBean) obj;\n            if (metadataId.equals(tb.metadataId) && role.equals(tb.role) && vCard.equals(tb.vCard)) {\n                equal = true;\n            }\n        }\n        return equal;\n    }\n\n    /**\n     * Compares two ContributorBeans.  The comparison is done upon\n     * first the metadataId, then if those are equal, the role, and finally\n     * if those are equal, the vCard.\n     *\n     * Note: We don't check the type of the object because if we detect that\n     * the types don't match, there is no valid/logical return value we\n     * can give to indicate this.  Therefore we rely upon a\n     * ClassCastException to be thrown.\n     */\n    public int compareTo(Object obj) throws ClassCastException {\n        ContributorBean tb = (ContributorBean) obj;\n        int result;\n        result = metadataId.compareTo(tb.metadataId);\n        if (result == 0) {\n            result = role.compareTo(tb.role);\n            if (result == 0) {\n                result = vCard.compareTo(tb.vCard);\n            }\n        }\n        return result;\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n\n    public String getDateDescription() {\n        return dateDescription;\n    }\n\n    public void setDateDescription(String dateDescription) {\n        this.dateDescription = dateDescription;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public void setVersion(String version) {\n        this.version = version;\n    }\n\n    public String getStatus() {\n        return status;\n    }\n\n    public void setStatus(String status) {\n        this.status = status;\n    }\n\n    public String toString() {\n        return \"ContributorBean{\" + \"contributorId='\" + contributorId + \"'\" + \", vCard='\" + vCard + \"'\" + \", date=\" + date + \", dateDescription='\" + dateDescription + \"'\" + \", metadataId='\" + metadataId + \"'\" + \", role='\" + role + \"'\" + \", version='\" + version + \"'\" + \", status='\" + status + \"'\" + \"}\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/ContributorBeanTest1.java",
		"test_prompt": "// ContributorBeanTest1.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ContributorBean}.\n* It contains ten unit test cases for the {@link ContributorBean#compareTo(Object)} method.\n*/\nclass ContributorBeanTest1 {"
	},
	{
		"original_code": "// MetadataDAO.java\npackage org.heal.module.metadata;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport org.heal.util.CommonDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.List;\n\n/**\n * This DAO was created by Grace, its content came from original MetadataServicesBean.java.\n * This contains the metadata access database functionality of\n * saving metadata as well as looking up short and IMS\n * records.  It also supports generating a metadata\n * collection in XML (for NSDL support) as well as\n * generating a list of content IDs for the NSDL.\n *\n * @author Seth Wright\n * @author Grace Yang\n */\npublic class MetadataDAO implements Serializable {\n\n    public MetadataDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private FileLocator fileLocator = null;\n\n    private static final String METADATAINSERTSQL = \"INSERT INTO Metadata (FileName, FileSize, Title, Location, SourceCollection, SourceCollectionID, ContributeUserID, ContributeDate, Annotated, Inappropriate, Archived, Private, Description, PublicationId, SubmissionAgreement, LearningResourceType, SpecimenType, RadiographType, Orientation, Magnification, ClinicalHistory, FileWidth, FileHeight, Duration, ApproveDate, CatalogDate, RejectDate, CreationDate, LanguageType) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String METADATAUPDATESQL = \"UPDATE Metadata SET FileName = ?, FileSize = ?, Title = ?, Location = ?, SourceCollection = ?, SourceCollectionID = ?, ContributeUserID = ?, ContributeDate = ?, Annotated = ?, Inappropriate = ?, Archived = ?, Private = ?, Description = ?, PublicationId = ?, SubmissionAgreement = ?, LearningResourceType = ?, SpecimenType = ?, RadiographType = ?, Orientation = ?, Magnification = ?, ClinicalHistory = ?, FileWidth = ?, FileHeight = ?, Duration = ?, ApproveDate = ?, CatalogDate = ?, RejectDate = ?, CreationDate = ? WHERE MetadataID = ?\";\n\n    private static final String PUBLICATIONINSERTSQL = \"INSERT INTO Publications (Name, PublicationDate) VALUES (?, ?)\";\n\n    private static final String PUBLICATIONUPDATESQL = \"UPDATE Publications SET Name = ?, PublicationDate = ? WHERE PublicationId = ?\";\n\n    private static final String METAMETADATA_IDENTIFIER_INSERT_SQL = \"INSERT INTO MetametadataIdentifiers (MetadataID, Catalogue, Entry, MetadataSchema) VALUES (?, ?, ?, ?)\";\n\n    private static final String METAMETADATA_IDENTIFIER_UPDATE_SQL = \"UPDATE MetametadataIdentifiers SET MetadataID = ?, Catalogue = ?, Entry = ?, MetadataSchema = ? WHERE MetametadataIdentifierID = ?\";\n\n    private static final String METAMETADATA_CONTRIBUTOR_INSERT_SQL = \"INSERT INTO MetametadataContributors (MetadataID, Role, ContributeDate, ContributeDateDescription, vCardID) VALUES (?, ?, ?, ?, ?)\";\n\n    private static final String METAMETADATA_CONTRIBUTOR_UPDATE_SQL = \"UPDATE MetametadataContributors SET MetadataID = ?, Role = ?, ContributeDate = ?, ContributeDateDescription = ?, vCardID = ? WHERE MetametadataContributorID = ?\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        MetadataBean metaBean = null;\n        try {\n            metaBean = cd.getMetadata(metadataId, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return metaBean;\n    }\n\n    /**\n     * Inserts the information about the specified metadata, or\n     * updates the information if it is already defined in the\n     * database.\n     */\n    public void saveMetadata(MetadataBean metadataInfo) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetadata(metadataInfo, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n    }\n\n    /**\n     * Inserts the information about the specified metadata,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveMetadata(MetadataBean metadata, Connection conn) throws SQLException {\n        if (metadata == null) {\n            return;\n        }\n        String sql;\n        MetadataBean dbInfo = cd.getMetadata(metadata.getMetadataId(), conn);\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql = METADATAINSERTSQL;\n        } else {\n            sql = METADATAUPDATESQL;\n        }\n        // Inserts the publication first in case we need the id\n        if (null != metadata.getPublicationName() || null != metadata.getPublicationId() || null != metadata.getPublicationDate()) {\n            final int publicationId = savePublication(metadata.getPublicationId(), metadata.getPublicationName(), metadata.getPublicationDate());\n            metadata.setPublicationId(String.valueOf(publicationId));\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(cd.getLongValue(metadata.getFileSize()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(new StringValue(metadata.getSourceCollection()));\n        values.addElement(new StringValue(metadata.getSourceCollectionId()));\n        values.addElement(cd.getIntValue(metadata.getContributeUserId()));\n        values.addElement(cd.getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new BooleanValue(metadata.isAnnotated()));\n        values.addElement(new BooleanValue(metadata.isInappropriate()));\n        values.addElement(new BooleanValue(metadata.isArchived()));\n        values.addElement(new BooleanValue(metadata.isPrivate()));\n        values.addElement(new StringValue(metadata.getDescription()));\n        values.addElement(new StringValue(metadata.getPublicationId()));\n        values.addElement(new StringValue(metadata.getSubmissionAgreement()));\n        values.addElement(new StringValue(metadata.getLearningResourceType()));\n        values.addElement(new StringValue(metadata.getSpecimenType()));\n        values.addElement(new StringValue(metadata.getRadiographType()));\n        values.addElement(new StringValue(metadata.getOrientation()));\n        values.addElement(new StringValue(metadata.getMagnification()));\n        values.addElement(new StringValue(metadata.getClinicalHistory()));\n        values.addElement(cd.getIntValue(metadata.getFileWidth()));\n        values.addElement(cd.getIntValue(metadata.getFileHeight()));\n        values.addElement(cd.getIntValue(metadata.getDuration()));\n        values.addElement(cd.getTimestampValue(metadata.getApproveDate()));\n        values.addElement(cd.getTimestampValue(metadata.getCatalogDate()));\n        values.addElement(cd.getTimestampValue(metadata.getRejectDate()));\n        values.addElement(cd.getTimestampValue(metadata.getCreationDate()));\n        values.addElement(new StringValue(metadata.getLanguageType()));\n        if (dbInfo != null) {\n            values.addElement(new StringValue(metadata.getMetadataId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Returns the short record for the specified metadata in XML format.\n     */\n    public String getShortRecord(String metadataId) throws SQLException, IOException {\n        ShortMetadataBean metaInfo = getShortMetadata(metadataId);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        HealMetadataXMLConverter.shortMetadataToXML(metaInfo, stream);\n        return stream.toString();\n    }\n\n    public ShortMetadataBean getShortMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        // Get the metadata info from the database\n        Row metadataRow = cd.getMetadataProperty(metadataId, \"MetadataID, GlobalID, \" + \"FileName, \" + \"FileSize, Title, \" + \"Description, Location, \" + \"SourceCollection, \" + \"FileWidth, FileHeight, \" + \"ContributeUserID,\" + \"LearningResourceType\", \"Metadata\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        ShortMetadataBean metadataInfo = new ShortMetadataBean();\n        try {\n            String sc = (String) metadataRow.getString(\"SourceCollection\");\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setCollectionBean(cd.getSCollectionBean(sc, conn));\n            metadataInfo.setThumbnail(cd.getThumbnail(metadataId, conn));\n            String format = cd.getMetadataPropertyAsString(metadataId, \"Format\", \"Formats\", conn);\n            metadataInfo.setFormat(format);\n            /*        } catch (UnsupportedConversionException uce) {\n                  throw new SQLException(uce.toString());\n            */\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns the IMS record for the specified metadata in XML format.\n     * XXX Is the parameter here the global id or the metadata id?\n     */\n    public String getIMSRecord(String metadataId) throws SQLException, IOException {\n        CompleteMetadataBean metaInfo = getCompleteMetadata(metadataId);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        HealMetadataXMLConverter.metadataToIMSXML(metaInfo, fileLocator, stream);\n        return stream.toString();\n    }\n\n    /**\n     * Returns information about the HEAL system as a whole.  This is to be\n     * returned to the NSDL, but the spec isn't out yet, so we don't know\n     * what to include here.\n     */\n    public String getCollectionMetadata() {\n        throw new UnsupportedOperationException(\"getCollectionMetadata not implemented\");\n    }\n\n    public CompleteMetadataBean getCompleteMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        CompleteMetadataBean result;\n        try {\n            result = getCompleteMetadata(metadataId, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return result;\n    }\n\n    public CompleteMetadataBean getCompleteMetadata(String metadataId, Connection conn) throws SQLException {\n        CompleteMetadataBean result = new CompleteMetadataBean();\n        try {\n            result.setMetadataId(metadataId);\n            MetadataBean m = cd.getMetadata(metadataId, conn);\n            String name = m.getSourceCollection();\n            result.setMetadata(m);\n            result.setDiseaseDiagnoses(getDiseaseDiagnoses(metadataId, conn));\n            result.setCopyrights(getCopyrights(metadataId, conn));\n            result.setTaxonPaths(getTaxonPaths(metadataId, conn));\n            result.setCopyrightHolders(getCopyrightHolders(metadataId, conn));\n            result.setContextURLs(getContextURLs(metadataId, conn));\n            result.setRequirements(getRequirements(metadataId, conn));\n            result.setContributors(getContributors(metadataId, conn));\n            result.setRelations(getRelations(metadataId, conn));\n            result.setKeywords(getKeywords(metadataId, conn));\n            result.setTargetUserGroups(getTargetUserGroups(metadataId, conn));\n            result.setFormats(getFormats(metadataId, conn));\n            result.setThumbnail(cd.getThumbnail(metadataId, conn));\n            result.setCollectionBean(cd.getSCollectionBean(name, conn));\n            result.setMetametadataIdentifiers(cd.getMetametadataIdentifiers(metadataId, conn));\n            result.setMetametadataContributors(cd.getMetametadataContributors(metadataId, conn));\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n        return result;\n    }\n\n    /**\n     * @param metadataId The metadataId of the target user groups to look up.\n     * @param conn The connection to the database to query.\n     *\n     * @return Am ArrayList of {@link org.heal.module.metadata.TargetUserGroupBean TargetUserGroupBeans}.\n     *         This method will never return <code>null</code>, but may return an empty\n     *         list if no target user groups are found for the given metadataId.\n     *\n     * @throws SQLException Thrown when a database error occurs.\n     */\n    private ArrayList getTargetUserGroups(String metadataId, Connection conn) throws SQLException {\n        ArrayList ret = new ArrayList();\n        Vector rows = cd.getMetadataProperties(metadataId, \"*\", \"TargetUserGroups\", conn);\n        if (null != rows) {\n            for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                Row row = (Row) iter.next();\n                try {\n                    TargetUserGroupBean tug = new TargetUserGroupBean();\n                    tug.setMetadataId(metadataId);\n                    tug.setTargetUserGroup(row.getString(\"TargetUserGroup\"));\n                    ret.add(tug);\n                } catch (NoSuchColumnException e) {\n                    throw new RuntimeException(e);\n                    // TODO logging?\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Saves a CompleteMetadataBean.  Only non-null properties are stored in\n     * the database.  For all properties except the MetadataBean, if the\n     * properties ID (i.e. TaxonID for a TaxonBean) is not null, an update\n     * will be performed for that entry.  If the ID is null, then an insert\n     * will be performed.\n     * If a set of data (for example the keywords) is null or empty, then no\n     * changes are made to those entries in the database.  If it is not\n     * null, then the keywords are added to the database, but the previous\n     * keywords stored in the database are not removed.  If you want to have\n     * the previous settings for the complete metadata bean fields removed,\n     * use updateCompleteMetadata.\n     */\n    public void saveCompleteMetadata(CompleteMetadataBean cmb) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveCompleteMetadata(cmb, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n    }\n\n    /**\n     * If the {@link CompleteMetadataBean} does not have a metadataId (for\n     * example if it represents a new record not yet in the database), then\n     * the <code>Connection</code> <em>must</em> be commited during the\n     * execution of this method.  However if a metadataId <em>does</em> exist,\n     * then the transactional state of the <code>Connection</code> will not\n     * be modified here.\n     *\n     * @see #saveCompleteMetadata(CompleteMetadataBean)\n     */\n    public void saveCompleteMetadata(CompleteMetadataBean cmb, Connection conn) throws SQLException {\n        List elems;\n        Iterator elemIterator;\n        saveMetadata(cmb, conn);\n        String metadataId = cmb.getMetadataId();\n        if (metadataId == null) {\n            //we need to store the metadata\n            conn.commit();\n            //now we look it up via the location so that we can get the id.\n            metadataId = getMetadataIdFromProperty(cmb.getLocation(), \"Location\", conn);\n        }\n        cmb.setMetadataId(metadataId);\n        elems = cmb.getDiseaseDiagnoses();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            DiseaseDiagnosisBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (DiseaseDiagnosisBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveDiseaseDiagnosis(elem, conn);\n            }\n        }\n        elems = cmb.getCopyrights();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveCopyright(elem, conn);\n            }\n        }\n        elems = cmb.getTaxonPaths();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            TaxonPathBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (TaxonPathBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveTaxonPath(elem, conn);\n            }\n        }\n        elems = cmb.getCopyrightHolders();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightHolderBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightHolderBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveCopyrightHolder(elem, conn);\n            }\n        }\n        elems = cmb.getContextURLs();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            ContextURLBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (ContextURLBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveContextURL(elem, conn);\n            }\n        }\n        elems = cmb.getRequirements();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RequirementBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RequirementBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveRequirement(elem, conn);\n            }\n        }\n        TreeMap contributors = cmb.getContributors();\n        Iterator contributorsIterator = contributors.values().iterator();\n        while (contributorsIterator.hasNext()) {\n            elems = (ArrayList) contributorsIterator.next();\n            if (elems != null) {\n                elemIterator = elems.iterator();\n                ContributorBean elem;\n                while (elemIterator.hasNext()) {\n                    elem = (ContributorBean) elemIterator.next();\n                    elem.setMetadataId(metadataId);\n                    cd.saveContributor(elem, conn);\n                }\n            }\n        }\n        elems = cmb.getRelations();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RelationBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RelationBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveRelation(elem, conn);\n            }\n        }\n        elems = cmb.getKeywords();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            KeywordBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (KeywordBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveKeyword(elem, conn);\n            }\n        }\n        elems = cmb.getTargetUserGroups();\n        if (null != elems) {\n            TargetUserGroupBean elem;\n            elemIterator = elems.iterator();\n            while (elemIterator.hasNext()) {\n                elem = (TargetUserGroupBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveTargetUserGroup(elem, conn);\n            }\n        }\n        elems = cmb.getFormats();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            FormatBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (FormatBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveFormat(elem, conn);\n            }\n        }\n        ThumbnailBean thumbnail = cmb.getThumbnail();\n        if (thumbnail != null) {\n            thumbnail.setMetadataId(metadataId);\n            cd.saveThumbnail(thumbnail, conn);\n        }\n        elems = cmb.getMetametadataIdentifiers();\n        if (null != elems) {\n            MetametadataIdentifierBean mib;\n            elemIterator = elems.listIterator();\n            while (elemIterator.hasNext()) {\n                mib = (MetametadataIdentifierBean) elemIterator.next();\n                mib.setMetadataId(metadataId);\n                saveMetametadataIdentifier(mib, conn);\n            }\n        }\n        elems = cmb.getMetametadataContributors();\n        if (null != elems) {\n            MetametadataContributorBean mcb;\n            elemIterator = elems.listIterator();\n            while (elemIterator.hasNext()) {\n                mcb = (MetametadataContributorBean) elemIterator.next();\n                mcb.setMetadataId(metadataId);\n                saveMetametadataContributor(mcb, conn);\n            }\n        }\n    }\n\n    /**\n     * Updates a CompleteMetadataBean.\n     * This differs from the saveCompleteMetadata method in that\n     * it will remove entries in the database that do not show up\n     * in the complete metadata parameter.\n     */\n    public void updateCompleteMetadata(CompleteMetadataBean cmb) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            updateCompleteMetadata(cmb, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n    }\n\n    /**\n     * Updates a CompleteMetadataBean.\n     * See updateCompleteMetadata(cmb)\n     */\n    public void updateCompleteMetadata(CompleteMetadataBean cmb, Connection conn) throws SQLException {\n        if (cmb == null || cmb.getMetadataId() == null || conn == null) {\n            return;\n        }\n        String metadataId = cmb.getMetadataId();\n        /* STRATEGY ALERT: (by Seth Wright)\n         * In the interest of finishing this portion of the project on time\n         * I am taking a slight shortcut.  Rather than determining the\n         * difference between the current database settings and the one we\n         * want, I am simply deleting all old entries and adding new ones.\n         * This could result in a large growth in the id numbers of\n         * such tables as keywords entries.\n         * So, here is what we do, we remove all settings from the database\n         * that are one to many relations and then call saveCompleteMetadata\n         * The fields with multiple entries are:\n         * taxons/taxonpaths\n         * relations\n         * requirements\n         * keywords\n         * formats\n         * disease diagnoses\n         * copyright holders\n         * contexturls\n         * contributors\n         * copyrights/copyrighttexts\n         */\n        cd.removeMetadataFromTable(metadataId, \"Relations\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Formats\", conn);\n        cd.removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        cd.removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        cd.removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        cd.removeMetadataFromTable(metadataId, \"TargetUserGroups\", conn);\n        cd.removeTaxonPaths(metadataId, conn);\n        cd.removeCopyrights(metadataId, conn);\n        doUpdateHack(cmb);\n        saveCompleteMetadata(cmb, conn);\n    }\n\n    /**\n     * The update hack is where the IDs (such as\n     * KeywordId) are stripped from the complete metadata bean.\n     * This is done so that saveCompleteMetadata works correctly.\n     */\n    private void doUpdateHack(CompleteMetadataBean cmb) {\n        ArrayList elems;\n        Iterator elemIterator;\n        /* change log\n        elems = cmb.getDiseaseDiagnoses();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            DiseaseDiagnosisBean elem;\n            while (elemIterator.hasNext()) {\n            elem = (DiseaseDiagnosisBean)elemIterator.next();\n            elem.setDiseaseDiagnosisId(null);\n            }\n        }*/\n        elems = cmb.getCopyrights();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightBean) elemIterator.next();\n                elem.setCopyrightId(null);\n            }\n        }\n        elems = cmb.getTaxonPaths();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            TaxonPathBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (TaxonPathBean) elemIterator.next();\n                elem.setTaxonPathId(null);\n            }\n        }\n        elems = cmb.getCopyrightHolders();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightHolderBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightHolderBean) elemIterator.next();\n                elem.setCopyrightHolderId(null);\n            }\n        }\n        elems = cmb.getContextURLs();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            ContextURLBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (ContextURLBean) elemIterator.next();\n                elem.setContextURLId(null);\n            }\n        }\n        elems = cmb.getRequirements();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RequirementBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RequirementBean) elemIterator.next();\n                elem.setRequirementId(null);\n            }\n        }\n        TreeMap contributors = cmb.getContributors();\n        Iterator contributorsIterator = contributors.values().iterator();\n        while (contributorsIterator.hasNext()) {\n            elems = (ArrayList) contributorsIterator.next();\n            if (elems != null) {\n                elemIterator = elems.iterator();\n                ContributorBean elem;\n                while (elemIterator.hasNext()) {\n                    elem = (ContributorBean) elemIterator.next();\n                    elem.setContributorId(null);\n                }\n            }\n        }\n        elems = cmb.getRelations();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RelationBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RelationBean) elemIterator.next();\n                elem.setRelationId(null);\n            }\n        }\n        elems = cmb.getKeywords();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            KeywordBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (KeywordBean) elemIterator.next();\n                elem.setKeywordId(null);\n            }\n        }\n        elems = cmb.getFormats();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            FormatBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (FormatBean) elemIterator.next();\n                elem.setFormatId(null);\n            }\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = cd.getMetadata(metadataId, conn);\n        cd.addToDeletedItems(metadata, comment, conn);\n        success = cd.deleteMetadataReferences(metadataId, conn);\n        cd.removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Returns a ArrayList of DiseaseDiagnosisBeans associated with the\n     * given metadataId.\n     * If no diagnoses are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getDiseaseDiagnoses(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"DiseaseDiagnosisID, \" + \"DiseaseDiagnosis\", \"DiseaseDiagnoses\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                DiseaseDiagnosisBean dd;\n                String id;\n                String ddString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    dd = new DiseaseDiagnosisBean();\n                    id = row.getString(\"DiseaseDiagnosisID\");\n                    ddString = row.getString(\"DiseaseDiagnosis\");\n                    dd.setDiseaseDiagnosisId(id);\n                    dd.setMetadataId(metadataId);\n                    dd.setDiseaseDiagnosis(ddString);\n                    results.add(dd);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of CopyrightBeans associated with the\n     * given metadataId.\n     * If no copyrightss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getCopyrights(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"CopyrightID, CopyrightTextID\", \"Copyrights\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                CopyrightBean copyright;\n                CopyrightTextBean copyrightText;\n                String copyrightTextString;\n                String copyrightId;\n                String copyrightTextId;\n                SQLCommandBean sqlCommandBean = new SQLCommandBean();\n                sqlCommandBean.setConnection(conn);\n                sqlCommandBean.setSqlValue(\"SELECT CopyrightText FROM CopyrightTexts WHERE CopyrightTextID = ?\");\n                Vector values = new Vector();\n                Vector copyrighttextrows = null;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    copyright = new CopyrightBean();\n                    copyrightId = row.getString(\"CopyrightID\");\n                    copyrightTextId = row.getString(\"CopyrightTextID\");\n                    copyright.setCopyrightId(copyrightId);\n                    copyright.setMetadataId(metadataId);\n                    copyrightText = null;\n                    values.clear();\n                    values.addElement(new StringValue(copyrightTextId));\n                    sqlCommandBean.setValues(values);\n                    try {\n                        copyrighttextrows = sqlCommandBean.executeQuery();\n                    } catch (UnsupportedTypeException e) {\n                        throw new SQLException(e.toString());\n                    }\n                    if (copyrighttextrows != null && copyrighttextrows.size() > 0) {\n                        row = (Row) copyrighttextrows.firstElement();\n                        copyrightTextString = row.getString(\"CopyrightText\");\n                        copyrightText = new CopyrightTextBean();\n                        copyrightText.setCopyrightTextId(copyrightTextId);\n                        copyrightText.setCopyrightText(copyrightTextString);\n                    }\n                    copyright.setCopyrightText(copyrightText);\n                    results.add(copyright);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of CopyrightHolderBeans associated with the\n     * given metadataId.\n     * If no copyright holders are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getCopyrightHolders(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            // queries the database\n            Vector rows;\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT a.CopyrightHolderID, b.vCard \");\n            sql.append(\"FROM  CopyrightHolders a INNER JOIN\");\n            sql.append(\"  vCards b ON a.vCardID = b.vCardID \");\n            sql.append(\"WHERE  (a.MetadataID = ?)\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            sqlCommandBean.setValues(values);\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                CopyrightHolderBean ch;\n                String id;\n                String chString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    ch = new CopyrightHolderBean();\n                    id = row.getString(\"CopyrightHolderID\");\n                    chString = row.getString(\"VCard\");\n                    ch.setCopyrightHolderId(id);\n                    ch.setMetadataId(metadataId);\n                    ch.setVCard(chString);\n                    results.add(ch);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of TaxonPathBeans associated with the given\n     * metadataId.\n     * If no taxonPathss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getTaxonPaths(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        try {\n            return getTaxonPaths(metadataId, conn);\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n    }\n\n    /**\n     * Returns a ArrayList of TaxonPathBeans associated with the given\n     * metadataId.\n     * If no taxonPathss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getTaxonPaths(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"TaxonPathID, Source\", \"TaxonPaths\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                TaxonPathBean taxonPath;\n                String taxonPathId;\n                String taxonPathSource;\n                TaxonBean taxon = null;\n                String taxonId, id, entry;\n                SQLCommandBean sqlCommandBean = new SQLCommandBean();\n                sqlCommandBean.setConnection(conn);\n                sqlCommandBean.setSqlValue(\"SELECT TaxonID, ID, Entry FROM Taxons WHERE TaxonPathID = ?\");\n                Vector values = new Vector();\n                Vector taxonrows = null;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    taxonPath = new TaxonPathBean();\n                    taxonPathId = row.getString(\"TaxonPathID\");\n                    taxonPathSource = row.getString(\"Source\");\n                    taxonPath.setTaxonPathId(taxonPathId);\n                    taxonPath.setMetadataId(metadataId);\n                    taxonPath.setSource(taxonPathSource);\n                    values.clear();\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    try {\n                        taxonrows = sqlCommandBean.executeQuery();\n                    } catch (UnsupportedTypeException e) {\n                        throw new SQLException(e.toString());\n                    }\n                    if (taxonrows != null && taxonrows.size() > 0) {\n                        Iterator taxonIterator = taxonrows.iterator();\n                        while (taxonIterator.hasNext()) {\n                            row = (Row) taxonIterator.next();\n                            taxon = new TaxonBean();\n                            taxonId = row.getString(\"TaxonID\");\n                            id = row.getString(\"ID\");\n                            entry = row.getString(\"Entry\");\n                            taxon.setTaxonId(taxonId);\n                            taxon.setTaxonPathId(taxonPathId);\n                            taxon.setId(id);\n                            taxon.setEntry(entry);\n                            taxonPath.addTaxon(taxon);\n                        }\n                    }\n                    results.add(taxonPath);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of ContextURLBeans associated with the given\n     * If no contextURLs are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getContextURLs(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"ContextURLID, ContextURL, ContextURLDescription\", \"ContextURLs\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                ContextURLBean contextURL;\n                String contextURLId;\n                String contextURLString;\n                String contextURLDescription;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    contextURL = new ContextURLBean();\n                    contextURLId = row.getString(\"ContextURLID\");\n                    contextURLString = row.getString(\"ContextURL\");\n                    contextURLDescription = row.getString(\"ContextURLDescription\");\n                    contextURL.setContextURLId(contextURLId);\n                    contextURL.setMetadataId(metadataId);\n                    contextURL.setContextURL(contextURLString);\n                    contextURL.setContextURLDescription(contextURLDescription);\n                    results.add(contextURL);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of RequirementBeans associated with the\n     * given metadataId.\n     * If no requirements are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getRequirements(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"RequirementID, \" + \"RequirementType, \" + \"RequirementName\", \"Requirements\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                RequirementBean rb;\n                String id;\n                String requirementType, requirementName;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    rb = new RequirementBean();\n                    id = row.getString(\"RequirementID\");\n                    requirementType = row.getString(\"RequirementType\");\n                    requirementName = row.getString(\"RequirementName\");\n                    rb.setRequirementId(id);\n                    rb.setMetadataId(metadataId);\n                    rb.setRequirementType(requirementType);\n                    rb.setRequirementName(requirementName);\n                    results.add(rb);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a TreeMap of ContributorBeans associated with the\n     * given metadataId.\n     * If no contributors are found or an error occurs, an empty TreeMap is\n     * returned.\n     */\n    public TreeMap getContributors(String metadataId, Connection conn) throws SQLException {\n        TreeMap results = new TreeMap();\n        if (metadataId != null) {\n            // queries the database\n            PreparedStatement ps = null;\n            ResultSet rs = null;\n            try {\n                StringBuffer sql = new StringBuffer();\n                sql.append(\"SELECT a.ContributorID, a.Role, a.ContributeDate,\").append(\" a.ContributeDateDescription, b.vCard \");\n                sql.append(\"FROM  Contributors a INNER JOIN\");\n                sql.append(\"  vCards b ON a.VCardID = b.vCardID \");\n                sql.append(\"WHERE  (a.MetadataID = ?)\");\n                ps = conn.prepareStatement(sql.toString());\n                ps.setString(1, metadataId);\n                rs = ps.executeQuery();\n                while (rs.next()) {\n                    ContributorBean cb = new ContributorBean();\n                    final String id = rs.getString(1);\n                    final String role = rs.getString(2);\n                    final Date contributeDate = rs.getDate(3);\n                    final String contributeDateDescription = rs.getString(4);\n                    final String vCard = rs.getString(5);\n                    cb.setContributorId(id);\n                    cb.setRole(role);\n                    cb.setDate(contributeDate);\n                    cb.setDateDescription(contributeDateDescription);\n                    cb.setVCard(vCard);\n                    List roles = (List) results.get(role);\n                    if (null == roles) {\n                        roles = new ArrayList();\n                        results.put(role, roles);\n                    }\n                    roles.add(cb);\n                }\n            } finally {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of RelationBeans associated with the\n     * given metadataId.\n     * If no relations are found or an error occurs, an empty ArrayList\n     * is returned.\n     */\n    public ArrayList getRelations(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"RelationID, \" + \"Resource, Kind, Description\", \"Relations\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                RelationBean rb;\n                String id;\n                String resource, kind, description;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    rb = new RelationBean();\n                    id = row.getString(\"RelationID\");\n                    resource = row.getString(\"Resource\");\n                    kind = row.getString(\"Kind\");\n                    description = row.getString(\"Description\");\n                    rb.setRelationId(id);\n                    rb.setMetadataId(metadataId);\n                    rb.setResource(resource);\n                    rb.setKind(kind);\n                    rb.setDescription(description);\n                    results.add(rb);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns an ArrayList of KeywordBeans associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getKeywords(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"KeywordID, Keyword\", \"Keywords\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                KeywordBean keyword;\n                String keywordId;\n                String keywordString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    keyword = new KeywordBean();\n                    keywordId = row.getString(\"KeywordID\");\n                    keywordString = row.getString(\"Keyword\");\n                    keyword.setKeywordId(keywordId);\n                    keyword.setMetadataId(metadataId);\n                    keyword.setKeyword(keywordString);\n                    results.add(keyword);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns an ArrayList of FormatBeans associated with the given\n     * metadataId.\n     * If no format is found or an error occurs, an empty ArrayList\n     * is returned.\n     */\n    public ArrayList getFormats(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"FormatID, Format\", \"Formats\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                FormatBean format;\n                String formatId;\n                String formatString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    format = new FormatBean();\n                    formatId = row.getString(\"FormatID\");\n                    formatString = row.getString(\"Format\");\n                    format.setFormatId(formatId);\n                    format.setMetadataId(metadataId);\n                    format.setFormat(formatString);\n                    results.add(format);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns the first metadataId returned when the Metadata table is\n     * queried for all entries with the given value for the given column.\n     */\n    public String getMetadataIdFromProperty(String columnValue, String columnName, Connection conn) throws SQLException {\n        if (columnName == null || columnValue == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT MetadataID FROM Metadata \").append(\"WHERE \" + columnName + \" = ? ORDER BY MetadataID DESC\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(columnValue));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // nothing found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        try {\n            String metadataId = aRow.getString(\"MetadataID\");\n            return metadataId;\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n    }\n\n    /**\n     * Returns the first metadataId returned when the Metadata table is\n     * queried for all entries with the given value for the given column.\n     */\n    public String getMetadataIdFromProperty(String columnValue, String columnName) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        String metadataId = null;\n        try {\n            metadataId = getMetadataIdFromProperty(columnValue, columnName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return metadataId;\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     */\n    public ArrayList getPointerListArrayList(java.util.Date lastReceivedDate) throws SQLException {\n        return getPointerList(lastReceivedDate, false);\n    }\n\n    /**\n     * Returns a list of content Ids in XML format.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     */\n    public String getPointerList(java.util.Date lastReceivedDate) throws SQLException, IOException {\n        ArrayList ids = getPointerList(lastReceivedDate, false);\n        return HealMetadataXMLConverter.getPointerListXML(ids);\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     * If the includeHidden parameter is set to true, all metadata Ids are\n     * returned, not just those set as visible.  If the parameter\n     * set to false, then only those set as \"visible\" will be returned.\n     */\n    public ArrayList getPointerListArrayList(java.util.Date lastReceivedDate, boolean includeHidden) throws SQLException {\n        return getPointerList(lastReceivedDate, includeHidden);\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     * Depending upon the second parameter, this method will return a list\n     * containing only metadata not marked as hidden if false, and all\n     * metadata Ids if the includeHidden parameter is set to true.\n     */\n    public ArrayList getPointerList(java.util.Date lastReceivedDate, boolean includeHidden) throws SQLException {\n        ArrayList ids = null;\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT MetadataID FROM Metadata\");\n        Vector values = new Vector();\n        if (lastReceivedDate != null) {\n            Timestamp lastReceivedTimestamp = new Timestamp(lastReceivedDate.getTime());\n            values.addElement(new TimestampValue(lastReceivedTimestamp));\n            if (!includeHidden) {\n                sql.append(\" WHERE CatalogDate >= ? AND Private = ?\");\n                values.addElement(new BooleanValue(includeHidden));\n            } else {\n                //if we want to show all, then don't filter Private setting\n                sql.append(\" WHERE CatalogDate >= ?\");\n            }\n            sqlCommandBean.setValues(values);\n        } else if (!includeHidden) {\n            //we only want to screen if we are EXCLUDING ids(don't show hidden)\n            sql.append(\" WHERE Private = ?\");\n            values.addElement(new BooleanValue(includeHidden));\n            sqlCommandBean.setValues(values);\n        }\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            if (rows != null && rows.size() > 0) {\n                ids = new ArrayList();\n                Iterator rowIter = rows.iterator();\n                while (rowIter.hasNext()) {\n                    String id = ((Row) rowIter.next()).getString(\"MetadataID\");\n                    ids.add(id);\n                }\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException e2) {\n            throw new SQLException(e2.toString());\n        } finally // Can not happen here\n        {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        //cycle through all of the rows and pull out the MetadataIDs\n        return ids;\n    }\n\n    /**\n     * Used by {@link org.heal.servlet.cataloger.SaveMetadataAction SaveMetadataAction}\n     * so that we can manage a database transaction when updating old records.  This method\n     * is somewhat specific to SaveMetadataAction.\n     *\n     * @param cmb The {@link org.heal.module.metadata.CompleteMetadataBean CompleteMetadataBean}\n     * generated from form data.\n     */\n    public void saveEditMetadataForm(CompleteMetadataBean cmb) throws SQLException {\n        final String metadataId = cmb.getMetadataId();\n        Set contextURLExcludes = new HashSet();\n        for (Iterator iter = cmb.getContextURLs().iterator(); iter.hasNext(); ) {\n            final ContextURLBean cub = (ContextURLBean) iter.next();\n            if (null != cub && null != cub.getContextURLId()) {\n                contextURLExcludes.add(cub.getContextURLId());\n            }\n        }\n        Set contributorExcludes = new HashSet();\n        for (Iterator iter = cmb.getContributorList().iterator(); iter.hasNext(); ) {\n            final ContributorBean cb = (ContributorBean) iter.next();\n            if (null != cb.getContributorId()) {\n                contributorExcludes.add(cb.getContributorId());\n            }\n        }\n        Set copyrightHolderExcludes = new HashSet();\n        for (Iterator iter = cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n            final CopyrightHolderBean chb = (CopyrightHolderBean) iter.next();\n            if (null != chb.getCopyrightHolderId()) {\n                copyrightHolderExcludes.add(chb.getCopyrightHolderId());\n            }\n        }\n        Set taxonPathExcludes = new HashSet();\n        for (Iterator iter = cmb.getTaxonPaths().iterator(); iter.hasNext(); ) {\n            final TaxonPathBean tpb = (TaxonPathBean) iter.next();\n            if (null != tpb.getTaxonPathId()) {\n                taxonPathExcludes.add(tpb.getTaxonPathId());\n            }\n        }\n        Set requirementExcludes = new HashSet();\n        for (Iterator iter = cmb.getRequirements().iterator(); iter.hasNext(); ) {\n            final RequirementBean rb = (RequirementBean) iter.next();\n            if (null != rb.getRequirementId()) {\n                requirementExcludes.add(rb.getRequirementId());\n            }\n        }\n        Set relationExcludes = new HashSet();\n        for (Iterator iter = cmb.getRelations().iterator(); iter.hasNext(); ) {\n            final RelationBean rb = (RelationBean) iter.next();\n            if (null != rb.getRelationId()) {\n                relationExcludes.add(rb.getRelationId());\n            }\n        }\n        Set mmIdentifierExcludes = new HashSet();\n        for (Object o : cmb.getMetametadataIdentifiers()) {\n            final MetametadataIdentifierBean mib = (MetametadataIdentifierBean) o;\n            if (null != mib.getMetametadataIdentifierId()) {\n                mmIdentifierExcludes.add(mib.getMetametadataIdentifierId());\n            }\n        }\n        Set mmContributorExcludes = new HashSet();\n        for (Object o : cmb.getMetametadataContributors()) {\n            final MetametadataContributorBean mcb = (MetametadataContributorBean) o;\n            if (null != mcb.getMetametadataContributorId()) {\n                mmContributorExcludes.add(mcb.getMetametadataContributorId());\n            }\n        }\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            if (null != metadataId) {\n                // If this is an existing metadata record, we must\n                // change the values in the database currently to\n                // match the CompleteMetadataBean submitted from the\n                // edit page\n                cd.removeMetadataFromTable(metadataId, \"Keywords\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Formats\", conn);\n                cd.removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n                cd.removeMetadataFromTable(metadataId, \"TargetUserGroups\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Copyrights\", conn);\n                deleteForeignKeyRecordsNotInSet(\"ContextURLs\", \"MetadataID\", \"ContextURLID\", metadataId, contextURLExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Contributors\", \"MetadataID\", \"ContributorID\", metadataId, contributorExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"CopyrightHolders\", \"MetadataID\", \"CopyrightHolderID\", metadataId, copyrightHolderExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"TaxonPaths\", \"MetadataID\", \"TaxonPathID\", metadataId, taxonPathExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Requirements\", \"MetadataID\", \"RequirementID\", metadataId, requirementExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Relations\", \"MetadataID\", \"RelationID\", metadataId, relationExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"MetametadataIdentifiers\", \"MetadataID\", \"MetametadataIdentifierID\", metadataId, mmIdentifierExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"MetametadataContributors\", \"MetadataID\", \"MetametadataContributorID\", metadataId, mmContributorExcludes, conn);\n                for (Iterator iter = cmb.getTaxonPaths().iterator(); iter.hasNext(); ) {\n                    final TaxonPathBean tpb = (TaxonPathBean) iter.next();\n                    final String taxonPathId = tpb.getTaxonPathId();\n                    if (null != taxonPathId) {\n                        Set taxonExcludes = new HashSet();\n                        for (Iterator iterTwo = tpb.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                            final TaxonBean tb = (TaxonBean) iterTwo.next();\n                            if (null != tb.getTaxonId()) {\n                                taxonExcludes.add(tb.getTaxonId());\n                            }\n                        }\n                        deleteForeignKeyRecordsNotInSet(\"Taxons\", \"TaxonPathID\", \"TaxonID\", taxonPathId, taxonExcludes, conn);\n                    }\n                }\n            }\n            // Cleaning up pieces of the metadata which are empty, and therefor\n            // should be null when inserted in the database...\n            if (isEmpty(cmb.getGlobalId())) {\n                cmb.setGlobalId(null);\n            }\n            if (isEmpty(cmb.getSpecimenType())) {\n                cmb.setSpecimenType(null);\n            }\n            if (isEmpty(cmb.getRadiographType())) {\n                cmb.setRadiographType(null);\n            }\n            if (isEmpty(cmb.getOrientation())) {\n                cmb.setOrientation(null);\n            }\n            if (isEmpty(cmb.getMagnification())) {\n                cmb.setMagnification(null);\n            }\n            if (isEmpty(cmb.getClinicalHistory())) {\n                cmb.setClinicalHistory(null);\n            }\n            if (null != cmb.getThumbnail()) {\n                final ThumbnailBean tb = cmb.getThumbnail();\n                if (isEmpty(tb.getFileHeight()) && isEmpty(tb.getFileWidth()) && isEmpty(tb.getLocation())) {\n                    cmb.setThumbnail(null);\n                }\n            }\n            saveCompleteMetadata(cmb, conn);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.close();\n        }\n    }\n\n    private static boolean isEmpty(String str) {\n        boolean empty = false;\n        if (null == str || str.trim().length() == 0) {\n            empty = true;\n        }\n        return empty;\n    }\n\n    /**\n     * Deletes records from a table that match a given foreign key and which\n     * do not have ids that are found in a <code>Set</code>.\n     *\n     * @param tableName The name of the table to delete records from.\n     * @param foreignKeyFieldName The name of the field which acts as a foreign key in the table.\n     * @param excludeFieldName The name of the field to match id's to exclude from the deletion.\n     * @param foreignKey The foreign key value associated with the records to delete.\n     * @param excludes A set of Strings representing ids of records that should\n     * not be deleted.\n     * @param conn The <code>Connection</code> to the database.\n     *\n     * @throws SQLException\n     */\n    public void deleteForeignKeyRecordsNotInSet(String tableName, String foreignKeyFieldName, String excludeFieldName, String foreignKey, Set excludes, Connection conn) throws SQLException {\n        String sql;\n        if (0 < excludes.size()) {\n            StringBuffer exclude = new StringBuffer(\"(\");\n            for (int i = 0; i < excludes.size(); ++i) {\n                exclude.append(\"?\");\n                if (i < (excludes.size() - 1)) {\n                    exclude.append(\", \");\n                }\n            }\n            exclude.append(\")\");\n            sql = \"DELETE FROM \" + tableName + \" WHERE \" + foreignKeyFieldName + \" = ? AND \" + excludeFieldName + \" NOT IN \" + exclude.toString();\n        } else {\n            sql = \"DELETE FROM \" + tableName + \" WHERE \" + foreignKeyFieldName + \"= ?\";\n        }\n        PreparedStatement ps = conn.prepareStatement(sql);\n        try {\n            ps.setInt(1, Integer.parseInt(foreignKey));\n            int nextParameter = 2;\n            for (Iterator iter = excludes.iterator(); iter.hasNext(); ) {\n                final String exclude = (String) iter.next();\n                ps.setInt(nextParameter, Integer.parseInt(exclude));\n                ++nextParameter;\n            }\n            ps.executeUpdate();\n        } finally {\n            ps.close();\n        }\n    }\n\n    public int savePublication(String id, String name, Date publicationDate) throws SQLException {\n        int ret = 0;\n        Connection conn = dataSource.getConnection();\n        try {\n            ret = savePublication(id, name, publicationDate, dataSource.getConnection());\n        } finally {\n            if (null != conn) {\n                conn.close();\n            }\n        }\n        return ret;\n    }\n\n    public int savePublication(String id, String name, Date publicationDate, Connection conn) throws SQLException {\n        Integer ret = null;\n        try {\n            ret = new Integer(Integer.parseInt(id));\n        } catch (NumberFormatException e) {\n            // does nothing\n        }\n        String sql;\n        if (null == ret) {\n            sql = PUBLICATIONINSERTSQL;\n        } else {\n            sql = PUBLICATIONUPDATESQL;\n        }\n        java.sql.Date publicationSqlDate = null;\n        if (null != publicationDate) {\n            publicationSqlDate = new java.sql.Date(publicationDate.getTime());\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, name);\n            ps.setDate(2, publicationSqlDate);\n            if (null != ret) {\n                ps.setInt(3, ret.intValue());\n            }\n            ps.executeUpdate();\n            if (null == ret) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT MAX(PublicationId) AS uid FROM Publications\");\n                rs = ps.executeQuery();\n                if (rs.next()) {\n                    ret = new Integer(rs.getInt(1));\n                }\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        if (null == ret) {\n            throw new RuntimeException(\"Unable to save publication: ('\" + id + \"', '\" + name + \"', '\" + publicationDate.toString() + \"')\");\n        }\n        return ret.intValue();\n    }\n\n    public void saveMetametadataIdentifier(MetametadataIdentifierBean mib, Connection conn) throws SQLException {\n        final String sql;\n        if (null == mib.getMetametadataIdentifierId()) {\n            sql = METAMETADATA_IDENTIFIER_INSERT_SQL;\n        } else {\n            sql = METAMETADATA_IDENTIFIER_UPDATE_SQL;\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, mib.getMetadataId());\n            ps.setString(2, mib.getCatalog());\n            ps.setString(3, mib.getEntry());\n            ps.setString(4, mib.getMetadataSchema());\n            if (null != mib.getMetametadataIdentifierId()) {\n                ps.setString(5, mib.getMetametadataIdentifierId());\n            }\n            ps.executeUpdate();\n            if (null == mib.getMetametadataIdentifierId()) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT @@Identity AS ID\");\n                rs = ps.executeQuery();\n                rs.next();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public void saveMetametadataContributor(MetametadataContributorBean mcb) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetametadataContributor(mcb, conn);\n            conn.commit();\n        } finally {\n            conn.setAutoCommit(true);\n            conn.close();\n        }\n    }\n\n    public void saveMetametadataIdentifier(MetametadataIdentifierBean mcb) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetametadataIdentifier(mcb, conn);\n            conn.commit();\n        } finally {\n            conn.setAutoCommit(true);\n            conn.close();\n        }\n    }\n\n    /**\n     * May have the side-effect of saving a vcard to the vCards table.\n     *\n     * @param mcb\n     * @param conn\n     * @throws SQLException\n     */\n    public void saveMetametadataContributor(MetametadataContributorBean mcb, Connection conn) throws SQLException {\n        final String sql;\n        if (null == mcb.getMetametadataContributorId()) {\n            sql = METAMETADATA_CONTRIBUTOR_INSERT_SQL;\n        } else {\n            sql = METAMETADATA_CONTRIBUTOR_UPDATE_SQL;\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String vcardId = cd.saveVCard(mcb.getvCard(), conn);\n            java.sql.Date date = null;\n            if (null != mcb.getDate()) {\n                date = new java.sql.Date(mcb.getDate().getTime());\n            }\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, mcb.getMetadataId());\n            ps.setString(2, mcb.getRole());\n            ps.setDate(3, date);\n            ps.setString(4, mcb.getDateDescription());\n            ps.setString(5, vcardId);\n            if (null != mcb.getMetametadataContributorId()) {\n                ps.setString(6, mcb.getMetametadataContributorId());\n            }\n            ps.executeUpdate();\n            if (null == mcb.getMetametadataContributorId()) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT @@Identity AS ID\");\n                rs = ps.executeQuery();\n                rs.next();\n                mcb.setMetametadataContributorId(rs.getString(1));\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Returns the count of total resources in the database\n     * Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfResources() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(metadataId) as Expr1 FROM Metadata where private = 0\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return count;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataDAOTest0.java",
		"test_prompt": "// MetadataDAOTest0.java\npackage org.heal.module.metadata;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport org.heal.util.CommonDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataDAO}.\n* It contains ten unit test cases for the {@link MetadataDAO#moveToDeletedItems(String, String, Connection)} method.\n*/\nclass MetadataDAOTest0 {"
	},
	{
		"original_code": "// MetadataDAO.java\npackage org.heal.module.metadata;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport org.heal.util.CommonDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.List;\n\n/**\n * This DAO was created by Grace, its content came from original MetadataServicesBean.java.\n * This contains the metadata access database functionality of\n * saving metadata as well as looking up short and IMS\n * records.  It also supports generating a metadata\n * collection in XML (for NSDL support) as well as\n * generating a list of content IDs for the NSDL.\n *\n * @author Seth Wright\n * @author Grace Yang\n */\npublic class MetadataDAO implements Serializable {\n\n    public MetadataDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private FileLocator fileLocator = null;\n\n    private static final String METADATAINSERTSQL = \"INSERT INTO Metadata (FileName, FileSize, Title, Location, SourceCollection, SourceCollectionID, ContributeUserID, ContributeDate, Annotated, Inappropriate, Archived, Private, Description, PublicationId, SubmissionAgreement, LearningResourceType, SpecimenType, RadiographType, Orientation, Magnification, ClinicalHistory, FileWidth, FileHeight, Duration, ApproveDate, CatalogDate, RejectDate, CreationDate, LanguageType) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String METADATAUPDATESQL = \"UPDATE Metadata SET FileName = ?, FileSize = ?, Title = ?, Location = ?, SourceCollection = ?, SourceCollectionID = ?, ContributeUserID = ?, ContributeDate = ?, Annotated = ?, Inappropriate = ?, Archived = ?, Private = ?, Description = ?, PublicationId = ?, SubmissionAgreement = ?, LearningResourceType = ?, SpecimenType = ?, RadiographType = ?, Orientation = ?, Magnification = ?, ClinicalHistory = ?, FileWidth = ?, FileHeight = ?, Duration = ?, ApproveDate = ?, CatalogDate = ?, RejectDate = ?, CreationDate = ? WHERE MetadataID = ?\";\n\n    private static final String PUBLICATIONINSERTSQL = \"INSERT INTO Publications (Name, PublicationDate) VALUES (?, ?)\";\n\n    private static final String PUBLICATIONUPDATESQL = \"UPDATE Publications SET Name = ?, PublicationDate = ? WHERE PublicationId = ?\";\n\n    private static final String METAMETADATA_IDENTIFIER_INSERT_SQL = \"INSERT INTO MetametadataIdentifiers (MetadataID, Catalogue, Entry, MetadataSchema) VALUES (?, ?, ?, ?)\";\n\n    private static final String METAMETADATA_IDENTIFIER_UPDATE_SQL = \"UPDATE MetametadataIdentifiers SET MetadataID = ?, Catalogue = ?, Entry = ?, MetadataSchema = ? WHERE MetametadataIdentifierID = ?\";\n\n    private static final String METAMETADATA_CONTRIBUTOR_INSERT_SQL = \"INSERT INTO MetametadataContributors (MetadataID, Role, ContributeDate, ContributeDateDescription, vCardID) VALUES (?, ?, ?, ?, ?)\";\n\n    private static final String METAMETADATA_CONTRIBUTOR_UPDATE_SQL = \"UPDATE MetametadataContributors SET MetadataID = ?, Role = ?, ContributeDate = ?, ContributeDateDescription = ?, vCardID = ? WHERE MetametadataContributorID = ?\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        MetadataBean metaBean = null;\n        try {\n            metaBean = cd.getMetadata(metadataId, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return metaBean;\n    }\n\n    /**\n     * Inserts the information about the specified metadata, or\n     * updates the information if it is already defined in the\n     * database.\n     */\n    public void saveMetadata(MetadataBean metadataInfo) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetadata(metadataInfo, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n    }\n\n    /**\n     * Inserts the information about the specified metadata,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveMetadata(MetadataBean metadata, Connection conn) throws SQLException {\n        if (metadata == null) {\n            return;\n        }\n        String sql;\n        MetadataBean dbInfo = cd.getMetadata(metadata.getMetadataId(), conn);\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql = METADATAINSERTSQL;\n        } else {\n            sql = METADATAUPDATESQL;\n        }\n        // Inserts the publication first in case we need the id\n        if (null != metadata.getPublicationName() || null != metadata.getPublicationId() || null != metadata.getPublicationDate()) {\n            final int publicationId = savePublication(metadata.getPublicationId(), metadata.getPublicationName(), metadata.getPublicationDate());\n            metadata.setPublicationId(String.valueOf(publicationId));\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(cd.getLongValue(metadata.getFileSize()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(new StringValue(metadata.getSourceCollection()));\n        values.addElement(new StringValue(metadata.getSourceCollectionId()));\n        values.addElement(cd.getIntValue(metadata.getContributeUserId()));\n        values.addElement(cd.getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new BooleanValue(metadata.isAnnotated()));\n        values.addElement(new BooleanValue(metadata.isInappropriate()));\n        values.addElement(new BooleanValue(metadata.isArchived()));\n        values.addElement(new BooleanValue(metadata.isPrivate()));\n        values.addElement(new StringValue(metadata.getDescription()));\n        values.addElement(new StringValue(metadata.getPublicationId()));\n        values.addElement(new StringValue(metadata.getSubmissionAgreement()));\n        values.addElement(new StringValue(metadata.getLearningResourceType()));\n        values.addElement(new StringValue(metadata.getSpecimenType()));\n        values.addElement(new StringValue(metadata.getRadiographType()));\n        values.addElement(new StringValue(metadata.getOrientation()));\n        values.addElement(new StringValue(metadata.getMagnification()));\n        values.addElement(new StringValue(metadata.getClinicalHistory()));\n        values.addElement(cd.getIntValue(metadata.getFileWidth()));\n        values.addElement(cd.getIntValue(metadata.getFileHeight()));\n        values.addElement(cd.getIntValue(metadata.getDuration()));\n        values.addElement(cd.getTimestampValue(metadata.getApproveDate()));\n        values.addElement(cd.getTimestampValue(metadata.getCatalogDate()));\n        values.addElement(cd.getTimestampValue(metadata.getRejectDate()));\n        values.addElement(cd.getTimestampValue(metadata.getCreationDate()));\n        values.addElement(new StringValue(metadata.getLanguageType()));\n        if (dbInfo != null) {\n            values.addElement(new StringValue(metadata.getMetadataId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Returns the short record for the specified metadata in XML format.\n     */\n    public String getShortRecord(String metadataId) throws SQLException, IOException {\n        ShortMetadataBean metaInfo = getShortMetadata(metadataId);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        HealMetadataXMLConverter.shortMetadataToXML(metaInfo, stream);\n        return stream.toString();\n    }\n\n    public ShortMetadataBean getShortMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        // Get the metadata info from the database\n        Row metadataRow = cd.getMetadataProperty(metadataId, \"MetadataID, GlobalID, \" + \"FileName, \" + \"FileSize, Title, \" + \"Description, Location, \" + \"SourceCollection, \" + \"FileWidth, FileHeight, \" + \"ContributeUserID,\" + \"LearningResourceType\", \"Metadata\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        ShortMetadataBean metadataInfo = new ShortMetadataBean();\n        try {\n            String sc = (String) metadataRow.getString(\"SourceCollection\");\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setCollectionBean(cd.getSCollectionBean(sc, conn));\n            metadataInfo.setThumbnail(cd.getThumbnail(metadataId, conn));\n            String format = cd.getMetadataPropertyAsString(metadataId, \"Format\", \"Formats\", conn);\n            metadataInfo.setFormat(format);\n            /*        } catch (UnsupportedConversionException uce) {\n                  throw new SQLException(uce.toString());\n            */\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns the IMS record for the specified metadata in XML format.\n     * XXX Is the parameter here the global id or the metadata id?\n     */\n    public String getIMSRecord(String metadataId) throws SQLException, IOException {\n        CompleteMetadataBean metaInfo = getCompleteMetadata(metadataId);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        HealMetadataXMLConverter.metadataToIMSXML(metaInfo, fileLocator, stream);\n        return stream.toString();\n    }\n\n    /**\n     * Returns information about the HEAL system as a whole.  This is to be\n     * returned to the NSDL, but the spec isn't out yet, so we don't know\n     * what to include here.\n     */\n    public String getCollectionMetadata() {\n        throw new UnsupportedOperationException(\"getCollectionMetadata not implemented\");\n    }\n\n    public CompleteMetadataBean getCompleteMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        CompleteMetadataBean result;\n        try {\n            result = getCompleteMetadata(metadataId, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return result;\n    }\n\n    public CompleteMetadataBean getCompleteMetadata(String metadataId, Connection conn) throws SQLException {\n        CompleteMetadataBean result = new CompleteMetadataBean();\n        try {\n            result.setMetadataId(metadataId);\n            MetadataBean m = cd.getMetadata(metadataId, conn);\n            String name = m.getSourceCollection();\n            result.setMetadata(m);\n            result.setDiseaseDiagnoses(getDiseaseDiagnoses(metadataId, conn));\n            result.setCopyrights(getCopyrights(metadataId, conn));\n            result.setTaxonPaths(getTaxonPaths(metadataId, conn));\n            result.setCopyrightHolders(getCopyrightHolders(metadataId, conn));\n            result.setContextURLs(getContextURLs(metadataId, conn));\n            result.setRequirements(getRequirements(metadataId, conn));\n            result.setContributors(getContributors(metadataId, conn));\n            result.setRelations(getRelations(metadataId, conn));\n            result.setKeywords(getKeywords(metadataId, conn));\n            result.setTargetUserGroups(getTargetUserGroups(metadataId, conn));\n            result.setFormats(getFormats(metadataId, conn));\n            result.setThumbnail(cd.getThumbnail(metadataId, conn));\n            result.setCollectionBean(cd.getSCollectionBean(name, conn));\n            result.setMetametadataIdentifiers(cd.getMetametadataIdentifiers(metadataId, conn));\n            result.setMetametadataContributors(cd.getMetametadataContributors(metadataId, conn));\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n        return result;\n    }\n\n    /**\n     * @param metadataId The metadataId of the target user groups to look up.\n     * @param conn The connection to the database to query.\n     *\n     * @return Am ArrayList of {@link org.heal.module.metadata.TargetUserGroupBean TargetUserGroupBeans}.\n     *         This method will never return <code>null</code>, but may return an empty\n     *         list if no target user groups are found for the given metadataId.\n     *\n     * @throws SQLException Thrown when a database error occurs.\n     */\n    private ArrayList getTargetUserGroups(String metadataId, Connection conn) throws SQLException {\n        ArrayList ret = new ArrayList();\n        Vector rows = cd.getMetadataProperties(metadataId, \"*\", \"TargetUserGroups\", conn);\n        if (null != rows) {\n            for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                Row row = (Row) iter.next();\n                try {\n                    TargetUserGroupBean tug = new TargetUserGroupBean();\n                    tug.setMetadataId(metadataId);\n                    tug.setTargetUserGroup(row.getString(\"TargetUserGroup\"));\n                    ret.add(tug);\n                } catch (NoSuchColumnException e) {\n                    throw new RuntimeException(e);\n                    // TODO logging?\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Saves a CompleteMetadataBean.  Only non-null properties are stored in\n     * the database.  For all properties except the MetadataBean, if the\n     * properties ID (i.e. TaxonID for a TaxonBean) is not null, an update\n     * will be performed for that entry.  If the ID is null, then an insert\n     * will be performed.\n     * If a set of data (for example the keywords) is null or empty, then no\n     * changes are made to those entries in the database.  If it is not\n     * null, then the keywords are added to the database, but the previous\n     * keywords stored in the database are not removed.  If you want to have\n     * the previous settings for the complete metadata bean fields removed,\n     * use updateCompleteMetadata.\n     */\n    public void saveCompleteMetadata(CompleteMetadataBean cmb) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveCompleteMetadata(cmb, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n    }\n\n    /**\n     * If the {@link CompleteMetadataBean} does not have a metadataId (for\n     * example if it represents a new record not yet in the database), then\n     * the <code>Connection</code> <em>must</em> be commited during the\n     * execution of this method.  However if a metadataId <em>does</em> exist,\n     * then the transactional state of the <code>Connection</code> will not\n     * be modified here.\n     *\n     * @see #saveCompleteMetadata(CompleteMetadataBean)\n     */\n    public void saveCompleteMetadata(CompleteMetadataBean cmb, Connection conn) throws SQLException {\n        List elems;\n        Iterator elemIterator;\n        saveMetadata(cmb, conn);\n        String metadataId = cmb.getMetadataId();\n        if (metadataId == null) {\n            //we need to store the metadata\n            conn.commit();\n            //now we look it up via the location so that we can get the id.\n            metadataId = getMetadataIdFromProperty(cmb.getLocation(), \"Location\", conn);\n        }\n        cmb.setMetadataId(metadataId);\n        elems = cmb.getDiseaseDiagnoses();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            DiseaseDiagnosisBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (DiseaseDiagnosisBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveDiseaseDiagnosis(elem, conn);\n            }\n        }\n        elems = cmb.getCopyrights();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveCopyright(elem, conn);\n            }\n        }\n        elems = cmb.getTaxonPaths();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            TaxonPathBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (TaxonPathBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveTaxonPath(elem, conn);\n            }\n        }\n        elems = cmb.getCopyrightHolders();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightHolderBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightHolderBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveCopyrightHolder(elem, conn);\n            }\n        }\n        elems = cmb.getContextURLs();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            ContextURLBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (ContextURLBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveContextURL(elem, conn);\n            }\n        }\n        elems = cmb.getRequirements();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RequirementBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RequirementBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveRequirement(elem, conn);\n            }\n        }\n        TreeMap contributors = cmb.getContributors();\n        Iterator contributorsIterator = contributors.values().iterator();\n        while (contributorsIterator.hasNext()) {\n            elems = (ArrayList) contributorsIterator.next();\n            if (elems != null) {\n                elemIterator = elems.iterator();\n                ContributorBean elem;\n                while (elemIterator.hasNext()) {\n                    elem = (ContributorBean) elemIterator.next();\n                    elem.setMetadataId(metadataId);\n                    cd.saveContributor(elem, conn);\n                }\n            }\n        }\n        elems = cmb.getRelations();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RelationBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RelationBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveRelation(elem, conn);\n            }\n        }\n        elems = cmb.getKeywords();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            KeywordBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (KeywordBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveKeyword(elem, conn);\n            }\n        }\n        elems = cmb.getTargetUserGroups();\n        if (null != elems) {\n            TargetUserGroupBean elem;\n            elemIterator = elems.iterator();\n            while (elemIterator.hasNext()) {\n                elem = (TargetUserGroupBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveTargetUserGroup(elem, conn);\n            }\n        }\n        elems = cmb.getFormats();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            FormatBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (FormatBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveFormat(elem, conn);\n            }\n        }\n        ThumbnailBean thumbnail = cmb.getThumbnail();\n        if (thumbnail != null) {\n            thumbnail.setMetadataId(metadataId);\n            cd.saveThumbnail(thumbnail, conn);\n        }\n        elems = cmb.getMetametadataIdentifiers();\n        if (null != elems) {\n            MetametadataIdentifierBean mib;\n            elemIterator = elems.listIterator();\n            while (elemIterator.hasNext()) {\n                mib = (MetametadataIdentifierBean) elemIterator.next();\n                mib.setMetadataId(metadataId);\n                saveMetametadataIdentifier(mib, conn);\n            }\n        }\n        elems = cmb.getMetametadataContributors();\n        if (null != elems) {\n            MetametadataContributorBean mcb;\n            elemIterator = elems.listIterator();\n            while (elemIterator.hasNext()) {\n                mcb = (MetametadataContributorBean) elemIterator.next();\n                mcb.setMetadataId(metadataId);\n                saveMetametadataContributor(mcb, conn);\n            }\n        }\n    }\n\n    /**\n     * Updates a CompleteMetadataBean.\n     * This differs from the saveCompleteMetadata method in that\n     * it will remove entries in the database that do not show up\n     * in the complete metadata parameter.\n     */\n    public void updateCompleteMetadata(CompleteMetadataBean cmb) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            updateCompleteMetadata(cmb, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n    }\n\n    /**\n     * Updates a CompleteMetadataBean.\n     * See updateCompleteMetadata(cmb)\n     */\n    public void updateCompleteMetadata(CompleteMetadataBean cmb, Connection conn) throws SQLException {\n        if (cmb == null || cmb.getMetadataId() == null || conn == null) {\n            return;\n        }\n        String metadataId = cmb.getMetadataId();\n        /* STRATEGY ALERT: (by Seth Wright)\n         * In the interest of finishing this portion of the project on time\n         * I am taking a slight shortcut.  Rather than determining the\n         * difference between the current database settings and the one we\n         * want, I am simply deleting all old entries and adding new ones.\n         * This could result in a large growth in the id numbers of\n         * such tables as keywords entries.\n         * So, here is what we do, we remove all settings from the database\n         * that are one to many relations and then call saveCompleteMetadata\n         * The fields with multiple entries are:\n         * taxons/taxonpaths\n         * relations\n         * requirements\n         * keywords\n         * formats\n         * disease diagnoses\n         * copyright holders\n         * contexturls\n         * contributors\n         * copyrights/copyrighttexts\n         */\n        cd.removeMetadataFromTable(metadataId, \"Relations\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Formats\", conn);\n        cd.removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        cd.removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        cd.removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        cd.removeMetadataFromTable(metadataId, \"TargetUserGroups\", conn);\n        cd.removeTaxonPaths(metadataId, conn);\n        cd.removeCopyrights(metadataId, conn);\n        doUpdateHack(cmb);\n        saveCompleteMetadata(cmb, conn);\n    }\n\n    /**\n     * The update hack is where the IDs (such as\n     * KeywordId) are stripped from the complete metadata bean.\n     * This is done so that saveCompleteMetadata works correctly.\n     */\n    private void doUpdateHack(CompleteMetadataBean cmb) {\n        ArrayList elems;\n        Iterator elemIterator;\n        /* change log\n        elems = cmb.getDiseaseDiagnoses();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            DiseaseDiagnosisBean elem;\n            while (elemIterator.hasNext()) {\n            elem = (DiseaseDiagnosisBean)elemIterator.next();\n            elem.setDiseaseDiagnosisId(null);\n            }\n        }*/\n        elems = cmb.getCopyrights();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightBean) elemIterator.next();\n                elem.setCopyrightId(null);\n            }\n        }\n        elems = cmb.getTaxonPaths();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            TaxonPathBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (TaxonPathBean) elemIterator.next();\n                elem.setTaxonPathId(null);\n            }\n        }\n        elems = cmb.getCopyrightHolders();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightHolderBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightHolderBean) elemIterator.next();\n                elem.setCopyrightHolderId(null);\n            }\n        }\n        elems = cmb.getContextURLs();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            ContextURLBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (ContextURLBean) elemIterator.next();\n                elem.setContextURLId(null);\n            }\n        }\n        elems = cmb.getRequirements();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RequirementBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RequirementBean) elemIterator.next();\n                elem.setRequirementId(null);\n            }\n        }\n        TreeMap contributors = cmb.getContributors();\n        Iterator contributorsIterator = contributors.values().iterator();\n        while (contributorsIterator.hasNext()) {\n            elems = (ArrayList) contributorsIterator.next();\n            if (elems != null) {\n                elemIterator = elems.iterator();\n                ContributorBean elem;\n                while (elemIterator.hasNext()) {\n                    elem = (ContributorBean) elemIterator.next();\n                    elem.setContributorId(null);\n                }\n            }\n        }\n        elems = cmb.getRelations();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RelationBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RelationBean) elemIterator.next();\n                elem.setRelationId(null);\n            }\n        }\n        elems = cmb.getKeywords();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            KeywordBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (KeywordBean) elemIterator.next();\n                elem.setKeywordId(null);\n            }\n        }\n        elems = cmb.getFormats();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            FormatBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (FormatBean) elemIterator.next();\n                elem.setFormatId(null);\n            }\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = cd.getMetadata(metadataId, conn);\n        cd.addToDeletedItems(metadata, comment, conn);\n        success = cd.deleteMetadataReferences(metadataId, conn);\n        cd.removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Returns a ArrayList of DiseaseDiagnosisBeans associated with the\n     * given metadataId.\n     * If no diagnoses are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getDiseaseDiagnoses(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"DiseaseDiagnosisID, \" + \"DiseaseDiagnosis\", \"DiseaseDiagnoses\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                DiseaseDiagnosisBean dd;\n                String id;\n                String ddString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    dd = new DiseaseDiagnosisBean();\n                    id = row.getString(\"DiseaseDiagnosisID\");\n                    ddString = row.getString(\"DiseaseDiagnosis\");\n                    dd.setDiseaseDiagnosisId(id);\n                    dd.setMetadataId(metadataId);\n                    dd.setDiseaseDiagnosis(ddString);\n                    results.add(dd);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of CopyrightBeans associated with the\n     * given metadataId.\n     * If no copyrightss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getCopyrights(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"CopyrightID, CopyrightTextID\", \"Copyrights\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                CopyrightBean copyright;\n                CopyrightTextBean copyrightText;\n                String copyrightTextString;\n                String copyrightId;\n                String copyrightTextId;\n                SQLCommandBean sqlCommandBean = new SQLCommandBean();\n                sqlCommandBean.setConnection(conn);\n                sqlCommandBean.setSqlValue(\"SELECT CopyrightText FROM CopyrightTexts WHERE CopyrightTextID = ?\");\n                Vector values = new Vector();\n                Vector copyrighttextrows = null;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    copyright = new CopyrightBean();\n                    copyrightId = row.getString(\"CopyrightID\");\n                    copyrightTextId = row.getString(\"CopyrightTextID\");\n                    copyright.setCopyrightId(copyrightId);\n                    copyright.setMetadataId(metadataId);\n                    copyrightText = null;\n                    values.clear();\n                    values.addElement(new StringValue(copyrightTextId));\n                    sqlCommandBean.setValues(values);\n                    try {\n                        copyrighttextrows = sqlCommandBean.executeQuery();\n                    } catch (UnsupportedTypeException e) {\n                        throw new SQLException(e.toString());\n                    }\n                    if (copyrighttextrows != null && copyrighttextrows.size() > 0) {\n                        row = (Row) copyrighttextrows.firstElement();\n                        copyrightTextString = row.getString(\"CopyrightText\");\n                        copyrightText = new CopyrightTextBean();\n                        copyrightText.setCopyrightTextId(copyrightTextId);\n                        copyrightText.setCopyrightText(copyrightTextString);\n                    }\n                    copyright.setCopyrightText(copyrightText);\n                    results.add(copyright);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of CopyrightHolderBeans associated with the\n     * given metadataId.\n     * If no copyright holders are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getCopyrightHolders(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            // queries the database\n            Vector rows;\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT a.CopyrightHolderID, b.vCard \");\n            sql.append(\"FROM  CopyrightHolders a INNER JOIN\");\n            sql.append(\"  vCards b ON a.vCardID = b.vCardID \");\n            sql.append(\"WHERE  (a.MetadataID = ?)\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            sqlCommandBean.setValues(values);\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                CopyrightHolderBean ch;\n                String id;\n                String chString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    ch = new CopyrightHolderBean();\n                    id = row.getString(\"CopyrightHolderID\");\n                    chString = row.getString(\"VCard\");\n                    ch.setCopyrightHolderId(id);\n                    ch.setMetadataId(metadataId);\n                    ch.setVCard(chString);\n                    results.add(ch);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of TaxonPathBeans associated with the given\n     * metadataId.\n     * If no taxonPathss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getTaxonPaths(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        try {\n            return getTaxonPaths(metadataId, conn);\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n    }\n\n    /**\n     * Returns a ArrayList of TaxonPathBeans associated with the given\n     * metadataId.\n     * If no taxonPathss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getTaxonPaths(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"TaxonPathID, Source\", \"TaxonPaths\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                TaxonPathBean taxonPath;\n                String taxonPathId;\n                String taxonPathSource;\n                TaxonBean taxon = null;\n                String taxonId, id, entry;\n                SQLCommandBean sqlCommandBean = new SQLCommandBean();\n                sqlCommandBean.setConnection(conn);\n                sqlCommandBean.setSqlValue(\"SELECT TaxonID, ID, Entry FROM Taxons WHERE TaxonPathID = ?\");\n                Vector values = new Vector();\n                Vector taxonrows = null;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    taxonPath = new TaxonPathBean();\n                    taxonPathId = row.getString(\"TaxonPathID\");\n                    taxonPathSource = row.getString(\"Source\");\n                    taxonPath.setTaxonPathId(taxonPathId);\n                    taxonPath.setMetadataId(metadataId);\n                    taxonPath.setSource(taxonPathSource);\n                    values.clear();\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    try {\n                        taxonrows = sqlCommandBean.executeQuery();\n                    } catch (UnsupportedTypeException e) {\n                        throw new SQLException(e.toString());\n                    }\n                    if (taxonrows != null && taxonrows.size() > 0) {\n                        Iterator taxonIterator = taxonrows.iterator();\n                        while (taxonIterator.hasNext()) {\n                            row = (Row) taxonIterator.next();\n                            taxon = new TaxonBean();\n                            taxonId = row.getString(\"TaxonID\");\n                            id = row.getString(\"ID\");\n                            entry = row.getString(\"Entry\");\n                            taxon.setTaxonId(taxonId);\n                            taxon.setTaxonPathId(taxonPathId);\n                            taxon.setId(id);\n                            taxon.setEntry(entry);\n                            taxonPath.addTaxon(taxon);\n                        }\n                    }\n                    results.add(taxonPath);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of ContextURLBeans associated with the given\n     * If no contextURLs are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getContextURLs(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"ContextURLID, ContextURL, ContextURLDescription\", \"ContextURLs\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                ContextURLBean contextURL;\n                String contextURLId;\n                String contextURLString;\n                String contextURLDescription;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    contextURL = new ContextURLBean();\n                    contextURLId = row.getString(\"ContextURLID\");\n                    contextURLString = row.getString(\"ContextURL\");\n                    contextURLDescription = row.getString(\"ContextURLDescription\");\n                    contextURL.setContextURLId(contextURLId);\n                    contextURL.setMetadataId(metadataId);\n                    contextURL.setContextURL(contextURLString);\n                    contextURL.setContextURLDescription(contextURLDescription);\n                    results.add(contextURL);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of RequirementBeans associated with the\n     * given metadataId.\n     * If no requirements are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getRequirements(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"RequirementID, \" + \"RequirementType, \" + \"RequirementName\", \"Requirements\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                RequirementBean rb;\n                String id;\n                String requirementType, requirementName;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    rb = new RequirementBean();\n                    id = row.getString(\"RequirementID\");\n                    requirementType = row.getString(\"RequirementType\");\n                    requirementName = row.getString(\"RequirementName\");\n                    rb.setRequirementId(id);\n                    rb.setMetadataId(metadataId);\n                    rb.setRequirementType(requirementType);\n                    rb.setRequirementName(requirementName);\n                    results.add(rb);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a TreeMap of ContributorBeans associated with the\n     * given metadataId.\n     * If no contributors are found or an error occurs, an empty TreeMap is\n     * returned.\n     */\n    public TreeMap getContributors(String metadataId, Connection conn) throws SQLException {\n        TreeMap results = new TreeMap();\n        if (metadataId != null) {\n            // queries the database\n            PreparedStatement ps = null;\n            ResultSet rs = null;\n            try {\n                StringBuffer sql = new StringBuffer();\n                sql.append(\"SELECT a.ContributorID, a.Role, a.ContributeDate,\").append(\" a.ContributeDateDescription, b.vCard \");\n                sql.append(\"FROM  Contributors a INNER JOIN\");\n                sql.append(\"  vCards b ON a.VCardID = b.vCardID \");\n                sql.append(\"WHERE  (a.MetadataID = ?)\");\n                ps = conn.prepareStatement(sql.toString());\n                ps.setString(1, metadataId);\n                rs = ps.executeQuery();\n                while (rs.next()) {\n                    ContributorBean cb = new ContributorBean();\n                    final String id = rs.getString(1);\n                    final String role = rs.getString(2);\n                    final Date contributeDate = rs.getDate(3);\n                    final String contributeDateDescription = rs.getString(4);\n                    final String vCard = rs.getString(5);\n                    cb.setContributorId(id);\n                    cb.setRole(role);\n                    cb.setDate(contributeDate);\n                    cb.setDateDescription(contributeDateDescription);\n                    cb.setVCard(vCard);\n                    List roles = (List) results.get(role);\n                    if (null == roles) {\n                        roles = new ArrayList();\n                        results.put(role, roles);\n                    }\n                    roles.add(cb);\n                }\n            } finally {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of RelationBeans associated with the\n     * given metadataId.\n     * If no relations are found or an error occurs, an empty ArrayList\n     * is returned.\n     */\n    public ArrayList getRelations(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"RelationID, \" + \"Resource, Kind, Description\", \"Relations\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                RelationBean rb;\n                String id;\n                String resource, kind, description;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    rb = new RelationBean();\n                    id = row.getString(\"RelationID\");\n                    resource = row.getString(\"Resource\");\n                    kind = row.getString(\"Kind\");\n                    description = row.getString(\"Description\");\n                    rb.setRelationId(id);\n                    rb.setMetadataId(metadataId);\n                    rb.setResource(resource);\n                    rb.setKind(kind);\n                    rb.setDescription(description);\n                    results.add(rb);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns an ArrayList of KeywordBeans associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getKeywords(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"KeywordID, Keyword\", \"Keywords\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                KeywordBean keyword;\n                String keywordId;\n                String keywordString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    keyword = new KeywordBean();\n                    keywordId = row.getString(\"KeywordID\");\n                    keywordString = row.getString(\"Keyword\");\n                    keyword.setKeywordId(keywordId);\n                    keyword.setMetadataId(metadataId);\n                    keyword.setKeyword(keywordString);\n                    results.add(keyword);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns an ArrayList of FormatBeans associated with the given\n     * metadataId.\n     * If no format is found or an error occurs, an empty ArrayList\n     * is returned.\n     */\n    public ArrayList getFormats(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"FormatID, Format\", \"Formats\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                FormatBean format;\n                String formatId;\n                String formatString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    format = new FormatBean();\n                    formatId = row.getString(\"FormatID\");\n                    formatString = row.getString(\"Format\");\n                    format.setFormatId(formatId);\n                    format.setMetadataId(metadataId);\n                    format.setFormat(formatString);\n                    results.add(format);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns the first metadataId returned when the Metadata table is\n     * queried for all entries with the given value for the given column.\n     */\n    public String getMetadataIdFromProperty(String columnValue, String columnName, Connection conn) throws SQLException {\n        if (columnName == null || columnValue == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT MetadataID FROM Metadata \").append(\"WHERE \" + columnName + \" = ? ORDER BY MetadataID DESC\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(columnValue));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // nothing found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        try {\n            String metadataId = aRow.getString(\"MetadataID\");\n            return metadataId;\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n    }\n\n    /**\n     * Returns the first metadataId returned when the Metadata table is\n     * queried for all entries with the given value for the given column.\n     */\n    public String getMetadataIdFromProperty(String columnValue, String columnName) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        String metadataId = null;\n        try {\n            metadataId = getMetadataIdFromProperty(columnValue, columnName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return metadataId;\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     */\n    public ArrayList getPointerListArrayList(java.util.Date lastReceivedDate) throws SQLException {\n        return getPointerList(lastReceivedDate, false);\n    }\n\n    /**\n     * Returns a list of content Ids in XML format.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     */\n    public String getPointerList(java.util.Date lastReceivedDate) throws SQLException, IOException {\n        ArrayList ids = getPointerList(lastReceivedDate, false);\n        return HealMetadataXMLConverter.getPointerListXML(ids);\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     * If the includeHidden parameter is set to true, all metadata Ids are\n     * returned, not just those set as visible.  If the parameter\n     * set to false, then only those set as \"visible\" will be returned.\n     */\n    public ArrayList getPointerListArrayList(java.util.Date lastReceivedDate, boolean includeHidden) throws SQLException {\n        return getPointerList(lastReceivedDate, includeHidden);\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     * Depending upon the second parameter, this method will return a list\n     * containing only metadata not marked as hidden if false, and all\n     * metadata Ids if the includeHidden parameter is set to true.\n     */\n    public ArrayList getPointerList(java.util.Date lastReceivedDate, boolean includeHidden) throws SQLException {\n        ArrayList ids = null;\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT MetadataID FROM Metadata\");\n        Vector values = new Vector();\n        if (lastReceivedDate != null) {\n            Timestamp lastReceivedTimestamp = new Timestamp(lastReceivedDate.getTime());\n            values.addElement(new TimestampValue(lastReceivedTimestamp));\n            if (!includeHidden) {\n                sql.append(\" WHERE CatalogDate >= ? AND Private = ?\");\n                values.addElement(new BooleanValue(includeHidden));\n            } else {\n                //if we want to show all, then don't filter Private setting\n                sql.append(\" WHERE CatalogDate >= ?\");\n            }\n            sqlCommandBean.setValues(values);\n        } else if (!includeHidden) {\n            //we only want to screen if we are EXCLUDING ids(don't show hidden)\n            sql.append(\" WHERE Private = ?\");\n            values.addElement(new BooleanValue(includeHidden));\n            sqlCommandBean.setValues(values);\n        }\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            if (rows != null && rows.size() > 0) {\n                ids = new ArrayList();\n                Iterator rowIter = rows.iterator();\n                while (rowIter.hasNext()) {\n                    String id = ((Row) rowIter.next()).getString(\"MetadataID\");\n                    ids.add(id);\n                }\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException e2) {\n            throw new SQLException(e2.toString());\n        } finally // Can not happen here\n        {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        //cycle through all of the rows and pull out the MetadataIDs\n        return ids;\n    }\n\n    /**\n     * Used by {@link org.heal.servlet.cataloger.SaveMetadataAction SaveMetadataAction}\n     * so that we can manage a database transaction when updating old records.  This method\n     * is somewhat specific to SaveMetadataAction.\n     *\n     * @param cmb The {@link org.heal.module.metadata.CompleteMetadataBean CompleteMetadataBean}\n     * generated from form data.\n     */\n    public void saveEditMetadataForm(CompleteMetadataBean cmb) throws SQLException {\n        final String metadataId = cmb.getMetadataId();\n        Set contextURLExcludes = new HashSet();\n        for (Iterator iter = cmb.getContextURLs().iterator(); iter.hasNext(); ) {\n            final ContextURLBean cub = (ContextURLBean) iter.next();\n            if (null != cub && null != cub.getContextURLId()) {\n                contextURLExcludes.add(cub.getContextURLId());\n            }\n        }\n        Set contributorExcludes = new HashSet();\n        for (Iterator iter = cmb.getContributorList().iterator(); iter.hasNext(); ) {\n            final ContributorBean cb = (ContributorBean) iter.next();\n            if (null != cb.getContributorId()) {\n                contributorExcludes.add(cb.getContributorId());\n            }\n        }\n        Set copyrightHolderExcludes = new HashSet();\n        for (Iterator iter = cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n            final CopyrightHolderBean chb = (CopyrightHolderBean) iter.next();\n            if (null != chb.getCopyrightHolderId()) {\n                copyrightHolderExcludes.add(chb.getCopyrightHolderId());\n            }\n        }\n        Set taxonPathExcludes = new HashSet();\n        for (Iterator iter = cmb.getTaxonPaths().iterator(); iter.hasNext(); ) {\n            final TaxonPathBean tpb = (TaxonPathBean) iter.next();\n            if (null != tpb.getTaxonPathId()) {\n                taxonPathExcludes.add(tpb.getTaxonPathId());\n            }\n        }\n        Set requirementExcludes = new HashSet();\n        for (Iterator iter = cmb.getRequirements().iterator(); iter.hasNext(); ) {\n            final RequirementBean rb = (RequirementBean) iter.next();\n            if (null != rb.getRequirementId()) {\n                requirementExcludes.add(rb.getRequirementId());\n            }\n        }\n        Set relationExcludes = new HashSet();\n        for (Iterator iter = cmb.getRelations().iterator(); iter.hasNext(); ) {\n            final RelationBean rb = (RelationBean) iter.next();\n            if (null != rb.getRelationId()) {\n                relationExcludes.add(rb.getRelationId());\n            }\n        }\n        Set mmIdentifierExcludes = new HashSet();\n        for (Object o : cmb.getMetametadataIdentifiers()) {\n            final MetametadataIdentifierBean mib = (MetametadataIdentifierBean) o;\n            if (null != mib.getMetametadataIdentifierId()) {\n                mmIdentifierExcludes.add(mib.getMetametadataIdentifierId());\n            }\n        }\n        Set mmContributorExcludes = new HashSet();\n        for (Object o : cmb.getMetametadataContributors()) {\n            final MetametadataContributorBean mcb = (MetametadataContributorBean) o;\n            if (null != mcb.getMetametadataContributorId()) {\n                mmContributorExcludes.add(mcb.getMetametadataContributorId());\n            }\n        }\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            if (null != metadataId) {\n                // If this is an existing metadata record, we must\n                // change the values in the database currently to\n                // match the CompleteMetadataBean submitted from the\n                // edit page\n                cd.removeMetadataFromTable(metadataId, \"Keywords\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Formats\", conn);\n                cd.removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n                cd.removeMetadataFromTable(metadataId, \"TargetUserGroups\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Copyrights\", conn);\n                deleteForeignKeyRecordsNotInSet(\"ContextURLs\", \"MetadataID\", \"ContextURLID\", metadataId, contextURLExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Contributors\", \"MetadataID\", \"ContributorID\", metadataId, contributorExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"CopyrightHolders\", \"MetadataID\", \"CopyrightHolderID\", metadataId, copyrightHolderExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"TaxonPaths\", \"MetadataID\", \"TaxonPathID\", metadataId, taxonPathExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Requirements\", \"MetadataID\", \"RequirementID\", metadataId, requirementExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Relations\", \"MetadataID\", \"RelationID\", metadataId, relationExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"MetametadataIdentifiers\", \"MetadataID\", \"MetametadataIdentifierID\", metadataId, mmIdentifierExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"MetametadataContributors\", \"MetadataID\", \"MetametadataContributorID\", metadataId, mmContributorExcludes, conn);\n                for (Iterator iter = cmb.getTaxonPaths().iterator(); iter.hasNext(); ) {\n                    final TaxonPathBean tpb = (TaxonPathBean) iter.next();\n                    final String taxonPathId = tpb.getTaxonPathId();\n                    if (null != taxonPathId) {\n                        Set taxonExcludes = new HashSet();\n                        for (Iterator iterTwo = tpb.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                            final TaxonBean tb = (TaxonBean) iterTwo.next();\n                            if (null != tb.getTaxonId()) {\n                                taxonExcludes.add(tb.getTaxonId());\n                            }\n                        }\n                        deleteForeignKeyRecordsNotInSet(\"Taxons\", \"TaxonPathID\", \"TaxonID\", taxonPathId, taxonExcludes, conn);\n                    }\n                }\n            }\n            // Cleaning up pieces of the metadata which are empty, and therefor\n            // should be null when inserted in the database...\n            if (isEmpty(cmb.getGlobalId())) {\n                cmb.setGlobalId(null);\n            }\n            if (isEmpty(cmb.getSpecimenType())) {\n                cmb.setSpecimenType(null);\n            }\n            if (isEmpty(cmb.getRadiographType())) {\n                cmb.setRadiographType(null);\n            }\n            if (isEmpty(cmb.getOrientation())) {\n                cmb.setOrientation(null);\n            }\n            if (isEmpty(cmb.getMagnification())) {\n                cmb.setMagnification(null);\n            }\n            if (isEmpty(cmb.getClinicalHistory())) {\n                cmb.setClinicalHistory(null);\n            }\n            if (null != cmb.getThumbnail()) {\n                final ThumbnailBean tb = cmb.getThumbnail();\n                if (isEmpty(tb.getFileHeight()) && isEmpty(tb.getFileWidth()) && isEmpty(tb.getLocation())) {\n                    cmb.setThumbnail(null);\n                }\n            }\n            saveCompleteMetadata(cmb, conn);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.close();\n        }\n    }\n\n    private static boolean isEmpty(String str) {\n        boolean empty = false;\n        if (null == str || str.trim().length() == 0) {\n            empty = true;\n        }\n        return empty;\n    }\n\n    /**\n     * Deletes records from a table that match a given foreign key and which\n     * do not have ids that are found in a <code>Set</code>.\n     *\n     * @param tableName The name of the table to delete records from.\n     * @param foreignKeyFieldName The name of the field which acts as a foreign key in the table.\n     * @param excludeFieldName The name of the field to match id's to exclude from the deletion.\n     * @param foreignKey The foreign key value associated with the records to delete.\n     * @param excludes A set of Strings representing ids of records that should\n     * not be deleted.\n     * @param conn The <code>Connection</code> to the database.\n     *\n     * @throws SQLException\n     */\n    public void deleteForeignKeyRecordsNotInSet(String tableName, String foreignKeyFieldName, String excludeFieldName, String foreignKey, Set excludes, Connection conn) throws SQLException {\n        String sql;\n        if (0 < excludes.size()) {\n            StringBuffer exclude = new StringBuffer(\"(\");\n            for (int i = 0; i < excludes.size(); ++i) {\n                exclude.append(\"?\");\n                if (i < (excludes.size() - 1)) {\n                    exclude.append(\", \");\n                }\n            }\n            exclude.append(\")\");\n            sql = \"DELETE FROM \" + tableName + \" WHERE \" + foreignKeyFieldName + \" = ? AND \" + excludeFieldName + \" NOT IN \" + exclude.toString();\n        } else {\n            sql = \"DELETE FROM \" + tableName + \" WHERE \" + foreignKeyFieldName + \"= ?\";\n        }\n        PreparedStatement ps = conn.prepareStatement(sql);\n        try {\n            ps.setInt(1, Integer.parseInt(foreignKey));\n            int nextParameter = 2;\n            for (Iterator iter = excludes.iterator(); iter.hasNext(); ) {\n                final String exclude = (String) iter.next();\n                ps.setInt(nextParameter, Integer.parseInt(exclude));\n                ++nextParameter;\n            }\n            ps.executeUpdate();\n        } finally {\n            ps.close();\n        }\n    }\n\n    public int savePublication(String id, String name, Date publicationDate) throws SQLException {\n        int ret = 0;\n        Connection conn = dataSource.getConnection();\n        try {\n            ret = savePublication(id, name, publicationDate, dataSource.getConnection());\n        } finally {\n            if (null != conn) {\n                conn.close();\n            }\n        }\n        return ret;\n    }\n\n    public int savePublication(String id, String name, Date publicationDate, Connection conn) throws SQLException {\n        Integer ret = null;\n        try {\n            ret = new Integer(Integer.parseInt(id));\n        } catch (NumberFormatException e) {\n            // does nothing\n        }\n        String sql;\n        if (null == ret) {\n            sql = PUBLICATIONINSERTSQL;\n        } else {\n            sql = PUBLICATIONUPDATESQL;\n        }\n        java.sql.Date publicationSqlDate = null;\n        if (null != publicationDate) {\n            publicationSqlDate = new java.sql.Date(publicationDate.getTime());\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, name);\n            ps.setDate(2, publicationSqlDate);\n            if (null != ret) {\n                ps.setInt(3, ret.intValue());\n            }\n            ps.executeUpdate();\n            if (null == ret) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT MAX(PublicationId) AS uid FROM Publications\");\n                rs = ps.executeQuery();\n                if (rs.next()) {\n                    ret = new Integer(rs.getInt(1));\n                }\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        if (null == ret) {\n            throw new RuntimeException(\"Unable to save publication: ('\" + id + \"', '\" + name + \"', '\" + publicationDate.toString() + \"')\");\n        }\n        return ret.intValue();\n    }\n\n    public void saveMetametadataIdentifier(MetametadataIdentifierBean mib, Connection conn) throws SQLException {\n        final String sql;\n        if (null == mib.getMetametadataIdentifierId()) {\n            sql = METAMETADATA_IDENTIFIER_INSERT_SQL;\n        } else {\n            sql = METAMETADATA_IDENTIFIER_UPDATE_SQL;\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, mib.getMetadataId());\n            ps.setString(2, mib.getCatalog());\n            ps.setString(3, mib.getEntry());\n            ps.setString(4, mib.getMetadataSchema());\n            if (null != mib.getMetametadataIdentifierId()) {\n                ps.setString(5, mib.getMetametadataIdentifierId());\n            }\n            ps.executeUpdate();\n            if (null == mib.getMetametadataIdentifierId()) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT @@Identity AS ID\");\n                rs = ps.executeQuery();\n                rs.next();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public void saveMetametadataContributor(MetametadataContributorBean mcb) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetametadataContributor(mcb, conn);\n            conn.commit();\n        } finally {\n            conn.setAutoCommit(true);\n            conn.close();\n        }\n    }\n\n    public void saveMetametadataIdentifier(MetametadataIdentifierBean mcb) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetametadataIdentifier(mcb, conn);\n            conn.commit();\n        } finally {\n            conn.setAutoCommit(true);\n            conn.close();\n        }\n    }\n\n    /**\n     * May have the side-effect of saving a vcard to the vCards table.\n     *\n     * @param mcb\n     * @param conn\n     * @throws SQLException\n     */\n    public void saveMetametadataContributor(MetametadataContributorBean mcb, Connection conn) throws SQLException {\n        final String sql;\n        if (null == mcb.getMetametadataContributorId()) {\n            sql = METAMETADATA_CONTRIBUTOR_INSERT_SQL;\n        } else {\n            sql = METAMETADATA_CONTRIBUTOR_UPDATE_SQL;\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String vcardId = cd.saveVCard(mcb.getvCard(), conn);\n            java.sql.Date date = null;\n            if (null != mcb.getDate()) {\n                date = new java.sql.Date(mcb.getDate().getTime());\n            }\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, mcb.getMetadataId());\n            ps.setString(2, mcb.getRole());\n            ps.setDate(3, date);\n            ps.setString(4, mcb.getDateDescription());\n            ps.setString(5, vcardId);\n            if (null != mcb.getMetametadataContributorId()) {\n                ps.setString(6, mcb.getMetametadataContributorId());\n            }\n            ps.executeUpdate();\n            if (null == mcb.getMetametadataContributorId()) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT @@Identity AS ID\");\n                rs = ps.executeQuery();\n                rs.next();\n                mcb.setMetametadataContributorId(rs.getString(1));\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Returns the count of total resources in the database\n     * Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfResources() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(metadataId) as Expr1 FROM Metadata where private = 0\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return count;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataDAOTest1.java",
		"test_prompt": "// MetadataDAOTest1.java\npackage org.heal.module.metadata;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport org.heal.util.CommonDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataDAO}.\n* It contains ten unit test cases for the {@link MetadataDAO#savePublication(String, String, Date)} method.\n*/\nclass MetadataDAOTest1 {"
	},
	{
		"original_code": "// MetadataDAO.java\npackage org.heal.module.metadata;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport org.heal.util.CommonDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.List;\n\n/**\n * This DAO was created by Grace, its content came from original MetadataServicesBean.java.\n * This contains the metadata access database functionality of\n * saving metadata as well as looking up short and IMS\n * records.  It also supports generating a metadata\n * collection in XML (for NSDL support) as well as\n * generating a list of content IDs for the NSDL.\n *\n * @author Seth Wright\n * @author Grace Yang\n */\npublic class MetadataDAO implements Serializable {\n\n    public MetadataDAO() {\n    }\n\n    private DataSource dataSource;\n\n    private CommonDAO cd = new CommonDAO();\n\n    private FileLocator fileLocator = null;\n\n    private static final String METADATAINSERTSQL = \"INSERT INTO Metadata (FileName, FileSize, Title, Location, SourceCollection, SourceCollectionID, ContributeUserID, ContributeDate, Annotated, Inappropriate, Archived, Private, Description, PublicationId, SubmissionAgreement, LearningResourceType, SpecimenType, RadiographType, Orientation, Magnification, ClinicalHistory, FileWidth, FileHeight, Duration, ApproveDate, CatalogDate, RejectDate, CreationDate, LanguageType) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\";\n\n    private static final String METADATAUPDATESQL = \"UPDATE Metadata SET FileName = ?, FileSize = ?, Title = ?, Location = ?, SourceCollection = ?, SourceCollectionID = ?, ContributeUserID = ?, ContributeDate = ?, Annotated = ?, Inappropriate = ?, Archived = ?, Private = ?, Description = ?, PublicationId = ?, SubmissionAgreement = ?, LearningResourceType = ?, SpecimenType = ?, RadiographType = ?, Orientation = ?, Magnification = ?, ClinicalHistory = ?, FileWidth = ?, FileHeight = ?, Duration = ?, ApproveDate = ?, CatalogDate = ?, RejectDate = ?, CreationDate = ? WHERE MetadataID = ?\";\n\n    private static final String PUBLICATIONINSERTSQL = \"INSERT INTO Publications (Name, PublicationDate) VALUES (?, ?)\";\n\n    private static final String PUBLICATIONUPDATESQL = \"UPDATE Publications SET Name = ?, PublicationDate = ? WHERE PublicationId = ?\";\n\n    private static final String METAMETADATA_IDENTIFIER_INSERT_SQL = \"INSERT INTO MetametadataIdentifiers (MetadataID, Catalogue, Entry, MetadataSchema) VALUES (?, ?, ?, ?)\";\n\n    private static final String METAMETADATA_IDENTIFIER_UPDATE_SQL = \"UPDATE MetametadataIdentifiers SET MetadataID = ?, Catalogue = ?, Entry = ?, MetadataSchema = ? WHERE MetametadataIdentifierID = ?\";\n\n    private static final String METAMETADATA_CONTRIBUTOR_INSERT_SQL = \"INSERT INTO MetametadataContributors (MetadataID, Role, ContributeDate, ContributeDateDescription, vCardID) VALUES (?, ?, ?, ?, ?)\";\n\n    private static final String METAMETADATA_CONTRIBUTOR_UPDATE_SQL = \"UPDATE MetametadataContributors SET MetadataID = ?, Role = ?, ContributeDate = ?, ContributeDateDescription = ?, vCardID = ? WHERE MetametadataContributorID = ?\";\n\n    /**\n     * Sets the dataSource property value.\n     */\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    /**\n     * Returns a MetadataBean initialized with the information\n     * found in the database specified by the given metadataId,\n     * or null if the metadataId is not found in the database.\n     */\n    public MetadataBean getMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        MetadataBean metaBean = null;\n        try {\n            metaBean = cd.getMetadata(metadataId, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return metaBean;\n    }\n\n    /**\n     * Inserts the information about the specified metadata, or\n     * updates the information if it is already defined in the\n     * database.\n     */\n    public void saveMetadata(MetadataBean metadataInfo) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetadata(metadataInfo, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n    }\n\n    /**\n     * Inserts the information about the specified metadata,\n     * or updates the information if it's already defined in the\n     * database.\n     */\n    public void saveMetadata(MetadataBean metadata, Connection conn) throws SQLException {\n        if (metadata == null) {\n            return;\n        }\n        String sql;\n        MetadataBean dbInfo = cd.getMetadata(metadata.getMetadataId(), conn);\n        if (dbInfo == null) {\n            // Use INSERT statement\n            sql = METADATAINSERTSQL;\n        } else {\n            sql = METADATAUPDATESQL;\n        }\n        // Inserts the publication first in case we need the id\n        if (null != metadata.getPublicationName() || null != metadata.getPublicationId() || null != metadata.getPublicationDate()) {\n            final int publicationId = savePublication(metadata.getPublicationId(), metadata.getPublicationName(), metadata.getPublicationDate());\n            metadata.setPublicationId(String.valueOf(publicationId));\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        sqlCommandBean.setSqlValue(sql);\n        Vector values = new Vector();\n        values.addElement(new StringValue(metadata.getFileName()));\n        values.addElement(cd.getLongValue(metadata.getFileSize()));\n        values.addElement(new StringValue(metadata.getTitle()));\n        values.addElement(new StringValue(metadata.getLocation()));\n        values.addElement(new StringValue(metadata.getSourceCollection()));\n        values.addElement(new StringValue(metadata.getSourceCollectionId()));\n        values.addElement(cd.getIntValue(metadata.getContributeUserId()));\n        values.addElement(cd.getTimestampValue(metadata.getContributeDate()));\n        values.addElement(new BooleanValue(metadata.isAnnotated()));\n        values.addElement(new BooleanValue(metadata.isInappropriate()));\n        values.addElement(new BooleanValue(metadata.isArchived()));\n        values.addElement(new BooleanValue(metadata.isPrivate()));\n        values.addElement(new StringValue(metadata.getDescription()));\n        values.addElement(new StringValue(metadata.getPublicationId()));\n        values.addElement(new StringValue(metadata.getSubmissionAgreement()));\n        values.addElement(new StringValue(metadata.getLearningResourceType()));\n        values.addElement(new StringValue(metadata.getSpecimenType()));\n        values.addElement(new StringValue(metadata.getRadiographType()));\n        values.addElement(new StringValue(metadata.getOrientation()));\n        values.addElement(new StringValue(metadata.getMagnification()));\n        values.addElement(new StringValue(metadata.getClinicalHistory()));\n        values.addElement(cd.getIntValue(metadata.getFileWidth()));\n        values.addElement(cd.getIntValue(metadata.getFileHeight()));\n        values.addElement(cd.getIntValue(metadata.getDuration()));\n        values.addElement(cd.getTimestampValue(metadata.getApproveDate()));\n        values.addElement(cd.getTimestampValue(metadata.getCatalogDate()));\n        values.addElement(cd.getTimestampValue(metadata.getRejectDate()));\n        values.addElement(cd.getTimestampValue(metadata.getCreationDate()));\n        values.addElement(new StringValue(metadata.getLanguageType()));\n        if (dbInfo != null) {\n            values.addElement(new StringValue(metadata.getMetadataId()));\n        }\n        sqlCommandBean.setValues(values);\n        sqlCommandBean.executeUpdate();\n    }\n\n    /**\n     * Returns the short record for the specified metadata in XML format.\n     */\n    public String getShortRecord(String metadataId) throws SQLException, IOException {\n        ShortMetadataBean metaInfo = getShortMetadata(metadataId);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        HealMetadataXMLConverter.shortMetadataToXML(metaInfo, stream);\n        return stream.toString();\n    }\n\n    public ShortMetadataBean getShortMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        // Get the metadata info from the database\n        Row metadataRow = cd.getMetadataProperty(metadataId, \"MetadataID, GlobalID, \" + \"FileName, \" + \"FileSize, Title, \" + \"Description, Location, \" + \"SourceCollection, \" + \"FileWidth, FileHeight, \" + \"ContributeUserID,\" + \"LearningResourceType\", \"Metadata\", conn);\n        if (metadataRow == null) {\n            return null;\n        }\n        ShortMetadataBean metadataInfo = new ShortMetadataBean();\n        try {\n            String sc = (String) metadataRow.getString(\"SourceCollection\");\n            metadataInfo.setMetadataId(metadataRow.getString(\"MetadataID\"));\n            metadataInfo.setGlobalId(metadataRow.getString(\"GlobalID\"));\n            metadataInfo.setFileName(metadataRow.getString(\"FileName\"));\n            metadataInfo.setFileSize(metadataRow.getString(\"FileSize\"));\n            metadataInfo.setTitle(metadataRow.getString(\"Title\"));\n            metadataInfo.setDescription(metadataRow.getString(\"Description\"));\n            metadataInfo.setLocation(metadataRow.getString(\"Location\"));\n            metadataInfo.setSourceCollection(metadataRow.getString(\"SourceCollection\"));\n            metadataInfo.setFileWidth(metadataRow.getString(\"FileWidth\"));\n            metadataInfo.setFileHeight(metadataRow.getString(\"FileHeight\"));\n            metadataInfo.setContributeUserId(metadataRow.getString(\"ContributeUserID\"));\n            metadataInfo.setLearningResourceType(metadataRow.getString(\"LearningResourceType\"));\n            metadataInfo.setCollectionBean(cd.getSCollectionBean(sc, conn));\n            metadataInfo.setThumbnail(cd.getThumbnail(metadataId, conn));\n            String format = cd.getMetadataPropertyAsString(metadataId, \"Format\", \"Formats\", conn);\n            metadataInfo.setFormat(format);\n            /*        } catch (UnsupportedConversionException uce) {\n                  throw new SQLException(uce.toString());\n            */\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                //ignore...\n            }\n        }\n        return metadataInfo;\n    }\n\n    /**\n     * Returns the IMS record for the specified metadata in XML format.\n     * XXX Is the parameter here the global id or the metadata id?\n     */\n    public String getIMSRecord(String metadataId) throws SQLException, IOException {\n        CompleteMetadataBean metaInfo = getCompleteMetadata(metadataId);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        HealMetadataXMLConverter.metadataToIMSXML(metaInfo, fileLocator, stream);\n        return stream.toString();\n    }\n\n    /**\n     * Returns information about the HEAL system as a whole.  This is to be\n     * returned to the NSDL, but the spec isn't out yet, so we don't know\n     * what to include here.\n     */\n    public String getCollectionMetadata() {\n        throw new UnsupportedOperationException(\"getCollectionMetadata not implemented\");\n    }\n\n    public CompleteMetadataBean getCompleteMetadata(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        CompleteMetadataBean result;\n        try {\n            result = getCompleteMetadata(metadataId, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return result;\n    }\n\n    public CompleteMetadataBean getCompleteMetadata(String metadataId, Connection conn) throws SQLException {\n        CompleteMetadataBean result = new CompleteMetadataBean();\n        try {\n            result.setMetadataId(metadataId);\n            MetadataBean m = cd.getMetadata(metadataId, conn);\n            String name = m.getSourceCollection();\n            result.setMetadata(m);\n            result.setDiseaseDiagnoses(getDiseaseDiagnoses(metadataId, conn));\n            result.setCopyrights(getCopyrights(metadataId, conn));\n            result.setTaxonPaths(getTaxonPaths(metadataId, conn));\n            result.setCopyrightHolders(getCopyrightHolders(metadataId, conn));\n            result.setContextURLs(getContextURLs(metadataId, conn));\n            result.setRequirements(getRequirements(metadataId, conn));\n            result.setContributors(getContributors(metadataId, conn));\n            result.setRelations(getRelations(metadataId, conn));\n            result.setKeywords(getKeywords(metadataId, conn));\n            result.setTargetUserGroups(getTargetUserGroups(metadataId, conn));\n            result.setFormats(getFormats(metadataId, conn));\n            result.setThumbnail(cd.getThumbnail(metadataId, conn));\n            result.setCollectionBean(cd.getSCollectionBean(name, conn));\n            result.setMetametadataIdentifiers(cd.getMetametadataIdentifiers(metadataId, conn));\n            result.setMetametadataContributors(cd.getMetametadataContributors(metadataId, conn));\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n        return result;\n    }\n\n    /**\n     * @param metadataId The metadataId of the target user groups to look up.\n     * @param conn The connection to the database to query.\n     *\n     * @return Am ArrayList of {@link org.heal.module.metadata.TargetUserGroupBean TargetUserGroupBeans}.\n     *         This method will never return <code>null</code>, but may return an empty\n     *         list if no target user groups are found for the given metadataId.\n     *\n     * @throws SQLException Thrown when a database error occurs.\n     */\n    private ArrayList getTargetUserGroups(String metadataId, Connection conn) throws SQLException {\n        ArrayList ret = new ArrayList();\n        Vector rows = cd.getMetadataProperties(metadataId, \"*\", \"TargetUserGroups\", conn);\n        if (null != rows) {\n            for (Iterator iter = rows.iterator(); iter.hasNext(); ) {\n                Row row = (Row) iter.next();\n                try {\n                    TargetUserGroupBean tug = new TargetUserGroupBean();\n                    tug.setMetadataId(metadataId);\n                    tug.setTargetUserGroup(row.getString(\"TargetUserGroup\"));\n                    ret.add(tug);\n                } catch (NoSuchColumnException e) {\n                    throw new RuntimeException(e);\n                    // TODO logging?\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Saves a CompleteMetadataBean.  Only non-null properties are stored in\n     * the database.  For all properties except the MetadataBean, if the\n     * properties ID (i.e. TaxonID for a TaxonBean) is not null, an update\n     * will be performed for that entry.  If the ID is null, then an insert\n     * will be performed.\n     * If a set of data (for example the keywords) is null or empty, then no\n     * changes are made to those entries in the database.  If it is not\n     * null, then the keywords are added to the database, but the previous\n     * keywords stored in the database are not removed.  If you want to have\n     * the previous settings for the complete metadata bean fields removed,\n     * use updateCompleteMetadata.\n     */\n    public void saveCompleteMetadata(CompleteMetadataBean cmb) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveCompleteMetadata(cmb, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n    }\n\n    /**\n     * If the {@link CompleteMetadataBean} does not have a metadataId (for\n     * example if it represents a new record not yet in the database), then\n     * the <code>Connection</code> <em>must</em> be commited during the\n     * execution of this method.  However if a metadataId <em>does</em> exist,\n     * then the transactional state of the <code>Connection</code> will not\n     * be modified here.\n     *\n     * @see #saveCompleteMetadata(CompleteMetadataBean)\n     */\n    public void saveCompleteMetadata(CompleteMetadataBean cmb, Connection conn) throws SQLException {\n        List elems;\n        Iterator elemIterator;\n        saveMetadata(cmb, conn);\n        String metadataId = cmb.getMetadataId();\n        if (metadataId == null) {\n            //we need to store the metadata\n            conn.commit();\n            //now we look it up via the location so that we can get the id.\n            metadataId = getMetadataIdFromProperty(cmb.getLocation(), \"Location\", conn);\n        }\n        cmb.setMetadataId(metadataId);\n        elems = cmb.getDiseaseDiagnoses();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            DiseaseDiagnosisBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (DiseaseDiagnosisBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveDiseaseDiagnosis(elem, conn);\n            }\n        }\n        elems = cmb.getCopyrights();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveCopyright(elem, conn);\n            }\n        }\n        elems = cmb.getTaxonPaths();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            TaxonPathBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (TaxonPathBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveTaxonPath(elem, conn);\n            }\n        }\n        elems = cmb.getCopyrightHolders();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightHolderBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightHolderBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveCopyrightHolder(elem, conn);\n            }\n        }\n        elems = cmb.getContextURLs();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            ContextURLBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (ContextURLBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveContextURL(elem, conn);\n            }\n        }\n        elems = cmb.getRequirements();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RequirementBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RequirementBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveRequirement(elem, conn);\n            }\n        }\n        TreeMap contributors = cmb.getContributors();\n        Iterator contributorsIterator = contributors.values().iterator();\n        while (contributorsIterator.hasNext()) {\n            elems = (ArrayList) contributorsIterator.next();\n            if (elems != null) {\n                elemIterator = elems.iterator();\n                ContributorBean elem;\n                while (elemIterator.hasNext()) {\n                    elem = (ContributorBean) elemIterator.next();\n                    elem.setMetadataId(metadataId);\n                    cd.saveContributor(elem, conn);\n                }\n            }\n        }\n        elems = cmb.getRelations();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RelationBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RelationBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveRelation(elem, conn);\n            }\n        }\n        elems = cmb.getKeywords();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            KeywordBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (KeywordBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveKeyword(elem, conn);\n            }\n        }\n        elems = cmb.getTargetUserGroups();\n        if (null != elems) {\n            TargetUserGroupBean elem;\n            elemIterator = elems.iterator();\n            while (elemIterator.hasNext()) {\n                elem = (TargetUserGroupBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveTargetUserGroup(elem, conn);\n            }\n        }\n        elems = cmb.getFormats();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            FormatBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (FormatBean) elemIterator.next();\n                elem.setMetadataId(metadataId);\n                cd.saveFormat(elem, conn);\n            }\n        }\n        ThumbnailBean thumbnail = cmb.getThumbnail();\n        if (thumbnail != null) {\n            thumbnail.setMetadataId(metadataId);\n            cd.saveThumbnail(thumbnail, conn);\n        }\n        elems = cmb.getMetametadataIdentifiers();\n        if (null != elems) {\n            MetametadataIdentifierBean mib;\n            elemIterator = elems.listIterator();\n            while (elemIterator.hasNext()) {\n                mib = (MetametadataIdentifierBean) elemIterator.next();\n                mib.setMetadataId(metadataId);\n                saveMetametadataIdentifier(mib, conn);\n            }\n        }\n        elems = cmb.getMetametadataContributors();\n        if (null != elems) {\n            MetametadataContributorBean mcb;\n            elemIterator = elems.listIterator();\n            while (elemIterator.hasNext()) {\n                mcb = (MetametadataContributorBean) elemIterator.next();\n                mcb.setMetadataId(metadataId);\n                saveMetametadataContributor(mcb, conn);\n            }\n        }\n    }\n\n    /**\n     * Updates a CompleteMetadataBean.\n     * This differs from the saveCompleteMetadata method in that\n     * it will remove entries in the database that do not show up\n     * in the complete metadata parameter.\n     */\n    public void updateCompleteMetadata(CompleteMetadataBean cmb) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            updateCompleteMetadata(cmb, conn);\n            conn.commit();\n        } finally {\n            try {\n                conn.setAutoCommit(true);\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n    }\n\n    /**\n     * Updates a CompleteMetadataBean.\n     * See updateCompleteMetadata(cmb)\n     */\n    public void updateCompleteMetadata(CompleteMetadataBean cmb, Connection conn) throws SQLException {\n        if (cmb == null || cmb.getMetadataId() == null || conn == null) {\n            return;\n        }\n        String metadataId = cmb.getMetadataId();\n        /* STRATEGY ALERT: (by Seth Wright)\n         * In the interest of finishing this portion of the project on time\n         * I am taking a slight shortcut.  Rather than determining the\n         * difference between the current database settings and the one we\n         * want, I am simply deleting all old entries and adding new ones.\n         * This could result in a large growth in the id numbers of\n         * such tables as keywords entries.\n         * So, here is what we do, we remove all settings from the database\n         * that are one to many relations and then call saveCompleteMetadata\n         * The fields with multiple entries are:\n         * taxons/taxonpaths\n         * relations\n         * requirements\n         * keywords\n         * formats\n         * disease diagnoses\n         * copyright holders\n         * contexturls\n         * contributors\n         * copyrights/copyrighttexts\n         */\n        cd.removeMetadataFromTable(metadataId, \"Relations\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Requirements\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Keywords\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Formats\", conn);\n        cd.removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n        cd.removeMetadataFromTable(metadataId, \"CopyrightHolders\", conn);\n        cd.removeMetadataFromTable(metadataId, \"ContextURLs\", conn);\n        cd.removeMetadataFromTable(metadataId, \"Contributors\", conn);\n        cd.removeMetadataFromTable(metadataId, \"TargetUserGroups\", conn);\n        cd.removeTaxonPaths(metadataId, conn);\n        cd.removeCopyrights(metadataId, conn);\n        doUpdateHack(cmb);\n        saveCompleteMetadata(cmb, conn);\n    }\n\n    /**\n     * The update hack is where the IDs (such as\n     * KeywordId) are stripped from the complete metadata bean.\n     * This is done so that saveCompleteMetadata works correctly.\n     */\n    private void doUpdateHack(CompleteMetadataBean cmb) {\n        ArrayList elems;\n        Iterator elemIterator;\n        /* change log\n        elems = cmb.getDiseaseDiagnoses();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            DiseaseDiagnosisBean elem;\n            while (elemIterator.hasNext()) {\n            elem = (DiseaseDiagnosisBean)elemIterator.next();\n            elem.setDiseaseDiagnosisId(null);\n            }\n        }*/\n        elems = cmb.getCopyrights();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightBean) elemIterator.next();\n                elem.setCopyrightId(null);\n            }\n        }\n        elems = cmb.getTaxonPaths();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            TaxonPathBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (TaxonPathBean) elemIterator.next();\n                elem.setTaxonPathId(null);\n            }\n        }\n        elems = cmb.getCopyrightHolders();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            CopyrightHolderBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (CopyrightHolderBean) elemIterator.next();\n                elem.setCopyrightHolderId(null);\n            }\n        }\n        elems = cmb.getContextURLs();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            ContextURLBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (ContextURLBean) elemIterator.next();\n                elem.setContextURLId(null);\n            }\n        }\n        elems = cmb.getRequirements();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RequirementBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RequirementBean) elemIterator.next();\n                elem.setRequirementId(null);\n            }\n        }\n        TreeMap contributors = cmb.getContributors();\n        Iterator contributorsIterator = contributors.values().iterator();\n        while (contributorsIterator.hasNext()) {\n            elems = (ArrayList) contributorsIterator.next();\n            if (elems != null) {\n                elemIterator = elems.iterator();\n                ContributorBean elem;\n                while (elemIterator.hasNext()) {\n                    elem = (ContributorBean) elemIterator.next();\n                    elem.setContributorId(null);\n                }\n            }\n        }\n        elems = cmb.getRelations();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            RelationBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (RelationBean) elemIterator.next();\n                elem.setRelationId(null);\n            }\n        }\n        elems = cmb.getKeywords();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            KeywordBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (KeywordBean) elemIterator.next();\n                elem.setKeywordId(null);\n            }\n        }\n        elems = cmb.getFormats();\n        if (elems != null) {\n            elemIterator = elems.iterator();\n            FormatBean elem;\n            while (elemIterator.hasNext()) {\n                elem = (FormatBean) elemIterator.next();\n                elem.setFormatId(null);\n            }\n        }\n    }\n\n    /**\n     * Given a metadataId, creates an entry for that metadata in the\n     * DeletedItems table with information from the current Metadata\n     * table and the provided comment.  The DeleteDate will be set\n     * as the current date.\n     * Returns true if no problems occured, false otherwise.\n     */\n    public boolean moveToDeletedItems(String metadataId, String comment, Connection conn) throws SQLException {\n        boolean success = false;\n        MetadataBean metadata = cd.getMetadata(metadataId, conn);\n        cd.addToDeletedItems(metadata, comment, conn);\n        success = cd.deleteMetadataReferences(metadataId, conn);\n        cd.removeMetadataFromTable(metadataId, \"Metadata\", conn);\n        return success;\n    }\n\n    /**\n     * Returns a ArrayList of DiseaseDiagnosisBeans associated with the\n     * given metadataId.\n     * If no diagnoses are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getDiseaseDiagnoses(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"DiseaseDiagnosisID, \" + \"DiseaseDiagnosis\", \"DiseaseDiagnoses\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                DiseaseDiagnosisBean dd;\n                String id;\n                String ddString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    dd = new DiseaseDiagnosisBean();\n                    id = row.getString(\"DiseaseDiagnosisID\");\n                    ddString = row.getString(\"DiseaseDiagnosis\");\n                    dd.setDiseaseDiagnosisId(id);\n                    dd.setMetadataId(metadataId);\n                    dd.setDiseaseDiagnosis(ddString);\n                    results.add(dd);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of CopyrightBeans associated with the\n     * given metadataId.\n     * If no copyrightss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getCopyrights(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"CopyrightID, CopyrightTextID\", \"Copyrights\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                CopyrightBean copyright;\n                CopyrightTextBean copyrightText;\n                String copyrightTextString;\n                String copyrightId;\n                String copyrightTextId;\n                SQLCommandBean sqlCommandBean = new SQLCommandBean();\n                sqlCommandBean.setConnection(conn);\n                sqlCommandBean.setSqlValue(\"SELECT CopyrightText FROM CopyrightTexts WHERE CopyrightTextID = ?\");\n                Vector values = new Vector();\n                Vector copyrighttextrows = null;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    copyright = new CopyrightBean();\n                    copyrightId = row.getString(\"CopyrightID\");\n                    copyrightTextId = row.getString(\"CopyrightTextID\");\n                    copyright.setCopyrightId(copyrightId);\n                    copyright.setMetadataId(metadataId);\n                    copyrightText = null;\n                    values.clear();\n                    values.addElement(new StringValue(copyrightTextId));\n                    sqlCommandBean.setValues(values);\n                    try {\n                        copyrighttextrows = sqlCommandBean.executeQuery();\n                    } catch (UnsupportedTypeException e) {\n                        throw new SQLException(e.toString());\n                    }\n                    if (copyrighttextrows != null && copyrighttextrows.size() > 0) {\n                        row = (Row) copyrighttextrows.firstElement();\n                        copyrightTextString = row.getString(\"CopyrightText\");\n                        copyrightText = new CopyrightTextBean();\n                        copyrightText.setCopyrightTextId(copyrightTextId);\n                        copyrightText.setCopyrightText(copyrightTextString);\n                    }\n                    copyright.setCopyrightText(copyrightText);\n                    results.add(copyright);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of CopyrightHolderBeans associated with the\n     * given metadataId.\n     * If no copyright holders are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getCopyrightHolders(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            // queries the database\n            Vector rows;\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"SELECT a.CopyrightHolderID, b.vCard \");\n            sql.append(\"FROM  CopyrightHolders a INNER JOIN\");\n            sql.append(\"  vCards b ON a.vCardID = b.vCardID \");\n            sql.append(\"WHERE  (a.MetadataID = ?)\");\n            sqlCommandBean.setSqlValue(sql.toString());\n            Vector values = new Vector();\n            values.addElement(new StringValue(metadataId));\n            sqlCommandBean.setValues(values);\n            try {\n                rows = sqlCommandBean.executeQuery();\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            }\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                CopyrightHolderBean ch;\n                String id;\n                String chString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    ch = new CopyrightHolderBean();\n                    id = row.getString(\"CopyrightHolderID\");\n                    chString = row.getString(\"VCard\");\n                    ch.setCopyrightHolderId(id);\n                    ch.setMetadataId(metadataId);\n                    ch.setVCard(chString);\n                    results.add(ch);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of TaxonPathBeans associated with the given\n     * metadataId.\n     * If no taxonPathss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getTaxonPaths(String metadataId) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        try {\n            return getTaxonPaths(metadataId, conn);\n        } catch (NoSuchColumnException ex) {\n            throw new SQLException(ex.toString());\n        }\n    }\n\n    /**\n     * Returns a ArrayList of TaxonPathBeans associated with the given\n     * metadataId.\n     * If no taxonPathss are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getTaxonPaths(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"TaxonPathID, Source\", \"TaxonPaths\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                TaxonPathBean taxonPath;\n                String taxonPathId;\n                String taxonPathSource;\n                TaxonBean taxon = null;\n                String taxonId, id, entry;\n                SQLCommandBean sqlCommandBean = new SQLCommandBean();\n                sqlCommandBean.setConnection(conn);\n                sqlCommandBean.setSqlValue(\"SELECT TaxonID, ID, Entry FROM Taxons WHERE TaxonPathID = ?\");\n                Vector values = new Vector();\n                Vector taxonrows = null;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    taxonPath = new TaxonPathBean();\n                    taxonPathId = row.getString(\"TaxonPathID\");\n                    taxonPathSource = row.getString(\"Source\");\n                    taxonPath.setTaxonPathId(taxonPathId);\n                    taxonPath.setMetadataId(metadataId);\n                    taxonPath.setSource(taxonPathSource);\n                    values.clear();\n                    values.addElement(new StringValue(taxonPathId));\n                    sqlCommandBean.setValues(values);\n                    try {\n                        taxonrows = sqlCommandBean.executeQuery();\n                    } catch (UnsupportedTypeException e) {\n                        throw new SQLException(e.toString());\n                    }\n                    if (taxonrows != null && taxonrows.size() > 0) {\n                        Iterator taxonIterator = taxonrows.iterator();\n                        while (taxonIterator.hasNext()) {\n                            row = (Row) taxonIterator.next();\n                            taxon = new TaxonBean();\n                            taxonId = row.getString(\"TaxonID\");\n                            id = row.getString(\"ID\");\n                            entry = row.getString(\"Entry\");\n                            taxon.setTaxonId(taxonId);\n                            taxon.setTaxonPathId(taxonPathId);\n                            taxon.setId(id);\n                            taxon.setEntry(entry);\n                            taxonPath.addTaxon(taxon);\n                        }\n                    }\n                    results.add(taxonPath);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of ContextURLBeans associated with the given\n     * If no contextURLs are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getContextURLs(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"ContextURLID, ContextURL, ContextURLDescription\", \"ContextURLs\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                ContextURLBean contextURL;\n                String contextURLId;\n                String contextURLString;\n                String contextURLDescription;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    contextURL = new ContextURLBean();\n                    contextURLId = row.getString(\"ContextURLID\");\n                    contextURLString = row.getString(\"ContextURL\");\n                    contextURLDescription = row.getString(\"ContextURLDescription\");\n                    contextURL.setContextURLId(contextURLId);\n                    contextURL.setMetadataId(metadataId);\n                    contextURL.setContextURL(contextURLString);\n                    contextURL.setContextURLDescription(contextURLDescription);\n                    results.add(contextURL);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of RequirementBeans associated with the\n     * given metadataId.\n     * If no requirements are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getRequirements(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"RequirementID, \" + \"RequirementType, \" + \"RequirementName\", \"Requirements\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                RequirementBean rb;\n                String id;\n                String requirementType, requirementName;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    rb = new RequirementBean();\n                    id = row.getString(\"RequirementID\");\n                    requirementType = row.getString(\"RequirementType\");\n                    requirementName = row.getString(\"RequirementName\");\n                    rb.setRequirementId(id);\n                    rb.setMetadataId(metadataId);\n                    rb.setRequirementType(requirementType);\n                    rb.setRequirementName(requirementName);\n                    results.add(rb);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a TreeMap of ContributorBeans associated with the\n     * given metadataId.\n     * If no contributors are found or an error occurs, an empty TreeMap is\n     * returned.\n     */\n    public TreeMap getContributors(String metadataId, Connection conn) throws SQLException {\n        TreeMap results = new TreeMap();\n        if (metadataId != null) {\n            // queries the database\n            PreparedStatement ps = null;\n            ResultSet rs = null;\n            try {\n                StringBuffer sql = new StringBuffer();\n                sql.append(\"SELECT a.ContributorID, a.Role, a.ContributeDate,\").append(\" a.ContributeDateDescription, b.vCard \");\n                sql.append(\"FROM  Contributors a INNER JOIN\");\n                sql.append(\"  vCards b ON a.VCardID = b.vCardID \");\n                sql.append(\"WHERE  (a.MetadataID = ?)\");\n                ps = conn.prepareStatement(sql.toString());\n                ps.setString(1, metadataId);\n                rs = ps.executeQuery();\n                while (rs.next()) {\n                    ContributorBean cb = new ContributorBean();\n                    final String id = rs.getString(1);\n                    final String role = rs.getString(2);\n                    final Date contributeDate = rs.getDate(3);\n                    final String contributeDateDescription = rs.getString(4);\n                    final String vCard = rs.getString(5);\n                    cb.setContributorId(id);\n                    cb.setRole(role);\n                    cb.setDate(contributeDate);\n                    cb.setDateDescription(contributeDateDescription);\n                    cb.setVCard(vCard);\n                    List roles = (List) results.get(role);\n                    if (null == roles) {\n                        roles = new ArrayList();\n                        results.put(role, roles);\n                    }\n                    roles.add(cb);\n                }\n            } finally {\n                if (null != rs) {\n                    rs.close();\n                }\n                if (null != ps) {\n                    ps.close();\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns a ArrayList of RelationBeans associated with the\n     * given metadataId.\n     * If no relations are found or an error occurs, an empty ArrayList\n     * is returned.\n     */\n    public ArrayList getRelations(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"RelationID, \" + \"Resource, Kind, Description\", \"Relations\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                RelationBean rb;\n                String id;\n                String resource, kind, description;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    rb = new RelationBean();\n                    id = row.getString(\"RelationID\");\n                    resource = row.getString(\"Resource\");\n                    kind = row.getString(\"Kind\");\n                    description = row.getString(\"Description\");\n                    rb.setRelationId(id);\n                    rb.setMetadataId(metadataId);\n                    rb.setResource(resource);\n                    rb.setKind(kind);\n                    rb.setDescription(description);\n                    results.add(rb);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns an ArrayList of KeywordBeans associated with the\n     * given metadataId.\n     * If no keywords are found or an error occurs, an empty\n     * ArrayList is returned.\n     */\n    public ArrayList getKeywords(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"KeywordID, Keyword\", \"Keywords\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                KeywordBean keyword;\n                String keywordId;\n                String keywordString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    keyword = new KeywordBean();\n                    keywordId = row.getString(\"KeywordID\");\n                    keywordString = row.getString(\"Keyword\");\n                    keyword.setKeywordId(keywordId);\n                    keyword.setMetadataId(metadataId);\n                    keyword.setKeyword(keywordString);\n                    results.add(keyword);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns an ArrayList of FormatBeans associated with the given\n     * metadataId.\n     * If no format is found or an error occurs, an empty ArrayList\n     * is returned.\n     */\n    public ArrayList getFormats(String metadataId, Connection conn) throws SQLException, NoSuchColumnException {\n        ArrayList results = new ArrayList();\n        if (metadataId != null) {\n            Vector rows = cd.getMetadataProperties(metadataId, \"FormatID, Format\", \"Formats\", conn);\n            if (rows != null && rows.size() > 0) {\n                Iterator rowIterator = rows.iterator();\n                Row row;\n                FormatBean format;\n                String formatId;\n                String formatString;\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    format = new FormatBean();\n                    formatId = row.getString(\"FormatID\");\n                    formatString = row.getString(\"Format\");\n                    format.setFormatId(formatId);\n                    format.setMetadataId(metadataId);\n                    format.setFormat(formatString);\n                    results.add(format);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Returns the first metadataId returned when the Metadata table is\n     * queried for all entries with the given value for the given column.\n     */\n    public String getMetadataIdFromProperty(String columnValue, String columnName, Connection conn) throws SQLException {\n        if (columnName == null || columnValue == null) {\n            return null;\n        }\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT MetadataID FROM Metadata \").append(\"WHERE \" + columnName + \" = ? ORDER BY MetadataID DESC\");\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector values = new Vector();\n        values.addElement(new StringValue(columnValue));\n        sqlCommandBean.setValues(values);\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        }\n        if (rows == null || rows.size() == 0) {\n            // nothing found\n            return null;\n        }\n        Row aRow = (Row) rows.firstElement();\n        try {\n            String metadataId = aRow.getString(\"MetadataID\");\n            return metadataId;\n        } catch (NoSuchColumnException nsce) {\n            throw new SQLException(nsce.toString());\n        }\n    }\n\n    /**\n     * Returns the first metadataId returned when the Metadata table is\n     * queried for all entries with the given value for the given column.\n     */\n    public String getMetadataIdFromProperty(String columnValue, String columnName) throws SQLException {\n        Connection conn = dataSource.getConnection();\n        String metadataId = null;\n        try {\n            metadataId = getMetadataIdFromProperty(columnValue, columnName, conn);\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex2) {\n                //ignore\n            }\n        }\n        return metadataId;\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     */\n    public ArrayList getPointerListArrayList(java.util.Date lastReceivedDate) throws SQLException {\n        return getPointerList(lastReceivedDate, false);\n    }\n\n    /**\n     * Returns a list of content Ids in XML format.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     */\n    public String getPointerList(java.util.Date lastReceivedDate) throws SQLException, IOException {\n        ArrayList ids = getPointerList(lastReceivedDate, false);\n        return HealMetadataXMLConverter.getPointerListXML(ids);\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     * If the includeHidden parameter is set to true, all metadata Ids are\n     * returned, not just those set as visible.  If the parameter\n     * set to false, then only those set as \"visible\" will be returned.\n     */\n    public ArrayList getPointerListArrayList(java.util.Date lastReceivedDate, boolean includeHidden) throws SQLException {\n        return getPointerList(lastReceivedDate, includeHidden);\n    }\n\n    /**\n     * Returns a list of content Ids in an ArrayList.  The parameter specifies\n     * a date used to request all new metadata since the given time.\n     * If the provided date is null, all content Ids are returned.\n     * Depending upon the second parameter, this method will return a list\n     * containing only metadata not marked as hidden if false, and all\n     * metadata Ids if the includeHidden parameter is set to true.\n     */\n    public ArrayList getPointerList(java.util.Date lastReceivedDate, boolean includeHidden) throws SQLException {\n        ArrayList ids = null;\n        Connection conn = dataSource.getConnection();\n        SQLCommandBean sqlCommandBean = new SQLCommandBean();\n        sqlCommandBean.setConnection(conn);\n        StringBuffer sql = new StringBuffer();\n        sql.append(\"SELECT MetadataID FROM Metadata\");\n        Vector values = new Vector();\n        if (lastReceivedDate != null) {\n            Timestamp lastReceivedTimestamp = new Timestamp(lastReceivedDate.getTime());\n            values.addElement(new TimestampValue(lastReceivedTimestamp));\n            if (!includeHidden) {\n                sql.append(\" WHERE CatalogDate >= ? AND Private = ?\");\n                values.addElement(new BooleanValue(includeHidden));\n            } else {\n                //if we want to show all, then don't filter Private setting\n                sql.append(\" WHERE CatalogDate >= ?\");\n            }\n            sqlCommandBean.setValues(values);\n        } else if (!includeHidden) {\n            //we only want to screen if we are EXCLUDING ids(don't show hidden)\n            sql.append(\" WHERE Private = ?\");\n            values.addElement(new BooleanValue(includeHidden));\n            sqlCommandBean.setValues(values);\n        }\n        sqlCommandBean.setSqlValue(sql.toString());\n        Vector rows = null;\n        try {\n            rows = sqlCommandBean.executeQuery();\n            if (rows != null && rows.size() > 0) {\n                ids = new ArrayList();\n                Iterator rowIter = rows.iterator();\n                while (rowIter.hasNext()) {\n                    String id = ((Row) rowIter.next()).getString(\"MetadataID\");\n                    ids.add(id);\n                }\n            }\n        } catch (UnsupportedTypeException e) {\n            throw new SQLException(e.toString());\n        } catch (NoSuchColumnException e2) {\n            throw new SQLException(e2.toString());\n        } finally // Can not happen here\n        {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        if (rows == null || rows.size() == 0) {\n            // Metadata not found\n            return null;\n        }\n        //cycle through all of the rows and pull out the MetadataIDs\n        return ids;\n    }\n\n    /**\n     * Used by {@link org.heal.servlet.cataloger.SaveMetadataAction SaveMetadataAction}\n     * so that we can manage a database transaction when updating old records.  This method\n     * is somewhat specific to SaveMetadataAction.\n     *\n     * @param cmb The {@link org.heal.module.metadata.CompleteMetadataBean CompleteMetadataBean}\n     * generated from form data.\n     */\n    public void saveEditMetadataForm(CompleteMetadataBean cmb) throws SQLException {\n        final String metadataId = cmb.getMetadataId();\n        Set contextURLExcludes = new HashSet();\n        for (Iterator iter = cmb.getContextURLs().iterator(); iter.hasNext(); ) {\n            final ContextURLBean cub = (ContextURLBean) iter.next();\n            if (null != cub && null != cub.getContextURLId()) {\n                contextURLExcludes.add(cub.getContextURLId());\n            }\n        }\n        Set contributorExcludes = new HashSet();\n        for (Iterator iter = cmb.getContributorList().iterator(); iter.hasNext(); ) {\n            final ContributorBean cb = (ContributorBean) iter.next();\n            if (null != cb.getContributorId()) {\n                contributorExcludes.add(cb.getContributorId());\n            }\n        }\n        Set copyrightHolderExcludes = new HashSet();\n        for (Iterator iter = cmb.getCopyrightHolders().iterator(); iter.hasNext(); ) {\n            final CopyrightHolderBean chb = (CopyrightHolderBean) iter.next();\n            if (null != chb.getCopyrightHolderId()) {\n                copyrightHolderExcludes.add(chb.getCopyrightHolderId());\n            }\n        }\n        Set taxonPathExcludes = new HashSet();\n        for (Iterator iter = cmb.getTaxonPaths().iterator(); iter.hasNext(); ) {\n            final TaxonPathBean tpb = (TaxonPathBean) iter.next();\n            if (null != tpb.getTaxonPathId()) {\n                taxonPathExcludes.add(tpb.getTaxonPathId());\n            }\n        }\n        Set requirementExcludes = new HashSet();\n        for (Iterator iter = cmb.getRequirements().iterator(); iter.hasNext(); ) {\n            final RequirementBean rb = (RequirementBean) iter.next();\n            if (null != rb.getRequirementId()) {\n                requirementExcludes.add(rb.getRequirementId());\n            }\n        }\n        Set relationExcludes = new HashSet();\n        for (Iterator iter = cmb.getRelations().iterator(); iter.hasNext(); ) {\n            final RelationBean rb = (RelationBean) iter.next();\n            if (null != rb.getRelationId()) {\n                relationExcludes.add(rb.getRelationId());\n            }\n        }\n        Set mmIdentifierExcludes = new HashSet();\n        for (Object o : cmb.getMetametadataIdentifiers()) {\n            final MetametadataIdentifierBean mib = (MetametadataIdentifierBean) o;\n            if (null != mib.getMetametadataIdentifierId()) {\n                mmIdentifierExcludes.add(mib.getMetametadataIdentifierId());\n            }\n        }\n        Set mmContributorExcludes = new HashSet();\n        for (Object o : cmb.getMetametadataContributors()) {\n            final MetametadataContributorBean mcb = (MetametadataContributorBean) o;\n            if (null != mcb.getMetametadataContributorId()) {\n                mmContributorExcludes.add(mcb.getMetametadataContributorId());\n            }\n        }\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            if (null != metadataId) {\n                // If this is an existing metadata record, we must\n                // change the values in the database currently to\n                // match the CompleteMetadataBean submitted from the\n                // edit page\n                cd.removeMetadataFromTable(metadataId, \"Keywords\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Formats\", conn);\n                cd.removeMetadataFromTable(metadataId, \"DiseaseDiagnoses\", conn);\n                cd.removeMetadataFromTable(metadataId, \"TargetUserGroups\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Thumbnails\", conn);\n                cd.removeMetadataFromTable(metadataId, \"Copyrights\", conn);\n                deleteForeignKeyRecordsNotInSet(\"ContextURLs\", \"MetadataID\", \"ContextURLID\", metadataId, contextURLExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Contributors\", \"MetadataID\", \"ContributorID\", metadataId, contributorExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"CopyrightHolders\", \"MetadataID\", \"CopyrightHolderID\", metadataId, copyrightHolderExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"TaxonPaths\", \"MetadataID\", \"TaxonPathID\", metadataId, taxonPathExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Requirements\", \"MetadataID\", \"RequirementID\", metadataId, requirementExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"Relations\", \"MetadataID\", \"RelationID\", metadataId, relationExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"MetametadataIdentifiers\", \"MetadataID\", \"MetametadataIdentifierID\", metadataId, mmIdentifierExcludes, conn);\n                deleteForeignKeyRecordsNotInSet(\"MetametadataContributors\", \"MetadataID\", \"MetametadataContributorID\", metadataId, mmContributorExcludes, conn);\n                for (Iterator iter = cmb.getTaxonPaths().iterator(); iter.hasNext(); ) {\n                    final TaxonPathBean tpb = (TaxonPathBean) iter.next();\n                    final String taxonPathId = tpb.getTaxonPathId();\n                    if (null != taxonPathId) {\n                        Set taxonExcludes = new HashSet();\n                        for (Iterator iterTwo = tpb.getTaxons().iterator(); iterTwo.hasNext(); ) {\n                            final TaxonBean tb = (TaxonBean) iterTwo.next();\n                            if (null != tb.getTaxonId()) {\n                                taxonExcludes.add(tb.getTaxonId());\n                            }\n                        }\n                        deleteForeignKeyRecordsNotInSet(\"Taxons\", \"TaxonPathID\", \"TaxonID\", taxonPathId, taxonExcludes, conn);\n                    }\n                }\n            }\n            // Cleaning up pieces of the metadata which are empty, and therefor\n            // should be null when inserted in the database...\n            if (isEmpty(cmb.getGlobalId())) {\n                cmb.setGlobalId(null);\n            }\n            if (isEmpty(cmb.getSpecimenType())) {\n                cmb.setSpecimenType(null);\n            }\n            if (isEmpty(cmb.getRadiographType())) {\n                cmb.setRadiographType(null);\n            }\n            if (isEmpty(cmb.getOrientation())) {\n                cmb.setOrientation(null);\n            }\n            if (isEmpty(cmb.getMagnification())) {\n                cmb.setMagnification(null);\n            }\n            if (isEmpty(cmb.getClinicalHistory())) {\n                cmb.setClinicalHistory(null);\n            }\n            if (null != cmb.getThumbnail()) {\n                final ThumbnailBean tb = cmb.getThumbnail();\n                if (isEmpty(tb.getFileHeight()) && isEmpty(tb.getFileWidth()) && isEmpty(tb.getLocation())) {\n                    cmb.setThumbnail(null);\n                }\n            }\n            saveCompleteMetadata(cmb, conn);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.close();\n        }\n    }\n\n    private static boolean isEmpty(String str) {\n        boolean empty = false;\n        if (null == str || str.trim().length() == 0) {\n            empty = true;\n        }\n        return empty;\n    }\n\n    /**\n     * Deletes records from a table that match a given foreign key and which\n     * do not have ids that are found in a <code>Set</code>.\n     *\n     * @param tableName The name of the table to delete records from.\n     * @param foreignKeyFieldName The name of the field which acts as a foreign key in the table.\n     * @param excludeFieldName The name of the field to match id's to exclude from the deletion.\n     * @param foreignKey The foreign key value associated with the records to delete.\n     * @param excludes A set of Strings representing ids of records that should\n     * not be deleted.\n     * @param conn The <code>Connection</code> to the database.\n     *\n     * @throws SQLException\n     */\n    public void deleteForeignKeyRecordsNotInSet(String tableName, String foreignKeyFieldName, String excludeFieldName, String foreignKey, Set excludes, Connection conn) throws SQLException {\n        String sql;\n        if (0 < excludes.size()) {\n            StringBuffer exclude = new StringBuffer(\"(\");\n            for (int i = 0; i < excludes.size(); ++i) {\n                exclude.append(\"?\");\n                if (i < (excludes.size() - 1)) {\n                    exclude.append(\", \");\n                }\n            }\n            exclude.append(\")\");\n            sql = \"DELETE FROM \" + tableName + \" WHERE \" + foreignKeyFieldName + \" = ? AND \" + excludeFieldName + \" NOT IN \" + exclude.toString();\n        } else {\n            sql = \"DELETE FROM \" + tableName + \" WHERE \" + foreignKeyFieldName + \"= ?\";\n        }\n        PreparedStatement ps = conn.prepareStatement(sql);\n        try {\n            ps.setInt(1, Integer.parseInt(foreignKey));\n            int nextParameter = 2;\n            for (Iterator iter = excludes.iterator(); iter.hasNext(); ) {\n                final String exclude = (String) iter.next();\n                ps.setInt(nextParameter, Integer.parseInt(exclude));\n                ++nextParameter;\n            }\n            ps.executeUpdate();\n        } finally {\n            ps.close();\n        }\n    }\n\n    public int savePublication(String id, String name, Date publicationDate) throws SQLException {\n        int ret = 0;\n        Connection conn = dataSource.getConnection();\n        try {\n            ret = savePublication(id, name, publicationDate, dataSource.getConnection());\n        } finally {\n            if (null != conn) {\n                conn.close();\n            }\n        }\n        return ret;\n    }\n\n    public int savePublication(String id, String name, Date publicationDate, Connection conn) throws SQLException {\n        Integer ret = null;\n        try {\n            ret = new Integer(Integer.parseInt(id));\n        } catch (NumberFormatException e) {\n            // does nothing\n        }\n        String sql;\n        if (null == ret) {\n            sql = PUBLICATIONINSERTSQL;\n        } else {\n            sql = PUBLICATIONUPDATESQL;\n        }\n        java.sql.Date publicationSqlDate = null;\n        if (null != publicationDate) {\n            publicationSqlDate = new java.sql.Date(publicationDate.getTime());\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, name);\n            ps.setDate(2, publicationSqlDate);\n            if (null != ret) {\n                ps.setInt(3, ret.intValue());\n            }\n            ps.executeUpdate();\n            if (null == ret) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT MAX(PublicationId) AS uid FROM Publications\");\n                rs = ps.executeQuery();\n                if (rs.next()) {\n                    ret = new Integer(rs.getInt(1));\n                }\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n        if (null == ret) {\n            throw new RuntimeException(\"Unable to save publication: ('\" + id + \"', '\" + name + \"', '\" + publicationDate.toString() + \"')\");\n        }\n        return ret.intValue();\n    }\n\n    public void saveMetametadataIdentifier(MetametadataIdentifierBean mib, Connection conn) throws SQLException {\n        final String sql;\n        if (null == mib.getMetametadataIdentifierId()) {\n            sql = METAMETADATA_IDENTIFIER_INSERT_SQL;\n        } else {\n            sql = METAMETADATA_IDENTIFIER_UPDATE_SQL;\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, mib.getMetadataId());\n            ps.setString(2, mib.getCatalog());\n            ps.setString(3, mib.getEntry());\n            ps.setString(4, mib.getMetadataSchema());\n            if (null != mib.getMetametadataIdentifierId()) {\n                ps.setString(5, mib.getMetametadataIdentifierId());\n            }\n            ps.executeUpdate();\n            if (null == mib.getMetametadataIdentifierId()) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT @@Identity AS ID\");\n                rs = ps.executeQuery();\n                rs.next();\n                mib.setMetametadataIdentifierId(rs.getString(1));\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    public void saveMetametadataContributor(MetametadataContributorBean mcb) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetametadataContributor(mcb, conn);\n            conn.commit();\n        } finally {\n            conn.setAutoCommit(true);\n            conn.close();\n        }\n    }\n\n    public void saveMetametadataIdentifier(MetametadataIdentifierBean mcb) throws SQLException {\n        // Save the metadata info from the database\n        Connection conn = dataSource.getConnection();\n        conn.setAutoCommit(false);\n        try {\n            saveMetametadataIdentifier(mcb, conn);\n            conn.commit();\n        } finally {\n            conn.setAutoCommit(true);\n            conn.close();\n        }\n    }\n\n    /**\n     * May have the side-effect of saving a vcard to the vCards table.\n     *\n     * @param mcb\n     * @param conn\n     * @throws SQLException\n     */\n    public void saveMetametadataContributor(MetametadataContributorBean mcb, Connection conn) throws SQLException {\n        final String sql;\n        if (null == mcb.getMetametadataContributorId()) {\n            sql = METAMETADATA_CONTRIBUTOR_INSERT_SQL;\n        } else {\n            sql = METAMETADATA_CONTRIBUTOR_UPDATE_SQL;\n        }\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            String vcardId = cd.saveVCard(mcb.getvCard(), conn);\n            java.sql.Date date = null;\n            if (null != mcb.getDate()) {\n                date = new java.sql.Date(mcb.getDate().getTime());\n            }\n            ps = conn.prepareStatement(sql);\n            ps.setString(1, mcb.getMetadataId());\n            ps.setString(2, mcb.getRole());\n            ps.setDate(3, date);\n            ps.setString(4, mcb.getDateDescription());\n            ps.setString(5, vcardId);\n            if (null != mcb.getMetametadataContributorId()) {\n                ps.setString(6, mcb.getMetametadataContributorId());\n            }\n            ps.executeUpdate();\n            if (null == mcb.getMetametadataContributorId()) {\n                ps.close();\n                ps = conn.prepareStatement(\"SELECT @@Identity AS ID\");\n                rs = ps.executeQuery();\n                rs.next();\n                mcb.setMetametadataContributorId(rs.getString(1));\n            }\n        } finally {\n            if (null != rs) {\n                rs.close();\n            }\n            if (null != ps) {\n                ps.close();\n            }\n        }\n    }\n\n    /**\n     * Returns the count of total resources in the database\n     * Returns null on an error or if no entries exist in the\n     * database.\n     */\n    public int getCountOfResources() throws SQLException {\n        //Get the usernames from the database\n        Connection conn = dataSource.getConnection();\n        int count = 0;\n        try {\n            SQLCommandBean sqlCommandBean = new SQLCommandBean();\n            sqlCommandBean.setConnection(conn);\n            String sql = \"SELECT Count(metadataId) as Expr1 FROM Metadata where private = 0\";\n            sqlCommandBean.setSqlValue(sql);\n            try {\n                Vector rows = null;\n                Row row = null;\n                rows = sqlCommandBean.executeQuery();\n                Iterator rowIterator = rows.iterator();\n                while (rowIterator.hasNext()) {\n                    row = (Row) rowIterator.next();\n                    count = row.getInt(\"Expr1\");\n                }\n            } catch (UnsupportedTypeException e) {\n                throw new SQLException(e.toString());\n            } catch (NoSuchColumnException e2) {\n                throw new SQLException(e2.toString());\n            } catch (UnsupportedConversionException ex) {\n                throw new SQLException(ex.toString());\n            }\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n            }\n            // Ignore\n        }\n        return count;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataDAOTest2.java",
		"test_prompt": "// MetadataDAOTest2.java\npackage org.heal.module.metadata;\n\nimport com.ora.jsp.sql.NoSuchColumnException;\nimport com.ora.jsp.sql.Row;\nimport com.ora.jsp.sql.SQLCommandBean;\nimport com.ora.jsp.sql.UnsupportedConversionException;\nimport com.ora.jsp.sql.UnsupportedTypeException;\nimport com.ora.jsp.sql.value.BooleanValue;\nimport com.ora.jsp.sql.value.StringValue;\nimport com.ora.jsp.sql.value.TimestampValue;\nimport org.heal.util.CommonDAO;\nimport org.heal.util.FileLocator;\nimport javax.sql.DataSource;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataDAO}.\n* It contains ten unit test cases for the {@link MetadataDAO#savePublication(String, String, Date, Connection)} method.\n*/\nclass MetadataDAOTest2 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest0.java",
		"test_prompt": "// MetadataBeanTest0.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isAnnotated()} method.\n*/\nclass MetadataBeanTest0 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest1.java",
		"test_prompt": "// MetadataBeanTest1.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isInappropriate()} method.\n*/\nclass MetadataBeanTest1 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest2.java",
		"test_prompt": "// MetadataBeanTest2.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isApproved()} method.\n*/\nclass MetadataBeanTest2 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest3.java",
		"test_prompt": "// MetadataBeanTest3.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isCataloged()} method.\n*/\nclass MetadataBeanTest3 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest4.java",
		"test_prompt": "// MetadataBeanTest4.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isArchived()} method.\n*/\nclass MetadataBeanTest4 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest5.java",
		"test_prompt": "// MetadataBeanTest5.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isRejected()} method.\n*/\nclass MetadataBeanTest5 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest6.java",
		"test_prompt": "// MetadataBeanTest6.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isHidden()} method.\n*/\nclass MetadataBeanTest6 {"
	},
	{
		"original_code": "// MetadataBean.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * <p>This class contains extended information about heal metadata.</p>\n * <p/>\n * <p>All of the parameters contained by this object are stored in the\n * form of a <code>String</code>.  The reasoning behind storing the\n * information in this manner is that it can be meaningful if a value\n * is <code>null</code> (this is the default state of all parameters).\n * An example of where this behavior is used is in an advanced search:\n * if a boolean (represented as a <code>String</code> is\n * <code>null</code> then it isn't used for the search, and that value\n * is not used for comparison in the database.</p>\n * <p/>\n * <p>Boolean values are considered true only if the string is not null\n * and equal (ignoring case) to <code>\"true\"</code>, <code>\"yes\"</code>,\n * or <code>\"1\"</code>.  It also should be noted that the boolean values\n * may return their value in two separate ways: <ol>\n * <li>By calling getXXX, the user gets the actual String value.</li>\n * <li>By calling isXXX, the user will get the boolean value.</li>\n * </ol></p>\n *\n * @author Seth Wright\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see ShortMetadataBean\n * @see CompleteMetadataBean\n */\npublic class MetadataBean extends ShortMetadataBean implements Serializable {\n\n    // Properties\n    private String sourceCollectionId = null;\n\n    private Date contributeDate = null;\n\n    //really a boolean\n    private String annotated = null;\n\n    //really a boolean\n    private String inappropriate = null;\n\n    //really a boolean\n    private String archived = null;\n\n    private String publicationName = null;\n\n    private String publicationId = null;\n\n    private String submissionAgreement = null;\n\n    /*\n     * There cannot be an instance variable named \"private\"\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable 'hidden' and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     */\n    //really a boolean\n    private String hidden = null;\n\n    private String specimenType = null;\n\n    private String radiographType = null;\n\n    private String orientation = null;\n\n    private String magnification = null;\n\n    private String clinicalHistory = null;\n\n    //really a date/timestamp value\n    private String duration = null;\n\n    private Date approveDate = null;\n\n    private Date catalogDate = null;\n\n    private Date rejectDate = null;\n\n    private Date creationDate = null;\n\n    private Date publicationDate = null;\n\n    private String languageType = null;\n\n    /**\n     * @return the sourceCollectionId property value.\n     */\n    public String getSourceCollectionId() {\n        return sourceCollectionId;\n    }\n\n    /**\n     * Sets the sourceCollectionId property value.\n     *\n     * @param sourceCollectionId\n     */\n    public void setSourceCollectionId(String sourceCollectionId) {\n        this.sourceCollectionId = sourceCollectionId;\n    }\n\n    /**\n     * Returns the contributeDate property value.\n     */\n    public Date getContributeDate() {\n        return this.contributeDate;\n    }\n\n    /**\n     * Sets the contributeDate property value.\n     */\n    public void setContributeDate(Date newContributeDate) {\n        this.contributeDate = newContributeDate;\n    }\n\n    /**\n     * Returns the annotated property value.\n     */\n    public String getAnnotated() {\n        return this.annotated;\n    }\n\n    /**\n     * Returns true if the passed string is not null and (ignoring case)\n     * is equal to true, 1, or yes.\n     */\n    protected boolean checkTrue(String boolStr) {\n        if (boolStr != null && (\"true\".equalsIgnoreCase(boolStr) || \"1\".equalsIgnoreCase(boolStr) || \"yes\".equalsIgnoreCase(boolStr))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isAnnotated() {\n        return checkTrue(annotated);\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(String newAnnotated) {\n        this.annotated = newAnnotated;\n    }\n\n    /**\n     * Sets the annotated property value.\n     */\n    public void setAnnotated(boolean newAnnotated) {\n        this.annotated = String.valueOf(newAnnotated);\n    }\n\n    /**\n     * Returns the inappropriate property value.\n     */\n    public String getInappropriate() {\n        return this.inappropriate;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isInappropriate() {\n        return checkTrue(inappropriate);\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(String newInappropriate) {\n        this.inappropriate = newInappropriate;\n    }\n\n    /**\n     * Sets the inappropriate property value.\n     */\n    public void setInappropriate(boolean newInappropriate) {\n        this.inappropriate = String.valueOf(newInappropriate);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isApproved() {\n        return (getApproveDate() != null);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isCataloged() {\n        return (getCatalogDate() != null);\n    }\n\n    /**\n     * Returns the archived property value.\n     */\n    public String getArchived() {\n        return this.archived;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isArchived() {\n        return checkTrue(archived);\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(String newArchived) {\n        this.archived = newArchived;\n    }\n\n    /**\n     * Sets the archived property value.\n     */\n    public void setArchived(boolean newArchived) {\n        this.archived = String.valueOf(newArchived);\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     */\n    public boolean isRejected() {\n        return (getRejectDate() != null);\n    }\n\n    /**\n     * Returns the hidden property value.\n     *\n     * @see #getPrivate()\n     * @deprecated Use {@link #getPrivate()} instead.\n     */\n    public String getHidden() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\",\"yes\" or \"true\"\n     *\n     * @see #isPrivate()\n     * @deprecated Use {@link #isPrivate()} instead.\n     */\n    public boolean isHidden() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(String)\n     * @deprecated Use {@link #setPrivate(String)} instead.\n     */\n    public void setHidden(String newHidden) {\n        this.hidden = newHidden;\n    }\n\n    /**\n     * Sets the hidden property value.\n     *\n     * @see #setPrivate(boolean)\n     * @deprecated Use {@link #setPrivate(boolean)} instead.\n     */\n    public void setHidden(boolean newHidden) {\n        this.hidden = String.valueOf(newHidden);\n    }\n\n    /**\n     * Why do we have the isPrivate/setPrivate methods without the\n     * corresponding instance variable?  Well, the heal metadata calls for\n     * having a field called \"private.\"  Unfortunately, we cannot use that\n     * because Java uses the term private as a keyword.  So, we define the\n     * instance variable hidden and then still have the isPrivate and\n     * setPrivate methods that act on the variable named hidden.\n     *\n     * @return Returns the private (aka hidden) property value.\n     */\n    public String getPrivate() {\n        return this.hidden;\n    }\n\n    /**\n     * Returns true if the property is not null and either \"1\" or \"yes\" or \"true\"\n     */\n    public boolean isPrivate() {\n        return checkTrue(hidden);\n    }\n\n    /**\n     * Sets the private (aka hidden) property value.\n     */\n    public void setPrivate(String newPrivate) {\n        this.hidden = newPrivate;\n    }\n\n    /**\n     * Sets the private property value.\n     */\n    public void setPrivate(boolean newPrivate) {\n        this.hidden = String.valueOf(newPrivate);\n    }\n\n    /**\n     * Returns the specimenType property value.\n     */\n    public String getSpecimenType() {\n        return this.specimenType;\n    }\n\n    /**\n     * Sets the specimenType property value.\n     */\n    public void setSpecimenType(String newSpecimenType) {\n        this.specimenType = newSpecimenType;\n    }\n\n    /**\n     * Returns the radiographType property value.\n     */\n    public String getRadiographType() {\n        return this.radiographType;\n    }\n\n    /**\n     * Sets the radiographType property value.\n     */\n    public void setRadiographType(String newRadiographType) {\n        this.radiographType = newRadiographType;\n    }\n\n    /**\n     * Returns the orientation property value.\n     */\n    public String getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation property value.\n     */\n    public void setOrientation(String newOrientation) {\n        this.orientation = newOrientation;\n    }\n\n    /**\n     * Returns the magnification property value.\n     */\n    public String getMagnification() {\n        return this.magnification;\n    }\n\n    /**\n     * Sets the magnification property value.\n     */\n    public void setMagnification(String newMagnification) {\n        this.magnification = newMagnification;\n    }\n\n    /**\n     * Returns the clinicalHistory property value.\n     */\n    public String getClinicalHistory() {\n        return this.clinicalHistory;\n    }\n\n    /**\n     * Sets the clinicalHistory property value.\n     */\n    public void setClinicalHistory(String newClinicalHistory) {\n        this.clinicalHistory = newClinicalHistory;\n    }\n\n    /**\n     * Returns the duration property value.\n     */\n    public String getDuration() {\n        return this.duration;\n    }\n\n    /**\n     * Sets the duration property value.\n     */\n    public void setDuration(String newDuration) {\n        this.duration = newDuration;\n    }\n\n    /**\n     * Returns the approveDate property value.\n     */\n    public Date getApproveDate() {\n        return this.approveDate;\n    }\n\n    /**\n     * Sets the approveDate property value.\n     */\n    public void setApproveDate(Date newApproveDate) {\n        this.approveDate = newApproveDate;\n    }\n\n    /**\n     * Returns the catalogDate property value.\n     */\n    public Date getCatalogDate() {\n        return this.catalogDate;\n    }\n\n    /**\n     * Sets the catalogDate property value.\n     */\n    public void setCatalogDate(Date newCatalogDate) {\n        this.catalogDate = newCatalogDate;\n    }\n\n    /**\n     * Returns the rejectDate property value.\n     */\n    public Date getRejectDate() {\n        return this.rejectDate;\n    }\n\n    /**\n     * Sets the rejectDate property value.\n     */\n    public void setRejectDate(Date newRejectDate) {\n        this.rejectDate = newRejectDate;\n    }\n\n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    public void setCreationDate(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Returns the publicationName property value.\n     */\n    public String getPublicationName() {\n        return this.publicationName;\n    }\n\n    /**\n     * Sets the publicationName property value.\n     */\n    public void setPublicationName(String publication) {\n        this.publicationName = publication;\n    }\n\n    public String getPublicationId() {\n        return publicationId;\n    }\n\n    public void setPublicationId(String publicationId) {\n        this.publicationId = publicationId;\n    }\n\n    public Date getPublicationDate() {\n        return publicationDate;\n    }\n\n    public void setPublicationDate(Date publicationDate) {\n        this.publicationDate = publicationDate;\n    }\n\n    /**\n     * Returns the submission agreement property value.\n     */\n    public String getSubmissionAgreement() {\n        return this.submissionAgreement;\n    }\n\n    /**\n     * Sets the submission agreement property value.\n     */\n    public void setSubmissionAgreement(String submissionAgreement) {\n        this.submissionAgreement = submissionAgreement;\n    }\n\n    /**\n     * Returns the Language Type property value.\n     */\n    public String getLanguageType() {\n        return this.languageType;\n    }\n\n    /**\n     * Sets the Language Type property value.\n     */\n    public void setLanguageType(String languageType) {\n        this.languageType = languageType;\n    }\n\n    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString());\n        ret.append(System.getProperty(\"line.separator\"));\n        ret.append(\"Extended Metadata: \" + \" sourceCollectionId:\" + sourceCollectionId + \" annotated:\" + String.valueOf(isAnnotated()) + \" inappropriate:\" + String.valueOf(isInappropriate()) + \" archived:\" + String.valueOf(isArchived()) + \" private:\" + String.valueOf(isPrivate()) + \" specimenType:\" + specimenType + \" radiographType:\" + radiographType + \" orientation:\" + orientation + \" magnification:\" + magnification + \" clinicalHistory:\" + clinicalHistory + \" duration:\" + duration + \" publicationId:\" + publicationId + \" publicationName:\" + publicationName + \" publicationDate:\" + DateTools.format(publicationDate) + \" approveDate:\" + DateTools.format(approveDate) + \" catalogDate:\" + DateTools.format(catalogDate) + \" rejectDate:\" + DateTools.format(rejectDate) + \" creationDate:\" + DateTools.format(creationDate) + \" languageType:\" + languageType);\n        return ret.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/MetadataBeanTest7.java",
		"test_prompt": "// MetadataBeanTest7.java\npackage org.heal.module.metadata;\n\nimport org.heal.util.DateTools;\nimport java.io.Serializable;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataBean}.\n* It contains ten unit test cases for the {@link MetadataBean#isPrivate()} method.\n*/\nclass MetadataBeanTest7 {"
	},
	{
		"original_code": "// HealMetadataXMLConverter.java\npackage org.heal.module.metadata;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\n\npublic class HealMetadataXMLConverter {\n\n    //public static final String IMSNAMESPACETAG = \"imsmd\";\n    public static final String IMSNAMESPACETAG = null;\n\n    /**\n     * Given a metadata bean and document, generates a complete IMS metadata\n     * representation of the provided bean using the document to create the\n     * elements.  The elemprefix is intended to allow the element names to\n     * begin with namespace information, so each element IMS element will\n     * be created with that prefix as follows: \"prefix:elementName\".  So,\n     * the prefix should correspond to the prefix specified in an xmlns\n     * attribute that specifies the IMS metadata namespace definition.\n     * If no prefix is specified, then no prefix (or colon) is appended.\n     */\n    public static Element metadataToElement(CompleteMetadataBean metaInfo, FileLocator fileLocator, String elemPrefix, Document doc) {\n        Element recordElem, metametadataElem, generalElem, lifecycleElem;\n        Element technicalElem, educationalElem, classificationElem;\n        Element rightsElem;\n        String nsPrefix;\n        if (elemPrefix == null) {\n            nsPrefix = \"\";\n        } else {\n            nsPrefix = elemPrefix + \":\";\n        }\n        recordElem = doc.createElement(nsPrefix + \"record\");\n        metametadataElem = createMetametadataElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(metametadataElem);\n        generalElem = createGeneralElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(generalElem);\n        lifecycleElem = createLifecycleElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(lifecycleElem);\n        technicalElem = createTechnicalElem(metaInfo, fileLocator, nsPrefix, doc);\n        recordElem.appendChild(technicalElem);\n        educationalElem = createEducationalElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(educationalElem);\n        rightsElem = createRightsElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(rightsElem);\n        appendRelations(metaInfo, recordElem, nsPrefix, doc);\n        classificationElem = createClassificationElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(classificationElem);\n        return recordElem;\n    }\n\n    /**\n     * Takes a metadata bean and generates the IMS XML output for that\n     * bean.\n     */\n    public static void metadataToIMSXML(CompleteMetadataBean metaInfo, FileLocator fileLocator, OutputStream out) throws IOException {\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element recordElem = metadataToElement(metaInfo, fileLocator, IMSNAMESPACETAG, doc);\n            //recordElem.setAttribute(\"xmlns:\"+IMSNAMESPACETAG,\n            //\"http://www.imsproject.org/metadata\");\n            recordElem.setAttribute(\"xmlns\", \"http://www.healcentral.org/xsd/healmd_v1p5\");\n            recordElem.setAttribute(\"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\");\n            recordElem.setAttribute(\"xsi:schemaLocation\", \"http://www.healcentral.org/services/schema/HEALmdSchemaXMLv1p5.xsd\");\n            doc.appendChild(recordElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            throw new IOException(ex.toString());\n        }\n    }\n\n    /**\n     * Creates a custom heal representation of the metadata.  This metadata\n     * contains the id, title, description, filename, fileextension, and\n     * filesize.\n     */\n    public static void shortMetadataToXML(ShortMetadataBean metaInfo, OutputStream out) throws IOException {\n        String id = metaInfo.getGlobalId();\n        String title = metaInfo.getTitle();\n        String description = metaInfo.getDescription();\n        String fileName = metaInfo.getFileName();\n        String fileExtension = metaInfo.getFileExtension();\n        String fileSize = metaInfo.getFileSize();\n        //String nsPrefix = IMSNAMESPACETAG+\":\";\n        String nsPrefix = \"\";\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element fileNameElem, fileExtensionElem, fileSizeElem, titleElem;\n            Element titleStringElem, descriptionElem, descriptionStringElem;\n            Element extensionElem, catalogEntryElem, technicalElem, generalElem;\n            Element recordElem, metaElem, metaschemeElem, languageElem;\n            //make the general element and sub elements\n            titleElem = doc.createElement(nsPrefix + \"title\");\n            titleStringElem = doc.createElement(nsPrefix + \"langstring\");\n            titleStringElem.setAttribute(\"xml:lang\", \"en-US\");\n            titleStringElem.appendChild(doc.createTextNode(title));\n            titleElem.appendChild(titleStringElem);\n            descriptionElem = doc.createElement(nsPrefix + \"description\");\n            descriptionStringElem = doc.createElement(nsPrefix + \"langstring\");\n            descriptionStringElem.setAttribute(\"xml:lang\", \"en-US\");\n            descriptionStringElem.appendChild(doc.createTextNode(description));\n            descriptionElem.appendChild(titleStringElem);\n            catalogEntryElem = createCatalogEntryElem(id, nsPrefix, doc);\n            metaElem = doc.createElement(nsPrefix + \"metametadata\");\n            metaElem.appendChild(catalogEntryElem);\n            metaschemeElem = doc.createElement(nsPrefix + \"metadatascheme\");\n            metaschemeElem.appendChild(doc.createTextNode(\"IMS:1.1\"));\n            metaElem.appendChild(metaschemeElem);\n            languageElem = doc.createElement(nsPrefix + \"language\");\n            languageElem.appendChild(doc.createTextNode(\"en-US\"));\n            metaElem.appendChild(languageElem);\n            catalogEntryElem = createCatalogEntryElem(id, nsPrefix, doc);\n            generalElem = doc.createElement(nsPrefix + \"general\");\n            generalElem.appendChild(catalogEntryElem);\n            generalElem.appendChild(titleElem);\n            generalElem.appendChild(descriptionElem);\n            //make the technical portion\n            fileNameElem = doc.createElement(\"filename\");\n            fileNameElem.appendChild(doc.createTextNode(fileName));\n            fileExtensionElem = doc.createElement(\"fileextension\");\n            fileExtensionElem.appendChild(doc.createTextNode(fileExtension));\n            fileSizeElem = doc.createElement(\"size\");\n            fileSizeElem.appendChild(doc.createTextNode(fileSize));\n            extensionElem = doc.createElement(nsPrefix + \"extension\");\n            extensionElem.appendChild(fileNameElem);\n            extensionElem.appendChild(fileExtensionElem);\n            technicalElem = doc.createElement(nsPrefix + \"technical\");\n            technicalElem.appendChild(extensionElem);\n            technicalElem.appendChild(fileSizeElem);\n            recordElem = doc.createElement(nsPrefix + \"record\");\n            recordElem.setAttribute(\"xmlns:\" + IMSNAMESPACETAG, \"http://www.imsproject.org/metadata\");\n            recordElem.appendChild(metaElem);\n            recordElem.appendChild(generalElem);\n            recordElem.appendChild(technicalElem);\n            doc.appendChild(recordElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            throw new IOException(ex.toString());\n        }\n    }\n\n    private static Element createCatalogEntryElem(String entry, String nsPrefix, Document doc) {\n        //make the catalogentry portion of the general elem\n        Element catalogueElem = doc.createElement(nsPrefix + \"catalogue\");\n        catalogueElem.appendChild(doc.createTextNode(\"HEAL.org\"));\n        Element entryElem = createElementWithLang(nsPrefix + \"entry\", \"en-US\", entry, nsPrefix, doc);\n        Element catalogEntryElem = doc.createElement(nsPrefix + \"catalogentry\");\n        catalogEntryElem.appendChild(catalogueElem);\n        catalogEntryElem.appendChild(entryElem);\n        return catalogEntryElem;\n    }\n\n    /**\n     * Generates the metametadata element which contains the catalog entry\n     * which contains the global id, the metadata scheme and version, the\n     * language, and the contributors.\n     */\n    private static Element createMetametadataElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        Element metaElem, catalogElem, schemeElem, languageElem;\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        MetadataBean metadata = cmb.getMetadata();\n        //\tString metadataId = metadata.getMetadataId();\n        String globalId = metadata.getGlobalId();\n        metaElem = doc.createElement(nsPrefix + \"metametadata\");\n        catalogElem = createCatalogEntryElem(globalId, nsPrefix, doc);\n        metaElem.appendChild(catalogElem);\n        appendContributors(cmb, metaElem, nsPrefix, doc);\n        schemeElem = doc.createElement(nsPrefix + \"metadatascheme\");\n        schemeElem.appendChild(doc.createTextNode(\"IMS:1.1\"));\n        metaElem.appendChild(schemeElem);\n        languageElem = doc.createElement(nsPrefix + \"language\");\n        languageElem.appendChild(doc.createTextNode(\"en-US\"));\n        metaElem.appendChild(languageElem);\n        return metaElem;\n    }\n\n    /**\n     * Given an element, appends the contributors specified in the complete\n     * metadata bean to the given element.\n     */\n    private static void appendContributors(CompleteMetadataBean cmb, Element parentElem, String nsPrefix, Document doc) {\n        if (cmb == null || parentElem == null || doc == null) {\n            return;\n        }\n        TreeMap contributors = cmb.getContributors();\n        String contributeDate = null;\n        String role = null;\n        String vCard = null;\n        ContributorBean contributor = null;\n        Element dateElem, roleElem, contributorElem, vCardElem;\n        ArrayList contribList;\n        Iterator listIterator;\n        contributeDate = DateTools.format(cmb.getContributeDate());\n        if (contributors != null) {\n            Iterator contributorIterator = contributors.keySet().iterator();\n            while (contributorIterator.hasNext()) {\n                role = (String) contributorIterator.next();\n                contribList = (ArrayList) contributors.get(role);\n                listIterator = contribList.iterator();\n                contributorElem = doc.createElement(nsPrefix + \"contribute\");\n                roleElem = createElementWithLang(nsPrefix + \"role\", null, role, nsPrefix, doc);\n                contributorElem.appendChild(roleElem);\n                while (listIterator.hasNext()) {\n                    contributor = (ContributorBean) listIterator.next();\n                    vCard = contributor.getVCard();\n                    vCardElem = createVCardElem(vCard, nsPrefix, doc);\n                    contributorElem.appendChild(vCardElem);\n                }\n                if (contributeDate != null) {\n                    dateElem = createDateElem(contributeDate, nsPrefix, doc);\n                    contributorElem.appendChild(dateElem);\n                }\n                parentElem.appendChild(contributorElem);\n            }\n        }\n    }\n\n    /**\n     * Generates a vcard element that adheres to the specified\n     * IMS hierarchy (centity containing a vcard).\n     */\n    private static Element createVCardElem(String vCard, String nsPrefix, Document doc) {\n        if (vCard == null || doc == null) {\n            return null;\n        }\n        Element centityElem = doc.createElement(nsPrefix + \"centity\");\n        Element vCardElem = doc.createElement(nsPrefix + \"vcard\");\n        vCardElem.appendChild(doc.createTextNode(vCard));\n        centityElem.appendChild(vCardElem);\n        return centityElem;\n    }\n\n    /**\n     * Given a date string, creates a date and datetime element that adheres\n     * to the IMS's specifications for dates.\n     */\n    private static Element createDateElem(String date, String nsPrefix, Document doc) {\n        if (date == null || doc == null) {\n            return null;\n        }\n        Element dateElem = doc.createElement(nsPrefix + \"date\");\n        Element dateTimeElem = doc.createElement(nsPrefix + \"datetime\");\n        dateTimeElem.appendChild(doc.createTextNode(date));\n        dateElem.appendChild(dateTimeElem);\n        return dateElem;\n    }\n\n    private static Element createGeneralElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element generalElem, catalogElem, descriptionElem, languageElem;\n        //\tElement keywordsElem, titleElem, extensionElem;\n        Element titleElem, extensionElem;\n        MetadataBean metadata = cmb.getMetadata();\n        generalElem = doc.createElement(nsPrefix + \"general\");\n        if (metadata == null) {\n            return generalElem;\n        }\n        //\tString metadataId = metadata.getMetadataId();\n        String title = metadata.getTitle();\n        String globalId = metadata.getGlobalId();\n        String description = metadata.getDescription();\n        //ArrayList keywords = cmb.getKeywords();\n        titleElem = createElementWithLang(nsPrefix + \"title\", null, title, nsPrefix, doc);\n        generalElem.appendChild(titleElem);\n        catalogElem = createCatalogEntryElem(globalId, nsPrefix, doc);\n        generalElem.appendChild(catalogElem);\n        languageElem = doc.createElement(nsPrefix + \"language\");\n        languageElem.appendChild(doc.createTextNode(\"en-US\"));\n        generalElem.appendChild(languageElem);\n        descriptionElem = createElementWithLang(nsPrefix + \"description\", null, description, nsPrefix, doc);\n        generalElem.appendChild(descriptionElem);\n        //appendKeywordList(generalElem,keywords,nsPrefix,doc);\n        extensionElem = createGeneralExtensionElem(cmb, nsPrefix, doc);\n        generalElem.appendChild(extensionElem);\n        return generalElem;\n    }\n\n    private static Element createGeneralExtensionElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element extensionElem;\n        MetadataBean meta = cmb.getMetadata();\n        extensionElem = doc.createElement(nsPrefix + \"extension\");\n        if (meta == null) {\n            return extensionElem;\n        }\n        extensionElem.appendChild(createTextElement(\"specimentype\", meta.getSpecimenType(), doc));\n        extensionElem.appendChild(createTextElement(\"radiographtype\", meta.getRadiographType(), doc));\n        extensionElem.appendChild(createTextElement(\"orientation\", meta.getOrientation(), doc));\n        extensionElem.appendChild(createTextElement(\"magnification\", meta.getMagnification(), doc));\n        extensionElem.appendChild(createTextElement(\"annotated\", booleanToYesNo(meta.isAnnotated()), doc));\n        for (Iterator iter = cmb.getDiseaseDiagnoses().iterator(); iter.hasNext(); ) {\n            DiseaseDiagnosisBean value = (DiseaseDiagnosisBean) iter.next();\n            extensionElem.appendChild(createTextElement(\"diseaseprocess\", value.getDiseaseDiagnosis(), doc));\n        }\n        extensionElem.appendChild(createTextElement(\"clinicalhistory\", meta.getClinicalHistory(), doc));\n        appendDiseaseDiagnosesList(extensionElem, cmb.getDiseaseDiagnoses(), doc);\n        appendContextURLList(extensionElem, cmb.getContextURLs(), doc);\n        extensionElem.appendChild(createTextElement(\"inappropriate\", booleanToYesNo(meta.isInappropriate()), doc));\n        return extensionElem;\n    }\n\n    private static Element createLifecycleElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element lifecycleElem;\n        lifecycleElem = doc.createElement(nsPrefix + \"lifecycle\");\n        appendContributors(cmb, lifecycleElem, nsPrefix, doc);\n        return lifecycleElem;\n    }\n\n    private static Element createTechnicalElem(CompleteMetadataBean cmb, FileLocator fileLocator, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element technicalElem, extensionElem, locationElem;\n        Element durationElem;\n        MetadataBean meta = cmb.getMetadata();\n        technicalElem = doc.createElement(nsPrefix + \"technical\");\n        extensionElem = createTechnicalExtensionElem(cmb, nsPrefix, doc);\n        technicalElem.appendChild(extensionElem);\n        if (meta != null) {\n            technicalElem.appendChild(createTextElement(nsPrefix + \"size\", meta.getFileSize(), doc));\n            String location = fileLocator.getContentURL(meta.getLocation());\n            locationElem = doc.createElement(nsPrefix + \"location\");\n            locationElem.setAttribute(\"type\", \"URI\");\n            locationElem.appendChild(doc.createTextNode(location));\n            technicalElem.appendChild(locationElem);\n        }\n        appendRequirementsList(technicalElem, cmb.getRequirements(), nsPrefix, doc);\n        String duration = meta.getDuration();\n        durationElem = doc.createElement(nsPrefix + \"duration\");\n        if (duration != null) {\n            try {\n                long durationLong = Long.parseLong(duration);\n                durationElem.appendChild(createDateTimeElem(durationLong, nsPrefix, doc));\n            } catch (NumberFormatException ex) {\n                //XXX ignore for now??  Should I output an error, log one?\n            }\n        }\n        technicalElem.appendChild(durationElem);\n        return technicalElem;\n    }\n\n    /**\n     * Creates an element of the form:\n     * <datetime>yyyy-mm-ddThh:mm:ss</datetime>\n     * The string is meant to be a duration, not a date, so a parameter of\n     * 180 will get a value of 0000-00-00T00:03:00 (3 minutes).\n     */\n    private static Element createDateTimeElem(long seconds, String nsPrefix, Document doc) {\n        long sec = seconds % 60;\n        long minutes = seconds / 60;\n        long min = minutes % 60;\n        long hours = minutes / 60;\n        String dtString = \"0000-00-00T\" + hours + min + sec;\n        Element dateTimeElem = doc.createElement(nsPrefix + \"datetime\");\n        dateTimeElem.appendChild(doc.createTextNode(dtString));\n        return dateTimeElem;\n    }\n\n    /**\n     * Creates a technical exstension element of the following form:\n     * If the CompleteMetadataBean's metadata property is not null, you get:\n     * <extension>\n     * <filename>name</filename>      (OR <filename /> if filename is null)\n     * <fileextension>extension</fileextension>\n     * (OR <fileextension /> if fileextension is null)\n     * <filewidth>width</filewidth> (OR <filewidth /> if filewidth is null)\n     * <fileheight>height</fileheight>\n     * (OR <fileheight /> if fileheight is null)\n     * </extension>\n     * <p/>\n     * if the metadata property is null, you get:\n     * <extension />\n     */\n    private static Element createTechnicalExtensionElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element extensionElem = doc.createElement(nsPrefix + \"extension\");\n        MetadataBean meta = cmb.getMetadata();\n        if (meta != null) {\n            extensionElem.appendChild(createTextElement(\"filename\", meta.getFileName(), doc));\n            extensionElem.appendChild(createTextElement(\"fileextension\", meta.getFileExtension(), doc));\n            extensionElem.appendChild(createTextElement(\"filewidth\", meta.getFileWidth(), doc));\n            extensionElem.appendChild(createTextElement(\"fileheight\", meta.getFileHeight(), doc));\n        }\n        return extensionElem;\n    }\n\n    private static Element createEducationalElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element educationalElem, learningElem;\n        educationalElem = doc.createElement(nsPrefix + \"educational\");\n        Iterator iter = cmb.getTargetUserGroups().iterator();\n        while (iter.hasNext()) {\n            learningElem = createElementWithLang(nsPrefix + \"learningcontext\", \"en\", ((TargetUserGroupBean) iter.next()).getTargetUserGroup(), nsPrefix, doc);\n            educationalElem.appendChild(learningElem);\n        }\n        return educationalElem;\n    }\n\n    private static Element createRightsElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element rightsElem, hasCopyElem, extensionElem;\n        ArrayList copyrights, copyrightHolders;\n        String hasCopyrights;\n        rightsElem = doc.createElement(nsPrefix + \"rights\");\n        copyrights = cmb.getCopyrights();\n        copyrightHolders = cmb.getCopyrightHolders();\n        if ((copyrights == null || copyrights.size() == 0) && (copyrightHolders == null || copyrightHolders.size() == 0)) {\n            hasCopyrights = \"no\";\n        } else {\n            hasCopyrights = \"yes\";\n        }\n        hasCopyElem = createElementWithLang(nsPrefix + \"copyrightorotherrestrictions\", null, hasCopyrights, nsPrefix, doc);\n        rightsElem.appendChild(hasCopyElem);\n        extensionElem = createRightsExtension(copyrights, copyrightHolders, nsPrefix, doc);\n        rightsElem.appendChild(extensionElem);\n        return rightsElem;\n    }\n\n    private static Element createRightsExtension(ArrayList copyrights, ArrayList copyrightHolders, String nsPrefix, Document doc) {\n        if (doc == null) {\n            return null;\n        }\n        Element extensionElem, copyrightElem, holderElem;\n        String holderString, copyrightString;\n        CopyrightBean copyright;\n        CopyrightTextBean copyrightText;\n        CopyrightHolderBean holder;\n        extensionElem = doc.createElement(nsPrefix + \"extension\");\n        if (copyrightHolders != null) {\n            Iterator holderIterator = copyrightHolders.iterator();\n            while (holderIterator.hasNext()) {\n                holder = (CopyrightHolderBean) holderIterator.next();\n                holderString = holder.getVCard();\n                holderElem = createVCardElem(holderString, nsPrefix, doc);\n                copyrightElem = doc.createElement(\"copyrightholder\");\n                copyrightElem.appendChild(holderElem);\n                extensionElem.appendChild(copyrightElem);\n            }\n        } else {\n            copyrightElem = doc.createElement(\"copyrightholder\");\n            extensionElem.appendChild(copyrightElem);\n        }\n        if (copyrights != null) {\n            Iterator copyrightIterator = copyrights.iterator();\n            while (copyrightIterator.hasNext()) {\n                copyright = (CopyrightBean) copyrightIterator.next();\n                copyrightText = copyright.getCopyrightText();\n                if (copyrightText != null) {\n                    copyrightString = copyrightText.getCopyrightText();\n                    copyrightElem = createElementWithLang(\"copyrightdescription\", null, copyrightString, nsPrefix, doc);\n                    extensionElem.appendChild(copyrightElem);\n                }\n            }\n        } else {\n            copyrightElem = doc.createElement(\"copyrightdescription\");\n            extensionElem.appendChild(copyrightElem);\n        }\n        return extensionElem;\n    }\n\n    private static void appendRelations(CompleteMetadataBean cmb, Element parentElem, String nsPrefix, Document doc) {\n        if (cmb == null || parentElem == null || doc == null) {\n            return;\n        }\n        ArrayList relations = cmb.getRelations();\n        Iterator relationIterator = relations.iterator();\n        RelationBean relation;\n        Element relationElem;\n        Element resourceElem;\n        String kind;\n        String description;\n        String resource;\n        while (relationIterator.hasNext()) {\n            relation = (RelationBean) relationIterator.next();\n            relationElem = doc.createElement(nsPrefix + \"relation\");\n            kind = relation.getKind();\n            if (kind != null) {\n                relationElem.appendChild(createElementWithLang(nsPrefix + \"kind\", null, kind, nsPrefix, doc));\n            }\n            description = relation.getDescription();\n            resource = relation.getResource();\n            resourceElem = doc.createElement(nsPrefix + \"resource\");\n            if (description != null) {\n                resourceElem.appendChild(createElementWithLang(nsPrefix + \"description\", null, description, nsPrefix, doc));\n            }\n            if (resource != null) {\n                resourceElem.appendChild(createCatalogEntryElem(resource, nsPrefix, doc));\n            }\n            relationElem.appendChild(resourceElem);\n            parentElem.appendChild(relationElem);\n        }\n    }\n\n    private static Element createClassificationElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        ArrayList paths;\n        SortedSet taxons;\n        TaxonPathBean taxonPath;\n        TaxonBean taxon;\n        String source, id, entry;\n        Element classificationElem, taxonElem, pathElem, entryElem;\n        Iterator pathIterator, taxonIterator;\n        classificationElem = doc.createElement(nsPrefix + \"classification\");\n        paths = cmb.getTaxonPaths();\n        if (paths != null) {\n            pathIterator = paths.iterator();\n            while (pathIterator.hasNext()) {\n                taxonPath = (TaxonPathBean) pathIterator.next();\n                source = taxonPath.getSource();\n                pathElem = doc.createElement(nsPrefix + \"taxonpath\");\n                pathElem.appendChild(createTextElement(nsPrefix + \"source\", source, doc));\n                taxons = taxonPath.getTaxons();\n                if (taxons != null) {\n                    taxonIterator = taxons.iterator();\n                    while (taxonIterator.hasNext()) {\n                        taxon = (TaxonBean) taxonIterator.next();\n                        id = taxon.getId();\n                        entry = taxon.getEntry();\n                        taxonElem = doc.createElement(nsPrefix + \"taxon\");\n                        taxonElem.appendChild(createTextElement(nsPrefix + \"id\", id, doc));\n                        entryElem = createElementWithLang(nsPrefix + \"entry\", null, entry, nsPrefix, doc);\n                        taxonElem.appendChild(entryElem);\n                        pathElem.appendChild(taxonElem);\n                    }\n                }\n                classificationElem.appendChild(pathElem);\n            }\n        }\n        ArrayList keywords = cmb.getKeywords();\n        appendKeywordList(classificationElem, keywords, nsPrefix, doc);\n        return classificationElem;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <elementName>\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     * </elementName>\n     */\n    private static Element createElementWithLang(String elementName, String languageAttr, String textvalue, String nsPrefix, Document doc) {\n        if (elementName == null) {\n            return null;\n        }\n        Element retval = doc.createElement(elementName);\n        if (textvalue != null) {\n            retval.appendChild(createLangstring(textvalue, languageAttr, nsPrefix, doc));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <elementName>elementValue</elementName>\n     * OR\n     * <elementName />\n     */\n    private static Element createTextElement(String elementName, String elementValue, Document doc) {\n        Element retval = doc.createElement(elementName);\n        if (elementValue != null) {\n            retval.appendChild(doc.createTextNode(elementValue));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <elementName>elementValue(1)</elementName>\n     * <elementName>elementValue(2)</elementName>\n     * <elementName>elementValue(3)</elementName>\n     * ...\n     * <elementName>elementValue(n)</elementName>\n     * OR\n     * <elementName />\n     */\n    private static void appendElementList(Element parentElem, String elementName, ArrayList elementValues, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(elementName));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            String value = null;\n            while (valueIterator.hasNext()) {\n                value = (String) valueIterator.next();\n                parentElem.appendChild(createTextElement(elementName, value, doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <contextURL>elementValue(1)</contextURL>\n     * <contextURL>elementValue(2)</contextURL>\n     * <contextURL>elementValue(3)</contextURL>\n     * ...\n     * <contextURL>elementValue(n)</contextURL>\n     * OR\n     * <contextURL />\n     */\n    private static void appendContextURLList(Element parentElem, ArrayList elementValues, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(\"contextURL\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            ContextURLBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (ContextURLBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(\"contextURL\", value.getContextURL(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <format>elementValue(1)</format>\n     * <format>elementValue(2)</format>\n     * <format>elementValue(3)</format>\n     * ...\n     * <format>elementValue(n)</format>\n     * OR\n     * <format />\n     */\n    private static void appendFormatList(Element parentElem, ArrayList elementValues, String nsPrefix, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(nsPrefix + \"format\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            FormatBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (FormatBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(nsPrefix + \"format\", value.getFormat(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <keyword>elementValue(1)</keyword>\n     * <keyword>elementValue(2)</keyword>\n     * <keyword>elementValue(3)</keyword>\n     * ...\n     * <keyword>elementValue(n)</keyword>\n     * OR\n     * <keyword />\n     */\n    private static void appendKeywordList(Element parentElem, ArrayList elementValues, String nsPrefix, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(nsPrefix + \"keyword\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            KeywordBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (KeywordBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(nsPrefix + \"keyword\", value.getKeyword(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <requirements>elementValue(1)</requirements>\n     * <requirements>elementValue(2)</requirements>\n     * <requirements>elementValue(3)</requirements>\n     * ...\n     * <requirements>elementValue(n)</requirements>\n     * OR\n     * <requirements />\n     */\n    private static void appendRequirementsList(Element parentElem, ArrayList elementValues, String nsPrefix, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(nsPrefix + \"requirements\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            RequirementBean value = null;\n            Element requirementElem, typeElem, nameElem;\n            while (valueIterator.hasNext()) {\n                value = (RequirementBean) valueIterator.next();\n                requirementElem = doc.createElement(nsPrefix + \"requirements\");\n                typeElem = createElementWithLang(nsPrefix + \"type\", null, value.getRequirementType(), nsPrefix, doc);\n                requirementElem.appendChild(typeElem);\n                nameElem = createElementWithLang(nsPrefix + \"name\", null, value.getRequirementName(), nsPrefix, doc);\n                requirementElem.appendChild(nameElem);\n                parentElem.appendChild(requirementElem);\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <diseasediagnosis>elementValue(1)</diseasediagnosis>\n     * <diseasediagnosis>elementValue(2)</diseasediagnosis>\n     * <diseasediagnosis>elementValue(3)</diseasediagnosis>\n     * ...\n     * <diseasediagnosis>elementValue(n)</diseasediagnosis>\n     * OR\n     * <diseasediagnosis />\n     */\n    private static void appendDiseaseDiagnosesList(Element parentElem, ArrayList elementValues, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(\"diseasediagnosis\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            DiseaseDiagnosisBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (DiseaseDiagnosisBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(\"diseasediagnosis\", value.getDiseaseDiagnosis(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and boolean value.\n     * Example:\n     * <elementName>true</elementName>\n     * OR\n     * <elementName>false</elementName>\n     */\n    private static Element createBooleanElement(String elementName, boolean elementValue, Document doc) {\n        Element retval = doc.createElement(elementName);\n        if (elementValue) {\n            retval.appendChild(doc.createTextNode(\"true\"));\n        } else {\n            retval.appendChild(doc.createTextNode(\"false\"));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <elementName>\n     * <langstring xml:lang=\"languageAttr\">textvalue(1)</langstring>\n     * <langstring xml:lang=\"languageAttr\">textvalue(2)</langstring>\n     * <langstring xml:lang=\"languageAttr\">textvalue(3)</langstring>\n     * ...\n     * <langstring xml:lang=\"languageAttr\">textvalue(n)</langstring>\n     * </elementName>\n     */\n    private static Element createElementWithLangList(String elementName, String languageAttr, ArrayList textvalues, String nsPrefix, Document doc) {\n        if (elementName == null) {\n            return null;\n        }\n        Element retval = doc.createElement(elementName);\n        if (textvalues == null) {\n            return retval;\n        }\n        Iterator valuesIterator = textvalues.iterator();\n        String value;\n        while (valuesIterator.hasNext()) {\n            value = (String) valuesIterator.next();\n            retval.appendChild(createLangstring(value, languageAttr, nsPrefix, doc));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     */\n    private static Element createLangstring(String textvalue, String languageAttr, String nsPrefix, Document doc) {\n        Element returnValue = doc.createElement(nsPrefix + \"langstring\");\n        if (languageAttr != null) {\n            returnValue.setAttribute(\"xml:lang\", languageAttr);\n        }\n        if (textvalue != null) {\n            returnValue.appendChild(doc.createTextNode(textvalue));\n        }\n        return returnValue;\n    }\n\n    public static String getPointerListXML(ArrayList ids) throws IOException {\n        if (ids == null) {\n            return null;\n        }\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element listElem = doc.createElement(\"metadatalist\");\n            Element catalogueElem = doc.createElement(\"catalogue\");\n            catalogueElem.appendChild(doc.createTextNode(\"HEAL.org\"));\n            listElem.appendChild(catalogueElem);\n            Iterator idIter = ids.iterator();\n            Element entryElem;\n            Element langstringElem;\n            while (idIter.hasNext()) {\n                String id = (String) idIter.next();\n                entryElem = doc.createElement(\"entry\");\n                langstringElem = doc.createElement(\"langstring\");\n                langstringElem.appendChild(doc.createTextNode(id));\n                entryElem.appendChild(langstringElem);\n                listElem.appendChild(entryElem);\n            }\n            doc.appendChild(listElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            throw new IOException(ex.toString());\n        }\n        return out.toString();\n    }\n\n    /**\n     * Creates the manifest element for the given metadata, including the\n     * metadata element (hard coded settings),\n     * organizations element (currently empty), and the dynamically\n     * generated resources element.\n     * No attributes are set on the element, but it is assumed that the\n     * namespace for the IMS metadata tags is \"imsmd\" (specified in\n     * org.heal.module.metadata.HealMetadataXMLConverter.IMSNAMESPACETAG).\n     * This is consistent with all of the manifest examples provided by IMS.\n     */\n    private static Element createManifestElement(CompleteMetadataBean[] metaInfo, FileLocator fileLocator, Document doc) {\n        Element metametadataElem, organizationsElem, resourcesElem;\n        Element manifestElem;\n        //manifestElem = doc.createElement(\"manifest\");\n        manifestElem = doc.createElement(\"imscp:manifest\");\n        metametadataElem = createManifestMetadataElem(doc);\n        manifestElem.appendChild(metametadataElem);\n        /* since this is a dynamically generated manifest for\n\t\t * a package constituted of potentially many disparate pieces of\n\t\t * content, we can't really provide any insight as to the\n\t\t * organization of the content, so we leave the organizations\n\t\t * element empty\n\t\t */\n        organizationsElem = doc.createElement(\"organizations\");\n        manifestElem.appendChild(organizationsElem);\n        resourcesElem = createManifestResourcesElem(metaInfo, fileLocator, doc);\n        manifestElem.appendChild(resourcesElem);\n        return manifestElem;\n    }\n\n    /**\n     * Creates a parent resources element containing multiple resource\n     * elements (one for each metadata).  The resource elements contain\n     * the content's metadata and the path to the file within the package.\n     * No dependency information is generated because this information is not\n     * encoded in the database.\n     */\n    private static Element createManifestResourcesElem(CompleteMetadataBean[] metaInfo, FileLocator fileLocator, Document doc) {\n        Element resourcesElem = doc.createElement(\"resources\");\n        Element resourceElem;\n        for (int i = 0; i < metaInfo.length; i++) {\n            resourceElem = createManifestResourceElem(\"RESOURCE\" + i, metaInfo[i], fileLocator, doc);\n            resourcesElem.appendChild(resourceElem);\n        }\n        return resourcesElem;\n    }\n\n    /**\n     * Given an identifier, metadata bean and dom document, creates a resource\n     * element for inclusion in the manifest.  The identifier is used to\n     * give a name to this element.  Usually this will just be something\n     * along the lines of \"RESOURCEi\" where i is a unique number in this\n     * manifest.\n     * The created element has a name of \"resource\" with an identifier\n     * of, well, \"identifier\".  The included elements are a file entry\n     * to specify the location of the file in the package and the\n     * content's metadata.  No dependency information is supplied.\n     * Also the resource tag contains a \"type\" attribute that is hardcoded\n     * to be \"webcontent\" since a) that is all we serve, and b) the IMS v1.1\n     * content packaging specification only defines that setting.\n     */\n    private static Element createManifestResourceElem(String identifier, CompleteMetadataBean metadata, FileLocator fileLocator, Document doc) {\n        Element resourceElem, metadataElem, fileElem;\n        resourceElem = doc.createElement(\"resource\");\n        resourceElem.setAttribute(\"identifier\", identifier);\n        resourceElem.setAttribute(\"type\", \"webcontent\");\n        String nsprefix = HealMetadataXMLConverter.IMSNAMESPACETAG;\n        metadataElem = HealMetadataXMLConverter.metadataToElement(metadata, fileLocator, nsprefix, doc);\n        MetadataBean meta = metadata.getMetadata();\n        String localpath = fileLocator.getContentURL(meta.getLocation());\n        fileElem = doc.createElement(\"file\");\n        fileElem.setAttribute(\"href\", localpath);\n        resourceElem.appendChild(metadataElem);\n        return resourceElem;\n    }\n\n    /**\n     * Creates an element of the form:\n     * <metadata>\n     * <schema>IMS Content</schema>\n     * <schemaversion>1.1</schemaversion>\n     * <imsmd:record>\n     * <imsmd:general>\n     * <imsmd:title>\n     * <imsmd:langstring xml:lang=\"en-US\">Dynamically Generated HEAL IMS Content Package</imsmd:langstring>\n     * </imsmd:title>\n     * </imsmd:general>\n     * </imsmd:record>\n     * </metadata>\n     */\n    private static Element createManifestMetadataElem(Document doc) {\n        Element schemaElem, schemaversionElem, recordElem;\n        Element generalElem, titleElem;\n        //Element metadataElem = doc.createElement(\"metadata\");\n        Element metadataElem = doc.createElement(\"imscp:metadata\");\n        //schemaElem = doc.createElement(\"schema\");\n        schemaElem = doc.createElement(\"imscp:schema\");\n        schemaElem.appendChild(doc.createTextNode(\"IMS Content\"));\n        //schemaversionElem = doc.createElement(\"schemaversion\");\n        schemaversionElem = doc.createElement(\"imscp:schemaversion\");\n        schemaversionElem.appendChild(doc.createTextNode(\"1.1\"));\n        //recordElem = doc.createElement(HealMetadataXMLConverter.IMSNAMESPACETAG+\":record\");\n        //generalElem = doc.createElement(HealMetadataXMLConverter.IMSNAMESPACETAG+\":general\");\n        //titleElem = createManifestElementWithLang(HealMetadataXMLConverter.IMSNAMESPACETAG+\":title\",\n        //\t\t\t\t\t  \"en-US\",\n        //\t\t\t\t\t  \"Dynamically Generated HEAL IMS Content Package\",\n        //\t\t\t\t\t  doc);\n        recordElem = doc.createElement(\"record\");\n        generalElem = doc.createElement(\"general\");\n        titleElem = createManifestElementWithLang(\"title\", \"en-US\", \"Dynamically Generated HEAL IMS Content Package\", doc);\n        generalElem.appendChild(titleElem);\n        recordElem.appendChild(generalElem);\n        metadataElem.appendChild(schemaElem);\n        metadataElem.appendChild(schemaversionElem);\n        metadataElem.appendChild(recordElem);\n        return metadataElem;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <elementName>\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     * </elementName>\n     */\n    private static Element createManifestElementWithLang(String elementName, String languageAttr, String textvalue, Document doc) {\n        Element retval = doc.createElement(elementName);\n        retval.appendChild(createManifestLangstring(textvalue, languageAttr, doc));\n        return retval;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     */\n    private static Element createManifestLangstring(String textvalue, String languageAttr, Document doc) {\n        //Element returnValue = doc.createElement(HealMetadataXMLConverter.IMSNAMESPACETAG+\":langstring\");\n        Element returnValue = doc.createElement(\"langstring\");\n        if (languageAttr != null) {\n            returnValue.setAttribute(\"xml:lang\", languageAttr);\n        }\n        returnValue.appendChild(doc.createTextNode(textvalue));\n        return returnValue;\n    }\n\n    /**\n     * Given an array of metadata beans, creates a manifest file for an IMS\n     * package containing the given metadata and content.  The XML manifest\n     * is then written to the provided output stream.\n     */\n    public static void getManifestIMSXML(CompleteMetadataBean[] metaInfo, FileLocator fileLocator, OutputStream out) throws IOException {\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element manifestElem = createManifestElement(metaInfo, fileLocator, doc);\n            manifestElem.setAttribute(\"identifier\", \"MANIFEST1\");\n            manifestElem.setAttribute(\"xmlns:imscp\", \"http://www.imsproject.org/xsd/ims_cp_rootv1p1\");\n            //manifestElem.setAttribute(\"xmlns:\"+HealMetadataXMLConverter.IMSNAMESPACETAG,\n            //\t      \"http://www.imsproject.org/xsd/ims_md_rootv1p1\");\n            manifestElem.setAttribute(\"xmlns\", \"http://www.healcentral.org/xsd/healmd_v1p5\");\n            manifestElem.setAttribute(\"xmlns:xsi\", \"http://www.w3.org/2000/10/XMLSchema-instance\");\n            //manifestElem.setAttribute(\"xsi:schemaLocation\",\"http://www.imsproject.org/xsd/ims_cp_rootv1p1 http://www.imsproject.org/xsd/ims_cp_rootv1p1.xsd http://www.imsproject.org/xsd/ims_md_rootv1p1 http://www.imsproject.org/xsd/ims_md_rootv1p1.xsd\");\n            manifestElem.setAttribute(\"xsi:schemaLocation\", \"http://www.imsproject.org/xsd/ims_cp_rootv1p1 http://www.imsproject.org/xsd/ims_cp_rootv1p1.xsd http://www.healcentral.org/services/schema/HEALmdSchemaXMLv1p5 http://www.healcentral.org/services/schema/HEALmdSchemaXMLv1p5.xsd\");\n            doc.appendChild(manifestElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            throw new IOException(ex.toString());\n        }\n    }\n\n    /**\n     * if bool is true, \"yes\" is returned - otherwise \"no\" is returned\n     */\n    private static String booleanToYesNo(boolean bool) {\n        return (bool ? \"yes\" : \"no\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/HealMetadataXMLConverterTest0.java",
		"test_prompt": "// HealMetadataXMLConverterTest0.java\npackage org.heal.module.metadata;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HealMetadataXMLConverter}.\n* It contains ten unit test cases for the {@link HealMetadataXMLConverter#metadataToElement(CompleteMetadataBean, FileLocator, String, Document)} method.\n*/\nclass HealMetadataXMLConverterTest0 {"
	},
	{
		"original_code": "// HealMetadataXMLConverter.java\npackage org.heal.module.metadata;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\n\npublic class HealMetadataXMLConverter {\n\n    //public static final String IMSNAMESPACETAG = \"imsmd\";\n    public static final String IMSNAMESPACETAG = null;\n\n    /**\n     * Given a metadata bean and document, generates a complete IMS metadata\n     * representation of the provided bean using the document to create the\n     * elements.  The elemprefix is intended to allow the element names to\n     * begin with namespace information, so each element IMS element will\n     * be created with that prefix as follows: \"prefix:elementName\".  So,\n     * the prefix should correspond to the prefix specified in an xmlns\n     * attribute that specifies the IMS metadata namespace definition.\n     * If no prefix is specified, then no prefix (or colon) is appended.\n     */\n    public static Element metadataToElement(CompleteMetadataBean metaInfo, FileLocator fileLocator, String elemPrefix, Document doc) {\n        Element recordElem, metametadataElem, generalElem, lifecycleElem;\n        Element technicalElem, educationalElem, classificationElem;\n        Element rightsElem;\n        String nsPrefix;\n        if (elemPrefix == null) {\n            nsPrefix = \"\";\n        } else {\n            nsPrefix = elemPrefix + \":\";\n        }\n        recordElem = doc.createElement(nsPrefix + \"record\");\n        metametadataElem = createMetametadataElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(metametadataElem);\n        generalElem = createGeneralElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(generalElem);\n        lifecycleElem = createLifecycleElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(lifecycleElem);\n        technicalElem = createTechnicalElem(metaInfo, fileLocator, nsPrefix, doc);\n        recordElem.appendChild(technicalElem);\n        educationalElem = createEducationalElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(educationalElem);\n        rightsElem = createRightsElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(rightsElem);\n        appendRelations(metaInfo, recordElem, nsPrefix, doc);\n        classificationElem = createClassificationElem(metaInfo, nsPrefix, doc);\n        recordElem.appendChild(classificationElem);\n        return recordElem;\n    }\n\n    /**\n     * Takes a metadata bean and generates the IMS XML output for that\n     * bean.\n     */\n    public static void metadataToIMSXML(CompleteMetadataBean metaInfo, FileLocator fileLocator, OutputStream out) throws IOException {\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element recordElem = metadataToElement(metaInfo, fileLocator, IMSNAMESPACETAG, doc);\n            //recordElem.setAttribute(\"xmlns:\"+IMSNAMESPACETAG,\n            //\"http://www.imsproject.org/metadata\");\n            recordElem.setAttribute(\"xmlns\", \"http://www.healcentral.org/xsd/healmd_v1p5\");\n            recordElem.setAttribute(\"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\");\n            recordElem.setAttribute(\"xsi:schemaLocation\", \"http://www.healcentral.org/services/schema/HEALmdSchemaXMLv1p5.xsd\");\n            doc.appendChild(recordElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            throw new IOException(ex.toString());\n        }\n    }\n\n    /**\n     * Creates a custom heal representation of the metadata.  This metadata\n     * contains the id, title, description, filename, fileextension, and\n     * filesize.\n     */\n    public static void shortMetadataToXML(ShortMetadataBean metaInfo, OutputStream out) throws IOException {\n        String id = metaInfo.getGlobalId();\n        String title = metaInfo.getTitle();\n        String description = metaInfo.getDescription();\n        String fileName = metaInfo.getFileName();\n        String fileExtension = metaInfo.getFileExtension();\n        String fileSize = metaInfo.getFileSize();\n        //String nsPrefix = IMSNAMESPACETAG+\":\";\n        String nsPrefix = \"\";\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element fileNameElem, fileExtensionElem, fileSizeElem, titleElem;\n            Element titleStringElem, descriptionElem, descriptionStringElem;\n            Element extensionElem, catalogEntryElem, technicalElem, generalElem;\n            Element recordElem, metaElem, metaschemeElem, languageElem;\n            //make the general element and sub elements\n            titleElem = doc.createElement(nsPrefix + \"title\");\n            titleStringElem = doc.createElement(nsPrefix + \"langstring\");\n            titleStringElem.setAttribute(\"xml:lang\", \"en-US\");\n            titleStringElem.appendChild(doc.createTextNode(title));\n            titleElem.appendChild(titleStringElem);\n            descriptionElem = doc.createElement(nsPrefix + \"description\");\n            descriptionStringElem = doc.createElement(nsPrefix + \"langstring\");\n            descriptionStringElem.setAttribute(\"xml:lang\", \"en-US\");\n            descriptionStringElem.appendChild(doc.createTextNode(description));\n            descriptionElem.appendChild(titleStringElem);\n            catalogEntryElem = createCatalogEntryElem(id, nsPrefix, doc);\n            metaElem = doc.createElement(nsPrefix + \"metametadata\");\n            metaElem.appendChild(catalogEntryElem);\n            metaschemeElem = doc.createElement(nsPrefix + \"metadatascheme\");\n            metaschemeElem.appendChild(doc.createTextNode(\"IMS:1.1\"));\n            metaElem.appendChild(metaschemeElem);\n            languageElem = doc.createElement(nsPrefix + \"language\");\n            languageElem.appendChild(doc.createTextNode(\"en-US\"));\n            metaElem.appendChild(languageElem);\n            catalogEntryElem = createCatalogEntryElem(id, nsPrefix, doc);\n            generalElem = doc.createElement(nsPrefix + \"general\");\n            generalElem.appendChild(catalogEntryElem);\n            generalElem.appendChild(titleElem);\n            generalElem.appendChild(descriptionElem);\n            //make the technical portion\n            fileNameElem = doc.createElement(\"filename\");\n            fileNameElem.appendChild(doc.createTextNode(fileName));\n            fileExtensionElem = doc.createElement(\"fileextension\");\n            fileExtensionElem.appendChild(doc.createTextNode(fileExtension));\n            fileSizeElem = doc.createElement(\"size\");\n            fileSizeElem.appendChild(doc.createTextNode(fileSize));\n            extensionElem = doc.createElement(nsPrefix + \"extension\");\n            extensionElem.appendChild(fileNameElem);\n            extensionElem.appendChild(fileExtensionElem);\n            technicalElem = doc.createElement(nsPrefix + \"technical\");\n            technicalElem.appendChild(extensionElem);\n            technicalElem.appendChild(fileSizeElem);\n            recordElem = doc.createElement(nsPrefix + \"record\");\n            recordElem.setAttribute(\"xmlns:\" + IMSNAMESPACETAG, \"http://www.imsproject.org/metadata\");\n            recordElem.appendChild(metaElem);\n            recordElem.appendChild(generalElem);\n            recordElem.appendChild(technicalElem);\n            doc.appendChild(recordElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            throw new IOException(ex.toString());\n        }\n    }\n\n    private static Element createCatalogEntryElem(String entry, String nsPrefix, Document doc) {\n        //make the catalogentry portion of the general elem\n        Element catalogueElem = doc.createElement(nsPrefix + \"catalogue\");\n        catalogueElem.appendChild(doc.createTextNode(\"HEAL.org\"));\n        Element entryElem = createElementWithLang(nsPrefix + \"entry\", \"en-US\", entry, nsPrefix, doc);\n        Element catalogEntryElem = doc.createElement(nsPrefix + \"catalogentry\");\n        catalogEntryElem.appendChild(catalogueElem);\n        catalogEntryElem.appendChild(entryElem);\n        return catalogEntryElem;\n    }\n\n    /**\n     * Generates the metametadata element which contains the catalog entry\n     * which contains the global id, the metadata scheme and version, the\n     * language, and the contributors.\n     */\n    private static Element createMetametadataElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        Element metaElem, catalogElem, schemeElem, languageElem;\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        MetadataBean metadata = cmb.getMetadata();\n        //\tString metadataId = metadata.getMetadataId();\n        String globalId = metadata.getGlobalId();\n        metaElem = doc.createElement(nsPrefix + \"metametadata\");\n        catalogElem = createCatalogEntryElem(globalId, nsPrefix, doc);\n        metaElem.appendChild(catalogElem);\n        appendContributors(cmb, metaElem, nsPrefix, doc);\n        schemeElem = doc.createElement(nsPrefix + \"metadatascheme\");\n        schemeElem.appendChild(doc.createTextNode(\"IMS:1.1\"));\n        metaElem.appendChild(schemeElem);\n        languageElem = doc.createElement(nsPrefix + \"language\");\n        languageElem.appendChild(doc.createTextNode(\"en-US\"));\n        metaElem.appendChild(languageElem);\n        return metaElem;\n    }\n\n    /**\n     * Given an element, appends the contributors specified in the complete\n     * metadata bean to the given element.\n     */\n    private static void appendContributors(CompleteMetadataBean cmb, Element parentElem, String nsPrefix, Document doc) {\n        if (cmb == null || parentElem == null || doc == null) {\n            return;\n        }\n        TreeMap contributors = cmb.getContributors();\n        String contributeDate = null;\n        String role = null;\n        String vCard = null;\n        ContributorBean contributor = null;\n        Element dateElem, roleElem, contributorElem, vCardElem;\n        ArrayList contribList;\n        Iterator listIterator;\n        contributeDate = DateTools.format(cmb.getContributeDate());\n        if (contributors != null) {\n            Iterator contributorIterator = contributors.keySet().iterator();\n            while (contributorIterator.hasNext()) {\n                role = (String) contributorIterator.next();\n                contribList = (ArrayList) contributors.get(role);\n                listIterator = contribList.iterator();\n                contributorElem = doc.createElement(nsPrefix + \"contribute\");\n                roleElem = createElementWithLang(nsPrefix + \"role\", null, role, nsPrefix, doc);\n                contributorElem.appendChild(roleElem);\n                while (listIterator.hasNext()) {\n                    contributor = (ContributorBean) listIterator.next();\n                    vCard = contributor.getVCard();\n                    vCardElem = createVCardElem(vCard, nsPrefix, doc);\n                    contributorElem.appendChild(vCardElem);\n                }\n                if (contributeDate != null) {\n                    dateElem = createDateElem(contributeDate, nsPrefix, doc);\n                    contributorElem.appendChild(dateElem);\n                }\n                parentElem.appendChild(contributorElem);\n            }\n        }\n    }\n\n    /**\n     * Generates a vcard element that adheres to the specified\n     * IMS hierarchy (centity containing a vcard).\n     */\n    private static Element createVCardElem(String vCard, String nsPrefix, Document doc) {\n        if (vCard == null || doc == null) {\n            return null;\n        }\n        Element centityElem = doc.createElement(nsPrefix + \"centity\");\n        Element vCardElem = doc.createElement(nsPrefix + \"vcard\");\n        vCardElem.appendChild(doc.createTextNode(vCard));\n        centityElem.appendChild(vCardElem);\n        return centityElem;\n    }\n\n    /**\n     * Given a date string, creates a date and datetime element that adheres\n     * to the IMS's specifications for dates.\n     */\n    private static Element createDateElem(String date, String nsPrefix, Document doc) {\n        if (date == null || doc == null) {\n            return null;\n        }\n        Element dateElem = doc.createElement(nsPrefix + \"date\");\n        Element dateTimeElem = doc.createElement(nsPrefix + \"datetime\");\n        dateTimeElem.appendChild(doc.createTextNode(date));\n        dateElem.appendChild(dateTimeElem);\n        return dateElem;\n    }\n\n    private static Element createGeneralElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element generalElem, catalogElem, descriptionElem, languageElem;\n        //\tElement keywordsElem, titleElem, extensionElem;\n        Element titleElem, extensionElem;\n        MetadataBean metadata = cmb.getMetadata();\n        generalElem = doc.createElement(nsPrefix + \"general\");\n        if (metadata == null) {\n            return generalElem;\n        }\n        //\tString metadataId = metadata.getMetadataId();\n        String title = metadata.getTitle();\n        String globalId = metadata.getGlobalId();\n        String description = metadata.getDescription();\n        //ArrayList keywords = cmb.getKeywords();\n        titleElem = createElementWithLang(nsPrefix + \"title\", null, title, nsPrefix, doc);\n        generalElem.appendChild(titleElem);\n        catalogElem = createCatalogEntryElem(globalId, nsPrefix, doc);\n        generalElem.appendChild(catalogElem);\n        languageElem = doc.createElement(nsPrefix + \"language\");\n        languageElem.appendChild(doc.createTextNode(\"en-US\"));\n        generalElem.appendChild(languageElem);\n        descriptionElem = createElementWithLang(nsPrefix + \"description\", null, description, nsPrefix, doc);\n        generalElem.appendChild(descriptionElem);\n        //appendKeywordList(generalElem,keywords,nsPrefix,doc);\n        extensionElem = createGeneralExtensionElem(cmb, nsPrefix, doc);\n        generalElem.appendChild(extensionElem);\n        return generalElem;\n    }\n\n    private static Element createGeneralExtensionElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element extensionElem;\n        MetadataBean meta = cmb.getMetadata();\n        extensionElem = doc.createElement(nsPrefix + \"extension\");\n        if (meta == null) {\n            return extensionElem;\n        }\n        extensionElem.appendChild(createTextElement(\"specimentype\", meta.getSpecimenType(), doc));\n        extensionElem.appendChild(createTextElement(\"radiographtype\", meta.getRadiographType(), doc));\n        extensionElem.appendChild(createTextElement(\"orientation\", meta.getOrientation(), doc));\n        extensionElem.appendChild(createTextElement(\"magnification\", meta.getMagnification(), doc));\n        extensionElem.appendChild(createTextElement(\"annotated\", booleanToYesNo(meta.isAnnotated()), doc));\n        for (Iterator iter = cmb.getDiseaseDiagnoses().iterator(); iter.hasNext(); ) {\n            DiseaseDiagnosisBean value = (DiseaseDiagnosisBean) iter.next();\n            extensionElem.appendChild(createTextElement(\"diseaseprocess\", value.getDiseaseDiagnosis(), doc));\n        }\n        extensionElem.appendChild(createTextElement(\"clinicalhistory\", meta.getClinicalHistory(), doc));\n        appendDiseaseDiagnosesList(extensionElem, cmb.getDiseaseDiagnoses(), doc);\n        appendContextURLList(extensionElem, cmb.getContextURLs(), doc);\n        extensionElem.appendChild(createTextElement(\"inappropriate\", booleanToYesNo(meta.isInappropriate()), doc));\n        return extensionElem;\n    }\n\n    private static Element createLifecycleElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element lifecycleElem;\n        lifecycleElem = doc.createElement(nsPrefix + \"lifecycle\");\n        appendContributors(cmb, lifecycleElem, nsPrefix, doc);\n        return lifecycleElem;\n    }\n\n    private static Element createTechnicalElem(CompleteMetadataBean cmb, FileLocator fileLocator, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element technicalElem, extensionElem, locationElem;\n        Element durationElem;\n        MetadataBean meta = cmb.getMetadata();\n        technicalElem = doc.createElement(nsPrefix + \"technical\");\n        extensionElem = createTechnicalExtensionElem(cmb, nsPrefix, doc);\n        technicalElem.appendChild(extensionElem);\n        if (meta != null) {\n            technicalElem.appendChild(createTextElement(nsPrefix + \"size\", meta.getFileSize(), doc));\n            String location = fileLocator.getContentURL(meta.getLocation());\n            locationElem = doc.createElement(nsPrefix + \"location\");\n            locationElem.setAttribute(\"type\", \"URI\");\n            locationElem.appendChild(doc.createTextNode(location));\n            technicalElem.appendChild(locationElem);\n        }\n        appendRequirementsList(technicalElem, cmb.getRequirements(), nsPrefix, doc);\n        String duration = meta.getDuration();\n        durationElem = doc.createElement(nsPrefix + \"duration\");\n        if (duration != null) {\n            try {\n                long durationLong = Long.parseLong(duration);\n                durationElem.appendChild(createDateTimeElem(durationLong, nsPrefix, doc));\n            } catch (NumberFormatException ex) {\n                //XXX ignore for now??  Should I output an error, log one?\n            }\n        }\n        technicalElem.appendChild(durationElem);\n        return technicalElem;\n    }\n\n    /**\n     * Creates an element of the form:\n     * <datetime>yyyy-mm-ddThh:mm:ss</datetime>\n     * The string is meant to be a duration, not a date, so a parameter of\n     * 180 will get a value of 0000-00-00T00:03:00 (3 minutes).\n     */\n    private static Element createDateTimeElem(long seconds, String nsPrefix, Document doc) {\n        long sec = seconds % 60;\n        long minutes = seconds / 60;\n        long min = minutes % 60;\n        long hours = minutes / 60;\n        String dtString = \"0000-00-00T\" + hours + min + sec;\n        Element dateTimeElem = doc.createElement(nsPrefix + \"datetime\");\n        dateTimeElem.appendChild(doc.createTextNode(dtString));\n        return dateTimeElem;\n    }\n\n    /**\n     * Creates a technical exstension element of the following form:\n     * If the CompleteMetadataBean's metadata property is not null, you get:\n     * <extension>\n     * <filename>name</filename>      (OR <filename /> if filename is null)\n     * <fileextension>extension</fileextension>\n     * (OR <fileextension /> if fileextension is null)\n     * <filewidth>width</filewidth> (OR <filewidth /> if filewidth is null)\n     * <fileheight>height</fileheight>\n     * (OR <fileheight /> if fileheight is null)\n     * </extension>\n     * <p/>\n     * if the metadata property is null, you get:\n     * <extension />\n     */\n    private static Element createTechnicalExtensionElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element extensionElem = doc.createElement(nsPrefix + \"extension\");\n        MetadataBean meta = cmb.getMetadata();\n        if (meta != null) {\n            extensionElem.appendChild(createTextElement(\"filename\", meta.getFileName(), doc));\n            extensionElem.appendChild(createTextElement(\"fileextension\", meta.getFileExtension(), doc));\n            extensionElem.appendChild(createTextElement(\"filewidth\", meta.getFileWidth(), doc));\n            extensionElem.appendChild(createTextElement(\"fileheight\", meta.getFileHeight(), doc));\n        }\n        return extensionElem;\n    }\n\n    private static Element createEducationalElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element educationalElem, learningElem;\n        educationalElem = doc.createElement(nsPrefix + \"educational\");\n        Iterator iter = cmb.getTargetUserGroups().iterator();\n        while (iter.hasNext()) {\n            learningElem = createElementWithLang(nsPrefix + \"learningcontext\", \"en\", ((TargetUserGroupBean) iter.next()).getTargetUserGroup(), nsPrefix, doc);\n            educationalElem.appendChild(learningElem);\n        }\n        return educationalElem;\n    }\n\n    private static Element createRightsElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        Element rightsElem, hasCopyElem, extensionElem;\n        ArrayList copyrights, copyrightHolders;\n        String hasCopyrights;\n        rightsElem = doc.createElement(nsPrefix + \"rights\");\n        copyrights = cmb.getCopyrights();\n        copyrightHolders = cmb.getCopyrightHolders();\n        if ((copyrights == null || copyrights.size() == 0) && (copyrightHolders == null || copyrightHolders.size() == 0)) {\n            hasCopyrights = \"no\";\n        } else {\n            hasCopyrights = \"yes\";\n        }\n        hasCopyElem = createElementWithLang(nsPrefix + \"copyrightorotherrestrictions\", null, hasCopyrights, nsPrefix, doc);\n        rightsElem.appendChild(hasCopyElem);\n        extensionElem = createRightsExtension(copyrights, copyrightHolders, nsPrefix, doc);\n        rightsElem.appendChild(extensionElem);\n        return rightsElem;\n    }\n\n    private static Element createRightsExtension(ArrayList copyrights, ArrayList copyrightHolders, String nsPrefix, Document doc) {\n        if (doc == null) {\n            return null;\n        }\n        Element extensionElem, copyrightElem, holderElem;\n        String holderString, copyrightString;\n        CopyrightBean copyright;\n        CopyrightTextBean copyrightText;\n        CopyrightHolderBean holder;\n        extensionElem = doc.createElement(nsPrefix + \"extension\");\n        if (copyrightHolders != null) {\n            Iterator holderIterator = copyrightHolders.iterator();\n            while (holderIterator.hasNext()) {\n                holder = (CopyrightHolderBean) holderIterator.next();\n                holderString = holder.getVCard();\n                holderElem = createVCardElem(holderString, nsPrefix, doc);\n                copyrightElem = doc.createElement(\"copyrightholder\");\n                copyrightElem.appendChild(holderElem);\n                extensionElem.appendChild(copyrightElem);\n            }\n        } else {\n            copyrightElem = doc.createElement(\"copyrightholder\");\n            extensionElem.appendChild(copyrightElem);\n        }\n        if (copyrights != null) {\n            Iterator copyrightIterator = copyrights.iterator();\n            while (copyrightIterator.hasNext()) {\n                copyright = (CopyrightBean) copyrightIterator.next();\n                copyrightText = copyright.getCopyrightText();\n                if (copyrightText != null) {\n                    copyrightString = copyrightText.getCopyrightText();\n                    copyrightElem = createElementWithLang(\"copyrightdescription\", null, copyrightString, nsPrefix, doc);\n                    extensionElem.appendChild(copyrightElem);\n                }\n            }\n        } else {\n            copyrightElem = doc.createElement(\"copyrightdescription\");\n            extensionElem.appendChild(copyrightElem);\n        }\n        return extensionElem;\n    }\n\n    private static void appendRelations(CompleteMetadataBean cmb, Element parentElem, String nsPrefix, Document doc) {\n        if (cmb == null || parentElem == null || doc == null) {\n            return;\n        }\n        ArrayList relations = cmb.getRelations();\n        Iterator relationIterator = relations.iterator();\n        RelationBean relation;\n        Element relationElem;\n        Element resourceElem;\n        String kind;\n        String description;\n        String resource;\n        while (relationIterator.hasNext()) {\n            relation = (RelationBean) relationIterator.next();\n            relationElem = doc.createElement(nsPrefix + \"relation\");\n            kind = relation.getKind();\n            if (kind != null) {\n                relationElem.appendChild(createElementWithLang(nsPrefix + \"kind\", null, kind, nsPrefix, doc));\n            }\n            description = relation.getDescription();\n            resource = relation.getResource();\n            resourceElem = doc.createElement(nsPrefix + \"resource\");\n            if (description != null) {\n                resourceElem.appendChild(createElementWithLang(nsPrefix + \"description\", null, description, nsPrefix, doc));\n            }\n            if (resource != null) {\n                resourceElem.appendChild(createCatalogEntryElem(resource, nsPrefix, doc));\n            }\n            relationElem.appendChild(resourceElem);\n            parentElem.appendChild(relationElem);\n        }\n    }\n\n    private static Element createClassificationElem(CompleteMetadataBean cmb, String nsPrefix, Document doc) {\n        if (cmb == null || doc == null) {\n            return null;\n        }\n        ArrayList paths;\n        SortedSet taxons;\n        TaxonPathBean taxonPath;\n        TaxonBean taxon;\n        String source, id, entry;\n        Element classificationElem, taxonElem, pathElem, entryElem;\n        Iterator pathIterator, taxonIterator;\n        classificationElem = doc.createElement(nsPrefix + \"classification\");\n        paths = cmb.getTaxonPaths();\n        if (paths != null) {\n            pathIterator = paths.iterator();\n            while (pathIterator.hasNext()) {\n                taxonPath = (TaxonPathBean) pathIterator.next();\n                source = taxonPath.getSource();\n                pathElem = doc.createElement(nsPrefix + \"taxonpath\");\n                pathElem.appendChild(createTextElement(nsPrefix + \"source\", source, doc));\n                taxons = taxonPath.getTaxons();\n                if (taxons != null) {\n                    taxonIterator = taxons.iterator();\n                    while (taxonIterator.hasNext()) {\n                        taxon = (TaxonBean) taxonIterator.next();\n                        id = taxon.getId();\n                        entry = taxon.getEntry();\n                        taxonElem = doc.createElement(nsPrefix + \"taxon\");\n                        taxonElem.appendChild(createTextElement(nsPrefix + \"id\", id, doc));\n                        entryElem = createElementWithLang(nsPrefix + \"entry\", null, entry, nsPrefix, doc);\n                        taxonElem.appendChild(entryElem);\n                        pathElem.appendChild(taxonElem);\n                    }\n                }\n                classificationElem.appendChild(pathElem);\n            }\n        }\n        ArrayList keywords = cmb.getKeywords();\n        appendKeywordList(classificationElem, keywords, nsPrefix, doc);\n        return classificationElem;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <elementName>\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     * </elementName>\n     */\n    private static Element createElementWithLang(String elementName, String languageAttr, String textvalue, String nsPrefix, Document doc) {\n        if (elementName == null) {\n            return null;\n        }\n        Element retval = doc.createElement(elementName);\n        if (textvalue != null) {\n            retval.appendChild(createLangstring(textvalue, languageAttr, nsPrefix, doc));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <elementName>elementValue</elementName>\n     * OR\n     * <elementName />\n     */\n    private static Element createTextElement(String elementName, String elementValue, Document doc) {\n        Element retval = doc.createElement(elementName);\n        if (elementValue != null) {\n            retval.appendChild(doc.createTextNode(elementValue));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <elementName>elementValue(1)</elementName>\n     * <elementName>elementValue(2)</elementName>\n     * <elementName>elementValue(3)</elementName>\n     * ...\n     * <elementName>elementValue(n)</elementName>\n     * OR\n     * <elementName />\n     */\n    private static void appendElementList(Element parentElem, String elementName, ArrayList elementValues, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(elementName));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            String value = null;\n            while (valueIterator.hasNext()) {\n                value = (String) valueIterator.next();\n                parentElem.appendChild(createTextElement(elementName, value, doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <contextURL>elementValue(1)</contextURL>\n     * <contextURL>elementValue(2)</contextURL>\n     * <contextURL>elementValue(3)</contextURL>\n     * ...\n     * <contextURL>elementValue(n)</contextURL>\n     * OR\n     * <contextURL />\n     */\n    private static void appendContextURLList(Element parentElem, ArrayList elementValues, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(\"contextURL\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            ContextURLBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (ContextURLBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(\"contextURL\", value.getContextURL(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <format>elementValue(1)</format>\n     * <format>elementValue(2)</format>\n     * <format>elementValue(3)</format>\n     * ...\n     * <format>elementValue(n)</format>\n     * OR\n     * <format />\n     */\n    private static void appendFormatList(Element parentElem, ArrayList elementValues, String nsPrefix, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(nsPrefix + \"format\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            FormatBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (FormatBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(nsPrefix + \"format\", value.getFormat(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <keyword>elementValue(1)</keyword>\n     * <keyword>elementValue(2)</keyword>\n     * <keyword>elementValue(3)</keyword>\n     * ...\n     * <keyword>elementValue(n)</keyword>\n     * OR\n     * <keyword />\n     */\n    private static void appendKeywordList(Element parentElem, ArrayList elementValues, String nsPrefix, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(nsPrefix + \"keyword\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            KeywordBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (KeywordBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(nsPrefix + \"keyword\", value.getKeyword(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <requirements>elementValue(1)</requirements>\n     * <requirements>elementValue(2)</requirements>\n     * <requirements>elementValue(3)</requirements>\n     * ...\n     * <requirements>elementValue(n)</requirements>\n     * OR\n     * <requirements />\n     */\n    private static void appendRequirementsList(Element parentElem, ArrayList elementValues, String nsPrefix, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(nsPrefix + \"requirements\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            RequirementBean value = null;\n            Element requirementElem, typeElem, nameElem;\n            while (valueIterator.hasNext()) {\n                value = (RequirementBean) valueIterator.next();\n                requirementElem = doc.createElement(nsPrefix + \"requirements\");\n                typeElem = createElementWithLang(nsPrefix + \"type\", null, value.getRequirementType(), nsPrefix, doc);\n                requirementElem.appendChild(typeElem);\n                nameElem = createElementWithLang(nsPrefix + \"name\", null, value.getRequirementName(), nsPrefix, doc);\n                requirementElem.appendChild(nameElem);\n                parentElem.appendChild(requirementElem);\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and text value.  If the value\n     * is null, then an empty element will be created:\n     * <diseasediagnosis>elementValue(1)</diseasediagnosis>\n     * <diseasediagnosis>elementValue(2)</diseasediagnosis>\n     * <diseasediagnosis>elementValue(3)</diseasediagnosis>\n     * ...\n     * <diseasediagnosis>elementValue(n)</diseasediagnosis>\n     * OR\n     * <diseasediagnosis />\n     */\n    private static void appendDiseaseDiagnosesList(Element parentElem, ArrayList elementValues, Document doc) {\n        if (parentElem == null) {\n            return;\n        }\n        if (elementValues == null) {\n            parentElem.appendChild(doc.createElement(\"diseasediagnosis\"));\n        } else {\n            Iterator valueIterator = elementValues.iterator();\n            DiseaseDiagnosisBean value = null;\n            while (valueIterator.hasNext()) {\n                value = (DiseaseDiagnosisBean) valueIterator.next();\n                parentElem.appendChild(createTextElement(\"diseasediagnosis\", value.getDiseaseDiagnosis(), doc));\n            }\n        }\n    }\n\n    /**\n     * Creates an element with the given name and boolean value.\n     * Example:\n     * <elementName>true</elementName>\n     * OR\n     * <elementName>false</elementName>\n     */\n    private static Element createBooleanElement(String elementName, boolean elementValue, Document doc) {\n        Element retval = doc.createElement(elementName);\n        if (elementValue) {\n            retval.appendChild(doc.createTextNode(\"true\"));\n        } else {\n            retval.appendChild(doc.createTextNode(\"false\"));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <elementName>\n     * <langstring xml:lang=\"languageAttr\">textvalue(1)</langstring>\n     * <langstring xml:lang=\"languageAttr\">textvalue(2)</langstring>\n     * <langstring xml:lang=\"languageAttr\">textvalue(3)</langstring>\n     * ...\n     * <langstring xml:lang=\"languageAttr\">textvalue(n)</langstring>\n     * </elementName>\n     */\n    private static Element createElementWithLangList(String elementName, String languageAttr, ArrayList textvalues, String nsPrefix, Document doc) {\n        if (elementName == null) {\n            return null;\n        }\n        Element retval = doc.createElement(elementName);\n        if (textvalues == null) {\n            return retval;\n        }\n        Iterator valuesIterator = textvalues.iterator();\n        String value;\n        while (valuesIterator.hasNext()) {\n            value = (String) valuesIterator.next();\n            retval.appendChild(createLangstring(value, languageAttr, nsPrefix, doc));\n        }\n        return retval;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     */\n    private static Element createLangstring(String textvalue, String languageAttr, String nsPrefix, Document doc) {\n        Element returnValue = doc.createElement(nsPrefix + \"langstring\");\n        if (languageAttr != null) {\n            returnValue.setAttribute(\"xml:lang\", languageAttr);\n        }\n        if (textvalue != null) {\n            returnValue.appendChild(doc.createTextNode(textvalue));\n        }\n        return returnValue;\n    }\n\n    public static String getPointerListXML(ArrayList ids) throws IOException {\n        if (ids == null) {\n            return null;\n        }\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element listElem = doc.createElement(\"metadatalist\");\n            Element catalogueElem = doc.createElement(\"catalogue\");\n            catalogueElem.appendChild(doc.createTextNode(\"HEAL.org\"));\n            listElem.appendChild(catalogueElem);\n            Iterator idIter = ids.iterator();\n            Element entryElem;\n            Element langstringElem;\n            while (idIter.hasNext()) {\n                String id = (String) idIter.next();\n                entryElem = doc.createElement(\"entry\");\n                langstringElem = doc.createElement(\"langstring\");\n                langstringElem.appendChild(doc.createTextNode(id));\n                entryElem.appendChild(langstringElem);\n                listElem.appendChild(entryElem);\n            }\n            doc.appendChild(listElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            throw new IOException(ex.toString());\n        }\n        return out.toString();\n    }\n\n    /**\n     * Creates the manifest element for the given metadata, including the\n     * metadata element (hard coded settings),\n     * organizations element (currently empty), and the dynamically\n     * generated resources element.\n     * No attributes are set on the element, but it is assumed that the\n     * namespace for the IMS metadata tags is \"imsmd\" (specified in\n     * org.heal.module.metadata.HealMetadataXMLConverter.IMSNAMESPACETAG).\n     * This is consistent with all of the manifest examples provided by IMS.\n     */\n    private static Element createManifestElement(CompleteMetadataBean[] metaInfo, FileLocator fileLocator, Document doc) {\n        Element metametadataElem, organizationsElem, resourcesElem;\n        Element manifestElem;\n        //manifestElem = doc.createElement(\"manifest\");\n        manifestElem = doc.createElement(\"imscp:manifest\");\n        metametadataElem = createManifestMetadataElem(doc);\n        manifestElem.appendChild(metametadataElem);\n        /* since this is a dynamically generated manifest for\n\t\t * a package constituted of potentially many disparate pieces of\n\t\t * content, we can't really provide any insight as to the\n\t\t * organization of the content, so we leave the organizations\n\t\t * element empty\n\t\t */\n        organizationsElem = doc.createElement(\"organizations\");\n        manifestElem.appendChild(organizationsElem);\n        resourcesElem = createManifestResourcesElem(metaInfo, fileLocator, doc);\n        manifestElem.appendChild(resourcesElem);\n        return manifestElem;\n    }\n\n    /**\n     * Creates a parent resources element containing multiple resource\n     * elements (one for each metadata).  The resource elements contain\n     * the content's metadata and the path to the file within the package.\n     * No dependency information is generated because this information is not\n     * encoded in the database.\n     */\n    private static Element createManifestResourcesElem(CompleteMetadataBean[] metaInfo, FileLocator fileLocator, Document doc) {\n        Element resourcesElem = doc.createElement(\"resources\");\n        Element resourceElem;\n        for (int i = 0; i < metaInfo.length; i++) {\n            resourceElem = createManifestResourceElem(\"RESOURCE\" + i, metaInfo[i], fileLocator, doc);\n            resourcesElem.appendChild(resourceElem);\n        }\n        return resourcesElem;\n    }\n\n    /**\n     * Given an identifier, metadata bean and dom document, creates a resource\n     * element for inclusion in the manifest.  The identifier is used to\n     * give a name to this element.  Usually this will just be something\n     * along the lines of \"RESOURCEi\" where i is a unique number in this\n     * manifest.\n     * The created element has a name of \"resource\" with an identifier\n     * of, well, \"identifier\".  The included elements are a file entry\n     * to specify the location of the file in the package and the\n     * content's metadata.  No dependency information is supplied.\n     * Also the resource tag contains a \"type\" attribute that is hardcoded\n     * to be \"webcontent\" since a) that is all we serve, and b) the IMS v1.1\n     * content packaging specification only defines that setting.\n     */\n    private static Element createManifestResourceElem(String identifier, CompleteMetadataBean metadata, FileLocator fileLocator, Document doc) {\n        Element resourceElem, metadataElem, fileElem;\n        resourceElem = doc.createElement(\"resource\");\n        resourceElem.setAttribute(\"identifier\", identifier);\n        resourceElem.setAttribute(\"type\", \"webcontent\");\n        String nsprefix = HealMetadataXMLConverter.IMSNAMESPACETAG;\n        metadataElem = HealMetadataXMLConverter.metadataToElement(metadata, fileLocator, nsprefix, doc);\n        MetadataBean meta = metadata.getMetadata();\n        String localpath = fileLocator.getContentURL(meta.getLocation());\n        fileElem = doc.createElement(\"file\");\n        fileElem.setAttribute(\"href\", localpath);\n        resourceElem.appendChild(metadataElem);\n        return resourceElem;\n    }\n\n    /**\n     * Creates an element of the form:\n     * <metadata>\n     * <schema>IMS Content</schema>\n     * <schemaversion>1.1</schemaversion>\n     * <imsmd:record>\n     * <imsmd:general>\n     * <imsmd:title>\n     * <imsmd:langstring xml:lang=\"en-US\">Dynamically Generated HEAL IMS Content Package</imsmd:langstring>\n     * </imsmd:title>\n     * </imsmd:general>\n     * </imsmd:record>\n     * </metadata>\n     */\n    private static Element createManifestMetadataElem(Document doc) {\n        Element schemaElem, schemaversionElem, recordElem;\n        Element generalElem, titleElem;\n        //Element metadataElem = doc.createElement(\"metadata\");\n        Element metadataElem = doc.createElement(\"imscp:metadata\");\n        //schemaElem = doc.createElement(\"schema\");\n        schemaElem = doc.createElement(\"imscp:schema\");\n        schemaElem.appendChild(doc.createTextNode(\"IMS Content\"));\n        //schemaversionElem = doc.createElement(\"schemaversion\");\n        schemaversionElem = doc.createElement(\"imscp:schemaversion\");\n        schemaversionElem.appendChild(doc.createTextNode(\"1.1\"));\n        //recordElem = doc.createElement(HealMetadataXMLConverter.IMSNAMESPACETAG+\":record\");\n        //generalElem = doc.createElement(HealMetadataXMLConverter.IMSNAMESPACETAG+\":general\");\n        //titleElem = createManifestElementWithLang(HealMetadataXMLConverter.IMSNAMESPACETAG+\":title\",\n        //\t\t\t\t\t  \"en-US\",\n        //\t\t\t\t\t  \"Dynamically Generated HEAL IMS Content Package\",\n        //\t\t\t\t\t  doc);\n        recordElem = doc.createElement(\"record\");\n        generalElem = doc.createElement(\"general\");\n        titleElem = createManifestElementWithLang(\"title\", \"en-US\", \"Dynamically Generated HEAL IMS Content Package\", doc);\n        generalElem.appendChild(titleElem);\n        recordElem.appendChild(generalElem);\n        metadataElem.appendChild(schemaElem);\n        metadataElem.appendChild(schemaversionElem);\n        metadataElem.appendChild(recordElem);\n        return metadataElem;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <elementName>\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     * </elementName>\n     */\n    private static Element createManifestElementWithLang(String elementName, String languageAttr, String textvalue, Document doc) {\n        Element retval = doc.createElement(elementName);\n        retval.appendChild(createManifestLangstring(textvalue, languageAttr, doc));\n        return retval;\n    }\n\n    /**\n     * Creates an Element of the form:\n     * <langstring xml:lang=\"languageAttr\">textvalue</langstring>\n     */\n    private static Element createManifestLangstring(String textvalue, String languageAttr, Document doc) {\n        //Element returnValue = doc.createElement(HealMetadataXMLConverter.IMSNAMESPACETAG+\":langstring\");\n        Element returnValue = doc.createElement(\"langstring\");\n        if (languageAttr != null) {\n            returnValue.setAttribute(\"xml:lang\", languageAttr);\n        }\n        returnValue.appendChild(doc.createTextNode(textvalue));\n        return returnValue;\n    }\n\n    /**\n     * Given an array of metadata beans, creates a manifest file for an IMS\n     * package containing the given metadata and content.  The XML manifest\n     * is then written to the provided output stream.\n     */\n    public static void getManifestIMSXML(CompleteMetadataBean[] metaInfo, FileLocator fileLocator, OutputStream out) throws IOException {\n        try {\n            //create a new Document using JAXP\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.newDocument();\n            Element manifestElem = createManifestElement(metaInfo, fileLocator, doc);\n            manifestElem.setAttribute(\"identifier\", \"MANIFEST1\");\n            manifestElem.setAttribute(\"xmlns:imscp\", \"http://www.imsproject.org/xsd/ims_cp_rootv1p1\");\n            //manifestElem.setAttribute(\"xmlns:\"+HealMetadataXMLConverter.IMSNAMESPACETAG,\n            //\t      \"http://www.imsproject.org/xsd/ims_md_rootv1p1\");\n            manifestElem.setAttribute(\"xmlns\", \"http://www.healcentral.org/xsd/healmd_v1p5\");\n            manifestElem.setAttribute(\"xmlns:xsi\", \"http://www.w3.org/2000/10/XMLSchema-instance\");\n            //manifestElem.setAttribute(\"xsi:schemaLocation\",\"http://www.imsproject.org/xsd/ims_cp_rootv1p1 http://www.imsproject.org/xsd/ims_cp_rootv1p1.xsd http://www.imsproject.org/xsd/ims_md_rootv1p1 http://www.imsproject.org/xsd/ims_md_rootv1p1.xsd\");\n            manifestElem.setAttribute(\"xsi:schemaLocation\", \"http://www.imsproject.org/xsd/ims_cp_rootv1p1 http://www.imsproject.org/xsd/ims_cp_rootv1p1.xsd http://www.healcentral.org/services/schema/HEALmdSchemaXMLv1p5 http://www.healcentral.org/services/schema/HEALmdSchemaXMLv1p5.xsd\");\n            doc.appendChild(manifestElem);\n            //now that we have the document built, we should write it out.\n            TransformerFactory tFactory = TransformerFactory.newInstance();\n            Transformer transformer = tFactory.newTransformer();\n            transformer.transform(new DOMSource(doc), new StreamResult(out));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            throw new IOException(ex.toString());\n        }\n    }\n\n    /**\n     * if bool is true, \"yes\" is returned - otherwise \"no\" is returned\n     */\n    private static String booleanToYesNo(boolean bool) {\n        return (bool ? \"yes\" : \"no\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/HealMetadataXMLConverterTest1.java",
		"test_prompt": "// HealMetadataXMLConverterTest1.java\npackage org.heal.module.metadata;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.heal.util.DateTools;\nimport org.heal.util.FileLocator;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HealMetadataXMLConverter}.\n* It contains ten unit test cases for the {@link HealMetadataXMLConverter#getPointerListXML(ArrayList)} method.\n*/\nclass HealMetadataXMLConverterTest1 {"
	},
	{
		"original_code": "// ThumbnailBean.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class contains information about a thumbnail image for\n * a metadata entry.\n *\n * @author Seth Wright\n * @version 0.1\n */\npublic class ThumbnailBean implements Serializable {\n\n    // Properties\n    private String thumbnailId = null;\n\n    private String metadataId = null;\n\n    private String location = null;\n\n    private String fileWidth = null;\n\n    private String fileHeight = null;\n\n    /**\n     * Returns the thumbnailId property value.\n     */\n    public String getThumbnailId() {\n        return this.thumbnailId;\n    }\n\n    /**\n     * Sets the thumbnail property value.\n     */\n    public void setThumbnailId(String newThumbnailId) {\n        this.thumbnailId = newThumbnailId;\n    }\n\n    /**\n     * Returns the metadataId property value.\n     */\n    public String getMetadataId() {\n        return this.metadataId;\n    }\n\n    /**\n     * Sets the metadata property value.\n     */\n    public void setMetadataId(String newMetadataId) {\n        this.metadataId = newMetadataId;\n    }\n\n    /**\n     * Returns the location property value.\n     */\n    public String getLocation() {\n        return this.location;\n    }\n\n    /**\n     * Sets the location property value.\n     */\n    public void setLocation(String newLocation) {\n        this.location = newLocation;\n    }\n\n    /**\n     * Returns the fileWidth property value.\n     */\n    public String getFileWidth() {\n        return this.fileWidth;\n    }\n\n    /**\n     * Sets the fileWidth property value.\n     */\n    public void setFileWidth(String newFileWidth) {\n        this.fileWidth = newFileWidth;\n    }\n\n    /**\n     * Returns the fileHeight property value.\n     */\n    public String getFileHeight() {\n        return this.fileHeight;\n    }\n\n    /**\n     * Sets the fileHeight property value.\n     */\n    public void setFileHeight(String newFileHeight) {\n        this.fileHeight = newFileHeight;\n    }\n\n    public String toString() {\n        return \"Thumbnail: ThumbnailId:\" + thumbnailId + \" MetadataId:\" + metadataId + \" location:\" + location + \" fileWidth:\" + fileWidth + \" fileHeight:\" + fileHeight;\n    }\n\n    public Object clone() {\n        ThumbnailBean result = new ThumbnailBean();\n        result.thumbnailId = new String(thumbnailId);\n        result.metadataId = new String(metadataId);\n        result.location = new String(location);\n        result.fileWidth = new String(fileWidth);\n        result.fileHeight = new String(fileHeight);\n        return result;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/metadata/ThumbnailBeanTest.java",
		"test_prompt": "// ThumbnailBeanTest.java\npackage org.heal.module.metadata;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ThumbnailBean}.\n* It contains ten unit test cases for the {@link ThumbnailBean#clone()} method.\n*/\nclass ThumbnailBeanTest {"
	},
	{
		"original_code": "// UploadServicesBean.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * @author Seth Wright\n * @version 0.1\n */\npublic class UploadServicesBean implements Serializable {\n\n    public static final int MAX_THUMB_WIDTH = 85;\n\n    public static final int MAX_THUMB_HEIGHT = 85;\n\n    private static final String JPEG_EXTENSION = \".jpg\";\n\n    private static final String THUMB_PREFIX = \"thb_\";\n\n    private FileLocator fileLocator = null;\n\n    public String getUploadPath() {\n        if (fileLocator == null)\n            return null;\n        return fileLocator.getUploadURL();\n    }\n\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Assumes that the metadata property in the CompleteMetadataBean parameter\n     * exists and already has a metadataId set.  (This implies that the\n     * metadata has already been validated and stored in the database at least\n     * once).  This method will then update the metadata's height and width\n     * parameters and generate a thumbnail if it can.  If it cannot generate a\n     * thumbnail, none will be set.  Either way, the database should be\n     * updated with the complete metadata bean after calling this method.\n     * The sourceFilePath is the location on disk of the source image\n     * we are trying to process.  If either parameter or the metadata property\n     * of the complete parameter is null, this method will return false.  Also,\n     * if the location setting in the metadata is null, false will be returned.\n     * If the method successfully determines the width and height of the\n     * image, true is returned.  Otherwise false is returned.  Whether or\n     * not a thumbnail is generated is not a factor in the return value of this\n     * method.\n     */\n    public boolean processImage(CompleteMetadataBean complete, String sourceFilePath) throws IOException {\n        MetadataBean metadata;\n        String sourceLocation;\n        String metadataId;\n        if (complete == null || (metadata = complete.getMetadata()) == null || (sourceLocation = metadata.getLocation()) == null || sourceFilePath == null) {\n            return false;\n        }\n        //metadataId may or may not be null\n        metadataId = metadata.getMetadataId();\n        if (sourceLocation == null) {\n            return false;\n        }\n        try {\n            PlanarImage image = JAI.create(\"fileload\", sourceFilePath);\n            metadata.setFileHeight(\"\" + image.getHeight());\n            metadata.setFileWidth(\"\" + image.getWidth());\n            ThumbnailBean thumbnail = null;\n            try {\n                thumbnail = generateThumbnail(sourceLocation, metadataId, image);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                thumbnail = null;\n            }\n            complete.setThumbnail(thumbnail);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Inner class used to wait for the media players used in\n     * the audio and video processing to realize.\n     */\n    private class RealizeListener implements ControllerListener {\n\n        Object waitSync = new Object();\n\n        boolean stateTransitionOK = true;\n\n        /**\n         * Block until the player has transitioned to the given state.\n         * Return false if the transition failed.\n         */\n        boolean waitForState(int state, Player p) {\n            synchronized (waitSync) {\n                try {\n                    while (p.getState() < state && stateTransitionOK) waitSync.wait();\n                } catch (Exception e) {\n                }\n            }\n            return stateTransitionOK;\n        }\n\n        /**\n         * Controller Listener.\n         */\n        public void controllerUpdate(ControllerEvent evt) {\n            if (evt instanceof ConfigureCompleteEvent || evt instanceof RealizeCompleteEvent || evt instanceof PrefetchCompleteEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = true;\n                    waitSync.notifyAll();\n                }\n            } else if (evt instanceof ResourceUnavailableEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = false;\n                    waitSync.notifyAll();\n                }\n            }\n        }\n    }\n\n    /**\n     * Extracts the width and height of the video media represented by\n     * the player and stores that information in the Metadata bean.\n     * If successful, true is returned, otherwise false is returned.\n     * The player needs to be in the realized state before this method\n     * is called.\n     */\n    private boolean readWidthAndHeight(Player player, MetadataBean metadata) {\n        FramePositioningControl fpc = (FramePositioningControl) player.getControl(\"javax.media.control.FramePositioningControl\");\n        FrameGrabbingControl fgc = (FrameGrabbingControl) player.getControl(\"javax.media.control.FrameGrabbingControl\");\n        if (fpc == null || fgc == null) {\n            System.err.println(\"Unable to get a positioning or grabbing control.\");\n            return false;\n        }\n        fpc.seek(1);\n        Buffer image = fgc.grabFrame();\n        VideoFormat format = (VideoFormat) image.getFormat();\n        if (format != null) {\n            System.err.println(\"Unable to get video format for initial frame of movie.\");\n            Dimension size = format.getSize();\n            metadata.setFileWidth(\"\" + size.width);\n            metadata.setFileHeight(\"\" + size.height);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Takes the video file stored at the given location and\n     * extracts the duration, width, and height of the video\n     * and stores that information in the metadata bean\n     * provided.  If an error occurs, false is returned, otherwise\n     * true is returned.  False will also be returned if either\n     * parameter is null, or the complete metadata bean's metadata bean\n     * is null.\n     */\n    public boolean processVideo(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            if (!readDuration(player, metadata))\n                return false;\n            //we got duration, so we should be able to find a frame\n            return readWidthAndHeight(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Given a source file path, creates a data source/media locator\n     * for that file, creates a new player, and waits for the\n     * player to be realized.  If no errors occur, the created player\n     * (in the realized state), is returned and ready for use.\n     * If an error occurs, null is returned.\n     */\n    private Player getAndRealizePlayer(String sourceFilePath) throws MalformedURLException {\n        if (sourceFilePath == null)\n            return null;\n        File file = new File(sourceFilePath);\n        URL url = file.toURL();\n        MediaLocator ml;\n        Player player;\n        if ((ml = new MediaLocator(url)) == null) {\n            System.err.println(\"Unable to load media file.\");\n            return null;\n        }\n        DataSource ds = null;\n        // Create a DataSource given the media locator.\n        try {\n            ds = Manager.createDataSource(ml);\n        } catch (Exception e) {\n            System.err.println(\"added here1: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n        try {\n            player = Manager.createPlayer(ds);\n        } catch (Exception e) {\n            System.err.println(\"Failed to create a player from the given DataSource: \" + e);\n            return null;\n        }\n        RealizeListener realizeListener = new RealizeListener();\n        player.addControllerListener(realizeListener);\n        player.realize();\n        if (!realizeListener.waitForState(player.Realized, player)) {\n            System.err.println(\"Failed to realize the player.\");\n            return null;\n        }\n        return player;\n    }\n\n    /**\n     * Given a source file path, this method\n     * gleans the duration (in milliseconds) of the audio.\n     * This information is then stored in the Duration field\n     * of the MetadataBean contained within the passed in\n     * CompleteMetadataBean.  If either of the parameters is null\n     * then false is returned.\n     * If the duration is successfully acquired, true is returned.\n     * Otherwise, false is returned.\n     */\n    public boolean processAudio(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            return readDuration(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Gets the duration of the media loaded by the Player and\n     * stores that information (in milliseconds) in the metadata\n     * bean's duration field.\n     * The player must be in the realized state for this to work\n     * correctly, and the metadata must not be null.  If an error occurs,\n     * false is returned.  Otherwise true is returned, meaning that\n     * the duration was successfully stored in the metadata bean.\n     */\n    private boolean readDuration(Player player, MetadataBean metadata) {\n        if (player == null || metadata == null)\n            return false;\n        Time t = player.getDuration();\n        if (t != Duration.DURATION_UNKNOWN) {\n            int milliseconds = (int) (t.getSeconds() * 1000);\n            metadata.setDuration(\"\" + milliseconds);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Given the path to an image file, opens that image and dynamically\n     * generates a thumbnail scaled to fit within the specified dimensions.\n     * The scaling means that the thumbnail's height will be no greater than\n     * the maxHeight parameter and the thumbnail's width will be no greater\n     * than the maxWidth parameter.  The unit of measurement for both\n     * maxWidth and maxHeight are pixels.\n     * It is important that the provided CompleteMetadataBean already have\n     * a MetadataBean set with a metadataId assigned.  If not, the\n     * ThumbnailBean generated will not contain a metadataId setting and\n     * the caller is responsible for setting it.\n     * KNOWN PROBLEM: DUE TO A BUG IN THE JAVA ADVANCED IMAGING GIF DECODER\n     * GIFS WITH TRANSPARENT BACKGROUNDS MAY NOT BE READ PROPERLY.\n     */\n    public ThumbnailBean generateThumbnail(String sourceLocation, String metadataId, PlanarImage image) throws IOException {\n        ThumbnailBean thumbnail = null;\n        if (sourceLocation == null) {\n            //failed because there was no metadata bean\n            return null;\n        }\n        String thumbLocation = getThumbnailLocationFromSource(sourceLocation, THUMB_PREFIX, JPEG_EXTENSION);\n        String thumbFilePath = fileLocator.getThumbnailFilePath(thumbLocation);\n        if (thumbFilePath != null) {\n            File thumbFile = new File(thumbFilePath);\n            File parentDir = thumbFile.getParentFile();\n            if (!parentDir.exists()) {\n                parentDir.mkdirs();\n            }\n        }\n        ParameterBlock parameters = getThumbnailParameterBlock(image);\n        PlanarImage thumb = JAI.create(\"scale\", parameters, null);\n        thumbnail = new ThumbnailBean();\n        thumbnail.setFileWidth(\"\" + thumb.getWidth());\n        thumbnail.setFileHeight(\"\" + thumb.getHeight());\n        thumbnail.setLocation(thumbLocation);\n        thumbnail.setMetadataId(metadataId);\n        //This is a workaround for a bug in the jpeg encoder, to read more\n        //about the bug, see:\n        //http://www.sun.com/software/imaging/JAI/11/bugs_codec.html\n        ParameterBlock pb = new ParameterBlock();\n        pb.addSource(thumb);\n        pb.add(DataBuffer.TYPE_BYTE);\n        PlanarImage thumbByte = JAI.create(\"format\", pb);\n        FileOutputStream dst = null;\n        try {\n            dst = new FileOutputStream(thumbFilePath);\n            ImageEncoder enc = ImageCodec.createImageEncoder(\"JPEG\", dst, null);\n            enc.encode(thumbByte);\n        } finally {\n            try {\n                if (dst != null) {\n                    dst.close();\n                }\n            } catch (Exception ex) {\n                //ignore for now, we just want the stream closed.\n            }\n        }\n        return thumbnail;\n    }\n\n    /**\n     * Given a location for a content file (e.g. /seth/images/brain.gif)\n     * This method will return a string indicating the thumbnail\n     * location to use (e.g. /seth/images/thb_brain.jpg).  Please note\n     * that this method assumes that all thumbnails will be jpgs.\n     */\n    private String getThumbnailLocationFromSource(String sourceLocation, String thumbPrefix, String thumbSuffix) {\n        int index = sourceLocation.lastIndexOf('/');\n        String prefix;\n        String tempname;\n        String finalname;\n        if (index == -1) {\n            prefix = \"\";\n            tempname = sourceLocation;\n        } else {\n            prefix = sourceLocation.substring(0, index + 1);\n            tempname = sourceLocation.substring(index + 1);\n        }\n        int extensionIndex = tempname.lastIndexOf('.');\n        if (extensionIndex == -1) {\n            finalname = thumbPrefix + tempname + thumbSuffix;\n        } else {\n            finalname = thumbPrefix + tempname.substring(0, extensionIndex) + thumbSuffix;\n        }\n        return prefix + finalname;\n    }\n\n    /**\n     * This method determines sets up the parameter block for the\n     * scaling function used to create the thumbnail.  Given an\n     * image, it calculates the scaling required to gain the desired\n     * size of thumbnail.\n     * Okay, so we're trying to constrain the thumbnail image as such:\n     * We want the maximum dimension of either height or width to\n     * be MAX_THUMB_HEIGHT or MAX_THUMB_WIDTH.  So, we figure out the\n     * float to multiply the image height by in order to make it fit within\n     * the specified maximum.  We do the same with the width parameter.\n     * The equation for this is: 1/(dimension/max) = max/dimension\n     * This will give us a scalar that is less than one (e.g. 0.5), or if\n     * the dimension is already less than the maximum, we set the\n     * dimension's scalar to 1.0F.\n     * Then, once we have determined the scalar for each, we take the\n     * smaller of the two because that is the dimension that requires the\n     * most scaling to be brought within it's max dimension.\n     */\n    private ParameterBlock getThumbnailParameterBlock(PlanarImage image) {\n        ParameterBlock parameters = new ParameterBlock();\n        int height = image.getHeight();\n        int width = image.getWidth();\n        float heightscalar;\n        float widthscalar;\n        if (height > MAX_THUMB_HEIGHT) {\n            heightscalar = ((float) MAX_THUMB_HEIGHT) / ((float) height);\n        } else {\n            //no scaling involved\n            heightscalar = 1.0F;\n        }\n        if (width > MAX_THUMB_WIDTH) {\n            widthscalar = ((float) MAX_THUMB_WIDTH) / ((float) width);\n        } else {\n            //no scaling involved\n            widthscalar = 1.0F;\n        }\n        float scalar = (widthscalar < heightscalar ? widthscalar : heightscalar);\n        parameters.addSource(image);\n        //x scalar\n        parameters.add(scalar);\n        //y scalar\n        parameters.add(scalar);\n        parameters.add(0.0F);\n        parameters.add(0.0F);\n        //these offer different algorithms for doing the scaling.\n        Interpolation interp;\n        interp = Interpolation.getInstance(Interpolation.INTERP_NEAREST);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BILINEAR);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BICUBIC);\n        parameters.add(interp);\n        return parameters;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/upload/UploadServicesBeanTest0.java",
		"test_prompt": "// UploadServicesBeanTest0.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UploadServicesBean}.\n* It contains ten unit test cases for the {@link UploadServicesBean#processImage(CompleteMetadataBean, String)} method.\n*/\nclass UploadServicesBeanTest0 {"
	},
	{
		"original_code": "// UploadServicesBean.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * @author Seth Wright\n * @version 0.1\n */\npublic class UploadServicesBean implements Serializable {\n\n    public static final int MAX_THUMB_WIDTH = 85;\n\n    public static final int MAX_THUMB_HEIGHT = 85;\n\n    private static final String JPEG_EXTENSION = \".jpg\";\n\n    private static final String THUMB_PREFIX = \"thb_\";\n\n    private FileLocator fileLocator = null;\n\n    public String getUploadPath() {\n        if (fileLocator == null)\n            return null;\n        return fileLocator.getUploadURL();\n    }\n\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Assumes that the metadata property in the CompleteMetadataBean parameter\n     * exists and already has a metadataId set.  (This implies that the\n     * metadata has already been validated and stored in the database at least\n     * once).  This method will then update the metadata's height and width\n     * parameters and generate a thumbnail if it can.  If it cannot generate a\n     * thumbnail, none will be set.  Either way, the database should be\n     * updated with the complete metadata bean after calling this method.\n     * The sourceFilePath is the location on disk of the source image\n     * we are trying to process.  If either parameter or the metadata property\n     * of the complete parameter is null, this method will return false.  Also,\n     * if the location setting in the metadata is null, false will be returned.\n     * If the method successfully determines the width and height of the\n     * image, true is returned.  Otherwise false is returned.  Whether or\n     * not a thumbnail is generated is not a factor in the return value of this\n     * method.\n     */\n    public boolean processImage(CompleteMetadataBean complete, String sourceFilePath) throws IOException {\n        MetadataBean metadata;\n        String sourceLocation;\n        String metadataId;\n        if (complete == null || (metadata = complete.getMetadata()) == null || (sourceLocation = metadata.getLocation()) == null || sourceFilePath == null) {\n            return false;\n        }\n        //metadataId may or may not be null\n        metadataId = metadata.getMetadataId();\n        if (sourceLocation == null) {\n            return false;\n        }\n        try {\n            PlanarImage image = JAI.create(\"fileload\", sourceFilePath);\n            metadata.setFileHeight(\"\" + image.getHeight());\n            metadata.setFileWidth(\"\" + image.getWidth());\n            ThumbnailBean thumbnail = null;\n            try {\n                thumbnail = generateThumbnail(sourceLocation, metadataId, image);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                thumbnail = null;\n            }\n            complete.setThumbnail(thumbnail);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Inner class used to wait for the media players used in\n     * the audio and video processing to realize.\n     */\n    private class RealizeListener implements ControllerListener {\n\n        Object waitSync = new Object();\n\n        boolean stateTransitionOK = true;\n\n        /**\n         * Block until the player has transitioned to the given state.\n         * Return false if the transition failed.\n         */\n        boolean waitForState(int state, Player p) {\n            synchronized (waitSync) {\n                try {\n                    while (p.getState() < state && stateTransitionOK) waitSync.wait();\n                } catch (Exception e) {\n                }\n            }\n            return stateTransitionOK;\n        }\n\n        /**\n         * Controller Listener.\n         */\n        public void controllerUpdate(ControllerEvent evt) {\n            if (evt instanceof ConfigureCompleteEvent || evt instanceof RealizeCompleteEvent || evt instanceof PrefetchCompleteEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = true;\n                    waitSync.notifyAll();\n                }\n            } else if (evt instanceof ResourceUnavailableEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = false;\n                    waitSync.notifyAll();\n                }\n            }\n        }\n    }\n\n    /**\n     * Extracts the width and height of the video media represented by\n     * the player and stores that information in the Metadata bean.\n     * If successful, true is returned, otherwise false is returned.\n     * The player needs to be in the realized state before this method\n     * is called.\n     */\n    private boolean readWidthAndHeight(Player player, MetadataBean metadata) {\n        FramePositioningControl fpc = (FramePositioningControl) player.getControl(\"javax.media.control.FramePositioningControl\");\n        FrameGrabbingControl fgc = (FrameGrabbingControl) player.getControl(\"javax.media.control.FrameGrabbingControl\");\n        if (fpc == null || fgc == null) {\n            System.err.println(\"Unable to get a positioning or grabbing control.\");\n            return false;\n        }\n        fpc.seek(1);\n        Buffer image = fgc.grabFrame();\n        VideoFormat format = (VideoFormat) image.getFormat();\n        if (format != null) {\n            System.err.println(\"Unable to get video format for initial frame of movie.\");\n            Dimension size = format.getSize();\n            metadata.setFileWidth(\"\" + size.width);\n            metadata.setFileHeight(\"\" + size.height);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Takes the video file stored at the given location and\n     * extracts the duration, width, and height of the video\n     * and stores that information in the metadata bean\n     * provided.  If an error occurs, false is returned, otherwise\n     * true is returned.  False will also be returned if either\n     * parameter is null, or the complete metadata bean's metadata bean\n     * is null.\n     */\n    public boolean processVideo(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            if (!readDuration(player, metadata))\n                return false;\n            //we got duration, so we should be able to find a frame\n            return readWidthAndHeight(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Given a source file path, creates a data source/media locator\n     * for that file, creates a new player, and waits for the\n     * player to be realized.  If no errors occur, the created player\n     * (in the realized state), is returned and ready for use.\n     * If an error occurs, null is returned.\n     */\n    private Player getAndRealizePlayer(String sourceFilePath) throws MalformedURLException {\n        if (sourceFilePath == null)\n            return null;\n        File file = new File(sourceFilePath);\n        URL url = file.toURL();\n        MediaLocator ml;\n        Player player;\n        if ((ml = new MediaLocator(url)) == null) {\n            System.err.println(\"Unable to load media file.\");\n            return null;\n        }\n        DataSource ds = null;\n        // Create a DataSource given the media locator.\n        try {\n            ds = Manager.createDataSource(ml);\n        } catch (Exception e) {\n            System.err.println(\"added here1: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n        try {\n            player = Manager.createPlayer(ds);\n        } catch (Exception e) {\n            System.err.println(\"Failed to create a player from the given DataSource: \" + e);\n            return null;\n        }\n        RealizeListener realizeListener = new RealizeListener();\n        player.addControllerListener(realizeListener);\n        player.realize();\n        if (!realizeListener.waitForState(player.Realized, player)) {\n            System.err.println(\"Failed to realize the player.\");\n            return null;\n        }\n        return player;\n    }\n\n    /**\n     * Given a source file path, this method\n     * gleans the duration (in milliseconds) of the audio.\n     * This information is then stored in the Duration field\n     * of the MetadataBean contained within the passed in\n     * CompleteMetadataBean.  If either of the parameters is null\n     * then false is returned.\n     * If the duration is successfully acquired, true is returned.\n     * Otherwise, false is returned.\n     */\n    public boolean processAudio(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            return readDuration(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Gets the duration of the media loaded by the Player and\n     * stores that information (in milliseconds) in the metadata\n     * bean's duration field.\n     * The player must be in the realized state for this to work\n     * correctly, and the metadata must not be null.  If an error occurs,\n     * false is returned.  Otherwise true is returned, meaning that\n     * the duration was successfully stored in the metadata bean.\n     */\n    private boolean readDuration(Player player, MetadataBean metadata) {\n        if (player == null || metadata == null)\n            return false;\n        Time t = player.getDuration();\n        if (t != Duration.DURATION_UNKNOWN) {\n            int milliseconds = (int) (t.getSeconds() * 1000);\n            metadata.setDuration(\"\" + milliseconds);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Given the path to an image file, opens that image and dynamically\n     * generates a thumbnail scaled to fit within the specified dimensions.\n     * The scaling means that the thumbnail's height will be no greater than\n     * the maxHeight parameter and the thumbnail's width will be no greater\n     * than the maxWidth parameter.  The unit of measurement for both\n     * maxWidth and maxHeight are pixels.\n     * It is important that the provided CompleteMetadataBean already have\n     * a MetadataBean set with a metadataId assigned.  If not, the\n     * ThumbnailBean generated will not contain a metadataId setting and\n     * the caller is responsible for setting it.\n     * KNOWN PROBLEM: DUE TO A BUG IN THE JAVA ADVANCED IMAGING GIF DECODER\n     * GIFS WITH TRANSPARENT BACKGROUNDS MAY NOT BE READ PROPERLY.\n     */\n    public ThumbnailBean generateThumbnail(String sourceLocation, String metadataId, PlanarImage image) throws IOException {\n        ThumbnailBean thumbnail = null;\n        if (sourceLocation == null) {\n            //failed because there was no metadata bean\n            return null;\n        }\n        String thumbLocation = getThumbnailLocationFromSource(sourceLocation, THUMB_PREFIX, JPEG_EXTENSION);\n        String thumbFilePath = fileLocator.getThumbnailFilePath(thumbLocation);\n        if (thumbFilePath != null) {\n            File thumbFile = new File(thumbFilePath);\n            File parentDir = thumbFile.getParentFile();\n            if (!parentDir.exists()) {\n                parentDir.mkdirs();\n            }\n        }\n        ParameterBlock parameters = getThumbnailParameterBlock(image);\n        PlanarImage thumb = JAI.create(\"scale\", parameters, null);\n        thumbnail = new ThumbnailBean();\n        thumbnail.setFileWidth(\"\" + thumb.getWidth());\n        thumbnail.setFileHeight(\"\" + thumb.getHeight());\n        thumbnail.setLocation(thumbLocation);\n        thumbnail.setMetadataId(metadataId);\n        //This is a workaround for a bug in the jpeg encoder, to read more\n        //about the bug, see:\n        //http://www.sun.com/software/imaging/JAI/11/bugs_codec.html\n        ParameterBlock pb = new ParameterBlock();\n        pb.addSource(thumb);\n        pb.add(DataBuffer.TYPE_BYTE);\n        PlanarImage thumbByte = JAI.create(\"format\", pb);\n        FileOutputStream dst = null;\n        try {\n            dst = new FileOutputStream(thumbFilePath);\n            ImageEncoder enc = ImageCodec.createImageEncoder(\"JPEG\", dst, null);\n            enc.encode(thumbByte);\n        } finally {\n            try {\n                if (dst != null) {\n                    dst.close();\n                }\n            } catch (Exception ex) {\n                //ignore for now, we just want the stream closed.\n            }\n        }\n        return thumbnail;\n    }\n\n    /**\n     * Given a location for a content file (e.g. /seth/images/brain.gif)\n     * This method will return a string indicating the thumbnail\n     * location to use (e.g. /seth/images/thb_brain.jpg).  Please note\n     * that this method assumes that all thumbnails will be jpgs.\n     */\n    private String getThumbnailLocationFromSource(String sourceLocation, String thumbPrefix, String thumbSuffix) {\n        int index = sourceLocation.lastIndexOf('/');\n        String prefix;\n        String tempname;\n        String finalname;\n        if (index == -1) {\n            prefix = \"\";\n            tempname = sourceLocation;\n        } else {\n            prefix = sourceLocation.substring(0, index + 1);\n            tempname = sourceLocation.substring(index + 1);\n        }\n        int extensionIndex = tempname.lastIndexOf('.');\n        if (extensionIndex == -1) {\n            finalname = thumbPrefix + tempname + thumbSuffix;\n        } else {\n            finalname = thumbPrefix + tempname.substring(0, extensionIndex) + thumbSuffix;\n        }\n        return prefix + finalname;\n    }\n\n    /**\n     * This method determines sets up the parameter block for the\n     * scaling function used to create the thumbnail.  Given an\n     * image, it calculates the scaling required to gain the desired\n     * size of thumbnail.\n     * Okay, so we're trying to constrain the thumbnail image as such:\n     * We want the maximum dimension of either height or width to\n     * be MAX_THUMB_HEIGHT or MAX_THUMB_WIDTH.  So, we figure out the\n     * float to multiply the image height by in order to make it fit within\n     * the specified maximum.  We do the same with the width parameter.\n     * The equation for this is: 1/(dimension/max) = max/dimension\n     * This will give us a scalar that is less than one (e.g. 0.5), or if\n     * the dimension is already less than the maximum, we set the\n     * dimension's scalar to 1.0F.\n     * Then, once we have determined the scalar for each, we take the\n     * smaller of the two because that is the dimension that requires the\n     * most scaling to be brought within it's max dimension.\n     */\n    private ParameterBlock getThumbnailParameterBlock(PlanarImage image) {\n        ParameterBlock parameters = new ParameterBlock();\n        int height = image.getHeight();\n        int width = image.getWidth();\n        float heightscalar;\n        float widthscalar;\n        if (height > MAX_THUMB_HEIGHT) {\n            heightscalar = ((float) MAX_THUMB_HEIGHT) / ((float) height);\n        } else {\n            //no scaling involved\n            heightscalar = 1.0F;\n        }\n        if (width > MAX_THUMB_WIDTH) {\n            widthscalar = ((float) MAX_THUMB_WIDTH) / ((float) width);\n        } else {\n            //no scaling involved\n            widthscalar = 1.0F;\n        }\n        float scalar = (widthscalar < heightscalar ? widthscalar : heightscalar);\n        parameters.addSource(image);\n        //x scalar\n        parameters.add(scalar);\n        //y scalar\n        parameters.add(scalar);\n        parameters.add(0.0F);\n        parameters.add(0.0F);\n        //these offer different algorithms for doing the scaling.\n        Interpolation interp;\n        interp = Interpolation.getInstance(Interpolation.INTERP_NEAREST);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BILINEAR);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BICUBIC);\n        parameters.add(interp);\n        return parameters;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/upload/UploadServicesBeanTest1.java",
		"test_prompt": "// UploadServicesBeanTest1.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UploadServicesBean}.\n* It contains ten unit test cases for the {@link UploadServicesBean#processVideo(CompleteMetadataBean, String)} method.\n*/\nclass UploadServicesBeanTest1 {"
	},
	{
		"original_code": "// UploadServicesBean.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * @author Seth Wright\n * @version 0.1\n */\npublic class UploadServicesBean implements Serializable {\n\n    public static final int MAX_THUMB_WIDTH = 85;\n\n    public static final int MAX_THUMB_HEIGHT = 85;\n\n    private static final String JPEG_EXTENSION = \".jpg\";\n\n    private static final String THUMB_PREFIX = \"thb_\";\n\n    private FileLocator fileLocator = null;\n\n    public String getUploadPath() {\n        if (fileLocator == null)\n            return null;\n        return fileLocator.getUploadURL();\n    }\n\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Assumes that the metadata property in the CompleteMetadataBean parameter\n     * exists and already has a metadataId set.  (This implies that the\n     * metadata has already been validated and stored in the database at least\n     * once).  This method will then update the metadata's height and width\n     * parameters and generate a thumbnail if it can.  If it cannot generate a\n     * thumbnail, none will be set.  Either way, the database should be\n     * updated with the complete metadata bean after calling this method.\n     * The sourceFilePath is the location on disk of the source image\n     * we are trying to process.  If either parameter or the metadata property\n     * of the complete parameter is null, this method will return false.  Also,\n     * if the location setting in the metadata is null, false will be returned.\n     * If the method successfully determines the width and height of the\n     * image, true is returned.  Otherwise false is returned.  Whether or\n     * not a thumbnail is generated is not a factor in the return value of this\n     * method.\n     */\n    public boolean processImage(CompleteMetadataBean complete, String sourceFilePath) throws IOException {\n        MetadataBean metadata;\n        String sourceLocation;\n        String metadataId;\n        if (complete == null || (metadata = complete.getMetadata()) == null || (sourceLocation = metadata.getLocation()) == null || sourceFilePath == null) {\n            return false;\n        }\n        //metadataId may or may not be null\n        metadataId = metadata.getMetadataId();\n        if (sourceLocation == null) {\n            return false;\n        }\n        try {\n            PlanarImage image = JAI.create(\"fileload\", sourceFilePath);\n            metadata.setFileHeight(\"\" + image.getHeight());\n            metadata.setFileWidth(\"\" + image.getWidth());\n            ThumbnailBean thumbnail = null;\n            try {\n                thumbnail = generateThumbnail(sourceLocation, metadataId, image);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                thumbnail = null;\n            }\n            complete.setThumbnail(thumbnail);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Inner class used to wait for the media players used in\n     * the audio and video processing to realize.\n     */\n    private class RealizeListener implements ControllerListener {\n\n        Object waitSync = new Object();\n\n        boolean stateTransitionOK = true;\n\n        /**\n         * Block until the player has transitioned to the given state.\n         * Return false if the transition failed.\n         */\n        boolean waitForState(int state, Player p) {\n            synchronized (waitSync) {\n                try {\n                    while (p.getState() < state && stateTransitionOK) waitSync.wait();\n                } catch (Exception e) {\n                }\n            }\n            return stateTransitionOK;\n        }\n\n        /**\n         * Controller Listener.\n         */\n        public void controllerUpdate(ControllerEvent evt) {\n            if (evt instanceof ConfigureCompleteEvent || evt instanceof RealizeCompleteEvent || evt instanceof PrefetchCompleteEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = true;\n                    waitSync.notifyAll();\n                }\n            } else if (evt instanceof ResourceUnavailableEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = false;\n                    waitSync.notifyAll();\n                }\n            }\n        }\n    }\n\n    /**\n     * Extracts the width and height of the video media represented by\n     * the player and stores that information in the Metadata bean.\n     * If successful, true is returned, otherwise false is returned.\n     * The player needs to be in the realized state before this method\n     * is called.\n     */\n    private boolean readWidthAndHeight(Player player, MetadataBean metadata) {\n        FramePositioningControl fpc = (FramePositioningControl) player.getControl(\"javax.media.control.FramePositioningControl\");\n        FrameGrabbingControl fgc = (FrameGrabbingControl) player.getControl(\"javax.media.control.FrameGrabbingControl\");\n        if (fpc == null || fgc == null) {\n            System.err.println(\"Unable to get a positioning or grabbing control.\");\n            return false;\n        }\n        fpc.seek(1);\n        Buffer image = fgc.grabFrame();\n        VideoFormat format = (VideoFormat) image.getFormat();\n        if (format != null) {\n            System.err.println(\"Unable to get video format for initial frame of movie.\");\n            Dimension size = format.getSize();\n            metadata.setFileWidth(\"\" + size.width);\n            metadata.setFileHeight(\"\" + size.height);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Takes the video file stored at the given location and\n     * extracts the duration, width, and height of the video\n     * and stores that information in the metadata bean\n     * provided.  If an error occurs, false is returned, otherwise\n     * true is returned.  False will also be returned if either\n     * parameter is null, or the complete metadata bean's metadata bean\n     * is null.\n     */\n    public boolean processVideo(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            if (!readDuration(player, metadata))\n                return false;\n            //we got duration, so we should be able to find a frame\n            return readWidthAndHeight(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Given a source file path, creates a data source/media locator\n     * for that file, creates a new player, and waits for the\n     * player to be realized.  If no errors occur, the created player\n     * (in the realized state), is returned and ready for use.\n     * If an error occurs, null is returned.\n     */\n    private Player getAndRealizePlayer(String sourceFilePath) throws MalformedURLException {\n        if (sourceFilePath == null)\n            return null;\n        File file = new File(sourceFilePath);\n        URL url = file.toURL();\n        MediaLocator ml;\n        Player player;\n        if ((ml = new MediaLocator(url)) == null) {\n            System.err.println(\"Unable to load media file.\");\n            return null;\n        }\n        DataSource ds = null;\n        // Create a DataSource given the media locator.\n        try {\n            ds = Manager.createDataSource(ml);\n        } catch (Exception e) {\n            System.err.println(\"added here1: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n        try {\n            player = Manager.createPlayer(ds);\n        } catch (Exception e) {\n            System.err.println(\"Failed to create a player from the given DataSource: \" + e);\n            return null;\n        }\n        RealizeListener realizeListener = new RealizeListener();\n        player.addControllerListener(realizeListener);\n        player.realize();\n        if (!realizeListener.waitForState(player.Realized, player)) {\n            System.err.println(\"Failed to realize the player.\");\n            return null;\n        }\n        return player;\n    }\n\n    /**\n     * Given a source file path, this method\n     * gleans the duration (in milliseconds) of the audio.\n     * This information is then stored in the Duration field\n     * of the MetadataBean contained within the passed in\n     * CompleteMetadataBean.  If either of the parameters is null\n     * then false is returned.\n     * If the duration is successfully acquired, true is returned.\n     * Otherwise, false is returned.\n     */\n    public boolean processAudio(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            return readDuration(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Gets the duration of the media loaded by the Player and\n     * stores that information (in milliseconds) in the metadata\n     * bean's duration field.\n     * The player must be in the realized state for this to work\n     * correctly, and the metadata must not be null.  If an error occurs,\n     * false is returned.  Otherwise true is returned, meaning that\n     * the duration was successfully stored in the metadata bean.\n     */\n    private boolean readDuration(Player player, MetadataBean metadata) {\n        if (player == null || metadata == null)\n            return false;\n        Time t = player.getDuration();\n        if (t != Duration.DURATION_UNKNOWN) {\n            int milliseconds = (int) (t.getSeconds() * 1000);\n            metadata.setDuration(\"\" + milliseconds);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Given the path to an image file, opens that image and dynamically\n     * generates a thumbnail scaled to fit within the specified dimensions.\n     * The scaling means that the thumbnail's height will be no greater than\n     * the maxHeight parameter and the thumbnail's width will be no greater\n     * than the maxWidth parameter.  The unit of measurement for both\n     * maxWidth and maxHeight are pixels.\n     * It is important that the provided CompleteMetadataBean already have\n     * a MetadataBean set with a metadataId assigned.  If not, the\n     * ThumbnailBean generated will not contain a metadataId setting and\n     * the caller is responsible for setting it.\n     * KNOWN PROBLEM: DUE TO A BUG IN THE JAVA ADVANCED IMAGING GIF DECODER\n     * GIFS WITH TRANSPARENT BACKGROUNDS MAY NOT BE READ PROPERLY.\n     */\n    public ThumbnailBean generateThumbnail(String sourceLocation, String metadataId, PlanarImage image) throws IOException {\n        ThumbnailBean thumbnail = null;\n        if (sourceLocation == null) {\n            //failed because there was no metadata bean\n            return null;\n        }\n        String thumbLocation = getThumbnailLocationFromSource(sourceLocation, THUMB_PREFIX, JPEG_EXTENSION);\n        String thumbFilePath = fileLocator.getThumbnailFilePath(thumbLocation);\n        if (thumbFilePath != null) {\n            File thumbFile = new File(thumbFilePath);\n            File parentDir = thumbFile.getParentFile();\n            if (!parentDir.exists()) {\n                parentDir.mkdirs();\n            }\n        }\n        ParameterBlock parameters = getThumbnailParameterBlock(image);\n        PlanarImage thumb = JAI.create(\"scale\", parameters, null);\n        thumbnail = new ThumbnailBean();\n        thumbnail.setFileWidth(\"\" + thumb.getWidth());\n        thumbnail.setFileHeight(\"\" + thumb.getHeight());\n        thumbnail.setLocation(thumbLocation);\n        thumbnail.setMetadataId(metadataId);\n        //This is a workaround for a bug in the jpeg encoder, to read more\n        //about the bug, see:\n        //http://www.sun.com/software/imaging/JAI/11/bugs_codec.html\n        ParameterBlock pb = new ParameterBlock();\n        pb.addSource(thumb);\n        pb.add(DataBuffer.TYPE_BYTE);\n        PlanarImage thumbByte = JAI.create(\"format\", pb);\n        FileOutputStream dst = null;\n        try {\n            dst = new FileOutputStream(thumbFilePath);\n            ImageEncoder enc = ImageCodec.createImageEncoder(\"JPEG\", dst, null);\n            enc.encode(thumbByte);\n        } finally {\n            try {\n                if (dst != null) {\n                    dst.close();\n                }\n            } catch (Exception ex) {\n                //ignore for now, we just want the stream closed.\n            }\n        }\n        return thumbnail;\n    }\n\n    /**\n     * Given a location for a content file (e.g. /seth/images/brain.gif)\n     * This method will return a string indicating the thumbnail\n     * location to use (e.g. /seth/images/thb_brain.jpg).  Please note\n     * that this method assumes that all thumbnails will be jpgs.\n     */\n    private String getThumbnailLocationFromSource(String sourceLocation, String thumbPrefix, String thumbSuffix) {\n        int index = sourceLocation.lastIndexOf('/');\n        String prefix;\n        String tempname;\n        String finalname;\n        if (index == -1) {\n            prefix = \"\";\n            tempname = sourceLocation;\n        } else {\n            prefix = sourceLocation.substring(0, index + 1);\n            tempname = sourceLocation.substring(index + 1);\n        }\n        int extensionIndex = tempname.lastIndexOf('.');\n        if (extensionIndex == -1) {\n            finalname = thumbPrefix + tempname + thumbSuffix;\n        } else {\n            finalname = thumbPrefix + tempname.substring(0, extensionIndex) + thumbSuffix;\n        }\n        return prefix + finalname;\n    }\n\n    /**\n     * This method determines sets up the parameter block for the\n     * scaling function used to create the thumbnail.  Given an\n     * image, it calculates the scaling required to gain the desired\n     * size of thumbnail.\n     * Okay, so we're trying to constrain the thumbnail image as such:\n     * We want the maximum dimension of either height or width to\n     * be MAX_THUMB_HEIGHT or MAX_THUMB_WIDTH.  So, we figure out the\n     * float to multiply the image height by in order to make it fit within\n     * the specified maximum.  We do the same with the width parameter.\n     * The equation for this is: 1/(dimension/max) = max/dimension\n     * This will give us a scalar that is less than one (e.g. 0.5), or if\n     * the dimension is already less than the maximum, we set the\n     * dimension's scalar to 1.0F.\n     * Then, once we have determined the scalar for each, we take the\n     * smaller of the two because that is the dimension that requires the\n     * most scaling to be brought within it's max dimension.\n     */\n    private ParameterBlock getThumbnailParameterBlock(PlanarImage image) {\n        ParameterBlock parameters = new ParameterBlock();\n        int height = image.getHeight();\n        int width = image.getWidth();\n        float heightscalar;\n        float widthscalar;\n        if (height > MAX_THUMB_HEIGHT) {\n            heightscalar = ((float) MAX_THUMB_HEIGHT) / ((float) height);\n        } else {\n            //no scaling involved\n            heightscalar = 1.0F;\n        }\n        if (width > MAX_THUMB_WIDTH) {\n            widthscalar = ((float) MAX_THUMB_WIDTH) / ((float) width);\n        } else {\n            //no scaling involved\n            widthscalar = 1.0F;\n        }\n        float scalar = (widthscalar < heightscalar ? widthscalar : heightscalar);\n        parameters.addSource(image);\n        //x scalar\n        parameters.add(scalar);\n        //y scalar\n        parameters.add(scalar);\n        parameters.add(0.0F);\n        parameters.add(0.0F);\n        //these offer different algorithms for doing the scaling.\n        Interpolation interp;\n        interp = Interpolation.getInstance(Interpolation.INTERP_NEAREST);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BILINEAR);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BICUBIC);\n        parameters.add(interp);\n        return parameters;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/upload/UploadServicesBeanTest2.java",
		"test_prompt": "// UploadServicesBeanTest2.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UploadServicesBean}.\n* It contains ten unit test cases for the {@link UploadServicesBean#processAudio(CompleteMetadataBean, String)} method.\n*/\nclass UploadServicesBeanTest2 {"
	},
	{
		"original_code": "// UploadServicesBean.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * @author Seth Wright\n * @version 0.1\n */\npublic class UploadServicesBean implements Serializable {\n\n    public static final int MAX_THUMB_WIDTH = 85;\n\n    public static final int MAX_THUMB_HEIGHT = 85;\n\n    private static final String JPEG_EXTENSION = \".jpg\";\n\n    private static final String THUMB_PREFIX = \"thb_\";\n\n    private FileLocator fileLocator = null;\n\n    public String getUploadPath() {\n        if (fileLocator == null)\n            return null;\n        return fileLocator.getUploadURL();\n    }\n\n    public void setFileLocator(FileLocator newFileLocator) {\n        fileLocator = newFileLocator;\n    }\n\n    public FileLocator getFileLocator() {\n        return fileLocator;\n    }\n\n    /**\n     * Assumes that the metadata property in the CompleteMetadataBean parameter\n     * exists and already has a metadataId set.  (This implies that the\n     * metadata has already been validated and stored in the database at least\n     * once).  This method will then update the metadata's height and width\n     * parameters and generate a thumbnail if it can.  If it cannot generate a\n     * thumbnail, none will be set.  Either way, the database should be\n     * updated with the complete metadata bean after calling this method.\n     * The sourceFilePath is the location on disk of the source image\n     * we are trying to process.  If either parameter or the metadata property\n     * of the complete parameter is null, this method will return false.  Also,\n     * if the location setting in the metadata is null, false will be returned.\n     * If the method successfully determines the width and height of the\n     * image, true is returned.  Otherwise false is returned.  Whether or\n     * not a thumbnail is generated is not a factor in the return value of this\n     * method.\n     */\n    public boolean processImage(CompleteMetadataBean complete, String sourceFilePath) throws IOException {\n        MetadataBean metadata;\n        String sourceLocation;\n        String metadataId;\n        if (complete == null || (metadata = complete.getMetadata()) == null || (sourceLocation = metadata.getLocation()) == null || sourceFilePath == null) {\n            return false;\n        }\n        //metadataId may or may not be null\n        metadataId = metadata.getMetadataId();\n        if (sourceLocation == null) {\n            return false;\n        }\n        try {\n            PlanarImage image = JAI.create(\"fileload\", sourceFilePath);\n            metadata.setFileHeight(\"\" + image.getHeight());\n            metadata.setFileWidth(\"\" + image.getWidth());\n            ThumbnailBean thumbnail = null;\n            try {\n                thumbnail = generateThumbnail(sourceLocation, metadataId, image);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                thumbnail = null;\n            }\n            complete.setThumbnail(thumbnail);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Inner class used to wait for the media players used in\n     * the audio and video processing to realize.\n     */\n    private class RealizeListener implements ControllerListener {\n\n        Object waitSync = new Object();\n\n        boolean stateTransitionOK = true;\n\n        /**\n         * Block until the player has transitioned to the given state.\n         * Return false if the transition failed.\n         */\n        boolean waitForState(int state, Player p) {\n            synchronized (waitSync) {\n                try {\n                    while (p.getState() < state && stateTransitionOK) waitSync.wait();\n                } catch (Exception e) {\n                }\n            }\n            return stateTransitionOK;\n        }\n\n        /**\n         * Controller Listener.\n         */\n        public void controllerUpdate(ControllerEvent evt) {\n            if (evt instanceof ConfigureCompleteEvent || evt instanceof RealizeCompleteEvent || evt instanceof PrefetchCompleteEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = true;\n                    waitSync.notifyAll();\n                }\n            } else if (evt instanceof ResourceUnavailableEvent) {\n                synchronized (waitSync) {\n                    stateTransitionOK = false;\n                    waitSync.notifyAll();\n                }\n            }\n        }\n    }\n\n    /**\n     * Extracts the width and height of the video media represented by\n     * the player and stores that information in the Metadata bean.\n     * If successful, true is returned, otherwise false is returned.\n     * The player needs to be in the realized state before this method\n     * is called.\n     */\n    private boolean readWidthAndHeight(Player player, MetadataBean metadata) {\n        FramePositioningControl fpc = (FramePositioningControl) player.getControl(\"javax.media.control.FramePositioningControl\");\n        FrameGrabbingControl fgc = (FrameGrabbingControl) player.getControl(\"javax.media.control.FrameGrabbingControl\");\n        if (fpc == null || fgc == null) {\n            System.err.println(\"Unable to get a positioning or grabbing control.\");\n            return false;\n        }\n        fpc.seek(1);\n        Buffer image = fgc.grabFrame();\n        VideoFormat format = (VideoFormat) image.getFormat();\n        if (format != null) {\n            System.err.println(\"Unable to get video format for initial frame of movie.\");\n            Dimension size = format.getSize();\n            metadata.setFileWidth(\"\" + size.width);\n            metadata.setFileHeight(\"\" + size.height);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Takes the video file stored at the given location and\n     * extracts the duration, width, and height of the video\n     * and stores that information in the metadata bean\n     * provided.  If an error occurs, false is returned, otherwise\n     * true is returned.  False will also be returned if either\n     * parameter is null, or the complete metadata bean's metadata bean\n     * is null.\n     */\n    public boolean processVideo(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            if (!readDuration(player, metadata))\n                return false;\n            //we got duration, so we should be able to find a frame\n            return readWidthAndHeight(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Given a source file path, creates a data source/media locator\n     * for that file, creates a new player, and waits for the\n     * player to be realized.  If no errors occur, the created player\n     * (in the realized state), is returned and ready for use.\n     * If an error occurs, null is returned.\n     */\n    private Player getAndRealizePlayer(String sourceFilePath) throws MalformedURLException {\n        if (sourceFilePath == null)\n            return null;\n        File file = new File(sourceFilePath);\n        URL url = file.toURL();\n        MediaLocator ml;\n        Player player;\n        if ((ml = new MediaLocator(url)) == null) {\n            System.err.println(\"Unable to load media file.\");\n            return null;\n        }\n        DataSource ds = null;\n        // Create a DataSource given the media locator.\n        try {\n            ds = Manager.createDataSource(ml);\n        } catch (Exception e) {\n            System.err.println(\"added here1: \" + e);\n            e.printStackTrace();\n            return null;\n        }\n        try {\n            player = Manager.createPlayer(ds);\n        } catch (Exception e) {\n            System.err.println(\"Failed to create a player from the given DataSource: \" + e);\n            return null;\n        }\n        RealizeListener realizeListener = new RealizeListener();\n        player.addControllerListener(realizeListener);\n        player.realize();\n        if (!realizeListener.waitForState(player.Realized, player)) {\n            System.err.println(\"Failed to realize the player.\");\n            return null;\n        }\n        return player;\n    }\n\n    /**\n     * Given a source file path, this method\n     * gleans the duration (in milliseconds) of the audio.\n     * This information is then stored in the Duration field\n     * of the MetadataBean contained within the passed in\n     * CompleteMetadataBean.  If either of the parameters is null\n     * then false is returned.\n     * If the duration is successfully acquired, true is returned.\n     * Otherwise, false is returned.\n     */\n    public boolean processAudio(CompleteMetadataBean complete, String sourceFilePath) {\n        MetadataBean metadata;\n        if (complete == null || (metadata = complete.getMetadata()) == null || sourceFilePath == null) {\n            return false;\n        }\n        try {\n            Player player = getAndRealizePlayer(sourceFilePath);\n            if (player == null)\n                return false;\n            return readDuration(player, metadata);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * Gets the duration of the media loaded by the Player and\n     * stores that information (in milliseconds) in the metadata\n     * bean's duration field.\n     * The player must be in the realized state for this to work\n     * correctly, and the metadata must not be null.  If an error occurs,\n     * false is returned.  Otherwise true is returned, meaning that\n     * the duration was successfully stored in the metadata bean.\n     */\n    private boolean readDuration(Player player, MetadataBean metadata) {\n        if (player == null || metadata == null)\n            return false;\n        Time t = player.getDuration();\n        if (t != Duration.DURATION_UNKNOWN) {\n            int milliseconds = (int) (t.getSeconds() * 1000);\n            metadata.setDuration(\"\" + milliseconds);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Given the path to an image file, opens that image and dynamically\n     * generates a thumbnail scaled to fit within the specified dimensions.\n     * The scaling means that the thumbnail's height will be no greater than\n     * the maxHeight parameter and the thumbnail's width will be no greater\n     * than the maxWidth parameter.  The unit of measurement for both\n     * maxWidth and maxHeight are pixels.\n     * It is important that the provided CompleteMetadataBean already have\n     * a MetadataBean set with a metadataId assigned.  If not, the\n     * ThumbnailBean generated will not contain a metadataId setting and\n     * the caller is responsible for setting it.\n     * KNOWN PROBLEM: DUE TO A BUG IN THE JAVA ADVANCED IMAGING GIF DECODER\n     * GIFS WITH TRANSPARENT BACKGROUNDS MAY NOT BE READ PROPERLY.\n     */\n    public ThumbnailBean generateThumbnail(String sourceLocation, String metadataId, PlanarImage image) throws IOException {\n        ThumbnailBean thumbnail = null;\n        if (sourceLocation == null) {\n            //failed because there was no metadata bean\n            return null;\n        }\n        String thumbLocation = getThumbnailLocationFromSource(sourceLocation, THUMB_PREFIX, JPEG_EXTENSION);\n        String thumbFilePath = fileLocator.getThumbnailFilePath(thumbLocation);\n        if (thumbFilePath != null) {\n            File thumbFile = new File(thumbFilePath);\n            File parentDir = thumbFile.getParentFile();\n            if (!parentDir.exists()) {\n                parentDir.mkdirs();\n            }\n        }\n        ParameterBlock parameters = getThumbnailParameterBlock(image);\n        PlanarImage thumb = JAI.create(\"scale\", parameters, null);\n        thumbnail = new ThumbnailBean();\n        thumbnail.setFileWidth(\"\" + thumb.getWidth());\n        thumbnail.setFileHeight(\"\" + thumb.getHeight());\n        thumbnail.setLocation(thumbLocation);\n        thumbnail.setMetadataId(metadataId);\n        //This is a workaround for a bug in the jpeg encoder, to read more\n        //about the bug, see:\n        //http://www.sun.com/software/imaging/JAI/11/bugs_codec.html\n        ParameterBlock pb = new ParameterBlock();\n        pb.addSource(thumb);\n        pb.add(DataBuffer.TYPE_BYTE);\n        PlanarImage thumbByte = JAI.create(\"format\", pb);\n        FileOutputStream dst = null;\n        try {\n            dst = new FileOutputStream(thumbFilePath);\n            ImageEncoder enc = ImageCodec.createImageEncoder(\"JPEG\", dst, null);\n            enc.encode(thumbByte);\n        } finally {\n            try {\n                if (dst != null) {\n                    dst.close();\n                }\n            } catch (Exception ex) {\n                //ignore for now, we just want the stream closed.\n            }\n        }\n        return thumbnail;\n    }\n\n    /**\n     * Given a location for a content file (e.g. /seth/images/brain.gif)\n     * This method will return a string indicating the thumbnail\n     * location to use (e.g. /seth/images/thb_brain.jpg).  Please note\n     * that this method assumes that all thumbnails will be jpgs.\n     */\n    private String getThumbnailLocationFromSource(String sourceLocation, String thumbPrefix, String thumbSuffix) {\n        int index = sourceLocation.lastIndexOf('/');\n        String prefix;\n        String tempname;\n        String finalname;\n        if (index == -1) {\n            prefix = \"\";\n            tempname = sourceLocation;\n        } else {\n            prefix = sourceLocation.substring(0, index + 1);\n            tempname = sourceLocation.substring(index + 1);\n        }\n        int extensionIndex = tempname.lastIndexOf('.');\n        if (extensionIndex == -1) {\n            finalname = thumbPrefix + tempname + thumbSuffix;\n        } else {\n            finalname = thumbPrefix + tempname.substring(0, extensionIndex) + thumbSuffix;\n        }\n        return prefix + finalname;\n    }\n\n    /**\n     * This method determines sets up the parameter block for the\n     * scaling function used to create the thumbnail.  Given an\n     * image, it calculates the scaling required to gain the desired\n     * size of thumbnail.\n     * Okay, so we're trying to constrain the thumbnail image as such:\n     * We want the maximum dimension of either height or width to\n     * be MAX_THUMB_HEIGHT or MAX_THUMB_WIDTH.  So, we figure out the\n     * float to multiply the image height by in order to make it fit within\n     * the specified maximum.  We do the same with the width parameter.\n     * The equation for this is: 1/(dimension/max) = max/dimension\n     * This will give us a scalar that is less than one (e.g. 0.5), or if\n     * the dimension is already less than the maximum, we set the\n     * dimension's scalar to 1.0F.\n     * Then, once we have determined the scalar for each, we take the\n     * smaller of the two because that is the dimension that requires the\n     * most scaling to be brought within it's max dimension.\n     */\n    private ParameterBlock getThumbnailParameterBlock(PlanarImage image) {\n        ParameterBlock parameters = new ParameterBlock();\n        int height = image.getHeight();\n        int width = image.getWidth();\n        float heightscalar;\n        float widthscalar;\n        if (height > MAX_THUMB_HEIGHT) {\n            heightscalar = ((float) MAX_THUMB_HEIGHT) / ((float) height);\n        } else {\n            //no scaling involved\n            heightscalar = 1.0F;\n        }\n        if (width > MAX_THUMB_WIDTH) {\n            widthscalar = ((float) MAX_THUMB_WIDTH) / ((float) width);\n        } else {\n            //no scaling involved\n            widthscalar = 1.0F;\n        }\n        float scalar = (widthscalar < heightscalar ? widthscalar : heightscalar);\n        parameters.addSource(image);\n        //x scalar\n        parameters.add(scalar);\n        //y scalar\n        parameters.add(scalar);\n        parameters.add(0.0F);\n        parameters.add(0.0F);\n        //these offer different algorithms for doing the scaling.\n        Interpolation interp;\n        interp = Interpolation.getInstance(Interpolation.INTERP_NEAREST);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BILINEAR);\n        // interp = Interpolation.getInstance(Interpolation.INTERP_BICUBIC);\n        parameters.add(interp);\n        return parameters;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/module/upload/UploadServicesBeanTest3.java",
		"test_prompt": "// UploadServicesBeanTest3.java\npackage org.heal.module.upload;\n\nimport com.sun.media.jai.codec.ImageCodec;\nimport com.sun.media.jai.codec.ImageEncoder;\nimport org.heal.module.metadata.CompleteMetadataBean;\nimport org.heal.module.metadata.MetadataBean;\nimport org.heal.module.metadata.ThumbnailBean;\nimport org.heal.util.FileLocator;\nimport javax.media.Buffer;\nimport javax.media.ConfigureCompleteEvent;\nimport javax.media.ControllerEvent;\nimport javax.media.ControllerListener;\nimport javax.media.Duration;\nimport javax.media.Manager;\nimport javax.media.MediaLocator;\nimport javax.media.Player;\nimport javax.media.PrefetchCompleteEvent;\nimport javax.media.RealizeCompleteEvent;\nimport javax.media.ResourceUnavailableEvent;\nimport javax.media.Time;\nimport javax.media.control.FrameGrabbingControl;\nimport javax.media.control.FramePositioningControl;\nimport javax.media.format.VideoFormat;\nimport javax.media.jai.Interpolation;\nimport javax.media.jai.JAI;\nimport javax.media.jai.PlanarImage;\nimport javax.media.protocol.DataSource;\nimport java.awt.Dimension;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.renderable.ParameterBlock;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UploadServicesBean}.\n* It contains ten unit test cases for the {@link UploadServicesBean#generateThumbnail(String, String, PlanarImage)} method.\n*/\nclass UploadServicesBeanTest3 {"
	},
	{
		"original_code": "// LastModifiedTag.java\npackage org.heal.tag;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Tag to display the modification date of a file.  Based on example\n * from <a href=\"http://www-106.ibm.com/developerworks/java/library/j-jsp08053.html\">http://www-106.ibm.com/developerworks/java/library/j-jsp08053.html</a>\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n */\npublic class LastModifiedTag extends TagSupport {\n\n    private String format = \"MMM dd yyyy\";\n\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    public int doEndTag() {\n        try {\n            HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();\n            String path = pageContext.getServletContext().getRealPath(request.getServletPath());\n            File file = new File(path);\n            DateFormat formatter = new SimpleDateFormat(format);\n            pageContext.getOut().print(formatter.format(new Date(file.lastModified())));\n        } catch (IOException e) {\n        }\n        return EVAL_PAGE;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/tag/LastModifiedTagTest.java",
		"test_prompt": "// LastModifiedTagTest.java\npackage org.heal.tag;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LastModifiedTag}.\n* It contains ten unit test cases for the {@link LastModifiedTag#doEndTag()} method.\n*/\nclass LastModifiedTagTest {"
	},
	{
		"original_code": "// DownloadFolderActionTag.java\npackage org.heal.tag.download;\n\nimport javax.servlet.jsp.tagext.BodyTagSupport;\n\n/**\n * A tag nested under a {@link org.heal.tag.download.DownloadFolderTag}\n * which will evaluate the body of this tag iff the parent tag's attributes\n * indicate that it matches the type of download folder action represented\n * by this object.\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see org.heal.tag.download.DownloadFolderTag\n */\npublic class DownloadFolderActionTag extends BodyTagSupport {\n\n    private int type = DownloadFolderTag.UNKNOWN;\n\n    public static final String TYPE_ADD = \"add\";\n\n    public static final String TYPE_REMOVE = \"remove\";\n\n    public static final String TYPE_UNAVAILABLE = \"unavailable\";\n\n    public static final String TYPE_REMOTE_IMAGE = \"remote image\";\n\n    public void setType(String type) {\n        if (null != type) {\n            type = type.toLowerCase();\n        }\n        if (TYPE_ADD.equals(type)) {\n            this.type = DownloadFolderTag.ADD;\n        } else if (TYPE_REMOVE.equals(type)) {\n            this.type = DownloadFolderTag.REMOVE;\n        } else if (TYPE_UNAVAILABLE.equals(type)) {\n            this.type = DownloadFolderTag.UNAVAILABLE;\n        } else if (TYPE_REMOTE_IMAGE.equals(type)) {\n            this.type = DownloadFolderTag.REMOTE_IMAGE;\n        }\n    }\n\n    public int doStartTag() {\n        int tagAction = SKIP_BODY;\n        DownloadFolderTag parent = (DownloadFolderTag) findAncestorWithClass(this, DownloadFolderTag.class);\n        if (null != parent) {\n            if (parent.getDownloadFolderType() == type) {\n                tagAction = EVAL_BODY_INCLUDE;\n            }\n        }\n        return tagAction;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/tag/download/DownloadFolderActionTagTest.java",
		"test_prompt": "// DownloadFolderActionTagTest.java\npackage org.heal.tag.download;\n\nimport javax.servlet.jsp.tagext.BodyTagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadFolderActionTag}.\n* It contains ten unit test cases for the {@link DownloadFolderActionTag#doStartTag()} method.\n*/\nclass DownloadFolderActionTagTest {"
	},
	{
		"original_code": "// DownloadFolderTag.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * A tag which is basically acts as a container for attributes which\n * nested tags will utilize.\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see org.heal.tag.download.DownloadFolderActionTag\n */\npublic class DownloadFolderTag extends TagSupport {\n\n    public static final int UNKNOWN = -1;\n\n    public static final int UNAVAILABLE = 0;\n\n    public static final int ADD = 1;\n\n    public static final int REMOVE = 2;\n\n    public static final int REMOTE_IMAGE = 3;\n\n    private DownloadQueueBean downloadQueue = null;\n\n    private ShortMetadataBean shortMetadata = null;\n\n    private int downloadFolderType = UNAVAILABLE;\n\n    public void setDownloadQueue(DownloadQueueBean downloadQueue) {\n        this.downloadQueue = downloadQueue;\n    }\n\n    public void setShortMetadata(ShortMetadataBean shortMetadata) {\n        this.shortMetadata = shortMetadata;\n    }\n\n    /**\n     * This is perhaps poorly named, but this will return an\n     * integer representing whether or not a metadata record may\n     * be added to the download folder, removed from the download folder,\n     * or if the download folder is unavailable for the metadata record.\n     *\n     * @return {@link #UNAVAILABLE DownloadFolderTag.UNAVAILABLE} or\n     * {@link #ADD DownloadFolderTag.ADD} or {@link #REMOVE DownloadFolderTag.REMOVE} or\n     * {@link #REMOTE_IMAGE DownloadFolderTag.REMOTE_IMAGE}.\n     */\n    public int getDownloadFolderType() {\n        return downloadFolderType;\n    }\n\n    /**\n     * Parses the attributes so as to initialize the\n     * {@link #getDownloadFolderType() download folder type} for child tags\n     * to use.\n     *\n     * @return Always returns <code>TagSupport.EVAL_BODY_INCLUDE</code>\n     */\n    public int doStartTag() {\n        FileLocator locator = (FileLocator) pageContext.getServletContext().getAttribute(\"healFileLocator\");\n        if (\"web page\".equals(shortMetadata.getFormat().toLowerCase()) || !shortMetadata.getLocation().toLowerCase().startsWith(locator.getServerBaseURL())) {\n            if (\"image\".equals(shortMetadata.getFormat().toLowerCase())) {\n                downloadFolderType = REMOTE_IMAGE;\n            } else {\n                downloadFolderType = UNAVAILABLE;\n            }\n        } else if (downloadQueue.isQueuedAlready(shortMetadata.getMetadataId())) {\n            downloadFolderType = REMOVE;\n        } else {\n            downloadFolderType = ADD;\n        }\n        return TagSupport.EVAL_BODY_INCLUDE;\n    }\n\n    /**\n     * Resets the internal state of the tag.\n     *\n     * @return Always returns <code>TagSupport.EVAL_PAGE</code>\n     */\n    public int doEndTag() {\n        // In case the servlet container re-uses this object\n        resetTag();\n        return EVAL_PAGE;\n    }\n\n    /**\n     * Resets the tag to its initial state.\n     */\n    private void resetTag() {\n        downloadFolderType = UNAVAILABLE;\n        downloadQueue = null;\n        shortMetadata = null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTagTest0.java",
		"test_prompt": "// DownloadFolderTagTest0.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadFolderTag}.\n* It contains ten unit test cases for the {@link DownloadFolderTag#doStartTag()} method.\n*/\nclass DownloadFolderTagTest0 {"
	},
	{
		"original_code": "// DownloadFolderTag.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\n\n/**\n * A tag which is basically acts as a container for attributes which\n * nested tags will utilize.\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see org.heal.tag.download.DownloadFolderActionTag\n */\npublic class DownloadFolderTag extends TagSupport {\n\n    public static final int UNKNOWN = -1;\n\n    public static final int UNAVAILABLE = 0;\n\n    public static final int ADD = 1;\n\n    public static final int REMOVE = 2;\n\n    public static final int REMOTE_IMAGE = 3;\n\n    private DownloadQueueBean downloadQueue = null;\n\n    private ShortMetadataBean shortMetadata = null;\n\n    private int downloadFolderType = UNAVAILABLE;\n\n    public void setDownloadQueue(DownloadQueueBean downloadQueue) {\n        this.downloadQueue = downloadQueue;\n    }\n\n    public void setShortMetadata(ShortMetadataBean shortMetadata) {\n        this.shortMetadata = shortMetadata;\n    }\n\n    /**\n     * This is perhaps poorly named, but this will return an\n     * integer representing whether or not a metadata record may\n     * be added to the download folder, removed from the download folder,\n     * or if the download folder is unavailable for the metadata record.\n     *\n     * @return {@link #UNAVAILABLE DownloadFolderTag.UNAVAILABLE} or\n     * {@link #ADD DownloadFolderTag.ADD} or {@link #REMOVE DownloadFolderTag.REMOVE} or\n     * {@link #REMOTE_IMAGE DownloadFolderTag.REMOTE_IMAGE}.\n     */\n    public int getDownloadFolderType() {\n        return downloadFolderType;\n    }\n\n    /**\n     * Parses the attributes so as to initialize the\n     * {@link #getDownloadFolderType() download folder type} for child tags\n     * to use.\n     *\n     * @return Always returns <code>TagSupport.EVAL_BODY_INCLUDE</code>\n     */\n    public int doStartTag() {\n        FileLocator locator = (FileLocator) pageContext.getServletContext().getAttribute(\"healFileLocator\");\n        if (\"web page\".equals(shortMetadata.getFormat().toLowerCase()) || !shortMetadata.getLocation().toLowerCase().startsWith(locator.getServerBaseURL())) {\n            if (\"image\".equals(shortMetadata.getFormat().toLowerCase())) {\n                downloadFolderType = REMOTE_IMAGE;\n            } else {\n                downloadFolderType = UNAVAILABLE;\n            }\n        } else if (downloadQueue.isQueuedAlready(shortMetadata.getMetadataId())) {\n            downloadFolderType = REMOVE;\n        } else {\n            downloadFolderType = ADD;\n        }\n        return TagSupport.EVAL_BODY_INCLUDE;\n    }\n\n    /**\n     * Resets the internal state of the tag.\n     *\n     * @return Always returns <code>TagSupport.EVAL_PAGE</code>\n     */\n    public int doEndTag() {\n        // In case the servlet container re-uses this object\n        resetTag();\n        return EVAL_PAGE;\n    }\n\n    /**\n     * Resets the tag to its initial state.\n     */\n    private void resetTag() {\n        downloadFolderType = UNAVAILABLE;\n        downloadQueue = null;\n        shortMetadata = null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/tag/download/DownloadFolderTagTest1.java",
		"test_prompt": "// DownloadFolderTagTest1.java\npackage org.heal.tag.download;\n\nimport org.heal.module.download.DownloadQueueBean;\nimport org.heal.module.metadata.ShortMetadataBean;\nimport org.heal.util.FileLocator;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadFolderTag}.\n* It contains ten unit test cases for the {@link DownloadFolderTag#doEndTag()} method.\n*/\nclass DownloadFolderTagTest1 {"
	},
	{
		"original_code": "// DownloadFolderActionTagExtraInfo.java\npackage org.heal.tag.download;\n\nimport javax.servlet.jsp.tagext.TagExtraInfo;\nimport javax.servlet.jsp.tagext.TagData;\n\n/**\n * A <code>TagExtraInfo</code> class for {@link DownloadFolderActionTag} to\n * validate the type attribute of the tag.\n *\n * @version 1.0\n * @author Brad Schaefer (<A HREF=\"mailto:schaefer@lib.med.utah.edu\">schaefer@lib.med.utah.edu</A>)\n * @see DownloadFolderActionTag\n */\npublic class DownloadFolderActionTagExtraInfo extends TagExtraInfo {\n\n    /**\n     * @param tagData\n     * @return Returns <code>true</code> only if the tagData has a valid\n     *      'type' attribute.\n     */\n    public boolean isValid(TagData tagData) {\n        boolean ret = false;\n        Object temp = tagData.getAttribute(\"type\");\n        if (temp instanceof String) {\n            String type = (String) temp;\n            // type constants are known to be lowercase\n            type = type.toLowerCase();\n            if (DownloadFolderActionTag.TYPE_ADD.equals(type) || DownloadFolderActionTag.TYPE_REMOVE.equals(type) || DownloadFolderActionTag.TYPE_UNAVAILABLE.equals(type) || DownloadFolderActionTag.TYPE_REMOTE_IMAGE.equals(type)) {\n                // this means the tagData is valid!\n                ret = true;\n            }\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/tag/download/DownloadFolderActionTagExtraInfoTest.java",
		"test_prompt": "// DownloadFolderActionTagExtraInfoTest.java\npackage org.heal.tag.download;\n\nimport javax.servlet.jsp.tagext.TagExtraInfo;\nimport javax.servlet.jsp.tagext.TagData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DownloadFolderActionTagExtraInfo}.\n* It contains ten unit test cases for the {@link DownloadFolderActionTagExtraInfo#isValid(TagData)} method.\n*/\nclass DownloadFolderActionTagExtraInfoTest {"
	},
	{
		"original_code": "// FormatDateTag.java\npackage org.heal.tag;\n\nimport org.heal.util.DateTools;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.io.IOException;\nimport java.util.Date;\n\n/**\n * A tag to display dates in a standard format, as well as allowing the\n * option of specifying a custom format.\n */\npublic class FormatDateTag extends TagSupport {\n\n    private String format = DateTools.DEFAULT_DATE_FORMAT;\n\n    private Date date = new Date();\n\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n\n    public int doEndTag() {\n        try {\n            pageContext.getOut().print((null != date ? DateTools.format(date, format) : new String()));\n        } catch (IOException e) {\n        }\n        return EVAL_PAGE;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/tag/FormatDateTagTest.java",
		"test_prompt": "// FormatDateTagTest.java\npackage org.heal.tag;\n\nimport org.heal.util.DateTools;\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.io.IOException;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FormatDateTag}.\n* It contains ten unit test cases for the {@link FormatDateTag#doEndTag()} method.\n*/\nclass FormatDateTagTest {"
	},
	{
		"original_code": "// TruncateStringTag.java\npackage org.heal.tag;\n\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.io.IOException;\n\n/**\n * A tag to truncate long strings by taking a substring and appending a <code>\"...\"</code>\n * to the end of them.\n */\npublic class TruncateStringTag extends TagSupport {\n\n    public static final int MAX_LENGTH = 60;\n\n    public static final String ELLIPSIS = new String(\"...\");\n\n    private String str = new String();\n\n    private int length = MAX_LENGTH;\n\n    public void setString(String str) {\n        this.str = str;\n    }\n\n    public String getString() {\n        return this.str;\n    }\n\n    public void setLength(String length) {\n        try {\n            this.length = Integer.parseInt(length);\n        } catch (NumberFormatException e) {\n        }\n    }\n\n    public String getLength() {\n        return String.valueOf(this.length);\n    }\n\n    public int doEndTag() {\n        String outputStr;\n        if (str.length() > (length + ELLIPSIS.length())) {\n            outputStr = str.substring(0, length) + ELLIPSIS;\n        } else {\n            outputStr = str;\n        }\n        try {\n            pageContext.getOut().print(outputStr);\n        } catch (IOException e) {\n        }\n        return EVAL_PAGE;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/heal/tag/TruncateStringTagTest.java",
		"test_prompt": "// TruncateStringTagTest.java\npackage org.heal.tag;\n\nimport javax.servlet.jsp.tagext.TagSupport;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TruncateStringTag}.\n* It contains ten unit test cases for the {@link TruncateStringTag#doEndTag()} method.\n*/\nclass TruncateStringTagTest {"
	},
	{
		"original_code": "// SearchResult.java\n/**\n * SearchResult.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResult implements java.io.Serializable {\n\n    private java.lang.String category;\n\n    private java.lang.String comments;\n\n    private int endIndex;\n\n    private java.lang.String query;\n\n    private org.merlot.fedsearch.type.SearchResultElement[] resultElements;\n\n    private float searchTime;\n\n    private int startIndex;\n\n    private int totalResultsCount;\n\n    public SearchResult() {\n    }\n\n    public SearchResult(java.lang.String category, java.lang.String comments, int endIndex, java.lang.String query, org.merlot.fedsearch.type.SearchResultElement[] resultElements, float searchTime, int startIndex, int totalResultsCount) {\n        this.category = category;\n        this.comments = comments;\n        this.endIndex = endIndex;\n        this.query = query;\n        this.resultElements = resultElements;\n        this.searchTime = searchTime;\n        this.startIndex = startIndex;\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    /**\n     * Gets the category value for this SearchResult.\n     *\n     * @return category\n     */\n    public java.lang.String getCategory() {\n        return category;\n    }\n\n    /**\n     * Sets the category value for this SearchResult.\n     *\n     * @param category\n     */\n    public void setCategory(java.lang.String category) {\n        this.category = category;\n    }\n\n    /**\n     * Gets the comments value for this SearchResult.\n     *\n     * @return comments\n     */\n    public java.lang.String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments value for this SearchResult.\n     *\n     * @param comments\n     */\n    public void setComments(java.lang.String comments) {\n        this.comments = comments;\n    }\n\n    /**\n     * Gets the endIndex value for this SearchResult.\n     *\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Sets the endIndex value for this SearchResult.\n     *\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * Gets the query value for this SearchResult.\n     *\n     * @return query\n     */\n    public java.lang.String getQuery() {\n        return query;\n    }\n\n    /**\n     * Sets the query value for this SearchResult.\n     *\n     * @param query\n     */\n    public void setQuery(java.lang.String query) {\n        this.query = query;\n    }\n\n    /**\n     * Gets the resultElements value for this SearchResult.\n     *\n     * @return resultElements\n     */\n    public org.merlot.fedsearch.type.SearchResultElement[] getResultElements() {\n        return resultElements;\n    }\n\n    /**\n     * Sets the resultElements value for this SearchResult.\n     *\n     * @param resultElements\n     */\n    public void setResultElements(org.merlot.fedsearch.type.SearchResultElement[] resultElements) {\n        this.resultElements = resultElements;\n    }\n\n    /**\n     * Gets the searchTime value for this SearchResult.\n     *\n     * @return searchTime\n     */\n    public float getSearchTime() {\n        return searchTime;\n    }\n\n    /**\n     * Sets the searchTime value for this SearchResult.\n     *\n     * @param searchTime\n     */\n    public void setSearchTime(float searchTime) {\n        this.searchTime = searchTime;\n    }\n\n    /**\n     * Gets the startIndex value for this SearchResult.\n     *\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * Sets the startIndex value for this SearchResult.\n     *\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * Gets the totalResultsCount value for this SearchResult.\n     *\n     * @return totalResultsCount\n     */\n    public int getTotalResultsCount() {\n        return totalResultsCount;\n    }\n\n    /**\n     * Sets the totalResultsCount value for this SearchResult.\n     *\n     * @param totalResultsCount\n     */\n    public void setTotalResultsCount(int totalResultsCount) {\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResult))\n            return false;\n        SearchResult other = (SearchResult) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.category == null && other.getCategory() == null) || (this.category != null && this.category.equals(other.getCategory()))) && ((this.comments == null && other.getComments() == null) || (this.comments != null && this.comments.equals(other.getComments()))) && this.endIndex == other.getEndIndex() && ((this.query == null && other.getQuery() == null) || (this.query != null && this.query.equals(other.getQuery()))) && ((this.resultElements == null && other.getResultElements() == null) || (this.resultElements != null && java.util.Arrays.equals(this.resultElements, other.getResultElements()))) && this.searchTime == other.getSearchTime() && this.startIndex == other.getStartIndex() && this.totalResultsCount == other.getTotalResultsCount();\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getCategory() != null) {\n            _hashCode += getCategory().hashCode();\n        }\n        if (getComments() != null) {\n            _hashCode += getComments().hashCode();\n        }\n        _hashCode += getEndIndex();\n        if (getQuery() != null) {\n            _hashCode += getQuery().hashCode();\n        }\n        if (getResultElements() != null) {\n            for (int i = 0; i < java.lang.reflect.Array.getLength(getResultElements()); i++) {\n                java.lang.Object obj = java.lang.reflect.Array.get(getResultElements(), i);\n                if (obj != null && !obj.getClass().isArray()) {\n                    _hashCode += obj.hashCode();\n                }\n            }\n        }\n        _hashCode += new Float(getSearchTime()).hashCode();\n        _hashCode += getStartIndex();\n        _hashCode += getTotalResultsCount();\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResult.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"category\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"category\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"comments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"comments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"endIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"endIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"query\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"query\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"resultElements\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"resultElements\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"searchTime\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"searchTime\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"float\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"startIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"startIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"totalResultsCount\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"totalResultsCount\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultTest0.java",
		"test_prompt": "// SearchResultTest0.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResult}.\n* It contains ten unit test cases for the {@link SearchResult#equals(java.lang.Object)} method.\n*/\nclass SearchResultTest0 {"
	},
	{
		"original_code": "// SearchResult.java\n/**\n * SearchResult.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResult implements java.io.Serializable {\n\n    private java.lang.String category;\n\n    private java.lang.String comments;\n\n    private int endIndex;\n\n    private java.lang.String query;\n\n    private org.merlot.fedsearch.type.SearchResultElement[] resultElements;\n\n    private float searchTime;\n\n    private int startIndex;\n\n    private int totalResultsCount;\n\n    public SearchResult() {\n    }\n\n    public SearchResult(java.lang.String category, java.lang.String comments, int endIndex, java.lang.String query, org.merlot.fedsearch.type.SearchResultElement[] resultElements, float searchTime, int startIndex, int totalResultsCount) {\n        this.category = category;\n        this.comments = comments;\n        this.endIndex = endIndex;\n        this.query = query;\n        this.resultElements = resultElements;\n        this.searchTime = searchTime;\n        this.startIndex = startIndex;\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    /**\n     * Gets the category value for this SearchResult.\n     *\n     * @return category\n     */\n    public java.lang.String getCategory() {\n        return category;\n    }\n\n    /**\n     * Sets the category value for this SearchResult.\n     *\n     * @param category\n     */\n    public void setCategory(java.lang.String category) {\n        this.category = category;\n    }\n\n    /**\n     * Gets the comments value for this SearchResult.\n     *\n     * @return comments\n     */\n    public java.lang.String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments value for this SearchResult.\n     *\n     * @param comments\n     */\n    public void setComments(java.lang.String comments) {\n        this.comments = comments;\n    }\n\n    /**\n     * Gets the endIndex value for this SearchResult.\n     *\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Sets the endIndex value for this SearchResult.\n     *\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * Gets the query value for this SearchResult.\n     *\n     * @return query\n     */\n    public java.lang.String getQuery() {\n        return query;\n    }\n\n    /**\n     * Sets the query value for this SearchResult.\n     *\n     * @param query\n     */\n    public void setQuery(java.lang.String query) {\n        this.query = query;\n    }\n\n    /**\n     * Gets the resultElements value for this SearchResult.\n     *\n     * @return resultElements\n     */\n    public org.merlot.fedsearch.type.SearchResultElement[] getResultElements() {\n        return resultElements;\n    }\n\n    /**\n     * Sets the resultElements value for this SearchResult.\n     *\n     * @param resultElements\n     */\n    public void setResultElements(org.merlot.fedsearch.type.SearchResultElement[] resultElements) {\n        this.resultElements = resultElements;\n    }\n\n    /**\n     * Gets the searchTime value for this SearchResult.\n     *\n     * @return searchTime\n     */\n    public float getSearchTime() {\n        return searchTime;\n    }\n\n    /**\n     * Sets the searchTime value for this SearchResult.\n     *\n     * @param searchTime\n     */\n    public void setSearchTime(float searchTime) {\n        this.searchTime = searchTime;\n    }\n\n    /**\n     * Gets the startIndex value for this SearchResult.\n     *\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * Sets the startIndex value for this SearchResult.\n     *\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * Gets the totalResultsCount value for this SearchResult.\n     *\n     * @return totalResultsCount\n     */\n    public int getTotalResultsCount() {\n        return totalResultsCount;\n    }\n\n    /**\n     * Sets the totalResultsCount value for this SearchResult.\n     *\n     * @param totalResultsCount\n     */\n    public void setTotalResultsCount(int totalResultsCount) {\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResult))\n            return false;\n        SearchResult other = (SearchResult) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.category == null && other.getCategory() == null) || (this.category != null && this.category.equals(other.getCategory()))) && ((this.comments == null && other.getComments() == null) || (this.comments != null && this.comments.equals(other.getComments()))) && this.endIndex == other.getEndIndex() && ((this.query == null && other.getQuery() == null) || (this.query != null && this.query.equals(other.getQuery()))) && ((this.resultElements == null && other.getResultElements() == null) || (this.resultElements != null && java.util.Arrays.equals(this.resultElements, other.getResultElements()))) && this.searchTime == other.getSearchTime() && this.startIndex == other.getStartIndex() && this.totalResultsCount == other.getTotalResultsCount();\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getCategory() != null) {\n            _hashCode += getCategory().hashCode();\n        }\n        if (getComments() != null) {\n            _hashCode += getComments().hashCode();\n        }\n        _hashCode += getEndIndex();\n        if (getQuery() != null) {\n            _hashCode += getQuery().hashCode();\n        }\n        if (getResultElements() != null) {\n            for (int i = 0; i < java.lang.reflect.Array.getLength(getResultElements()); i++) {\n                java.lang.Object obj = java.lang.reflect.Array.get(getResultElements(), i);\n                if (obj != null && !obj.getClass().isArray()) {\n                    _hashCode += obj.hashCode();\n                }\n            }\n        }\n        _hashCode += new Float(getSearchTime()).hashCode();\n        _hashCode += getStartIndex();\n        _hashCode += getTotalResultsCount();\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResult.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"category\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"category\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"comments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"comments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"endIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"endIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"query\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"query\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"resultElements\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"resultElements\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"searchTime\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"searchTime\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"float\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"startIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"startIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"totalResultsCount\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"totalResultsCount\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultTest1.java",
		"test_prompt": "// SearchResultTest1.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResult}.\n* It contains ten unit test cases for the {@link SearchResult#hashCode()} method.\n*/\nclass SearchResultTest1 {"
	},
	{
		"original_code": "// SearchResult.java\n/**\n * SearchResult.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResult implements java.io.Serializable {\n\n    private java.lang.String category;\n\n    private java.lang.String comments;\n\n    private int endIndex;\n\n    private java.lang.String query;\n\n    private org.merlot.fedsearch.type.SearchResultElement[] resultElements;\n\n    private float searchTime;\n\n    private int startIndex;\n\n    private int totalResultsCount;\n\n    public SearchResult() {\n    }\n\n    public SearchResult(java.lang.String category, java.lang.String comments, int endIndex, java.lang.String query, org.merlot.fedsearch.type.SearchResultElement[] resultElements, float searchTime, int startIndex, int totalResultsCount) {\n        this.category = category;\n        this.comments = comments;\n        this.endIndex = endIndex;\n        this.query = query;\n        this.resultElements = resultElements;\n        this.searchTime = searchTime;\n        this.startIndex = startIndex;\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    /**\n     * Gets the category value for this SearchResult.\n     *\n     * @return category\n     */\n    public java.lang.String getCategory() {\n        return category;\n    }\n\n    /**\n     * Sets the category value for this SearchResult.\n     *\n     * @param category\n     */\n    public void setCategory(java.lang.String category) {\n        this.category = category;\n    }\n\n    /**\n     * Gets the comments value for this SearchResult.\n     *\n     * @return comments\n     */\n    public java.lang.String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments value for this SearchResult.\n     *\n     * @param comments\n     */\n    public void setComments(java.lang.String comments) {\n        this.comments = comments;\n    }\n\n    /**\n     * Gets the endIndex value for this SearchResult.\n     *\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Sets the endIndex value for this SearchResult.\n     *\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * Gets the query value for this SearchResult.\n     *\n     * @return query\n     */\n    public java.lang.String getQuery() {\n        return query;\n    }\n\n    /**\n     * Sets the query value for this SearchResult.\n     *\n     * @param query\n     */\n    public void setQuery(java.lang.String query) {\n        this.query = query;\n    }\n\n    /**\n     * Gets the resultElements value for this SearchResult.\n     *\n     * @return resultElements\n     */\n    public org.merlot.fedsearch.type.SearchResultElement[] getResultElements() {\n        return resultElements;\n    }\n\n    /**\n     * Sets the resultElements value for this SearchResult.\n     *\n     * @param resultElements\n     */\n    public void setResultElements(org.merlot.fedsearch.type.SearchResultElement[] resultElements) {\n        this.resultElements = resultElements;\n    }\n\n    /**\n     * Gets the searchTime value for this SearchResult.\n     *\n     * @return searchTime\n     */\n    public float getSearchTime() {\n        return searchTime;\n    }\n\n    /**\n     * Sets the searchTime value for this SearchResult.\n     *\n     * @param searchTime\n     */\n    public void setSearchTime(float searchTime) {\n        this.searchTime = searchTime;\n    }\n\n    /**\n     * Gets the startIndex value for this SearchResult.\n     *\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * Sets the startIndex value for this SearchResult.\n     *\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * Gets the totalResultsCount value for this SearchResult.\n     *\n     * @return totalResultsCount\n     */\n    public int getTotalResultsCount() {\n        return totalResultsCount;\n    }\n\n    /**\n     * Sets the totalResultsCount value for this SearchResult.\n     *\n     * @param totalResultsCount\n     */\n    public void setTotalResultsCount(int totalResultsCount) {\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResult))\n            return false;\n        SearchResult other = (SearchResult) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.category == null && other.getCategory() == null) || (this.category != null && this.category.equals(other.getCategory()))) && ((this.comments == null && other.getComments() == null) || (this.comments != null && this.comments.equals(other.getComments()))) && this.endIndex == other.getEndIndex() && ((this.query == null && other.getQuery() == null) || (this.query != null && this.query.equals(other.getQuery()))) && ((this.resultElements == null && other.getResultElements() == null) || (this.resultElements != null && java.util.Arrays.equals(this.resultElements, other.getResultElements()))) && this.searchTime == other.getSearchTime() && this.startIndex == other.getStartIndex() && this.totalResultsCount == other.getTotalResultsCount();\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getCategory() != null) {\n            _hashCode += getCategory().hashCode();\n        }\n        if (getComments() != null) {\n            _hashCode += getComments().hashCode();\n        }\n        _hashCode += getEndIndex();\n        if (getQuery() != null) {\n            _hashCode += getQuery().hashCode();\n        }\n        if (getResultElements() != null) {\n            for (int i = 0; i < java.lang.reflect.Array.getLength(getResultElements()); i++) {\n                java.lang.Object obj = java.lang.reflect.Array.get(getResultElements(), i);\n                if (obj != null && !obj.getClass().isArray()) {\n                    _hashCode += obj.hashCode();\n                }\n            }\n        }\n        _hashCode += new Float(getSearchTime()).hashCode();\n        _hashCode += getStartIndex();\n        _hashCode += getTotalResultsCount();\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResult.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"category\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"category\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"comments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"comments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"endIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"endIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"query\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"query\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"resultElements\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"resultElements\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"searchTime\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"searchTime\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"float\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"startIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"startIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"totalResultsCount\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"totalResultsCount\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultTest2.java",
		"test_prompt": "// SearchResultTest2.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResult}.\n* It contains ten unit test cases for the {@link SearchResult#getTypeDesc()} method.\n*/\nclass SearchResultTest2 {"
	},
	{
		"original_code": "// SearchResult.java\n/**\n * SearchResult.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResult implements java.io.Serializable {\n\n    private java.lang.String category;\n\n    private java.lang.String comments;\n\n    private int endIndex;\n\n    private java.lang.String query;\n\n    private org.merlot.fedsearch.type.SearchResultElement[] resultElements;\n\n    private float searchTime;\n\n    private int startIndex;\n\n    private int totalResultsCount;\n\n    public SearchResult() {\n    }\n\n    public SearchResult(java.lang.String category, java.lang.String comments, int endIndex, java.lang.String query, org.merlot.fedsearch.type.SearchResultElement[] resultElements, float searchTime, int startIndex, int totalResultsCount) {\n        this.category = category;\n        this.comments = comments;\n        this.endIndex = endIndex;\n        this.query = query;\n        this.resultElements = resultElements;\n        this.searchTime = searchTime;\n        this.startIndex = startIndex;\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    /**\n     * Gets the category value for this SearchResult.\n     *\n     * @return category\n     */\n    public java.lang.String getCategory() {\n        return category;\n    }\n\n    /**\n     * Sets the category value for this SearchResult.\n     *\n     * @param category\n     */\n    public void setCategory(java.lang.String category) {\n        this.category = category;\n    }\n\n    /**\n     * Gets the comments value for this SearchResult.\n     *\n     * @return comments\n     */\n    public java.lang.String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments value for this SearchResult.\n     *\n     * @param comments\n     */\n    public void setComments(java.lang.String comments) {\n        this.comments = comments;\n    }\n\n    /**\n     * Gets the endIndex value for this SearchResult.\n     *\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Sets the endIndex value for this SearchResult.\n     *\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * Gets the query value for this SearchResult.\n     *\n     * @return query\n     */\n    public java.lang.String getQuery() {\n        return query;\n    }\n\n    /**\n     * Sets the query value for this SearchResult.\n     *\n     * @param query\n     */\n    public void setQuery(java.lang.String query) {\n        this.query = query;\n    }\n\n    /**\n     * Gets the resultElements value for this SearchResult.\n     *\n     * @return resultElements\n     */\n    public org.merlot.fedsearch.type.SearchResultElement[] getResultElements() {\n        return resultElements;\n    }\n\n    /**\n     * Sets the resultElements value for this SearchResult.\n     *\n     * @param resultElements\n     */\n    public void setResultElements(org.merlot.fedsearch.type.SearchResultElement[] resultElements) {\n        this.resultElements = resultElements;\n    }\n\n    /**\n     * Gets the searchTime value for this SearchResult.\n     *\n     * @return searchTime\n     */\n    public float getSearchTime() {\n        return searchTime;\n    }\n\n    /**\n     * Sets the searchTime value for this SearchResult.\n     *\n     * @param searchTime\n     */\n    public void setSearchTime(float searchTime) {\n        this.searchTime = searchTime;\n    }\n\n    /**\n     * Gets the startIndex value for this SearchResult.\n     *\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * Sets the startIndex value for this SearchResult.\n     *\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * Gets the totalResultsCount value for this SearchResult.\n     *\n     * @return totalResultsCount\n     */\n    public int getTotalResultsCount() {\n        return totalResultsCount;\n    }\n\n    /**\n     * Sets the totalResultsCount value for this SearchResult.\n     *\n     * @param totalResultsCount\n     */\n    public void setTotalResultsCount(int totalResultsCount) {\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResult))\n            return false;\n        SearchResult other = (SearchResult) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.category == null && other.getCategory() == null) || (this.category != null && this.category.equals(other.getCategory()))) && ((this.comments == null && other.getComments() == null) || (this.comments != null && this.comments.equals(other.getComments()))) && this.endIndex == other.getEndIndex() && ((this.query == null && other.getQuery() == null) || (this.query != null && this.query.equals(other.getQuery()))) && ((this.resultElements == null && other.getResultElements() == null) || (this.resultElements != null && java.util.Arrays.equals(this.resultElements, other.getResultElements()))) && this.searchTime == other.getSearchTime() && this.startIndex == other.getStartIndex() && this.totalResultsCount == other.getTotalResultsCount();\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getCategory() != null) {\n            _hashCode += getCategory().hashCode();\n        }\n        if (getComments() != null) {\n            _hashCode += getComments().hashCode();\n        }\n        _hashCode += getEndIndex();\n        if (getQuery() != null) {\n            _hashCode += getQuery().hashCode();\n        }\n        if (getResultElements() != null) {\n            for (int i = 0; i < java.lang.reflect.Array.getLength(getResultElements()); i++) {\n                java.lang.Object obj = java.lang.reflect.Array.get(getResultElements(), i);\n                if (obj != null && !obj.getClass().isArray()) {\n                    _hashCode += obj.hashCode();\n                }\n            }\n        }\n        _hashCode += new Float(getSearchTime()).hashCode();\n        _hashCode += getStartIndex();\n        _hashCode += getTotalResultsCount();\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResult.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"category\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"category\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"comments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"comments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"endIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"endIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"query\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"query\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"resultElements\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"resultElements\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"searchTime\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"searchTime\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"float\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"startIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"startIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"totalResultsCount\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"totalResultsCount\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultTest3.java",
		"test_prompt": "// SearchResultTest3.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResult}.\n* It contains ten unit test cases for the {@link SearchResult#getSerializer(java.lang.String, java.lang.Class, javax.xml.namespace.QName)} method.\n*/\nclass SearchResultTest3 {"
	},
	{
		"original_code": "// SearchResult.java\n/**\n * SearchResult.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResult implements java.io.Serializable {\n\n    private java.lang.String category;\n\n    private java.lang.String comments;\n\n    private int endIndex;\n\n    private java.lang.String query;\n\n    private org.merlot.fedsearch.type.SearchResultElement[] resultElements;\n\n    private float searchTime;\n\n    private int startIndex;\n\n    private int totalResultsCount;\n\n    public SearchResult() {\n    }\n\n    public SearchResult(java.lang.String category, java.lang.String comments, int endIndex, java.lang.String query, org.merlot.fedsearch.type.SearchResultElement[] resultElements, float searchTime, int startIndex, int totalResultsCount) {\n        this.category = category;\n        this.comments = comments;\n        this.endIndex = endIndex;\n        this.query = query;\n        this.resultElements = resultElements;\n        this.searchTime = searchTime;\n        this.startIndex = startIndex;\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    /**\n     * Gets the category value for this SearchResult.\n     *\n     * @return category\n     */\n    public java.lang.String getCategory() {\n        return category;\n    }\n\n    /**\n     * Sets the category value for this SearchResult.\n     *\n     * @param category\n     */\n    public void setCategory(java.lang.String category) {\n        this.category = category;\n    }\n\n    /**\n     * Gets the comments value for this SearchResult.\n     *\n     * @return comments\n     */\n    public java.lang.String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments value for this SearchResult.\n     *\n     * @param comments\n     */\n    public void setComments(java.lang.String comments) {\n        this.comments = comments;\n    }\n\n    /**\n     * Gets the endIndex value for this SearchResult.\n     *\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Sets the endIndex value for this SearchResult.\n     *\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * Gets the query value for this SearchResult.\n     *\n     * @return query\n     */\n    public java.lang.String getQuery() {\n        return query;\n    }\n\n    /**\n     * Sets the query value for this SearchResult.\n     *\n     * @param query\n     */\n    public void setQuery(java.lang.String query) {\n        this.query = query;\n    }\n\n    /**\n     * Gets the resultElements value for this SearchResult.\n     *\n     * @return resultElements\n     */\n    public org.merlot.fedsearch.type.SearchResultElement[] getResultElements() {\n        return resultElements;\n    }\n\n    /**\n     * Sets the resultElements value for this SearchResult.\n     *\n     * @param resultElements\n     */\n    public void setResultElements(org.merlot.fedsearch.type.SearchResultElement[] resultElements) {\n        this.resultElements = resultElements;\n    }\n\n    /**\n     * Gets the searchTime value for this SearchResult.\n     *\n     * @return searchTime\n     */\n    public float getSearchTime() {\n        return searchTime;\n    }\n\n    /**\n     * Sets the searchTime value for this SearchResult.\n     *\n     * @param searchTime\n     */\n    public void setSearchTime(float searchTime) {\n        this.searchTime = searchTime;\n    }\n\n    /**\n     * Gets the startIndex value for this SearchResult.\n     *\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * Sets the startIndex value for this SearchResult.\n     *\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * Gets the totalResultsCount value for this SearchResult.\n     *\n     * @return totalResultsCount\n     */\n    public int getTotalResultsCount() {\n        return totalResultsCount;\n    }\n\n    /**\n     * Sets the totalResultsCount value for this SearchResult.\n     *\n     * @param totalResultsCount\n     */\n    public void setTotalResultsCount(int totalResultsCount) {\n        this.totalResultsCount = totalResultsCount;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResult))\n            return false;\n        SearchResult other = (SearchResult) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.category == null && other.getCategory() == null) || (this.category != null && this.category.equals(other.getCategory()))) && ((this.comments == null && other.getComments() == null) || (this.comments != null && this.comments.equals(other.getComments()))) && this.endIndex == other.getEndIndex() && ((this.query == null && other.getQuery() == null) || (this.query != null && this.query.equals(other.getQuery()))) && ((this.resultElements == null && other.getResultElements() == null) || (this.resultElements != null && java.util.Arrays.equals(this.resultElements, other.getResultElements()))) && this.searchTime == other.getSearchTime() && this.startIndex == other.getStartIndex() && this.totalResultsCount == other.getTotalResultsCount();\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getCategory() != null) {\n            _hashCode += getCategory().hashCode();\n        }\n        if (getComments() != null) {\n            _hashCode += getComments().hashCode();\n        }\n        _hashCode += getEndIndex();\n        if (getQuery() != null) {\n            _hashCode += getQuery().hashCode();\n        }\n        if (getResultElements() != null) {\n            for (int i = 0; i < java.lang.reflect.Array.getLength(getResultElements()); i++) {\n                java.lang.Object obj = java.lang.reflect.Array.get(getResultElements(), i);\n                if (obj != null && !obj.getClass().isArray()) {\n                    _hashCode += obj.hashCode();\n                }\n            }\n        }\n        _hashCode += new Float(getSearchTime()).hashCode();\n        _hashCode += getStartIndex();\n        _hashCode += getTotalResultsCount();\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResult.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"category\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"category\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"comments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"comments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"endIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"endIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"query\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"query\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"resultElements\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"resultElements\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"searchTime\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"searchTime\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"float\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"startIndex\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"startIndex\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"totalResultsCount\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"totalResultsCount\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultTest4.java",
		"test_prompt": "// SearchResultTest4.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResult}.\n* It contains ten unit test cases for the {@link SearchResult#getDeserializer(java.lang.String, java.lang.Class, javax.xml.namespace.QName)} method.\n*/\nclass SearchResultTest4 {"
	},
	{
		"original_code": "// SearchResultElement.java\n/**\n * SearchResultElement.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResultElement implements java.io.Serializable {\n\n    private java.lang.String URL;\n\n    private java.lang.String assignmentsURL;\n\n    private java.lang.String authorName;\n\n    private int avgComments;\n\n    private int avgPeerReviews;\n\n    private java.lang.String award;\n\n    private java.lang.String commentsURL;\n\n    private java.lang.String creationDate;\n\n    private java.lang.String description;\n\n    private java.lang.String detailURL;\n\n    private java.lang.String itemType;\n\n    private int numAssignments;\n\n    private int numComments;\n\n    private int numPeerReviews;\n\n    private java.lang.String peerReviewsURL;\n\n    private int relevanceRanking;\n\n    private java.lang.String title;\n\n    public SearchResultElement() {\n    }\n\n    public SearchResultElement(java.lang.String URL, java.lang.String assignmentsURL, java.lang.String authorName, int avgComments, int avgPeerReviews, java.lang.String award, java.lang.String commentsURL, java.lang.String creationDate, java.lang.String description, java.lang.String detailURL, java.lang.String itemType, int numAssignments, int numComments, int numPeerReviews, java.lang.String peerReviewsURL, int relevanceRanking, java.lang.String title) {\n        this.URL = URL;\n        this.assignmentsURL = assignmentsURL;\n        this.authorName = authorName;\n        this.avgComments = avgComments;\n        this.avgPeerReviews = avgPeerReviews;\n        this.award = award;\n        this.commentsURL = commentsURL;\n        this.creationDate = creationDate;\n        this.description = description;\n        this.detailURL = detailURL;\n        this.itemType = itemType;\n        this.numAssignments = numAssignments;\n        this.numComments = numComments;\n        this.numPeerReviews = numPeerReviews;\n        this.peerReviewsURL = peerReviewsURL;\n        this.relevanceRanking = relevanceRanking;\n        this.title = title;\n    }\n\n    /**\n     * Gets the URL value for this SearchResultElement.\n     *\n     * @return URL\n     */\n    public java.lang.String getURL() {\n        return URL;\n    }\n\n    /**\n     * Sets the URL value for this SearchResultElement.\n     *\n     * @param URL\n     */\n    public void setURL(java.lang.String URL) {\n        this.URL = URL;\n    }\n\n    /**\n     * Gets the assignmentsURL value for this SearchResultElement.\n     *\n     * @return assignmentsURL\n     */\n    public java.lang.String getAssignmentsURL() {\n        return assignmentsURL;\n    }\n\n    /**\n     * Sets the assignmentsURL value for this SearchResultElement.\n     *\n     * @param assignmentsURL\n     */\n    public void setAssignmentsURL(java.lang.String assignmentsURL) {\n        this.assignmentsURL = assignmentsURL;\n    }\n\n    /**\n     * Gets the authorName value for this SearchResultElement.\n     *\n     * @return authorName\n     */\n    public java.lang.String getAuthorName() {\n        return authorName;\n    }\n\n    /**\n     * Sets the authorName value for this SearchResultElement.\n     *\n     * @param authorName\n     */\n    public void setAuthorName(java.lang.String authorName) {\n        this.authorName = authorName;\n    }\n\n    /**\n     * Gets the avgComments value for this SearchResultElement.\n     *\n     * @return avgComments\n     */\n    public int getAvgComments() {\n        return avgComments;\n    }\n\n    /**\n     * Sets the avgComments value for this SearchResultElement.\n     *\n     * @param avgComments\n     */\n    public void setAvgComments(int avgComments) {\n        this.avgComments = avgComments;\n    }\n\n    /**\n     * Gets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @return avgPeerReviews\n     */\n    public int getAvgPeerReviews() {\n        return avgPeerReviews;\n    }\n\n    /**\n     * Sets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @param avgPeerReviews\n     */\n    public void setAvgPeerReviews(int avgPeerReviews) {\n        this.avgPeerReviews = avgPeerReviews;\n    }\n\n    /**\n     * Gets the award value for this SearchResultElement.\n     *\n     * @return award\n     */\n    public java.lang.String getAward() {\n        return award;\n    }\n\n    /**\n     * Sets the award value for this SearchResultElement.\n     *\n     * @param award\n     */\n    public void setAward(java.lang.String award) {\n        this.award = award;\n    }\n\n    /**\n     * Gets the commentsURL value for this SearchResultElement.\n     *\n     * @return commentsURL\n     */\n    public java.lang.String getCommentsURL() {\n        return commentsURL;\n    }\n\n    /**\n     * Sets the commentsURL value for this SearchResultElement.\n     *\n     * @param commentsURL\n     */\n    public void setCommentsURL(java.lang.String commentsURL) {\n        this.commentsURL = commentsURL;\n    }\n\n    /**\n     * Gets the creationDate value for this SearchResultElement.\n     *\n     * @return creationDate\n     */\n    public java.lang.String getCreationDate() {\n        return creationDate;\n    }\n\n    /**\n     * Sets the creationDate value for this SearchResultElement.\n     *\n     * @param creationDate\n     */\n    public void setCreationDate(java.lang.String creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Gets the description value for this SearchResultElement.\n     *\n     * @return description\n     */\n    public java.lang.String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the description value for this SearchResultElement.\n     *\n     * @param description\n     */\n    public void setDescription(java.lang.String description) {\n        this.description = description;\n    }\n\n    /**\n     * Gets the detailURL value for this SearchResultElement.\n     *\n     * @return detailURL\n     */\n    public java.lang.String getDetailURL() {\n        return detailURL;\n    }\n\n    /**\n     * Sets the detailURL value for this SearchResultElement.\n     *\n     * @param detailURL\n     */\n    public void setDetailURL(java.lang.String detailURL) {\n        this.detailURL = detailURL;\n    }\n\n    /**\n     * Gets the itemType value for this SearchResultElement.\n     *\n     * @return itemType\n     */\n    public java.lang.String getItemType() {\n        return itemType;\n    }\n\n    /**\n     * Sets the itemType value for this SearchResultElement.\n     *\n     * @param itemType\n     */\n    public void setItemType(java.lang.String itemType) {\n        this.itemType = itemType;\n    }\n\n    /**\n     * Gets the numAssignments value for this SearchResultElement.\n     *\n     * @return numAssignments\n     */\n    public int getNumAssignments() {\n        return numAssignments;\n    }\n\n    /**\n     * Sets the numAssignments value for this SearchResultElement.\n     *\n     * @param numAssignments\n     */\n    public void setNumAssignments(int numAssignments) {\n        this.numAssignments = numAssignments;\n    }\n\n    /**\n     * Gets the numComments value for this SearchResultElement.\n     *\n     * @return numComments\n     */\n    public int getNumComments() {\n        return numComments;\n    }\n\n    /**\n     * Sets the numComments value for this SearchResultElement.\n     *\n     * @param numComments\n     */\n    public void setNumComments(int numComments) {\n        this.numComments = numComments;\n    }\n\n    /**\n     * Gets the numPeerReviews value for this SearchResultElement.\n     *\n     * @return numPeerReviews\n     */\n    public int getNumPeerReviews() {\n        return numPeerReviews;\n    }\n\n    /**\n     * Sets the numPeerReviews value for this SearchResultElement.\n     *\n     * @param numPeerReviews\n     */\n    public void setNumPeerReviews(int numPeerReviews) {\n        this.numPeerReviews = numPeerReviews;\n    }\n\n    /**\n     * Gets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @return peerReviewsURL\n     */\n    public java.lang.String getPeerReviewsURL() {\n        return peerReviewsURL;\n    }\n\n    /**\n     * Sets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @param peerReviewsURL\n     */\n    public void setPeerReviewsURL(java.lang.String peerReviewsURL) {\n        this.peerReviewsURL = peerReviewsURL;\n    }\n\n    /**\n     * Gets the relevanceRanking value for this SearchResultElement.\n     *\n     * @return relevanceRanking\n     */\n    public int getRelevanceRanking() {\n        return relevanceRanking;\n    }\n\n    /**\n     * Sets the relevanceRanking value for this SearchResultElement.\n     *\n     * @param relevanceRanking\n     */\n    public void setRelevanceRanking(int relevanceRanking) {\n        this.relevanceRanking = relevanceRanking;\n    }\n\n    /**\n     * Gets the title value for this SearchResultElement.\n     *\n     * @return title\n     */\n    public java.lang.String getTitle() {\n        return title;\n    }\n\n    /**\n     * Sets the title value for this SearchResultElement.\n     *\n     * @param title\n     */\n    public void setTitle(java.lang.String title) {\n        this.title = title;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResultElement))\n            return false;\n        SearchResultElement other = (SearchResultElement) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.URL == null && other.getURL() == null) || (this.URL != null && this.URL.equals(other.getURL()))) && ((this.assignmentsURL == null && other.getAssignmentsURL() == null) || (this.assignmentsURL != null && this.assignmentsURL.equals(other.getAssignmentsURL()))) && ((this.authorName == null && other.getAuthorName() == null) || (this.authorName != null && this.authorName.equals(other.getAuthorName()))) && this.avgComments == other.getAvgComments() && this.avgPeerReviews == other.getAvgPeerReviews() && ((this.award == null && other.getAward() == null) || (this.award != null && this.award.equals(other.getAward()))) && ((this.commentsURL == null && other.getCommentsURL() == null) || (this.commentsURL != null && this.commentsURL.equals(other.getCommentsURL()))) && ((this.creationDate == null && other.getCreationDate() == null) || (this.creationDate != null && this.creationDate.equals(other.getCreationDate()))) && ((this.description == null && other.getDescription() == null) || (this.description != null && this.description.equals(other.getDescription()))) && ((this.detailURL == null && other.getDetailURL() == null) || (this.detailURL != null && this.detailURL.equals(other.getDetailURL()))) && ((this.itemType == null && other.getItemType() == null) || (this.itemType != null && this.itemType.equals(other.getItemType()))) && this.numAssignments == other.getNumAssignments() && this.numComments == other.getNumComments() && this.numPeerReviews == other.getNumPeerReviews() && ((this.peerReviewsURL == null && other.getPeerReviewsURL() == null) || (this.peerReviewsURL != null && this.peerReviewsURL.equals(other.getPeerReviewsURL()))) && this.relevanceRanking == other.getRelevanceRanking() && ((this.title == null && other.getTitle() == null) || (this.title != null && this.title.equals(other.getTitle())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getURL() != null) {\n            _hashCode += getURL().hashCode();\n        }\n        if (getAssignmentsURL() != null) {\n            _hashCode += getAssignmentsURL().hashCode();\n        }\n        if (getAuthorName() != null) {\n            _hashCode += getAuthorName().hashCode();\n        }\n        _hashCode += getAvgComments();\n        _hashCode += getAvgPeerReviews();\n        if (getAward() != null) {\n            _hashCode += getAward().hashCode();\n        }\n        if (getCommentsURL() != null) {\n            _hashCode += getCommentsURL().hashCode();\n        }\n        if (getCreationDate() != null) {\n            _hashCode += getCreationDate().hashCode();\n        }\n        if (getDescription() != null) {\n            _hashCode += getDescription().hashCode();\n        }\n        if (getDetailURL() != null) {\n            _hashCode += getDetailURL().hashCode();\n        }\n        if (getItemType() != null) {\n            _hashCode += getItemType().hashCode();\n        }\n        _hashCode += getNumAssignments();\n        _hashCode += getNumComments();\n        _hashCode += getNumPeerReviews();\n        if (getPeerReviewsURL() != null) {\n            _hashCode += getPeerReviewsURL().hashCode();\n        }\n        _hashCode += getRelevanceRanking();\n        if (getTitle() != null) {\n            _hashCode += getTitle().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResultElement.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"URL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"URL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"assignmentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"assignmentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"authorName\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"authorName\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"award\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"award\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"commentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"commentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"creationDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"creationDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"description\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"description\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"detailURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"detailURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"itemType\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"itemType\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numAssignments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numAssignments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"peerReviewsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"peerReviewsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"relevanceRanking\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"relevanceRanking\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"title\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"title\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElementTest0.java",
		"test_prompt": "// SearchResultElementTest0.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultElement}.\n* It contains ten unit test cases for the {@link SearchResultElement#equals(java.lang.Object)} method.\n*/\nclass SearchResultElementTest0 {"
	},
	{
		"original_code": "// SearchResultElement.java\n/**\n * SearchResultElement.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResultElement implements java.io.Serializable {\n\n    private java.lang.String URL;\n\n    private java.lang.String assignmentsURL;\n\n    private java.lang.String authorName;\n\n    private int avgComments;\n\n    private int avgPeerReviews;\n\n    private java.lang.String award;\n\n    private java.lang.String commentsURL;\n\n    private java.lang.String creationDate;\n\n    private java.lang.String description;\n\n    private java.lang.String detailURL;\n\n    private java.lang.String itemType;\n\n    private int numAssignments;\n\n    private int numComments;\n\n    private int numPeerReviews;\n\n    private java.lang.String peerReviewsURL;\n\n    private int relevanceRanking;\n\n    private java.lang.String title;\n\n    public SearchResultElement() {\n    }\n\n    public SearchResultElement(java.lang.String URL, java.lang.String assignmentsURL, java.lang.String authorName, int avgComments, int avgPeerReviews, java.lang.String award, java.lang.String commentsURL, java.lang.String creationDate, java.lang.String description, java.lang.String detailURL, java.lang.String itemType, int numAssignments, int numComments, int numPeerReviews, java.lang.String peerReviewsURL, int relevanceRanking, java.lang.String title) {\n        this.URL = URL;\n        this.assignmentsURL = assignmentsURL;\n        this.authorName = authorName;\n        this.avgComments = avgComments;\n        this.avgPeerReviews = avgPeerReviews;\n        this.award = award;\n        this.commentsURL = commentsURL;\n        this.creationDate = creationDate;\n        this.description = description;\n        this.detailURL = detailURL;\n        this.itemType = itemType;\n        this.numAssignments = numAssignments;\n        this.numComments = numComments;\n        this.numPeerReviews = numPeerReviews;\n        this.peerReviewsURL = peerReviewsURL;\n        this.relevanceRanking = relevanceRanking;\n        this.title = title;\n    }\n\n    /**\n     * Gets the URL value for this SearchResultElement.\n     *\n     * @return URL\n     */\n    public java.lang.String getURL() {\n        return URL;\n    }\n\n    /**\n     * Sets the URL value for this SearchResultElement.\n     *\n     * @param URL\n     */\n    public void setURL(java.lang.String URL) {\n        this.URL = URL;\n    }\n\n    /**\n     * Gets the assignmentsURL value for this SearchResultElement.\n     *\n     * @return assignmentsURL\n     */\n    public java.lang.String getAssignmentsURL() {\n        return assignmentsURL;\n    }\n\n    /**\n     * Sets the assignmentsURL value for this SearchResultElement.\n     *\n     * @param assignmentsURL\n     */\n    public void setAssignmentsURL(java.lang.String assignmentsURL) {\n        this.assignmentsURL = assignmentsURL;\n    }\n\n    /**\n     * Gets the authorName value for this SearchResultElement.\n     *\n     * @return authorName\n     */\n    public java.lang.String getAuthorName() {\n        return authorName;\n    }\n\n    /**\n     * Sets the authorName value for this SearchResultElement.\n     *\n     * @param authorName\n     */\n    public void setAuthorName(java.lang.String authorName) {\n        this.authorName = authorName;\n    }\n\n    /**\n     * Gets the avgComments value for this SearchResultElement.\n     *\n     * @return avgComments\n     */\n    public int getAvgComments() {\n        return avgComments;\n    }\n\n    /**\n     * Sets the avgComments value for this SearchResultElement.\n     *\n     * @param avgComments\n     */\n    public void setAvgComments(int avgComments) {\n        this.avgComments = avgComments;\n    }\n\n    /**\n     * Gets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @return avgPeerReviews\n     */\n    public int getAvgPeerReviews() {\n        return avgPeerReviews;\n    }\n\n    /**\n     * Sets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @param avgPeerReviews\n     */\n    public void setAvgPeerReviews(int avgPeerReviews) {\n        this.avgPeerReviews = avgPeerReviews;\n    }\n\n    /**\n     * Gets the award value for this SearchResultElement.\n     *\n     * @return award\n     */\n    public java.lang.String getAward() {\n        return award;\n    }\n\n    /**\n     * Sets the award value for this SearchResultElement.\n     *\n     * @param award\n     */\n    public void setAward(java.lang.String award) {\n        this.award = award;\n    }\n\n    /**\n     * Gets the commentsURL value for this SearchResultElement.\n     *\n     * @return commentsURL\n     */\n    public java.lang.String getCommentsURL() {\n        return commentsURL;\n    }\n\n    /**\n     * Sets the commentsURL value for this SearchResultElement.\n     *\n     * @param commentsURL\n     */\n    public void setCommentsURL(java.lang.String commentsURL) {\n        this.commentsURL = commentsURL;\n    }\n\n    /**\n     * Gets the creationDate value for this SearchResultElement.\n     *\n     * @return creationDate\n     */\n    public java.lang.String getCreationDate() {\n        return creationDate;\n    }\n\n    /**\n     * Sets the creationDate value for this SearchResultElement.\n     *\n     * @param creationDate\n     */\n    public void setCreationDate(java.lang.String creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Gets the description value for this SearchResultElement.\n     *\n     * @return description\n     */\n    public java.lang.String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the description value for this SearchResultElement.\n     *\n     * @param description\n     */\n    public void setDescription(java.lang.String description) {\n        this.description = description;\n    }\n\n    /**\n     * Gets the detailURL value for this SearchResultElement.\n     *\n     * @return detailURL\n     */\n    public java.lang.String getDetailURL() {\n        return detailURL;\n    }\n\n    /**\n     * Sets the detailURL value for this SearchResultElement.\n     *\n     * @param detailURL\n     */\n    public void setDetailURL(java.lang.String detailURL) {\n        this.detailURL = detailURL;\n    }\n\n    /**\n     * Gets the itemType value for this SearchResultElement.\n     *\n     * @return itemType\n     */\n    public java.lang.String getItemType() {\n        return itemType;\n    }\n\n    /**\n     * Sets the itemType value for this SearchResultElement.\n     *\n     * @param itemType\n     */\n    public void setItemType(java.lang.String itemType) {\n        this.itemType = itemType;\n    }\n\n    /**\n     * Gets the numAssignments value for this SearchResultElement.\n     *\n     * @return numAssignments\n     */\n    public int getNumAssignments() {\n        return numAssignments;\n    }\n\n    /**\n     * Sets the numAssignments value for this SearchResultElement.\n     *\n     * @param numAssignments\n     */\n    public void setNumAssignments(int numAssignments) {\n        this.numAssignments = numAssignments;\n    }\n\n    /**\n     * Gets the numComments value for this SearchResultElement.\n     *\n     * @return numComments\n     */\n    public int getNumComments() {\n        return numComments;\n    }\n\n    /**\n     * Sets the numComments value for this SearchResultElement.\n     *\n     * @param numComments\n     */\n    public void setNumComments(int numComments) {\n        this.numComments = numComments;\n    }\n\n    /**\n     * Gets the numPeerReviews value for this SearchResultElement.\n     *\n     * @return numPeerReviews\n     */\n    public int getNumPeerReviews() {\n        return numPeerReviews;\n    }\n\n    /**\n     * Sets the numPeerReviews value for this SearchResultElement.\n     *\n     * @param numPeerReviews\n     */\n    public void setNumPeerReviews(int numPeerReviews) {\n        this.numPeerReviews = numPeerReviews;\n    }\n\n    /**\n     * Gets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @return peerReviewsURL\n     */\n    public java.lang.String getPeerReviewsURL() {\n        return peerReviewsURL;\n    }\n\n    /**\n     * Sets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @param peerReviewsURL\n     */\n    public void setPeerReviewsURL(java.lang.String peerReviewsURL) {\n        this.peerReviewsURL = peerReviewsURL;\n    }\n\n    /**\n     * Gets the relevanceRanking value for this SearchResultElement.\n     *\n     * @return relevanceRanking\n     */\n    public int getRelevanceRanking() {\n        return relevanceRanking;\n    }\n\n    /**\n     * Sets the relevanceRanking value for this SearchResultElement.\n     *\n     * @param relevanceRanking\n     */\n    public void setRelevanceRanking(int relevanceRanking) {\n        this.relevanceRanking = relevanceRanking;\n    }\n\n    /**\n     * Gets the title value for this SearchResultElement.\n     *\n     * @return title\n     */\n    public java.lang.String getTitle() {\n        return title;\n    }\n\n    /**\n     * Sets the title value for this SearchResultElement.\n     *\n     * @param title\n     */\n    public void setTitle(java.lang.String title) {\n        this.title = title;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResultElement))\n            return false;\n        SearchResultElement other = (SearchResultElement) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.URL == null && other.getURL() == null) || (this.URL != null && this.URL.equals(other.getURL()))) && ((this.assignmentsURL == null && other.getAssignmentsURL() == null) || (this.assignmentsURL != null && this.assignmentsURL.equals(other.getAssignmentsURL()))) && ((this.authorName == null && other.getAuthorName() == null) || (this.authorName != null && this.authorName.equals(other.getAuthorName()))) && this.avgComments == other.getAvgComments() && this.avgPeerReviews == other.getAvgPeerReviews() && ((this.award == null && other.getAward() == null) || (this.award != null && this.award.equals(other.getAward()))) && ((this.commentsURL == null && other.getCommentsURL() == null) || (this.commentsURL != null && this.commentsURL.equals(other.getCommentsURL()))) && ((this.creationDate == null && other.getCreationDate() == null) || (this.creationDate != null && this.creationDate.equals(other.getCreationDate()))) && ((this.description == null && other.getDescription() == null) || (this.description != null && this.description.equals(other.getDescription()))) && ((this.detailURL == null && other.getDetailURL() == null) || (this.detailURL != null && this.detailURL.equals(other.getDetailURL()))) && ((this.itemType == null && other.getItemType() == null) || (this.itemType != null && this.itemType.equals(other.getItemType()))) && this.numAssignments == other.getNumAssignments() && this.numComments == other.getNumComments() && this.numPeerReviews == other.getNumPeerReviews() && ((this.peerReviewsURL == null && other.getPeerReviewsURL() == null) || (this.peerReviewsURL != null && this.peerReviewsURL.equals(other.getPeerReviewsURL()))) && this.relevanceRanking == other.getRelevanceRanking() && ((this.title == null && other.getTitle() == null) || (this.title != null && this.title.equals(other.getTitle())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getURL() != null) {\n            _hashCode += getURL().hashCode();\n        }\n        if (getAssignmentsURL() != null) {\n            _hashCode += getAssignmentsURL().hashCode();\n        }\n        if (getAuthorName() != null) {\n            _hashCode += getAuthorName().hashCode();\n        }\n        _hashCode += getAvgComments();\n        _hashCode += getAvgPeerReviews();\n        if (getAward() != null) {\n            _hashCode += getAward().hashCode();\n        }\n        if (getCommentsURL() != null) {\n            _hashCode += getCommentsURL().hashCode();\n        }\n        if (getCreationDate() != null) {\n            _hashCode += getCreationDate().hashCode();\n        }\n        if (getDescription() != null) {\n            _hashCode += getDescription().hashCode();\n        }\n        if (getDetailURL() != null) {\n            _hashCode += getDetailURL().hashCode();\n        }\n        if (getItemType() != null) {\n            _hashCode += getItemType().hashCode();\n        }\n        _hashCode += getNumAssignments();\n        _hashCode += getNumComments();\n        _hashCode += getNumPeerReviews();\n        if (getPeerReviewsURL() != null) {\n            _hashCode += getPeerReviewsURL().hashCode();\n        }\n        _hashCode += getRelevanceRanking();\n        if (getTitle() != null) {\n            _hashCode += getTitle().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResultElement.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"URL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"URL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"assignmentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"assignmentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"authorName\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"authorName\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"award\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"award\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"commentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"commentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"creationDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"creationDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"description\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"description\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"detailURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"detailURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"itemType\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"itemType\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numAssignments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numAssignments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"peerReviewsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"peerReviewsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"relevanceRanking\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"relevanceRanking\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"title\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"title\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElementTest1.java",
		"test_prompt": "// SearchResultElementTest1.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultElement}.\n* It contains ten unit test cases for the {@link SearchResultElement#hashCode()} method.\n*/\nclass SearchResultElementTest1 {"
	},
	{
		"original_code": "// SearchResultElement.java\n/**\n * SearchResultElement.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResultElement implements java.io.Serializable {\n\n    private java.lang.String URL;\n\n    private java.lang.String assignmentsURL;\n\n    private java.lang.String authorName;\n\n    private int avgComments;\n\n    private int avgPeerReviews;\n\n    private java.lang.String award;\n\n    private java.lang.String commentsURL;\n\n    private java.lang.String creationDate;\n\n    private java.lang.String description;\n\n    private java.lang.String detailURL;\n\n    private java.lang.String itemType;\n\n    private int numAssignments;\n\n    private int numComments;\n\n    private int numPeerReviews;\n\n    private java.lang.String peerReviewsURL;\n\n    private int relevanceRanking;\n\n    private java.lang.String title;\n\n    public SearchResultElement() {\n    }\n\n    public SearchResultElement(java.lang.String URL, java.lang.String assignmentsURL, java.lang.String authorName, int avgComments, int avgPeerReviews, java.lang.String award, java.lang.String commentsURL, java.lang.String creationDate, java.lang.String description, java.lang.String detailURL, java.lang.String itemType, int numAssignments, int numComments, int numPeerReviews, java.lang.String peerReviewsURL, int relevanceRanking, java.lang.String title) {\n        this.URL = URL;\n        this.assignmentsURL = assignmentsURL;\n        this.authorName = authorName;\n        this.avgComments = avgComments;\n        this.avgPeerReviews = avgPeerReviews;\n        this.award = award;\n        this.commentsURL = commentsURL;\n        this.creationDate = creationDate;\n        this.description = description;\n        this.detailURL = detailURL;\n        this.itemType = itemType;\n        this.numAssignments = numAssignments;\n        this.numComments = numComments;\n        this.numPeerReviews = numPeerReviews;\n        this.peerReviewsURL = peerReviewsURL;\n        this.relevanceRanking = relevanceRanking;\n        this.title = title;\n    }\n\n    /**\n     * Gets the URL value for this SearchResultElement.\n     *\n     * @return URL\n     */\n    public java.lang.String getURL() {\n        return URL;\n    }\n\n    /**\n     * Sets the URL value for this SearchResultElement.\n     *\n     * @param URL\n     */\n    public void setURL(java.lang.String URL) {\n        this.URL = URL;\n    }\n\n    /**\n     * Gets the assignmentsURL value for this SearchResultElement.\n     *\n     * @return assignmentsURL\n     */\n    public java.lang.String getAssignmentsURL() {\n        return assignmentsURL;\n    }\n\n    /**\n     * Sets the assignmentsURL value for this SearchResultElement.\n     *\n     * @param assignmentsURL\n     */\n    public void setAssignmentsURL(java.lang.String assignmentsURL) {\n        this.assignmentsURL = assignmentsURL;\n    }\n\n    /**\n     * Gets the authorName value for this SearchResultElement.\n     *\n     * @return authorName\n     */\n    public java.lang.String getAuthorName() {\n        return authorName;\n    }\n\n    /**\n     * Sets the authorName value for this SearchResultElement.\n     *\n     * @param authorName\n     */\n    public void setAuthorName(java.lang.String authorName) {\n        this.authorName = authorName;\n    }\n\n    /**\n     * Gets the avgComments value for this SearchResultElement.\n     *\n     * @return avgComments\n     */\n    public int getAvgComments() {\n        return avgComments;\n    }\n\n    /**\n     * Sets the avgComments value for this SearchResultElement.\n     *\n     * @param avgComments\n     */\n    public void setAvgComments(int avgComments) {\n        this.avgComments = avgComments;\n    }\n\n    /**\n     * Gets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @return avgPeerReviews\n     */\n    public int getAvgPeerReviews() {\n        return avgPeerReviews;\n    }\n\n    /**\n     * Sets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @param avgPeerReviews\n     */\n    public void setAvgPeerReviews(int avgPeerReviews) {\n        this.avgPeerReviews = avgPeerReviews;\n    }\n\n    /**\n     * Gets the award value for this SearchResultElement.\n     *\n     * @return award\n     */\n    public java.lang.String getAward() {\n        return award;\n    }\n\n    /**\n     * Sets the award value for this SearchResultElement.\n     *\n     * @param award\n     */\n    public void setAward(java.lang.String award) {\n        this.award = award;\n    }\n\n    /**\n     * Gets the commentsURL value for this SearchResultElement.\n     *\n     * @return commentsURL\n     */\n    public java.lang.String getCommentsURL() {\n        return commentsURL;\n    }\n\n    /**\n     * Sets the commentsURL value for this SearchResultElement.\n     *\n     * @param commentsURL\n     */\n    public void setCommentsURL(java.lang.String commentsURL) {\n        this.commentsURL = commentsURL;\n    }\n\n    /**\n     * Gets the creationDate value for this SearchResultElement.\n     *\n     * @return creationDate\n     */\n    public java.lang.String getCreationDate() {\n        return creationDate;\n    }\n\n    /**\n     * Sets the creationDate value for this SearchResultElement.\n     *\n     * @param creationDate\n     */\n    public void setCreationDate(java.lang.String creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Gets the description value for this SearchResultElement.\n     *\n     * @return description\n     */\n    public java.lang.String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the description value for this SearchResultElement.\n     *\n     * @param description\n     */\n    public void setDescription(java.lang.String description) {\n        this.description = description;\n    }\n\n    /**\n     * Gets the detailURL value for this SearchResultElement.\n     *\n     * @return detailURL\n     */\n    public java.lang.String getDetailURL() {\n        return detailURL;\n    }\n\n    /**\n     * Sets the detailURL value for this SearchResultElement.\n     *\n     * @param detailURL\n     */\n    public void setDetailURL(java.lang.String detailURL) {\n        this.detailURL = detailURL;\n    }\n\n    /**\n     * Gets the itemType value for this SearchResultElement.\n     *\n     * @return itemType\n     */\n    public java.lang.String getItemType() {\n        return itemType;\n    }\n\n    /**\n     * Sets the itemType value for this SearchResultElement.\n     *\n     * @param itemType\n     */\n    public void setItemType(java.lang.String itemType) {\n        this.itemType = itemType;\n    }\n\n    /**\n     * Gets the numAssignments value for this SearchResultElement.\n     *\n     * @return numAssignments\n     */\n    public int getNumAssignments() {\n        return numAssignments;\n    }\n\n    /**\n     * Sets the numAssignments value for this SearchResultElement.\n     *\n     * @param numAssignments\n     */\n    public void setNumAssignments(int numAssignments) {\n        this.numAssignments = numAssignments;\n    }\n\n    /**\n     * Gets the numComments value for this SearchResultElement.\n     *\n     * @return numComments\n     */\n    public int getNumComments() {\n        return numComments;\n    }\n\n    /**\n     * Sets the numComments value for this SearchResultElement.\n     *\n     * @param numComments\n     */\n    public void setNumComments(int numComments) {\n        this.numComments = numComments;\n    }\n\n    /**\n     * Gets the numPeerReviews value for this SearchResultElement.\n     *\n     * @return numPeerReviews\n     */\n    public int getNumPeerReviews() {\n        return numPeerReviews;\n    }\n\n    /**\n     * Sets the numPeerReviews value for this SearchResultElement.\n     *\n     * @param numPeerReviews\n     */\n    public void setNumPeerReviews(int numPeerReviews) {\n        this.numPeerReviews = numPeerReviews;\n    }\n\n    /**\n     * Gets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @return peerReviewsURL\n     */\n    public java.lang.String getPeerReviewsURL() {\n        return peerReviewsURL;\n    }\n\n    /**\n     * Sets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @param peerReviewsURL\n     */\n    public void setPeerReviewsURL(java.lang.String peerReviewsURL) {\n        this.peerReviewsURL = peerReviewsURL;\n    }\n\n    /**\n     * Gets the relevanceRanking value for this SearchResultElement.\n     *\n     * @return relevanceRanking\n     */\n    public int getRelevanceRanking() {\n        return relevanceRanking;\n    }\n\n    /**\n     * Sets the relevanceRanking value for this SearchResultElement.\n     *\n     * @param relevanceRanking\n     */\n    public void setRelevanceRanking(int relevanceRanking) {\n        this.relevanceRanking = relevanceRanking;\n    }\n\n    /**\n     * Gets the title value for this SearchResultElement.\n     *\n     * @return title\n     */\n    public java.lang.String getTitle() {\n        return title;\n    }\n\n    /**\n     * Sets the title value for this SearchResultElement.\n     *\n     * @param title\n     */\n    public void setTitle(java.lang.String title) {\n        this.title = title;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResultElement))\n            return false;\n        SearchResultElement other = (SearchResultElement) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.URL == null && other.getURL() == null) || (this.URL != null && this.URL.equals(other.getURL()))) && ((this.assignmentsURL == null && other.getAssignmentsURL() == null) || (this.assignmentsURL != null && this.assignmentsURL.equals(other.getAssignmentsURL()))) && ((this.authorName == null && other.getAuthorName() == null) || (this.authorName != null && this.authorName.equals(other.getAuthorName()))) && this.avgComments == other.getAvgComments() && this.avgPeerReviews == other.getAvgPeerReviews() && ((this.award == null && other.getAward() == null) || (this.award != null && this.award.equals(other.getAward()))) && ((this.commentsURL == null && other.getCommentsURL() == null) || (this.commentsURL != null && this.commentsURL.equals(other.getCommentsURL()))) && ((this.creationDate == null && other.getCreationDate() == null) || (this.creationDate != null && this.creationDate.equals(other.getCreationDate()))) && ((this.description == null && other.getDescription() == null) || (this.description != null && this.description.equals(other.getDescription()))) && ((this.detailURL == null && other.getDetailURL() == null) || (this.detailURL != null && this.detailURL.equals(other.getDetailURL()))) && ((this.itemType == null && other.getItemType() == null) || (this.itemType != null && this.itemType.equals(other.getItemType()))) && this.numAssignments == other.getNumAssignments() && this.numComments == other.getNumComments() && this.numPeerReviews == other.getNumPeerReviews() && ((this.peerReviewsURL == null && other.getPeerReviewsURL() == null) || (this.peerReviewsURL != null && this.peerReviewsURL.equals(other.getPeerReviewsURL()))) && this.relevanceRanking == other.getRelevanceRanking() && ((this.title == null && other.getTitle() == null) || (this.title != null && this.title.equals(other.getTitle())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getURL() != null) {\n            _hashCode += getURL().hashCode();\n        }\n        if (getAssignmentsURL() != null) {\n            _hashCode += getAssignmentsURL().hashCode();\n        }\n        if (getAuthorName() != null) {\n            _hashCode += getAuthorName().hashCode();\n        }\n        _hashCode += getAvgComments();\n        _hashCode += getAvgPeerReviews();\n        if (getAward() != null) {\n            _hashCode += getAward().hashCode();\n        }\n        if (getCommentsURL() != null) {\n            _hashCode += getCommentsURL().hashCode();\n        }\n        if (getCreationDate() != null) {\n            _hashCode += getCreationDate().hashCode();\n        }\n        if (getDescription() != null) {\n            _hashCode += getDescription().hashCode();\n        }\n        if (getDetailURL() != null) {\n            _hashCode += getDetailURL().hashCode();\n        }\n        if (getItemType() != null) {\n            _hashCode += getItemType().hashCode();\n        }\n        _hashCode += getNumAssignments();\n        _hashCode += getNumComments();\n        _hashCode += getNumPeerReviews();\n        if (getPeerReviewsURL() != null) {\n            _hashCode += getPeerReviewsURL().hashCode();\n        }\n        _hashCode += getRelevanceRanking();\n        if (getTitle() != null) {\n            _hashCode += getTitle().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResultElement.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"URL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"URL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"assignmentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"assignmentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"authorName\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"authorName\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"award\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"award\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"commentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"commentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"creationDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"creationDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"description\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"description\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"detailURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"detailURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"itemType\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"itemType\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numAssignments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numAssignments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"peerReviewsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"peerReviewsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"relevanceRanking\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"relevanceRanking\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"title\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"title\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElementTest2.java",
		"test_prompt": "// SearchResultElementTest2.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultElement}.\n* It contains ten unit test cases for the {@link SearchResultElement#getTypeDesc()} method.\n*/\nclass SearchResultElementTest2 {"
	},
	{
		"original_code": "// SearchResultElement.java\n/**\n * SearchResultElement.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResultElement implements java.io.Serializable {\n\n    private java.lang.String URL;\n\n    private java.lang.String assignmentsURL;\n\n    private java.lang.String authorName;\n\n    private int avgComments;\n\n    private int avgPeerReviews;\n\n    private java.lang.String award;\n\n    private java.lang.String commentsURL;\n\n    private java.lang.String creationDate;\n\n    private java.lang.String description;\n\n    private java.lang.String detailURL;\n\n    private java.lang.String itemType;\n\n    private int numAssignments;\n\n    private int numComments;\n\n    private int numPeerReviews;\n\n    private java.lang.String peerReviewsURL;\n\n    private int relevanceRanking;\n\n    private java.lang.String title;\n\n    public SearchResultElement() {\n    }\n\n    public SearchResultElement(java.lang.String URL, java.lang.String assignmentsURL, java.lang.String authorName, int avgComments, int avgPeerReviews, java.lang.String award, java.lang.String commentsURL, java.lang.String creationDate, java.lang.String description, java.lang.String detailURL, java.lang.String itemType, int numAssignments, int numComments, int numPeerReviews, java.lang.String peerReviewsURL, int relevanceRanking, java.lang.String title) {\n        this.URL = URL;\n        this.assignmentsURL = assignmentsURL;\n        this.authorName = authorName;\n        this.avgComments = avgComments;\n        this.avgPeerReviews = avgPeerReviews;\n        this.award = award;\n        this.commentsURL = commentsURL;\n        this.creationDate = creationDate;\n        this.description = description;\n        this.detailURL = detailURL;\n        this.itemType = itemType;\n        this.numAssignments = numAssignments;\n        this.numComments = numComments;\n        this.numPeerReviews = numPeerReviews;\n        this.peerReviewsURL = peerReviewsURL;\n        this.relevanceRanking = relevanceRanking;\n        this.title = title;\n    }\n\n    /**\n     * Gets the URL value for this SearchResultElement.\n     *\n     * @return URL\n     */\n    public java.lang.String getURL() {\n        return URL;\n    }\n\n    /**\n     * Sets the URL value for this SearchResultElement.\n     *\n     * @param URL\n     */\n    public void setURL(java.lang.String URL) {\n        this.URL = URL;\n    }\n\n    /**\n     * Gets the assignmentsURL value for this SearchResultElement.\n     *\n     * @return assignmentsURL\n     */\n    public java.lang.String getAssignmentsURL() {\n        return assignmentsURL;\n    }\n\n    /**\n     * Sets the assignmentsURL value for this SearchResultElement.\n     *\n     * @param assignmentsURL\n     */\n    public void setAssignmentsURL(java.lang.String assignmentsURL) {\n        this.assignmentsURL = assignmentsURL;\n    }\n\n    /**\n     * Gets the authorName value for this SearchResultElement.\n     *\n     * @return authorName\n     */\n    public java.lang.String getAuthorName() {\n        return authorName;\n    }\n\n    /**\n     * Sets the authorName value for this SearchResultElement.\n     *\n     * @param authorName\n     */\n    public void setAuthorName(java.lang.String authorName) {\n        this.authorName = authorName;\n    }\n\n    /**\n     * Gets the avgComments value for this SearchResultElement.\n     *\n     * @return avgComments\n     */\n    public int getAvgComments() {\n        return avgComments;\n    }\n\n    /**\n     * Sets the avgComments value for this SearchResultElement.\n     *\n     * @param avgComments\n     */\n    public void setAvgComments(int avgComments) {\n        this.avgComments = avgComments;\n    }\n\n    /**\n     * Gets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @return avgPeerReviews\n     */\n    public int getAvgPeerReviews() {\n        return avgPeerReviews;\n    }\n\n    /**\n     * Sets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @param avgPeerReviews\n     */\n    public void setAvgPeerReviews(int avgPeerReviews) {\n        this.avgPeerReviews = avgPeerReviews;\n    }\n\n    /**\n     * Gets the award value for this SearchResultElement.\n     *\n     * @return award\n     */\n    public java.lang.String getAward() {\n        return award;\n    }\n\n    /**\n     * Sets the award value for this SearchResultElement.\n     *\n     * @param award\n     */\n    public void setAward(java.lang.String award) {\n        this.award = award;\n    }\n\n    /**\n     * Gets the commentsURL value for this SearchResultElement.\n     *\n     * @return commentsURL\n     */\n    public java.lang.String getCommentsURL() {\n        return commentsURL;\n    }\n\n    /**\n     * Sets the commentsURL value for this SearchResultElement.\n     *\n     * @param commentsURL\n     */\n    public void setCommentsURL(java.lang.String commentsURL) {\n        this.commentsURL = commentsURL;\n    }\n\n    /**\n     * Gets the creationDate value for this SearchResultElement.\n     *\n     * @return creationDate\n     */\n    public java.lang.String getCreationDate() {\n        return creationDate;\n    }\n\n    /**\n     * Sets the creationDate value for this SearchResultElement.\n     *\n     * @param creationDate\n     */\n    public void setCreationDate(java.lang.String creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Gets the description value for this SearchResultElement.\n     *\n     * @return description\n     */\n    public java.lang.String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the description value for this SearchResultElement.\n     *\n     * @param description\n     */\n    public void setDescription(java.lang.String description) {\n        this.description = description;\n    }\n\n    /**\n     * Gets the detailURL value for this SearchResultElement.\n     *\n     * @return detailURL\n     */\n    public java.lang.String getDetailURL() {\n        return detailURL;\n    }\n\n    /**\n     * Sets the detailURL value for this SearchResultElement.\n     *\n     * @param detailURL\n     */\n    public void setDetailURL(java.lang.String detailURL) {\n        this.detailURL = detailURL;\n    }\n\n    /**\n     * Gets the itemType value for this SearchResultElement.\n     *\n     * @return itemType\n     */\n    public java.lang.String getItemType() {\n        return itemType;\n    }\n\n    /**\n     * Sets the itemType value for this SearchResultElement.\n     *\n     * @param itemType\n     */\n    public void setItemType(java.lang.String itemType) {\n        this.itemType = itemType;\n    }\n\n    /**\n     * Gets the numAssignments value for this SearchResultElement.\n     *\n     * @return numAssignments\n     */\n    public int getNumAssignments() {\n        return numAssignments;\n    }\n\n    /**\n     * Sets the numAssignments value for this SearchResultElement.\n     *\n     * @param numAssignments\n     */\n    public void setNumAssignments(int numAssignments) {\n        this.numAssignments = numAssignments;\n    }\n\n    /**\n     * Gets the numComments value for this SearchResultElement.\n     *\n     * @return numComments\n     */\n    public int getNumComments() {\n        return numComments;\n    }\n\n    /**\n     * Sets the numComments value for this SearchResultElement.\n     *\n     * @param numComments\n     */\n    public void setNumComments(int numComments) {\n        this.numComments = numComments;\n    }\n\n    /**\n     * Gets the numPeerReviews value for this SearchResultElement.\n     *\n     * @return numPeerReviews\n     */\n    public int getNumPeerReviews() {\n        return numPeerReviews;\n    }\n\n    /**\n     * Sets the numPeerReviews value for this SearchResultElement.\n     *\n     * @param numPeerReviews\n     */\n    public void setNumPeerReviews(int numPeerReviews) {\n        this.numPeerReviews = numPeerReviews;\n    }\n\n    /**\n     * Gets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @return peerReviewsURL\n     */\n    public java.lang.String getPeerReviewsURL() {\n        return peerReviewsURL;\n    }\n\n    /**\n     * Sets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @param peerReviewsURL\n     */\n    public void setPeerReviewsURL(java.lang.String peerReviewsURL) {\n        this.peerReviewsURL = peerReviewsURL;\n    }\n\n    /**\n     * Gets the relevanceRanking value for this SearchResultElement.\n     *\n     * @return relevanceRanking\n     */\n    public int getRelevanceRanking() {\n        return relevanceRanking;\n    }\n\n    /**\n     * Sets the relevanceRanking value for this SearchResultElement.\n     *\n     * @param relevanceRanking\n     */\n    public void setRelevanceRanking(int relevanceRanking) {\n        this.relevanceRanking = relevanceRanking;\n    }\n\n    /**\n     * Gets the title value for this SearchResultElement.\n     *\n     * @return title\n     */\n    public java.lang.String getTitle() {\n        return title;\n    }\n\n    /**\n     * Sets the title value for this SearchResultElement.\n     *\n     * @param title\n     */\n    public void setTitle(java.lang.String title) {\n        this.title = title;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResultElement))\n            return false;\n        SearchResultElement other = (SearchResultElement) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.URL == null && other.getURL() == null) || (this.URL != null && this.URL.equals(other.getURL()))) && ((this.assignmentsURL == null && other.getAssignmentsURL() == null) || (this.assignmentsURL != null && this.assignmentsURL.equals(other.getAssignmentsURL()))) && ((this.authorName == null && other.getAuthorName() == null) || (this.authorName != null && this.authorName.equals(other.getAuthorName()))) && this.avgComments == other.getAvgComments() && this.avgPeerReviews == other.getAvgPeerReviews() && ((this.award == null && other.getAward() == null) || (this.award != null && this.award.equals(other.getAward()))) && ((this.commentsURL == null && other.getCommentsURL() == null) || (this.commentsURL != null && this.commentsURL.equals(other.getCommentsURL()))) && ((this.creationDate == null && other.getCreationDate() == null) || (this.creationDate != null && this.creationDate.equals(other.getCreationDate()))) && ((this.description == null && other.getDescription() == null) || (this.description != null && this.description.equals(other.getDescription()))) && ((this.detailURL == null && other.getDetailURL() == null) || (this.detailURL != null && this.detailURL.equals(other.getDetailURL()))) && ((this.itemType == null && other.getItemType() == null) || (this.itemType != null && this.itemType.equals(other.getItemType()))) && this.numAssignments == other.getNumAssignments() && this.numComments == other.getNumComments() && this.numPeerReviews == other.getNumPeerReviews() && ((this.peerReviewsURL == null && other.getPeerReviewsURL() == null) || (this.peerReviewsURL != null && this.peerReviewsURL.equals(other.getPeerReviewsURL()))) && this.relevanceRanking == other.getRelevanceRanking() && ((this.title == null && other.getTitle() == null) || (this.title != null && this.title.equals(other.getTitle())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getURL() != null) {\n            _hashCode += getURL().hashCode();\n        }\n        if (getAssignmentsURL() != null) {\n            _hashCode += getAssignmentsURL().hashCode();\n        }\n        if (getAuthorName() != null) {\n            _hashCode += getAuthorName().hashCode();\n        }\n        _hashCode += getAvgComments();\n        _hashCode += getAvgPeerReviews();\n        if (getAward() != null) {\n            _hashCode += getAward().hashCode();\n        }\n        if (getCommentsURL() != null) {\n            _hashCode += getCommentsURL().hashCode();\n        }\n        if (getCreationDate() != null) {\n            _hashCode += getCreationDate().hashCode();\n        }\n        if (getDescription() != null) {\n            _hashCode += getDescription().hashCode();\n        }\n        if (getDetailURL() != null) {\n            _hashCode += getDetailURL().hashCode();\n        }\n        if (getItemType() != null) {\n            _hashCode += getItemType().hashCode();\n        }\n        _hashCode += getNumAssignments();\n        _hashCode += getNumComments();\n        _hashCode += getNumPeerReviews();\n        if (getPeerReviewsURL() != null) {\n            _hashCode += getPeerReviewsURL().hashCode();\n        }\n        _hashCode += getRelevanceRanking();\n        if (getTitle() != null) {\n            _hashCode += getTitle().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResultElement.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"URL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"URL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"assignmentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"assignmentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"authorName\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"authorName\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"award\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"award\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"commentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"commentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"creationDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"creationDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"description\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"description\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"detailURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"detailURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"itemType\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"itemType\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numAssignments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numAssignments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"peerReviewsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"peerReviewsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"relevanceRanking\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"relevanceRanking\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"title\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"title\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElementTest3.java",
		"test_prompt": "// SearchResultElementTest3.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultElement}.\n* It contains ten unit test cases for the {@link SearchResultElement#getSerializer(java.lang.String, java.lang.Class, javax.xml.namespace.QName)} method.\n*/\nclass SearchResultElementTest3 {"
	},
	{
		"original_code": "// SearchResultElement.java\n/**\n * SearchResultElement.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.type;\n\npublic class SearchResultElement implements java.io.Serializable {\n\n    private java.lang.String URL;\n\n    private java.lang.String assignmentsURL;\n\n    private java.lang.String authorName;\n\n    private int avgComments;\n\n    private int avgPeerReviews;\n\n    private java.lang.String award;\n\n    private java.lang.String commentsURL;\n\n    private java.lang.String creationDate;\n\n    private java.lang.String description;\n\n    private java.lang.String detailURL;\n\n    private java.lang.String itemType;\n\n    private int numAssignments;\n\n    private int numComments;\n\n    private int numPeerReviews;\n\n    private java.lang.String peerReviewsURL;\n\n    private int relevanceRanking;\n\n    private java.lang.String title;\n\n    public SearchResultElement() {\n    }\n\n    public SearchResultElement(java.lang.String URL, java.lang.String assignmentsURL, java.lang.String authorName, int avgComments, int avgPeerReviews, java.lang.String award, java.lang.String commentsURL, java.lang.String creationDate, java.lang.String description, java.lang.String detailURL, java.lang.String itemType, int numAssignments, int numComments, int numPeerReviews, java.lang.String peerReviewsURL, int relevanceRanking, java.lang.String title) {\n        this.URL = URL;\n        this.assignmentsURL = assignmentsURL;\n        this.authorName = authorName;\n        this.avgComments = avgComments;\n        this.avgPeerReviews = avgPeerReviews;\n        this.award = award;\n        this.commentsURL = commentsURL;\n        this.creationDate = creationDate;\n        this.description = description;\n        this.detailURL = detailURL;\n        this.itemType = itemType;\n        this.numAssignments = numAssignments;\n        this.numComments = numComments;\n        this.numPeerReviews = numPeerReviews;\n        this.peerReviewsURL = peerReviewsURL;\n        this.relevanceRanking = relevanceRanking;\n        this.title = title;\n    }\n\n    /**\n     * Gets the URL value for this SearchResultElement.\n     *\n     * @return URL\n     */\n    public java.lang.String getURL() {\n        return URL;\n    }\n\n    /**\n     * Sets the URL value for this SearchResultElement.\n     *\n     * @param URL\n     */\n    public void setURL(java.lang.String URL) {\n        this.URL = URL;\n    }\n\n    /**\n     * Gets the assignmentsURL value for this SearchResultElement.\n     *\n     * @return assignmentsURL\n     */\n    public java.lang.String getAssignmentsURL() {\n        return assignmentsURL;\n    }\n\n    /**\n     * Sets the assignmentsURL value for this SearchResultElement.\n     *\n     * @param assignmentsURL\n     */\n    public void setAssignmentsURL(java.lang.String assignmentsURL) {\n        this.assignmentsURL = assignmentsURL;\n    }\n\n    /**\n     * Gets the authorName value for this SearchResultElement.\n     *\n     * @return authorName\n     */\n    public java.lang.String getAuthorName() {\n        return authorName;\n    }\n\n    /**\n     * Sets the authorName value for this SearchResultElement.\n     *\n     * @param authorName\n     */\n    public void setAuthorName(java.lang.String authorName) {\n        this.authorName = authorName;\n    }\n\n    /**\n     * Gets the avgComments value for this SearchResultElement.\n     *\n     * @return avgComments\n     */\n    public int getAvgComments() {\n        return avgComments;\n    }\n\n    /**\n     * Sets the avgComments value for this SearchResultElement.\n     *\n     * @param avgComments\n     */\n    public void setAvgComments(int avgComments) {\n        this.avgComments = avgComments;\n    }\n\n    /**\n     * Gets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @return avgPeerReviews\n     */\n    public int getAvgPeerReviews() {\n        return avgPeerReviews;\n    }\n\n    /**\n     * Sets the avgPeerReviews value for this SearchResultElement.\n     *\n     * @param avgPeerReviews\n     */\n    public void setAvgPeerReviews(int avgPeerReviews) {\n        this.avgPeerReviews = avgPeerReviews;\n    }\n\n    /**\n     * Gets the award value for this SearchResultElement.\n     *\n     * @return award\n     */\n    public java.lang.String getAward() {\n        return award;\n    }\n\n    /**\n     * Sets the award value for this SearchResultElement.\n     *\n     * @param award\n     */\n    public void setAward(java.lang.String award) {\n        this.award = award;\n    }\n\n    /**\n     * Gets the commentsURL value for this SearchResultElement.\n     *\n     * @return commentsURL\n     */\n    public java.lang.String getCommentsURL() {\n        return commentsURL;\n    }\n\n    /**\n     * Sets the commentsURL value for this SearchResultElement.\n     *\n     * @param commentsURL\n     */\n    public void setCommentsURL(java.lang.String commentsURL) {\n        this.commentsURL = commentsURL;\n    }\n\n    /**\n     * Gets the creationDate value for this SearchResultElement.\n     *\n     * @return creationDate\n     */\n    public java.lang.String getCreationDate() {\n        return creationDate;\n    }\n\n    /**\n     * Sets the creationDate value for this SearchResultElement.\n     *\n     * @param creationDate\n     */\n    public void setCreationDate(java.lang.String creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    /**\n     * Gets the description value for this SearchResultElement.\n     *\n     * @return description\n     */\n    public java.lang.String getDescription() {\n        return description;\n    }\n\n    /**\n     * Sets the description value for this SearchResultElement.\n     *\n     * @param description\n     */\n    public void setDescription(java.lang.String description) {\n        this.description = description;\n    }\n\n    /**\n     * Gets the detailURL value for this SearchResultElement.\n     *\n     * @return detailURL\n     */\n    public java.lang.String getDetailURL() {\n        return detailURL;\n    }\n\n    /**\n     * Sets the detailURL value for this SearchResultElement.\n     *\n     * @param detailURL\n     */\n    public void setDetailURL(java.lang.String detailURL) {\n        this.detailURL = detailURL;\n    }\n\n    /**\n     * Gets the itemType value for this SearchResultElement.\n     *\n     * @return itemType\n     */\n    public java.lang.String getItemType() {\n        return itemType;\n    }\n\n    /**\n     * Sets the itemType value for this SearchResultElement.\n     *\n     * @param itemType\n     */\n    public void setItemType(java.lang.String itemType) {\n        this.itemType = itemType;\n    }\n\n    /**\n     * Gets the numAssignments value for this SearchResultElement.\n     *\n     * @return numAssignments\n     */\n    public int getNumAssignments() {\n        return numAssignments;\n    }\n\n    /**\n     * Sets the numAssignments value for this SearchResultElement.\n     *\n     * @param numAssignments\n     */\n    public void setNumAssignments(int numAssignments) {\n        this.numAssignments = numAssignments;\n    }\n\n    /**\n     * Gets the numComments value for this SearchResultElement.\n     *\n     * @return numComments\n     */\n    public int getNumComments() {\n        return numComments;\n    }\n\n    /**\n     * Sets the numComments value for this SearchResultElement.\n     *\n     * @param numComments\n     */\n    public void setNumComments(int numComments) {\n        this.numComments = numComments;\n    }\n\n    /**\n     * Gets the numPeerReviews value for this SearchResultElement.\n     *\n     * @return numPeerReviews\n     */\n    public int getNumPeerReviews() {\n        return numPeerReviews;\n    }\n\n    /**\n     * Sets the numPeerReviews value for this SearchResultElement.\n     *\n     * @param numPeerReviews\n     */\n    public void setNumPeerReviews(int numPeerReviews) {\n        this.numPeerReviews = numPeerReviews;\n    }\n\n    /**\n     * Gets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @return peerReviewsURL\n     */\n    public java.lang.String getPeerReviewsURL() {\n        return peerReviewsURL;\n    }\n\n    /**\n     * Sets the peerReviewsURL value for this SearchResultElement.\n     *\n     * @param peerReviewsURL\n     */\n    public void setPeerReviewsURL(java.lang.String peerReviewsURL) {\n        this.peerReviewsURL = peerReviewsURL;\n    }\n\n    /**\n     * Gets the relevanceRanking value for this SearchResultElement.\n     *\n     * @return relevanceRanking\n     */\n    public int getRelevanceRanking() {\n        return relevanceRanking;\n    }\n\n    /**\n     * Sets the relevanceRanking value for this SearchResultElement.\n     *\n     * @param relevanceRanking\n     */\n    public void setRelevanceRanking(int relevanceRanking) {\n        this.relevanceRanking = relevanceRanking;\n    }\n\n    /**\n     * Gets the title value for this SearchResultElement.\n     *\n     * @return title\n     */\n    public java.lang.String getTitle() {\n        return title;\n    }\n\n    /**\n     * Sets the title value for this SearchResultElement.\n     *\n     * @param title\n     */\n    public void setTitle(java.lang.String title) {\n        this.title = title;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof SearchResultElement))\n            return false;\n        SearchResultElement other = (SearchResultElement) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && ((this.URL == null && other.getURL() == null) || (this.URL != null && this.URL.equals(other.getURL()))) && ((this.assignmentsURL == null && other.getAssignmentsURL() == null) || (this.assignmentsURL != null && this.assignmentsURL.equals(other.getAssignmentsURL()))) && ((this.authorName == null && other.getAuthorName() == null) || (this.authorName != null && this.authorName.equals(other.getAuthorName()))) && this.avgComments == other.getAvgComments() && this.avgPeerReviews == other.getAvgPeerReviews() && ((this.award == null && other.getAward() == null) || (this.award != null && this.award.equals(other.getAward()))) && ((this.commentsURL == null && other.getCommentsURL() == null) || (this.commentsURL != null && this.commentsURL.equals(other.getCommentsURL()))) && ((this.creationDate == null && other.getCreationDate() == null) || (this.creationDate != null && this.creationDate.equals(other.getCreationDate()))) && ((this.description == null && other.getDescription() == null) || (this.description != null && this.description.equals(other.getDescription()))) && ((this.detailURL == null && other.getDetailURL() == null) || (this.detailURL != null && this.detailURL.equals(other.getDetailURL()))) && ((this.itemType == null && other.getItemType() == null) || (this.itemType != null && this.itemType.equals(other.getItemType()))) && this.numAssignments == other.getNumAssignments() && this.numComments == other.getNumComments() && this.numPeerReviews == other.getNumPeerReviews() && ((this.peerReviewsURL == null && other.getPeerReviewsURL() == null) || (this.peerReviewsURL != null && this.peerReviewsURL.equals(other.getPeerReviewsURL()))) && this.relevanceRanking == other.getRelevanceRanking() && ((this.title == null && other.getTitle() == null) || (this.title != null && this.title.equals(other.getTitle())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getURL() != null) {\n            _hashCode += getURL().hashCode();\n        }\n        if (getAssignmentsURL() != null) {\n            _hashCode += getAssignmentsURL().hashCode();\n        }\n        if (getAuthorName() != null) {\n            _hashCode += getAuthorName().hashCode();\n        }\n        _hashCode += getAvgComments();\n        _hashCode += getAvgPeerReviews();\n        if (getAward() != null) {\n            _hashCode += getAward().hashCode();\n        }\n        if (getCommentsURL() != null) {\n            _hashCode += getCommentsURL().hashCode();\n        }\n        if (getCreationDate() != null) {\n            _hashCode += getCreationDate().hashCode();\n        }\n        if (getDescription() != null) {\n            _hashCode += getDescription().hashCode();\n        }\n        if (getDetailURL() != null) {\n            _hashCode += getDetailURL().hashCode();\n        }\n        if (getItemType() != null) {\n            _hashCode += getItemType().hashCode();\n        }\n        _hashCode += getNumAssignments();\n        _hashCode += getNumComments();\n        _hashCode += getNumPeerReviews();\n        if (getPeerReviewsURL() != null) {\n            _hashCode += getPeerReviewsURL().hashCode();\n        }\n        _hashCode += getRelevanceRanking();\n        if (getTitle() != null) {\n            _hashCode += getTitle().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(SearchResultElement.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"URL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"URL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"assignmentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"assignmentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"authorName\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"authorName\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"avgPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"avgPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"award\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"award\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"commentsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"commentsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"creationDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"creationDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"description\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"description\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"detailURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"detailURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"itemType\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"itemType\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numAssignments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numAssignments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numComments\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numComments\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"numPeerReviews\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"numPeerReviews\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"peerReviewsURL\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"peerReviewsURL\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"relevanceRanking\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"relevanceRanking\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"title\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"\", \"title\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/type/SearchResultElementTest4.java",
		"test_prompt": "// SearchResultElementTest4.java\npackage org.merlot.fedsearch.type;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchResultElement}.\n* It contains ten unit test cases for the {@link SearchResultElement#getDeserializer(java.lang.String, java.lang.Class, javax.xml.namespace.QName)} method.\n*/\nclass SearchResultElementTest4 {"
	},
	{
		"original_code": "// SearchServiceBindingStub.java\n/**\n * SearchServiceBindingStub.java\n *\n * This file was auto-generated from WSDL\n * by the Apache Axis 1.2 May 03, 2005 (02:20:24 EDT) WSDL2Java emitter.\n */\npackage org.merlot.fedsearch.wsdl;\n\npublic class SearchServiceBindingStub extends org.apache.axis.client.Stub implements org.merlot.fedsearch.wsdl.SearchService {\n\n    private java.util.Vector cachedSerClasses = new java.util.Vector();\n\n    private java.util.Vector cachedSerQNames = new java.util.Vector();\n\n    private java.util.Vector cachedSerFactories = new java.util.Vector();\n\n    private java.util.Vector cachedDeserFactories = new java.util.Vector();\n\n    static org.apache.axis.description.OperationDesc[] _operations;\n\n    static {\n        _operations = new org.apache.axis.description.OperationDesc[1];\n        _initOperationDesc1();\n    }\n\n    private static void _initOperationDesc1() {\n        org.apache.axis.description.OperationDesc oper;\n        org.apache.axis.description.ParameterDesc param;\n        oper = new org.apache.axis.description.OperationDesc();\n        oper.setName(\"doSearch\");\n        param = new org.apache.axis.description.ParameterDesc(new javax.xml.namespace.QName(\"\", \"String_1\"), org.apache.axis.description.ParameterDesc.IN, new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"), java.lang.String.class, false, false);\n        oper.addParameter(param);\n        param = new org.apache.axis.description.ParameterDesc(new javax.xml.namespace.QName(\"\", \"String_2\"), org.apache.axis.description.ParameterDesc.IN, new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"), java.lang.String.class, false, false);\n        oper.addParameter(param);\n        param = new org.apache.axis.description.ParameterDesc(new javax.xml.namespace.QName(\"\", \"int_3\"), org.apache.axis.description.ParameterDesc.IN, new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"), int.class, false, false);\n        oper.addParameter(param);\n        param = new org.apache.axis.description.ParameterDesc(new javax.xml.namespace.QName(\"\", \"int_4\"), org.apache.axis.description.ParameterDesc.IN, new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"int\"), int.class, false, false);\n        oper.addParameter(param);\n        oper.setReturnType(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\"));\n        oper.setReturnClass(org.merlot.fedsearch.type.SearchResult.class);\n        oper.setReturnQName(new javax.xml.namespace.QName(\"\", \"result\"));\n        oper.setStyle(org.apache.axis.constants.Style.RPC);\n        oper.setUse(org.apache.axis.constants.Use.ENCODED);\n        _operations[0] = oper;\n    }\n\n    public SearchServiceBindingStub() throws org.apache.axis.AxisFault {\n        this(null);\n    }\n\n    public SearchServiceBindingStub(java.net.URL endpointURL, javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {\n        this(service);\n        super.cachedEndpoint = endpointURL;\n    }\n\n    public SearchServiceBindingStub(javax.xml.rpc.Service service) throws org.apache.axis.AxisFault {\n        if (service == null) {\n            super.service = new org.apache.axis.client.Service();\n        } else {\n            super.service = service;\n        }\n        ((org.apache.axis.client.Service) super.service).setTypeMappingVersion(\"1.2\");\n        java.lang.Class cls;\n        javax.xml.namespace.QName qName;\n        javax.xml.namespace.QName qName2;\n        java.lang.Class beansf = org.apache.axis.encoding.ser.BeanSerializerFactory.class;\n        java.lang.Class beandf = org.apache.axis.encoding.ser.BeanDeserializerFactory.class;\n        java.lang.Class enumsf = org.apache.axis.encoding.ser.EnumSerializerFactory.class;\n        java.lang.Class enumdf = org.apache.axis.encoding.ser.EnumDeserializerFactory.class;\n        java.lang.Class arraysf = org.apache.axis.encoding.ser.ArraySerializerFactory.class;\n        java.lang.Class arraydf = org.apache.axis.encoding.ser.ArrayDeserializerFactory.class;\n        java.lang.Class simplesf = org.apache.axis.encoding.ser.SimpleSerializerFactory.class;\n        java.lang.Class simpledf = org.apache.axis.encoding.ser.SimpleDeserializerFactory.class;\n        java.lang.Class simplelistsf = org.apache.axis.encoding.ser.SimpleListSerializerFactory.class;\n        java.lang.Class simplelistdf = org.apache.axis.encoding.ser.SimpleListDeserializerFactory.class;\n        qName = new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"ArrayOfSearchResultElement\");\n        cachedSerQNames.add(qName);\n        cls = org.merlot.fedsearch.type.SearchResultElement[].class;\n        cachedSerClasses.add(cls);\n        qName = new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\");\n        qName2 = null;\n        cachedSerFactories.add(new org.apache.axis.encoding.ser.ArraySerializerFactory(qName, qName2));\n        cachedDeserFactories.add(new org.apache.axis.encoding.ser.ArrayDeserializerFactory());\n        qName = new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResult\");\n        cachedSerQNames.add(qName);\n        cls = org.merlot.fedsearch.type.SearchResult.class;\n        cachedSerClasses.add(cls);\n        cachedSerFactories.add(beansf);\n        cachedDeserFactories.add(beandf);\n        qName = new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/type\", \"SearchResultElement\");\n        cachedSerQNames.add(qName);\n        cls = org.merlot.fedsearch.type.SearchResultElement.class;\n        cachedSerClasses.add(cls);\n        cachedSerFactories.add(beansf);\n        cachedDeserFactories.add(beandf);\n    }\n\n    protected org.apache.axis.client.Call createCall() throws java.rmi.RemoteException {\n        try {\n            org.apache.axis.client.Call _call = super._createCall();\n            if (super.maintainSessionSet) {\n                _call.setMaintainSession(super.maintainSession);\n            }\n            if (super.cachedUsername != null) {\n                _call.setUsername(super.cachedUsername);\n            }\n            if (super.cachedPassword != null) {\n                _call.setPassword(super.cachedPassword);\n            }\n            if (super.cachedEndpoint != null) {\n                _call.setTargetEndpointAddress(super.cachedEndpoint);\n            }\n            if (super.cachedTimeout != null) {\n                _call.setTimeout(super.cachedTimeout);\n            }\n            if (super.cachedPortName != null) {\n                _call.setPortName(super.cachedPortName);\n            }\n            java.util.Enumeration keys = super.cachedProperties.keys();\n            while (keys.hasMoreElements()) {\n                java.lang.String key = (java.lang.String) keys.nextElement();\n                _call.setProperty(key, super.cachedProperties.get(key));\n            }\n            // All the type mapping information is registered\n            // when the first call is made.\n            // The type mapping information is actually registered in\n            // the TypeMappingRegistry of the service, which\n            // is the reason why registration is only needed for the first call.\n            synchronized (this) {\n                if (firstCall()) {\n                    // must set encoding style before registering serializers\n                    _call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);\n                    _call.setEncodingStyle(org.apache.axis.Constants.URI_SOAP11_ENC);\n                    for (int i = 0; i < cachedSerFactories.size(); ++i) {\n                        java.lang.Class cls = (java.lang.Class) cachedSerClasses.get(i);\n                        javax.xml.namespace.QName qName = (javax.xml.namespace.QName) cachedSerQNames.get(i);\n                        java.lang.Object x = cachedSerFactories.get(i);\n                        if (x instanceof Class) {\n                            java.lang.Class sf = (java.lang.Class) cachedSerFactories.get(i);\n                            java.lang.Class df = (java.lang.Class) cachedDeserFactories.get(i);\n                            _call.registerTypeMapping(cls, qName, sf, df, false);\n                        } else if (x instanceof javax.xml.rpc.encoding.SerializerFactory) {\n                            org.apache.axis.encoding.SerializerFactory sf = (org.apache.axis.encoding.SerializerFactory) cachedSerFactories.get(i);\n                            org.apache.axis.encoding.DeserializerFactory df = (org.apache.axis.encoding.DeserializerFactory) cachedDeserFactories.get(i);\n                            _call.registerTypeMapping(cls, qName, sf, df, false);\n                        }\n                    }\n                }\n            }\n            return _call;\n        } catch (java.lang.Throwable _t) {\n            throw new org.apache.axis.AxisFault(\"Failure trying to get the Call object\", _t);\n        }\n    }\n\n    public org.merlot.fedsearch.type.SearchResult doSearch(java.lang.String string_1, java.lang.String string_2, int int_3, int int_4) throws java.rmi.RemoteException {\n        if (super.cachedEndpoint == null) {\n            throw new org.apache.axis.NoEndPointException();\n        }\n        org.apache.axis.client.Call _call = createCall();\n        _call.setOperation(_operations[0]);\n        _call.setUseSOAPAction(true);\n        _call.setSOAPActionURI(\"\");\n        _call.setSOAPVersion(org.apache.axis.soap.SOAPConstants.SOAP11_CONSTANTS);\n        _call.setOperationName(new javax.xml.namespace.QName(\"http://fedsearch.merlot.org/wsdl\", \"doSearch\"));\n        _call.setProperty(org.apache.axis.AxisEngine.PROP_DOMULTIREFS, Boolean.FALSE);\n        setAttachments(_call);\n        try {\n            java.lang.Object _resp = _call.invoke(new java.lang.Object[] { string_1, string_2, new java.lang.Integer(int_3), new java.lang.Integer(int_4) });\n            if (_resp instanceof java.rmi.RemoteException) {\n                throw (java.rmi.RemoteException) _resp;\n            } else {\n                extractAttachments(_call);\n                try {\n                    return (org.merlot.fedsearch.type.SearchResult) _resp;\n                } catch (java.lang.Exception _exception) {\n                    return (org.merlot.fedsearch.type.SearchResult) org.apache.axis.utils.JavaUtils.convert(_resp, org.merlot.fedsearch.type.SearchResult.class);\n                }\n            }\n        } catch (org.apache.axis.AxisFault axisFaultException) {\n            throw axisFaultException;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/96_heal/src/main/java/org/merlot/fedsearch/wsdl/SearchServiceBindingStubTest.java",
		"test_prompt": "// SearchServiceBindingStubTest.java\npackage org.merlot.fedsearch.wsdl;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchServiceBindingStub}.\n* It contains ten unit test cases for the {@link SearchServiceBindingStub#doSearch(java.lang.String, java.lang.String, int, int)} method.\n*/\nclass SearchServiceBindingStubTest {"
	}
]