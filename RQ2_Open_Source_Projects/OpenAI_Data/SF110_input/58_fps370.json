[
	{
		"original_code": "// Fps370Panel.java\n/**\n *  Fps370Panel\n *  3D game template panel\n *\n *  Created for cpsc370 at Chapman University\n *  http://www.gamedev370.com\n *  (c) copyright 2006 - W. Wood Harter\n *\n *  Licensed under GNU General Public License\n *  http://www.gnu.org\n *\n *  This is the main panel for fps370.\n *  This needs to be refactored into a bunch of subclasses.\n * *\n *  In order to run this you will have to download the Milkshap model loader\n *  http://home.earthlink.net/~kduling/Milkshape/\n *  Place the MS3DLoader-1.0.8.jar in the fps370/lib/ext directory.\n */\npackage fps370;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\nimport javax.media.j3d.*;\nimport javax.swing.*;\nimport javax.vecmath.*;\nimport com.sun.j3d.utils.universe.*;\nimport com.sun.j3d.utils.geometry.*;\nimport com.sun.j3d.utils.image.*;\nimport com.sun.j3d.utils.behaviors.mouse.*;\nimport com.sun.j3d.utils.picking.*;\nimport com.sun.j3d.loaders.*;\n//import com.mnstarfire.loaders3d.Loader3DS;\nimport com.glyphein.j3d.loaders.milkshape.MS3DLoader;\nimport teder.*;\n\npublic class Fps370Panel extends JPanel implements KeyListener {\n\n    // parent window\n    Fps370 parent;\n\n    // 3d frame and universe\n    SimpleUniverse su;\n\n    Canvas3D c3d;\n\n    // scene graph to display\n    BranchGroup bgMain;\n\n    TransformGroup tgFloor;\n\n    AxisAngle4f aaFloor;\n\n    Transform3D t3dFloorRotate;\n\n    // temporary holding variables\n    Transform3D t3dTmp;\n\n    Transform3D t3dTmp2;\n\n    Vector3f v3fTmp;\n\n    Vector3f v3fTmp2;\n\n    Vector3f v3fTmp3;\n\n    Matrix4f m3fTmp1;\n\n    Matrix4f m3fTmp2;\n\n    BoundingSphere boundsMain;\n\n    Sphere sphere;\n\n    TransformGroup tgSphere;\n\n    Transform3D t3dSphereTranslate;\n\n    Vector3f vSphereVel = new Vector3f(0.0f, 0.0f, 0.0f);\n\n    Vector3f vSpherePos = new Vector3f(6.5f, 3.2f, 5.0f);\n\n    Vector3f vViewPos = new Vector3f(0.0f, 0.5f, 5.0f);\n\n    Vector3f vViewOri = new Vector3f(0.0f, 1.0f, 1.0f);\n\n    private static final float TILE_WIDTH = 1.0f;\n\n    private static final int NUM_TILE_TEXTURES = 10;\n\n    Appearance[] tileTextures;\n\n    Appearance textureStone;\n\n    TederLayer tl;\n\n    TederData td;\n\n    TransformGroup tgView;\n\n    // the current YPR rotation\n    Transform3D t3dYPR;\n\n    // temporary calculatiosn for YPR changes\n    AxisAngle4f aaYPR;\n\n    // the angle to look in the viewport\n    float lookUpAngle = 5.0f;\n\n    private static final float TURNDELTA = 0.5f;\n\n    boolean keyLeft;\n\n    boolean keyRight;\n\n    boolean keyForward;\n\n    boolean keyBackward;\n\n    boolean keyStrafeLeft;\n\n    boolean keyStrafeRight;\n\n    boolean keyLookUp;\n\n    boolean keyLookDown;\n\n    // mouse movement\n    int diffx, diffy;\n\n    int lastMouseX, lastMouseY;\n\n    int offcenterX, offcenterY;\n\n    Robot robot;\n\n    // collision detection with map\n    BranchGroup bgMap;\n\n    PickCylinderRay pickCylinder;\n\n    PickTool pickTool;\n\n    // HUD\n    PlatformGeometry bgHud;\n\n    Point3f[] hudPlane;\n\n    Appearance appHud;\n\n    Shape3D shapeHud;\n\n    Texture2D textureHud;\n\n    // the 2d texture image\n    ImageComponent2D icHud;\n\n    HudUpdater hudUpdater;\n\n    Image imgHudBack;\n\n    BufferedImage imgHud;\n\n    public Fps370Panel(Fps370 parentInit) {\n        parent = parentInit;\n        setLayout(new BorderLayout());\n        setPreferredSize(new Dimension(800, 600));\n        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();\n        c3d = new Canvas3D(config);\n        add(\"Center\", c3d);\n        // allow the canvas to get focus and give it focus\n        c3d.setFocusable(true);\n        c3d.requestFocus();\n        c3d.addKeyListener(this);\n        su = new SimpleUniverse(c3d);\n        t3dTmp = new Transform3D();\n        t3dTmp2 = new Transform3D();\n        v3fTmp = new Vector3f(0, 0, 0);\n        v3fTmp2 = new Vector3f(0, 0, 0);\n        v3fTmp3 = new Vector3f(0, 0, 0);\n        m3fTmp1 = new Matrix4f();\n        m3fTmp2 = new Matrix4f();\n        //m3fYPR = new Matrix4f();\n        t3dYPR = new Transform3D();\n        aaYPR = new AxisAngle4f();\n        try {\n            robot = new Robot();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n        td = new TederData(30, 30, 64, 64, \"images/floor/tiles.gif\", this);\n        loadTileTextures();\n        createSceneGraph();\n        initViewPosition();\n    }\n\n    // create appearances with each individual tile\n    // used to texture the individual floor tiles\n    public void loadTileTextures() {\n        tileTextures = new Appearance[NUM_TILE_TEXTURES];\n        int i;\n        for (i = 0; i < NUM_TILE_TEXTURES; i++) {\n            tileTextures[i] = new Appearance();\n            // mix the texture and the material colour\n            TextureAttributes ta = new TextureAttributes();\n            //ta.setTextureMode(TextureAttributes.MODULATE);\n            ta.setTextureMode(TextureAttributes.REPLACE);\n            tileTextures[i].setTextureAttributes(ta);\n            // load and set the texture\n            TextureLoader loader = new TextureLoader(\"images/floor/tile\" + i + \".jpg\", null);\n            //TextureLoader loader = new TextureLoader(\"images/floor/stone.jpg\", null);\n            Texture2D texture = (Texture2D) loader.getTexture();\n            // set the texture\n            tileTextures[i].setTexture(texture);\n            // set a default white material\n            Material mat = new Material();\n            // lighting switched on\n            mat.setLightingEnable(true);\n            tileTextures[i].setMaterial(mat);\n        }\n        textureStone = new Appearance();\n        // the default texture if one isn't given (ie. -1)\n        // mix the texture and the material colour\n        TextureAttributes ta = new TextureAttributes();\n        //ta.setTextureMode(TextureAttributes.MODULATE);\n        ta.setTextureMode(TextureAttributes.REPLACE);\n        textureStone.setTextureAttributes(ta);\n        // load and set the texture\n        TextureLoader loader = new TextureLoader(\"images/floor/stone.jpg\", null);\n        //TextureLoader loader = new TextureLoader(\"images/floor/stone.jpg\", null);\n        Texture2D texture = (Texture2D) loader.getTexture();\n        // set the texture\n        textureStone.setTexture(texture);\n        // set a default white material\n        Material mat = new Material();\n        // lighting switched on\n        mat.setLightingEnable(true);\n        textureStone.setMaterial(mat);\n    }\n\n    public Scene loadModel(String fname) {\n        Scene theScene = null;\n        // setup a file name \"fileName\"\n        try {\n            //Loader3DS loader = new Loader3DS();\n            // optional options to be used\n            //loader.setLogging(true); // turns on writing a log file\n            //loader.setDetail(7); // sets level of detail of report log\n            //loader.setTextureLightingOn(); // turns on texture modulate mode\n            //loader.setTexturePath(\"models\"); // optional alternate path to find texture files\n            // loader.noTextures(); // if you do not want to load textures\n            //theScene = loader.load(fname);\n            // milkshape loader\n            File file = new java.io.File(fname);\n            if (// figure out the base path\n            file.getParent().length() > 0) {\n                Loader loader = new MS3DLoader(MS3DLoader.LOAD_ALL);\n                loader.setBasePath(file.getParent() + java.io.File.separator);\n                theScene = loader.load(file.getName());\n                //BranchGroup group = scene.getSceneGroup();\n            }\n            // load a sphere model twice for testing\n        } catch (FileNotFoundException fnf) {\n            // Couldn't find the file you requested - deal with it!\n            fnf.printStackTrace();\n        }\n        return theScene;\n    }\n\n    public void createSceneGraph() {\n        // create a new scene branch\n        bgMain = new BranchGroup();\n        boundsMain = new BoundingSphere(new Point3d(0, 0, 0), 300);\n        createLights();\n        // create the temporary location for sphere translation - used in tick\n        // create a sphere\n        t3dSphereTranslate = new Transform3D();\n        t3dSphereTranslate.set(vSpherePos);\n        tgSphere = new TransformGroup(t3dSphereTranslate);\n        tgSphere.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);\n        tgSphere.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);\n        sphere = new Sphere(1.0f);\n        tgSphere.addChild(sphere);\n        // allow picking on the sphere\n        PickTool.setCapabilities(sphere.getShape(), PickTool.INTERSECT_COORD);\n        bgMain.addChild(tgSphere);\n        // create the floor\n        /*\n     * I sort of decided to only use models to build the map\n    aaFloor = new AxisAngle4f(0.0f, 1.0f, 0.0f, 0.0f);\n    t3dFloorRotate = new Transform3D();\n    t3dFloorRotate.setRotation(aaFloor);\n    tgFloor = new TransformGroup();\n    tgFloor.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);\n    tgFloor.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);\n    tgFloor.setTransform(t3dFloorRotate);\n    \n\n    // add a floor tile\n    addFloorTiles(tgFloor);\n    bgMain.addChild(tgFloor);\n    \n    addFloorTiles(tgFloor);\n    */\n        ViewingPlatform vp = su.getViewingPlatform();\n        // view point TG\n        tgView = vp.getViewPlatformTransform();\n        KeyUpBehavior bup = new KeyUpBehavior(this);\n        bup.setSchedulingBounds(boundsMain);\n        bgMain.addChild(bup);\n        KeyDownBehavior bdn = new KeyDownBehavior(this);\n        bdn.setSchedulingBounds(boundsMain);\n        bgMain.addChild(bdn);\n        MouseMoveBehavior mmb = new MouseMoveBehavior(this);\n        mmb.setSchedulingBounds(boundsMain);\n        bgMain.addChild(mmb);\n        // create the ticker behavior for the scene\n        Fps370Ticker tt = new Fps370Ticker(20, this);\n        tt.setSchedulingBounds(boundsMain);\n        bgMain.addChild(tt);\n        // get the temple model\n        Scene sc = loadModel(\"./models/map2.ms3d\");\n        // need to scale the model some, then slide it up and towards the origin\n        // allow picking on the cube for collision detection\n        bgMap = sc.getSceneGroup();\n        //bgModel.setPickable(true);\n        pickableModel(bgMap);\n        //PickTool.setCapabilities(bgModel,PickTool.INTERSECT_COORD);\n        bgMain.addChild(bgMap);\n        // used to see aim location during debugging\n        //addPickCylinder();\n        // add the hud to the display\n        addHud();\n        bgMain.compile();\n        su.addBranchGraph(bgMain);\n    }\n\n    // changes all the faces on a give model to allow picking\n    private void pickableModel(BranchGroup bg) {\n        // go through the model and set each Shape3D to pickable\n        Enumeration e = bg.getAllChildren();\n        while (e.hasMoreElements()) {\n            Object o = e.nextElement();\n            if (o instanceof Shape3D) {\n                PickTool.setCapabilities((Shape3D) o, PickTool.INTERSECT_COORD);\n                // need to also get normals for collision detection\n                ((Shape3D) o).getGeometry().setCapability(GeometryArray.ALLOW_NORMAL_READ);\n            }\n        }\n    }\n\n    // adds a hud image to the viewing platform\n    public void addHud() {\n        ViewingPlatform vp = su.getViewingPlatform();\n        bgHud = new PlatformGeometry();\n        // create a plane to add the hud image to\n        if (hudPlane == null) {\n            hudPlane = new Point3f[4];\n            // these coordinates were created with trial and error\n            hudPlane[0] = new Point3f(-0.29f, -0.22f, -0.7f);\n            hudPlane[1] = new Point3f(0.304f, -0.22f, -0.7f);\n            hudPlane[2] = new Point3f(0.304f, -0.1f, -0.7f);\n            hudPlane[3] = new Point3f(-0.29f, -0.1f, -0.7f);\n            // create a 4 point quad array (a plane)\n            QuadArray qaHud = new QuadArray(4, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2 | GeometryArray.NORMALS);\n            qaHud.setCoordinates(0, hudPlane);\n            // assign texture coords to each quad\n            // counter-clockwise, from bottom left\n            TexCoord2f[] tcoords = new TexCoord2f[4];\n            // for 1 point\n            tcoords[0] = new TexCoord2f(0.0f, 0.0f);\n            tcoords[1] = new TexCoord2f(1.0f, 0.0f);\n            tcoords[2] = new TexCoord2f(1.0f, 1.0f);\n            tcoords[3] = new TexCoord2f(0.0f, 1.0f);\n            qaHud.setTextureCoordinates(0, 0, tcoords);\n            // set the surface normal\n            // pointing up\n            Vector3f upNorm = new Vector3f(0.0f, 1.0f, 0.0f);\n            for (int i = 0; i < 4; i++) qaHud.setNormal(i, upNorm);\n            shapeHud = new Shape3D();\n            shapeHud.setGeometry(qaHud);\n            appHud = new Appearance();\n            // the texture blends with color on shape\n            TransparencyAttributes ta = new TransparencyAttributes();\n            ta.setTransparencyMode(TransparencyAttributes.BLENDED);\n            appHud.setTransparencyAttributes(ta);\n            // need to load the hud background\n            Toolkit tk = Toolkit.getDefaultToolkit();\n            imgHudBack = tk.getImage(\"images/hud/hud2.gif\");\n            // set up the media tracker to wait for the image\n            MediaTracker tracker = new MediaTracker(this);\n            tracker.addImage(imgHudBack, 0);\n            // wait for the image to load\n            try {\n                tracker.waitForID(0);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            // create the hud offscreen image\n            imgHud = new BufferedImage(imgHudBack.getWidth(this), imgHudBack.getHeight(this), BufferedImage.TYPE_4BYTE_ABGR);\n            drawHudImage();\n            // load and set the texture\n            // we specify by reference so we can update the image dynamically\n            TextureLoader loader = new TextureLoader(imgHud, TextureLoader.BY_REFERENCE);\n            textureHud = (Texture2D) loader.getTexture();\n            icHud = (ImageComponent2D) textureHud.getImage(0);\n            // set the texture\n            appHud.setTexture(textureHud);\n            hudUpdater = new HudUpdater(this);\n            // set a default white material\n            //Material mat = new Material();\n            //mat.setLightingEnable(true);    // lighting switched on\n            //appHud.setMaterial(mat);\n            shapeHud.setAppearance(appHud);\n            icHud.setCapability(ImageComponent.ALLOW_IMAGE_WRITE);\n            bgHud.addChild(shapeHud);\n            vp.setPlatformGeometry(bgHud);\n        }\n    }\n\n    // draw the hud background image\n    public void drawHudImage() {\n        // a test\n        //imgHud = new BufferedImage(imgHudBack.getWidth(this),imgHudBack.getHeight(this),BufferedImage.TYPE_4BYTE_ABGR);\n        // a test\n        Graphics gtmp = imgHud.getGraphics();\n        gtmp.drawImage(imgHudBack, 0, 0, this);\n        //gtmp.drawLine(0,0,100,100);\n        String stmp = \"X=\" + vViewPos.x + \" Y=\" + vViewPos.y + \" Z=\" + vViewPos.z;\n        gtmp.drawString(stmp, 10, imgHudBack.getHeight(this) - 20);\n        //System.out.println(\"strtmp=\"+stmp);\n    }\n\n    public void updateHud() {\n        icHud.updateData(hudUpdater, 0, 0, imgHudBack.getWidth(this), imgHudBack.getHeight(this));\n    }\n\n    // test routine which adds a cylinder to the view platform to\n    // give an idea as to where a \"weapon\" is pointing.\n    public void addPickCylinder() {\n        ViewingPlatform vp = su.getViewingPlatform();\n        // view point TG\n        tgView = vp.getViewPlatformTransform();\n        PlatformGeometry bgPickCyl = new PlatformGeometry();\n        t3dTmp.rotX(Math.toRadians(90.0f));\n        v3fTmp.set(0.0f, 0.0f, 1.0f);\n        t3dTmp2.set(v3fTmp);\n        t3dTmp.mul(t3dTmp2);\n        TransformGroup tgPickCyl = new TransformGroup(t3dTmp);\n        tgPickCyl.addChild(new Cylinder(0.05f, 300.0f));\n        bgPickCyl.addChild(tgPickCyl);\n        vp.setPlatformGeometry(bgPickCyl);\n    }\n\n    /*\n  public void loadFloorData()\n    {\n    tl = new TederLayer(30,30);\n    td.doLoadSingleLayer(tl,\"tiles.dat\");\n    }\n    \n  public void addFloorTiles(TransformGroup tgParent)\n    {\n    loadFloorData();\n    \n    ArrayList al = new ArrayList(4);\n    float tilex = 0.0f;\n    float tilez = 0.0f;\n    Point3f p1 = new Point3f(tilex,      0.0f,   tilez+TILE_WIDTH);\n    Point3f p2 = new Point3f(tilex+TILE_WIDTH, 0.0f,   tilez+TILE_WIDTH);\n    Point3f p3 = new Point3f(tilex+TILE_WIDTH, 0.0f,   tilez);\n    Point3f p4 = new Point3f(tilex,      0.0f,   tilez);   \n    al.add(p1); al.add(p2);  \n    al.add(p3); al.add(p4);  \n   \n    // width is the x direction\n    // height is the +z direction\n    int i,j;\n    int idx = 0;\n    for (i=0;i<tl.wid;i++)\n      {\n      tilex = 0.0f;\n      for (j=0;j<tl.hei;j++)\n        {\n        // change the points, they are already inside the array list\n        p1.set(tilex,0.0f,tilez+TILE_WIDTH);\n        p2.set(tilex+TILE_WIDTH,0.0f,tilez+TILE_WIDTH);\n        p3.set(tilex+TILE_WIDTH,0.0f,tilez);\n        p4.set(tilex,0.0f,tilez);\n        \n        // only add the tile if it has a texture\n        if (tl.tiles[idx]>=0)\n          tgFloor.addChild(new Tile(al,tl.tiles[idx]));\n        else\n          tgFloor.addChild(new Tile(al,-1));\n        tilex = tilex + TILE_WIDTH;\n        idx++;\n        }\n      tilez = tilez + TILE_WIDTH;\n      }\n    \n    }\n  public void addFloorCoords(ArrayList al)\n    {\n    float x = -0.5f;\n    float z = -0.5f;\n    // points created in counter-clockwise order\n    Point3f p1 = new Point3f(x,      0.0f,   z+5.0f);\n    Point3f p2 = new Point3f(x+5.0f, 0.0f,   z+5.0f);\n    Point3f p3 = new Point3f(x+5.0f, 0.0f,   z);\n    Point3f p4 = new Point3f(x,      0.0f,   z);   \n    al.add(p1); al.add(p2);  \n    al.add(p3); al.add(p4);  \n    }\n  \n      class Tile extends Shape3D\n        {\n        private QuadArray tile;\n        private int itexture;\n        \n        public Tile(ArrayList alCoords,int itextureInit)\n          {\n          itexture = itextureInit;\n          Vector3f upNorm = new Vector3f(0.0f, 1.0f, 0.0f);   // pointing up\n          \n          tile = new QuadArray(alCoords.size(),GeometryArray.COORDINATES | \n                                               GeometryArray.TEXTURE_COORDINATE_2 |\n                                               GeometryArray.NORMALS);\n          Point3f[] points = new Point3f[alCoords.size()];\n          alCoords.toArray( points );\n          tile.setCoordinates(0, points);\n \n          // assign texture coords to each quad\n          // counter-clockwise, from bottom left\n          TexCoord2f[] tcoords = new TexCoord2f[alCoords.size()];\n          for(int i=0; i < alCoords.size(); i=i+4) \n            {\n            tcoords[i] = new TexCoord2f(0.0f, 0.0f);   // for 1 point\n            tcoords[i+1] = new TexCoord2f(1.0f, 0.0f);\n            tcoords[i+2] = new TexCoord2f(1.0f, 1.0f);\n            tcoords[i+3] = new TexCoord2f(0.0f, 1.0f);\n            }\n          tile.setTextureCoordinates(0, 0, tcoords);\n         \n          // set the surface normal\n          for(int i=0; i < alCoords.size(); i++)\n            tile.setNormal(i, upNorm);\n            \n          setGeometry(tile);\n          \n          Appearance app = new Appearance();\n\n          if (itexture>=0)\n            setAppearance(tileTextures[itexture]);\n          else\n            setAppearance(textureStone);\n\n          }\n        }\n*/\n    public void createLights() {\n        // simple ambient white light\n        Color3f cWhite = new Color3f(1.0f, 1.0f, 1.0f);\n        AmbientLight amb = new AmbientLight(cWhite);\n        amb.setInfluencingBounds(boundsMain);\n        bgMain.addChild(amb);\n        // add one directional light pointing straight down\n        Vector3f vLight1 = new Vector3f(-1.0f, 1.0f, -1.0f);\n        DirectionalLight light = new DirectionalLight(cWhite, vLight1);\n        light.setInfluencingBounds(boundsMain);\n        light.setDirection(new Vector3f(1.0f, -1.0f, 1.0f));\n        bgMain.addChild(light);\n    }\n\n    public void initViewPosition() {\n        ViewingPlatform vp = su.getViewingPlatform();\n        TransformGroup tgView = vp.getViewPlatformTransform();\n        Transform3D t3d = new Transform3D();\n        // setup the initial yaw pitch roll\n        t3d.rotY(Math.toRadians(-90.0));\n        t3dYPR.mul(t3d);\n        // set the initial view position and orientation\n        t3d.set(t3dYPR);\n        t3dTmp2.set(vViewPos);\n        t3d.mul(t3dTmp2);\n        //tgView.getTransform(t3d);\n        // look at the origin, orient up\n        //t3d.lookAt(vViewPos,new Point3d(0,0,0),vViewOri);\n        //t3d.invert();\n        tgView.setTransform(t3d);\n    }\n\n    public boolean adjustMoveDistance(Vector3f vMove) {\n        // NOTE: I do not like creating the point3d and v3d everytime in this method\n        // it will have problems with performance and will need to be addressed\n        // WWH\n        // create the pick tool on first distance check, reuse for all later checks\n        if (pickTool == null) {\n            // create the picktool to always use the map\n            pickTool = new PickTool(bgMap);\n            /*\n      pickCylinder = new PickCylinderRay(new Point3d(vViewPos.x,vViewPos.y,vViewPos.z), \n                                         new Vector3d(vMove.x,vMove.y,vMove.z), \n                                         0.10d);\n      */\n        }\n        // set the shape of the pick tool as a ray from the current location\n        // in the direction of the move\n        pickTool.setShapeRay(new Point3d(vViewPos.x, vViewPos.y, vViewPos.z), new Vector3d(vMove.x, vMove.y, vMove.z));\n        // get a pick to the closest shape\n        PickResult res = pickTool.pickClosest();\n        // if we got a result, check for the closest intersection distance\n        if (res != null) {\n            int j;\n            // a big number just in case\n            float closestIntersect = 10000000.0f;\n            for (j = 0; j < res.numIntersections(); j++) {\n                if ((j == 0) || (res.getIntersection(j).getDistance() < closestIntersect))\n                    closestIntersect = (float) res.getIntersection(j).getDistance();\n            }\n            //System.out.println(\"closestIntersect = \"+closestIntersect);\n            if (closestIntersect < 2.0) {\n                // collision, adjust accordingly\n                vMove.set(0.0f, 0.0f, 0.0f);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void checkSphereHit() {\n        boolean didHit = true;\n        // we keep checking because one bounce may lead to another until we\n        // are headed away from all the walls\n        while (didHit) {\n            didHit = false;\n            // we are sharing the pick tool\n            if (pickTool == null) {\n                // create the picktool to always use the map\n                pickTool = new PickTool(bgMap);\n            }\n            // check for collision with a wall\n            pickTool.setShapeRay(new Point3d(vSpherePos.x, vSpherePos.y, vSpherePos.z), new Vector3d(vSphereVel.x, vSphereVel.y, vSphereVel.z));\n            // get a pick to the closest shape\n            PickResult res = pickTool.pickClosest();\n            // if we got a result, check for the closest intersection distance\n            if (res != null) {\n                int j;\n                // a big number just in case\n                float closestIntersect = 10000000.0f;\n                for (j = 0; j < res.numIntersections(); j++) {\n                    if ((j == 0) || (res.getIntersection(j).getDistance() < closestIntersect))\n                        closestIntersect = (float) res.getIntersection(j).getDistance();\n                }\n                // bounce if we are going to move beyond the wall\n                float magVel = vSphereVel.length();\n                //System.out.println(\"closestIntersect = \"+closestIntersect+\" velLen=\"+magVel);\n                if (closestIntersect < magVel) {\n                    //System.out.println(\"sphere hit dist=\"+closestIntersect+\" node=\"+res.getObject());\n                    // need the surface normal for the object it just hit\n                    Node nd = res.getObject();\n                    // we have it as a node, make sure it is a shape 3d\n                    if (nd instanceof Shape3D) {\n                        Shape3D sh = (Shape3D) nd;\n                        Geometry geo = sh.getGeometry();\n                        // we have the geometry, make sure it is a GeometryArray we can get a surface normal from\n                        if (geo instanceof GeometryArray) {\n                            // finally!, after all that, we can get the surface normal\n                            // just use the normal from the first vertex.\n                            ((GeometryArray) geo).getNormal(0, v3fTmp);\n                            // get a unit vector from the velocity\n                            //v3fTmp3.normalize(vSphereVel);\n                            // I had to double normalize here because a 180 degree vector with value\n                            // = 0.99999994 caused the normal to not be unit length - very odd\n                            v3fTmp3.set(vSphereVel);\n                            v3fTmp3.normalize();\n                            v3fTmp3.normalize();\n                            // get the dot product between the two\n                            float f = (float) v3fTmp.dot(v3fTmp3);\n                            // -1 for the dot product means the vectors are parallel and 180 in direction\n                            if (f == -1.0f) {\n                                // direct hit, the vectors face each other exactly, just reverse the velocity\n                                //System.out.println(\"negate the velocity\");\n                                vSphereVel.negate();\n                                // subtract a little friction to make up for the fact that the\n                                // sphere didn't actually touch the wall\n                                vSphereVel.scale(0.90f);\n                                didHit = true;\n                                // set the sphere to that intersection point\n                                // WWH - exercise for later\n                            } else if (// obtuse angle dot product - headed towards object\n                            f < 0.0f) {\n                                /* now for the not so simple case of an arbitrary hit */\n                                /* dot < 0.0 means we are headed towards the object (obtuse angle) */\n                                /* what we do here is rotate the velocity vector around the\n                 * cross product of the two vectors\n                 */\n                                v3fTmp2.cross(v3fTmp, v3fTmp3);\n                                //System.out.println(\"Normal = \"+v3fTmp+\"  vel=\"+vSphereVel+\" normvel=\"+v3fTmp3+\"  dot=\"+v3fTmp.dot(v3fTmp3)+\" cross=\"+v3fTmp2);\n                                // convert it to an angle\n                                f = (float) Math.toDegrees(Math.acos(f));\n                                // ret ang is the angle from the surface normal and the new bounce/return angle\n                                // draw some pictures to decide why 180-f\n                                float retang = 180.0f - f;\n                                // reflect the velocity as we will rotate that through the surface normal\n                                vSphereVel.negate();\n                                // rotate that the angle between the normal *2\n                                float frot = retang * 2.0f;\n                                // reusing the temporary AxisAngle that YPR uses\n                                //System.out.println(\"rot ang = \"+frot);\n                                aaYPR.set(v3fTmp2, (float) Math.toRadians(frot));\n                                // create a matrix then transform with this rotate\n                                m3fTmp1.set(aaYPR);\n                                t3dTmp.set(m3fTmp1);\n                                // multiply the current velocity by that rotation\n                                t3dTmp.transform(vSphereVel);\n                                // subtract a little friction to make up for the fact that the\n                                // sphere didn't actually touch the wall\n                                // otherwise the bounce gets larger and larger. This is a kludge\n                                vSphereVel.scale(0.90f);\n                                //System.out.println(\" post bounce vel=\"+vSphereVel);\n                                didHit = true;\n                            }\n                        }\n                        //System.out.println(\"is a shape3d \"+((Shape3D)nd).getGeometry());\n                    }\n                }\n                // closest intersect\n            }\n            // check pick result\n        }\n        // while didHit\n    }\n\n    public void tickSphere() {\n        // add some gravity to the sphere\n        vSphereVel.y = vSphereVel.y - 0.05f;\n        checkSphereHit();\n        // add the current velocity to the sphere\n        vSpherePos.add(vSphereVel);\n        // create a location translation transform for the sphere\n        t3dTmp.setTranslation(vSpherePos);\n        // set the changed transform\n        tgSphere.setTransform(t3dTmp);\n    }\n\n    public void tick() {\n        tickSphere();\n        updateHud();\n        if ((keyForward == true) || (keyBackward == true)) {\n            if (keyForward)\n                v3fTmp.set(0.0f, 0.0f, -1.0f);\n            else\n                v3fTmp.set(0.0f, 0.0f, 1.0f);\n            // transform the unit vector\n            t3dYPR.transform(v3fTmp);\n            // don't want a full unit, or it goes too fast\n            v3fTmp.scale(0.1f);\n            // map collision detection\n            adjustMoveDistance(v3fTmp);\n            // add that direction to the current position\n            vViewPos.add(v3fTmp);\n        }\n        if (keyLeft == true) {\n            // create a vector in the y direction\n            v3fTmp.set(0.0f, 1.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // create axis to rotate around that y axis in our orientation coordinate space\n            aaYPR.set(v3fTmp, (float) Math.toRadians(TURNDELTA));\n            // set a temporary transform\n            m3fTmp1.set(aaYPR);\n            t3dTmp.set(m3fTmp1);\n            // multiply the current view by that rotation\n            t3dYPR.mul(t3dTmp);\n            t3dYPR.normalize();\n        }\n        if (keyRight == true) {\n            // create a vector in the y direction\n            v3fTmp.set(0.0f, 1.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // create axis to rotate around that y axis in our orientation coordinate space\n            aaYPR.set(v3fTmp, (float) -Math.toRadians(TURNDELTA));\n            // set a temporary transform\n            m3fTmp1.set(aaYPR);\n            t3dTmp.set(m3fTmp1);\n            // multiply the current view by that rotation\n            t3dYPR.mul(t3dTmp);\n            t3dYPR.normalize();\n        }\n        if (keyStrafeLeft == true) {\n            // movement in the -x direction\n            v3fTmp.set(-1.0f, 0.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // don't want a full unit, or it goes too fast\n            v3fTmp.scale(0.1f);\n            // map collision detection\n            adjustMoveDistance(v3fTmp);\n            // add that direction to the current position\n            vViewPos.add(v3fTmp);\n        }\n        if (keyStrafeRight == true) {\n            // movement in the x direction\n            v3fTmp.set(1.0f, 0.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // don't want a full unit, or it goes too fast\n            v3fTmp.scale(0.1f);\n            // map collision detection\n            adjustMoveDistance(v3fTmp);\n            // add that direction to the current position\n            vViewPos.add(v3fTmp);\n        }\n        if (keyLookDown == true) {\n            lookUpAngle = lookUpAngle + 0.5f;\n            if (lookUpAngle > 45.0f)\n                lookUpAngle = 45.0f;\n        }\n        if (keyLookUp == true) {\n            lookUpAngle = lookUpAngle - 0.5f;\n            if (lookUpAngle < -45.0f)\n                lookUpAngle = -45.0f;\n        }\n        // set the temporary transform to the view/camera location\n        t3dTmp.setIdentity();\n        t3dTmp.setTranslation(vViewPos);\n        // add the y lookup angle\n        // create a vector in the x direction\n        v3fTmp.set(1.0f, 0.0f, 0.0f);\n        // rotate that vector into the current orientation\n        t3dYPR.transform(v3fTmp);\n        // create axis to rotate around that y axis in our orientation coordinate space\n        aaYPR.set(v3fTmp, (float) -Math.toRadians(lookUpAngle));\n        // set a temporary transform\n        m3fTmp1.set(aaYPR);\n        t3dTmp2.set(m3fTmp1);\n        // multiply the current view by that rotation\n        t3dTmp.mul(t3dTmp2);\n        // multiply the transform by the current view orientation\n        t3dTmp2.set(t3dYPR);\n        t3dTmp.mul(t3dTmp2);\n        tgView.setTransform(t3dTmp);\n    }\n\n    public void doFire() {\n        // pick\n        v3fTmp.set(0.0f, 0.0f, -1.0f);\n        // rotate the pick vector into the current view\n        t3dYPR.transform(v3fTmp);\n        PickCanvas pickCanvas = new PickCanvas(c3d, bgMain);\n        pickCanvas.setMode(PickTool.GEOMETRY_INTERSECT_INFO);\n        pickCanvas.setTolerance(4.0f);\n        pickCanvas.setShapeLocation(getWidth() / 2, getHeight() / 2);\n        PickResult[] results = pickCanvas.pickAll();\n        if (results != null) {\n            // find the closest object that we clicked on\n            int i, j;\n            int idx = 0;\n            // a big number just in case\n            float dst = 100000000.0f;\n            for (i = 0; i < results.length; i++) {\n                // a big number just in case\n                float closestIntersect = 10000000.0f;\n                for (j = 0; j < results[i].numIntersections(); j++) {\n                    if ((j == 0) || (results[i].getIntersection(j).getDistance() < closestIntersect))\n                        closestIntersect = (float) results[i].getIntersection(j).getDistance();\n                }\n                if ((i == 0) || (closestIntersect < dst)) {\n                    idx = i;\n                    dst = closestIntersect;\n                }\n            }\n            // is the closest object the sphere\n            if (results[idx].getObject() == sphere.getShape()) {\n                // v3fTmp now contains the ray that we hit the sphere with\n                // we need to change the ball's velocity with it\n                v3fTmp.normalize();\n                vSphereVel.add(v3fTmp);\n            }\n        }\n    }\n\n    public void keyPressed(KeyEvent e) {\n        int keyCode = e.getKeyCode();\n        if ((keyCode == KeyEvent.VK_ESCAPE) || (keyCode == KeyEvent.VK_Q) || ((keyCode == KeyEvent.VK_C) && e.isControlDown())) {\n            parent.dispose();\n            // exit() alone isn't sufficient most of the time\n            System.exit(0);\n        }\n    }\n\n    public void keyReleased(KeyEvent e) {\n    }\n\n    public void keyTyped(KeyEvent e) {\n    }\n\n    protected void processKeyDown(int keycode) {\n        if (keycode == KeyEvent.VK_W)\n            keyForward = true;\n        else if (keycode == KeyEvent.VK_S)\n            keyBackward = true;\n        else if (keycode == KeyEvent.VK_LEFT)\n            keyLeft = true;\n        else if (keycode == KeyEvent.VK_RIGHT)\n            keyRight = true;\n        else if (keycode == KeyEvent.VK_A)\n            keyStrafeLeft = true;\n        else if (keycode == KeyEvent.VK_D)\n            keyStrafeRight = true;\n        else if (keycode == KeyEvent.VK_UP)\n            keyLookUp = true;\n        else if (keycode == KeyEvent.VK_DOWN)\n            keyLookDown = true;\n        else if (keycode == KeyEvent.VK_SPACE)\n            doFire();\n    }\n\n    protected void processKeyUp(int keycode) {\n        if (keycode == KeyEvent.VK_W)\n            keyForward = false;\n        else if (keycode == KeyEvent.VK_S)\n            keyBackward = false;\n        else if (keycode == KeyEvent.VK_LEFT)\n            keyLeft = false;\n        else if (keycode == KeyEvent.VK_RIGHT)\n            keyRight = false;\n        else if (keycode == KeyEvent.VK_A)\n            keyStrafeLeft = false;\n        else if (keycode == KeyEvent.VK_D)\n            keyStrafeRight = false;\n        else if (keycode == KeyEvent.VK_UP)\n            keyLookUp = false;\n        else if (keycode == KeyEvent.VK_DOWN)\n            keyLookDown = false;\n    }\n\n    protected void processMouseMove(MouseEvent me) {\n        //System.out.println(\"mex = \"+me.getX());\n        //System.out.println(\"mey = \"+me.getY());\n        diffx = lastMouseX - me.getX();\n        diffy = lastMouseY - me.getY();\n        //offcenterX = me.getX() - (getWidth()/2);\n        //offcenterY = me.getY() - (getHeight()/2);\n        offcenterX = me.getX() - lastMouseX;\n        offcenterY = me.getY() - lastMouseY;\n        lastMouseX = me.getX();\n        lastMouseY = me.getY();\n        lastMouseX = getWidth() / 2;\n        lastMouseY = getHeight() / 2;\n        // put the mouse back in the center\n        Point p = getLocationOnScreen();\n        robot.mouseMove(p.x + lastMouseX, p.y + lastMouseY);\n        // probably too much processing to use a float for this check\n        // fix later\n        float abs = Math.abs(offcenterX);\n        if (abs > 0.0f) {\n            // create a vector in the y direction\n            v3fTmp.set(0.0f, 1.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // muck with the turn delta\n            // bigger offsets make bigger turns\n            float td = (float) -offcenterX * 0.0005f;\n            // maximum turns\n            if (Math.abs(td) > 0.02) {\n                if (td > 0.0f)\n                    td = 0.02f;\n                else\n                    td = -0.02f;\n            }\n            // create axis to rotate around that y axis in our orientation coordinate space\n            aaYPR.set(v3fTmp, td);\n            // set a temporary transform\n            m3fTmp1.set(aaYPR);\n            t3dTmp.set(m3fTmp1);\n            // multiply the current view by that rotation\n            t3dYPR.mul(t3dTmp);\n            t3dYPR.normalize();\n        }\n        abs = Math.abs(offcenterY);\n        if ((abs > 0.0f) && (abs < 120.0)) {\n            float rotAng = offcenterY * 0.05f;\n            //System.out.println(\"rotAng = \"+rotAng);\n            lookUpAngle = lookUpAngle + rotAng;\n            if (lookUpAngle > 45.0f)\n                lookUpAngle = 45.0f;\n            else if (lookUpAngle < -45.0f)\n                lookUpAngle = -45.0f;\n        }\n    }\n\n    protected void processMouseClicked(MouseEvent me) {\n        doFire();\n    }\n}\n\n// Fps370Panel\nclass KeyUpBehavior extends Behavior {\n\n    Fps370Panel t3p;\n\n    WakeupCondition keyRelease;\n\n    public KeyUpBehavior(Fps370Panel t3pInit) {\n        t3p = t3pInit;\n        keyRelease = new WakeupOnAWTEvent(KeyEvent.KEY_RELEASED);\n    }\n\n    public void initialize() {\n        wakeupOn(keyRelease);\n    }\n\n    public void processStimulus(Enumeration criteria) {\n        WakeupCriterion wakeup;\n        AWTEvent[] event;\n        boolean resetKeyDown = false;\n        boolean resetKeyUp = false;\n        //System.out.println(\"process stimulus: \"+criteria);\n        while (criteria.hasMoreElements()) {\n            wakeup = (WakeupCriterion) criteria.nextElement();\n            if (wakeup instanceof WakeupOnAWTEvent) {\n                event = ((WakeupOnAWTEvent) wakeup).getAWTEvent();\n                for (int i = 0; i < event.length; i++) {\n                    if (event[i].getID() == KeyEvent.KEY_RELEASED) {\n                        t3p.processKeyUp(((KeyEvent) event[i]).getKeyCode());\n                    }\n                }\n            }\n        }\n        wakeupOn(keyRelease);\n    }\n    // end of processStimulus()\n}\n\nclass KeyDownBehavior extends Behavior {\n\n    Fps370Panel t3p;\n\n    WakeupCondition keyPress;\n\n    public KeyDownBehavior(Fps370Panel t3pInit) {\n        t3p = t3pInit;\n        keyPress = new WakeupOnAWTEvent(KeyEvent.KEY_PRESSED);\n    }\n\n    public void initialize() {\n        wakeupOn(keyPress);\n    }\n\n    public void processStimulus(Enumeration criteria) {\n        WakeupCriterion wakeup;\n        AWTEvent[] event;\n        boolean resetKeyDown = false;\n        boolean resetKeyUp = false;\n        //System.out.println(\"process stimulus: \"+criteria);\n        while (criteria.hasMoreElements()) {\n            wakeup = (WakeupCriterion) criteria.nextElement();\n            if (wakeup instanceof WakeupOnAWTEvent) {\n                event = ((WakeupOnAWTEvent) wakeup).getAWTEvent();\n                for (int i = 0; i < event.length; i++) {\n                    if (event[i].getID() == KeyEvent.KEY_PRESSED) {\n                        t3p.processKeyDown(((KeyEvent) event[i]).getKeyCode());\n                    }\n                }\n            }\n        }\n        wakeupOn(keyPress);\n    }\n    // end of processStimulus()\n}\n\nclass MouseMoveBehavior extends MouseBehavior {\n\n    Fps370Panel t3p;\n\n    WakeupCondition mouseMove;\n\n    public MouseMoveBehavior(Fps370Panel t3pInit) {\n        super(t3pInit, MouseEvent.MOUSE_MOVED);\n        t3p = t3pInit;\n        mouseMove = new WakeupOnAWTEvent((long) (MouseEvent.MOUSE_MOVED | MouseEvent.MOUSE_CLICKED));\n    }\n\n    public void initialize() {\n        wakeupOn(mouseMove);\n    }\n\n    public void processStimulus(Enumeration criteria) {\n        WakeupCriterion wakeup;\n        AWTEvent[] event;\n        boolean resetKeyDown = false;\n        boolean resetKeyUp = false;\n        //System.out.println(\"process stimulus: \"+criteria);\n        while (criteria.hasMoreElements()) {\n            wakeup = (WakeupCriterion) criteria.nextElement();\n            if (wakeup instanceof WakeupOnAWTEvent) {\n                event = ((WakeupOnAWTEvent) wakeup).getAWTEvent();\n                for (int i = 0; i < event.length; i++) {\n                    if (event[i].getID() == MouseEvent.MOUSE_MOVED) {\n                        //System.out.println(\"Mouse moved\");\n                        t3p.processMouseMove(((MouseEvent) event[i]));\n                    } else if (event[i].getID() == MouseEvent.MOUSE_CLICKED) {\n                        //System.out.println(\"mouse clicked\");\n                        t3p.processMouseClicked((MouseEvent) event[i]);\n                    }\n                }\n            }\n        }\n        wakeupOn(mouseMove);\n    }\n    // end of processStimulus()\n}\n\nclass HudUpdater implements ImageComponent2D.Updater {\n\n    private Fps370Panel parent;\n\n    public HudUpdater(Fps370Panel parentInit) {\n        parent = parentInit;\n    }\n\n    public void updateData(ImageComponent2D icUpdate, int x, int y, int width, int height) {\n        //System.out.println(\"HUD Update Data x=\"+x+\" y=\"+y+\" w=\"+width+\" h=\"+height);\n        parent.drawHudImage();\n        //sicUpdate.set(parent.imgHud);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/fps370/Fps370PanelTest0.java",
		"test_prompt": "// Fps370PanelTest0.java\npackage fps370;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\nimport javax.media.j3d.*;\nimport javax.swing.*;\nimport javax.vecmath.*;\nimport com.sun.j3d.utils.universe.*;\nimport com.sun.j3d.utils.geometry.*;\nimport com.sun.j3d.utils.image.*;\nimport com.sun.j3d.utils.behaviors.mouse.*;\nimport com.sun.j3d.utils.picking.*;\nimport com.sun.j3d.loaders.*;\n//import com.mnstarfire.loaders3d.Loader3DS;\nimport com.glyphein.j3d.loaders.milkshape.MS3DLoader;\nimport teder.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Fps370Panel}.\n* It contains ten unit test cases for the {@link Fps370Panel#loadModel(String)} method.\n*/\nclass Fps370PanelTest0 {"
	},
	{
		"original_code": "// Fps370Panel.java\n/**\n *  Fps370Panel\n *  3D game template panel\n *\n *  Created for cpsc370 at Chapman University\n *  http://www.gamedev370.com\n *  (c) copyright 2006 - W. Wood Harter\n *\n *  Licensed under GNU General Public License\n *  http://www.gnu.org\n *\n *  This is the main panel for fps370.\n *  This needs to be refactored into a bunch of subclasses.\n * *\n *  In order to run this you will have to download the Milkshap model loader\n *  http://home.earthlink.net/~kduling/Milkshape/\n *  Place the MS3DLoader-1.0.8.jar in the fps370/lib/ext directory.\n */\npackage fps370;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\nimport javax.media.j3d.*;\nimport javax.swing.*;\nimport javax.vecmath.*;\nimport com.sun.j3d.utils.universe.*;\nimport com.sun.j3d.utils.geometry.*;\nimport com.sun.j3d.utils.image.*;\nimport com.sun.j3d.utils.behaviors.mouse.*;\nimport com.sun.j3d.utils.picking.*;\nimport com.sun.j3d.loaders.*;\n//import com.mnstarfire.loaders3d.Loader3DS;\nimport com.glyphein.j3d.loaders.milkshape.MS3DLoader;\nimport teder.*;\n\npublic class Fps370Panel extends JPanel implements KeyListener {\n\n    // parent window\n    Fps370 parent;\n\n    // 3d frame and universe\n    SimpleUniverse su;\n\n    Canvas3D c3d;\n\n    // scene graph to display\n    BranchGroup bgMain;\n\n    TransformGroup tgFloor;\n\n    AxisAngle4f aaFloor;\n\n    Transform3D t3dFloorRotate;\n\n    // temporary holding variables\n    Transform3D t3dTmp;\n\n    Transform3D t3dTmp2;\n\n    Vector3f v3fTmp;\n\n    Vector3f v3fTmp2;\n\n    Vector3f v3fTmp3;\n\n    Matrix4f m3fTmp1;\n\n    Matrix4f m3fTmp2;\n\n    BoundingSphere boundsMain;\n\n    Sphere sphere;\n\n    TransformGroup tgSphere;\n\n    Transform3D t3dSphereTranslate;\n\n    Vector3f vSphereVel = new Vector3f(0.0f, 0.0f, 0.0f);\n\n    Vector3f vSpherePos = new Vector3f(6.5f, 3.2f, 5.0f);\n\n    Vector3f vViewPos = new Vector3f(0.0f, 0.5f, 5.0f);\n\n    Vector3f vViewOri = new Vector3f(0.0f, 1.0f, 1.0f);\n\n    private static final float TILE_WIDTH = 1.0f;\n\n    private static final int NUM_TILE_TEXTURES = 10;\n\n    Appearance[] tileTextures;\n\n    Appearance textureStone;\n\n    TederLayer tl;\n\n    TederData td;\n\n    TransformGroup tgView;\n\n    // the current YPR rotation\n    Transform3D t3dYPR;\n\n    // temporary calculatiosn for YPR changes\n    AxisAngle4f aaYPR;\n\n    // the angle to look in the viewport\n    float lookUpAngle = 5.0f;\n\n    private static final float TURNDELTA = 0.5f;\n\n    boolean keyLeft;\n\n    boolean keyRight;\n\n    boolean keyForward;\n\n    boolean keyBackward;\n\n    boolean keyStrafeLeft;\n\n    boolean keyStrafeRight;\n\n    boolean keyLookUp;\n\n    boolean keyLookDown;\n\n    // mouse movement\n    int diffx, diffy;\n\n    int lastMouseX, lastMouseY;\n\n    int offcenterX, offcenterY;\n\n    Robot robot;\n\n    // collision detection with map\n    BranchGroup bgMap;\n\n    PickCylinderRay pickCylinder;\n\n    PickTool pickTool;\n\n    // HUD\n    PlatformGeometry bgHud;\n\n    Point3f[] hudPlane;\n\n    Appearance appHud;\n\n    Shape3D shapeHud;\n\n    Texture2D textureHud;\n\n    // the 2d texture image\n    ImageComponent2D icHud;\n\n    HudUpdater hudUpdater;\n\n    Image imgHudBack;\n\n    BufferedImage imgHud;\n\n    public Fps370Panel(Fps370 parentInit) {\n        parent = parentInit;\n        setLayout(new BorderLayout());\n        setPreferredSize(new Dimension(800, 600));\n        GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();\n        c3d = new Canvas3D(config);\n        add(\"Center\", c3d);\n        // allow the canvas to get focus and give it focus\n        c3d.setFocusable(true);\n        c3d.requestFocus();\n        c3d.addKeyListener(this);\n        su = new SimpleUniverse(c3d);\n        t3dTmp = new Transform3D();\n        t3dTmp2 = new Transform3D();\n        v3fTmp = new Vector3f(0, 0, 0);\n        v3fTmp2 = new Vector3f(0, 0, 0);\n        v3fTmp3 = new Vector3f(0, 0, 0);\n        m3fTmp1 = new Matrix4f();\n        m3fTmp2 = new Matrix4f();\n        //m3fYPR = new Matrix4f();\n        t3dYPR = new Transform3D();\n        aaYPR = new AxisAngle4f();\n        try {\n            robot = new Robot();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n        td = new TederData(30, 30, 64, 64, \"images/floor/tiles.gif\", this);\n        loadTileTextures();\n        createSceneGraph();\n        initViewPosition();\n    }\n\n    // create appearances with each individual tile\n    // used to texture the individual floor tiles\n    public void loadTileTextures() {\n        tileTextures = new Appearance[NUM_TILE_TEXTURES];\n        int i;\n        for (i = 0; i < NUM_TILE_TEXTURES; i++) {\n            tileTextures[i] = new Appearance();\n            // mix the texture and the material colour\n            TextureAttributes ta = new TextureAttributes();\n            //ta.setTextureMode(TextureAttributes.MODULATE);\n            ta.setTextureMode(TextureAttributes.REPLACE);\n            tileTextures[i].setTextureAttributes(ta);\n            // load and set the texture\n            TextureLoader loader = new TextureLoader(\"images/floor/tile\" + i + \".jpg\", null);\n            //TextureLoader loader = new TextureLoader(\"images/floor/stone.jpg\", null);\n            Texture2D texture = (Texture2D) loader.getTexture();\n            // set the texture\n            tileTextures[i].setTexture(texture);\n            // set a default white material\n            Material mat = new Material();\n            // lighting switched on\n            mat.setLightingEnable(true);\n            tileTextures[i].setMaterial(mat);\n        }\n        textureStone = new Appearance();\n        // the default texture if one isn't given (ie. -1)\n        // mix the texture and the material colour\n        TextureAttributes ta = new TextureAttributes();\n        //ta.setTextureMode(TextureAttributes.MODULATE);\n        ta.setTextureMode(TextureAttributes.REPLACE);\n        textureStone.setTextureAttributes(ta);\n        // load and set the texture\n        TextureLoader loader = new TextureLoader(\"images/floor/stone.jpg\", null);\n        //TextureLoader loader = new TextureLoader(\"images/floor/stone.jpg\", null);\n        Texture2D texture = (Texture2D) loader.getTexture();\n        // set the texture\n        textureStone.setTexture(texture);\n        // set a default white material\n        Material mat = new Material();\n        // lighting switched on\n        mat.setLightingEnable(true);\n        textureStone.setMaterial(mat);\n    }\n\n    public Scene loadModel(String fname) {\n        Scene theScene = null;\n        // setup a file name \"fileName\"\n        try {\n            //Loader3DS loader = new Loader3DS();\n            // optional options to be used\n            //loader.setLogging(true); // turns on writing a log file\n            //loader.setDetail(7); // sets level of detail of report log\n            //loader.setTextureLightingOn(); // turns on texture modulate mode\n            //loader.setTexturePath(\"models\"); // optional alternate path to find texture files\n            // loader.noTextures(); // if you do not want to load textures\n            //theScene = loader.load(fname);\n            // milkshape loader\n            File file = new java.io.File(fname);\n            if (// figure out the base path\n            file.getParent().length() > 0) {\n                Loader loader = new MS3DLoader(MS3DLoader.LOAD_ALL);\n                loader.setBasePath(file.getParent() + java.io.File.separator);\n                theScene = loader.load(file.getName());\n                //BranchGroup group = scene.getSceneGroup();\n            }\n            // load a sphere model twice for testing\n        } catch (FileNotFoundException fnf) {\n            // Couldn't find the file you requested - deal with it!\n            fnf.printStackTrace();\n        }\n        return theScene;\n    }\n\n    public void createSceneGraph() {\n        // create a new scene branch\n        bgMain = new BranchGroup();\n        boundsMain = new BoundingSphere(new Point3d(0, 0, 0), 300);\n        createLights();\n        // create the temporary location for sphere translation - used in tick\n        // create a sphere\n        t3dSphereTranslate = new Transform3D();\n        t3dSphereTranslate.set(vSpherePos);\n        tgSphere = new TransformGroup(t3dSphereTranslate);\n        tgSphere.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);\n        tgSphere.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);\n        sphere = new Sphere(1.0f);\n        tgSphere.addChild(sphere);\n        // allow picking on the sphere\n        PickTool.setCapabilities(sphere.getShape(), PickTool.INTERSECT_COORD);\n        bgMain.addChild(tgSphere);\n        // create the floor\n        /*\n     * I sort of decided to only use models to build the map\n    aaFloor = new AxisAngle4f(0.0f, 1.0f, 0.0f, 0.0f);\n    t3dFloorRotate = new Transform3D();\n    t3dFloorRotate.setRotation(aaFloor);\n    tgFloor = new TransformGroup();\n    tgFloor.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);\n    tgFloor.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);\n    tgFloor.setTransform(t3dFloorRotate);\n    \n\n    // add a floor tile\n    addFloorTiles(tgFloor);\n    bgMain.addChild(tgFloor);\n    \n    addFloorTiles(tgFloor);\n    */\n        ViewingPlatform vp = su.getViewingPlatform();\n        // view point TG\n        tgView = vp.getViewPlatformTransform();\n        KeyUpBehavior bup = new KeyUpBehavior(this);\n        bup.setSchedulingBounds(boundsMain);\n        bgMain.addChild(bup);\n        KeyDownBehavior bdn = new KeyDownBehavior(this);\n        bdn.setSchedulingBounds(boundsMain);\n        bgMain.addChild(bdn);\n        MouseMoveBehavior mmb = new MouseMoveBehavior(this);\n        mmb.setSchedulingBounds(boundsMain);\n        bgMain.addChild(mmb);\n        // create the ticker behavior for the scene\n        Fps370Ticker tt = new Fps370Ticker(20, this);\n        tt.setSchedulingBounds(boundsMain);\n        bgMain.addChild(tt);\n        // get the temple model\n        Scene sc = loadModel(\"./models/map2.ms3d\");\n        // need to scale the model some, then slide it up and towards the origin\n        // allow picking on the cube for collision detection\n        bgMap = sc.getSceneGroup();\n        //bgModel.setPickable(true);\n        pickableModel(bgMap);\n        //PickTool.setCapabilities(bgModel,PickTool.INTERSECT_COORD);\n        bgMain.addChild(bgMap);\n        // used to see aim location during debugging\n        //addPickCylinder();\n        // add the hud to the display\n        addHud();\n        bgMain.compile();\n        su.addBranchGraph(bgMain);\n    }\n\n    // changes all the faces on a give model to allow picking\n    private void pickableModel(BranchGroup bg) {\n        // go through the model and set each Shape3D to pickable\n        Enumeration e = bg.getAllChildren();\n        while (e.hasMoreElements()) {\n            Object o = e.nextElement();\n            if (o instanceof Shape3D) {\n                PickTool.setCapabilities((Shape3D) o, PickTool.INTERSECT_COORD);\n                // need to also get normals for collision detection\n                ((Shape3D) o).getGeometry().setCapability(GeometryArray.ALLOW_NORMAL_READ);\n            }\n        }\n    }\n\n    // adds a hud image to the viewing platform\n    public void addHud() {\n        ViewingPlatform vp = su.getViewingPlatform();\n        bgHud = new PlatformGeometry();\n        // create a plane to add the hud image to\n        if (hudPlane == null) {\n            hudPlane = new Point3f[4];\n            // these coordinates were created with trial and error\n            hudPlane[0] = new Point3f(-0.29f, -0.22f, -0.7f);\n            hudPlane[1] = new Point3f(0.304f, -0.22f, -0.7f);\n            hudPlane[2] = new Point3f(0.304f, -0.1f, -0.7f);\n            hudPlane[3] = new Point3f(-0.29f, -0.1f, -0.7f);\n            // create a 4 point quad array (a plane)\n            QuadArray qaHud = new QuadArray(4, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2 | GeometryArray.NORMALS);\n            qaHud.setCoordinates(0, hudPlane);\n            // assign texture coords to each quad\n            // counter-clockwise, from bottom left\n            TexCoord2f[] tcoords = new TexCoord2f[4];\n            // for 1 point\n            tcoords[0] = new TexCoord2f(0.0f, 0.0f);\n            tcoords[1] = new TexCoord2f(1.0f, 0.0f);\n            tcoords[2] = new TexCoord2f(1.0f, 1.0f);\n            tcoords[3] = new TexCoord2f(0.0f, 1.0f);\n            qaHud.setTextureCoordinates(0, 0, tcoords);\n            // set the surface normal\n            // pointing up\n            Vector3f upNorm = new Vector3f(0.0f, 1.0f, 0.0f);\n            for (int i = 0; i < 4; i++) qaHud.setNormal(i, upNorm);\n            shapeHud = new Shape3D();\n            shapeHud.setGeometry(qaHud);\n            appHud = new Appearance();\n            // the texture blends with color on shape\n            TransparencyAttributes ta = new TransparencyAttributes();\n            ta.setTransparencyMode(TransparencyAttributes.BLENDED);\n            appHud.setTransparencyAttributes(ta);\n            // need to load the hud background\n            Toolkit tk = Toolkit.getDefaultToolkit();\n            imgHudBack = tk.getImage(\"images/hud/hud2.gif\");\n            // set up the media tracker to wait for the image\n            MediaTracker tracker = new MediaTracker(this);\n            tracker.addImage(imgHudBack, 0);\n            // wait for the image to load\n            try {\n                tracker.waitForID(0);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            // create the hud offscreen image\n            imgHud = new BufferedImage(imgHudBack.getWidth(this), imgHudBack.getHeight(this), BufferedImage.TYPE_4BYTE_ABGR);\n            drawHudImage();\n            // load and set the texture\n            // we specify by reference so we can update the image dynamically\n            TextureLoader loader = new TextureLoader(imgHud, TextureLoader.BY_REFERENCE);\n            textureHud = (Texture2D) loader.getTexture();\n            icHud = (ImageComponent2D) textureHud.getImage(0);\n            // set the texture\n            appHud.setTexture(textureHud);\n            hudUpdater = new HudUpdater(this);\n            // set a default white material\n            //Material mat = new Material();\n            //mat.setLightingEnable(true);    // lighting switched on\n            //appHud.setMaterial(mat);\n            shapeHud.setAppearance(appHud);\n            icHud.setCapability(ImageComponent.ALLOW_IMAGE_WRITE);\n            bgHud.addChild(shapeHud);\n            vp.setPlatformGeometry(bgHud);\n        }\n    }\n\n    // draw the hud background image\n    public void drawHudImage() {\n        // a test\n        //imgHud = new BufferedImage(imgHudBack.getWidth(this),imgHudBack.getHeight(this),BufferedImage.TYPE_4BYTE_ABGR);\n        // a test\n        Graphics gtmp = imgHud.getGraphics();\n        gtmp.drawImage(imgHudBack, 0, 0, this);\n        //gtmp.drawLine(0,0,100,100);\n        String stmp = \"X=\" + vViewPos.x + \" Y=\" + vViewPos.y + \" Z=\" + vViewPos.z;\n        gtmp.drawString(stmp, 10, imgHudBack.getHeight(this) - 20);\n        //System.out.println(\"strtmp=\"+stmp);\n    }\n\n    public void updateHud() {\n        icHud.updateData(hudUpdater, 0, 0, imgHudBack.getWidth(this), imgHudBack.getHeight(this));\n    }\n\n    // test routine which adds a cylinder to the view platform to\n    // give an idea as to where a \"weapon\" is pointing.\n    public void addPickCylinder() {\n        ViewingPlatform vp = su.getViewingPlatform();\n        // view point TG\n        tgView = vp.getViewPlatformTransform();\n        PlatformGeometry bgPickCyl = new PlatformGeometry();\n        t3dTmp.rotX(Math.toRadians(90.0f));\n        v3fTmp.set(0.0f, 0.0f, 1.0f);\n        t3dTmp2.set(v3fTmp);\n        t3dTmp.mul(t3dTmp2);\n        TransformGroup tgPickCyl = new TransformGroup(t3dTmp);\n        tgPickCyl.addChild(new Cylinder(0.05f, 300.0f));\n        bgPickCyl.addChild(tgPickCyl);\n        vp.setPlatformGeometry(bgPickCyl);\n    }\n\n    /*\n  public void loadFloorData()\n    {\n    tl = new TederLayer(30,30);\n    td.doLoadSingleLayer(tl,\"tiles.dat\");\n    }\n    \n  public void addFloorTiles(TransformGroup tgParent)\n    {\n    loadFloorData();\n    \n    ArrayList al = new ArrayList(4);\n    float tilex = 0.0f;\n    float tilez = 0.0f;\n    Point3f p1 = new Point3f(tilex,      0.0f,   tilez+TILE_WIDTH);\n    Point3f p2 = new Point3f(tilex+TILE_WIDTH, 0.0f,   tilez+TILE_WIDTH);\n    Point3f p3 = new Point3f(tilex+TILE_WIDTH, 0.0f,   tilez);\n    Point3f p4 = new Point3f(tilex,      0.0f,   tilez);   \n    al.add(p1); al.add(p2);  \n    al.add(p3); al.add(p4);  \n   \n    // width is the x direction\n    // height is the +z direction\n    int i,j;\n    int idx = 0;\n    for (i=0;i<tl.wid;i++)\n      {\n      tilex = 0.0f;\n      for (j=0;j<tl.hei;j++)\n        {\n        // change the points, they are already inside the array list\n        p1.set(tilex,0.0f,tilez+TILE_WIDTH);\n        p2.set(tilex+TILE_WIDTH,0.0f,tilez+TILE_WIDTH);\n        p3.set(tilex+TILE_WIDTH,0.0f,tilez);\n        p4.set(tilex,0.0f,tilez);\n        \n        // only add the tile if it has a texture\n        if (tl.tiles[idx]>=0)\n          tgFloor.addChild(new Tile(al,tl.tiles[idx]));\n        else\n          tgFloor.addChild(new Tile(al,-1));\n        tilex = tilex + TILE_WIDTH;\n        idx++;\n        }\n      tilez = tilez + TILE_WIDTH;\n      }\n    \n    }\n  public void addFloorCoords(ArrayList al)\n    {\n    float x = -0.5f;\n    float z = -0.5f;\n    // points created in counter-clockwise order\n    Point3f p1 = new Point3f(x,      0.0f,   z+5.0f);\n    Point3f p2 = new Point3f(x+5.0f, 0.0f,   z+5.0f);\n    Point3f p3 = new Point3f(x+5.0f, 0.0f,   z);\n    Point3f p4 = new Point3f(x,      0.0f,   z);   \n    al.add(p1); al.add(p2);  \n    al.add(p3); al.add(p4);  \n    }\n  \n      class Tile extends Shape3D\n        {\n        private QuadArray tile;\n        private int itexture;\n        \n        public Tile(ArrayList alCoords,int itextureInit)\n          {\n          itexture = itextureInit;\n          Vector3f upNorm = new Vector3f(0.0f, 1.0f, 0.0f);   // pointing up\n          \n          tile = new QuadArray(alCoords.size(),GeometryArray.COORDINATES | \n                                               GeometryArray.TEXTURE_COORDINATE_2 |\n                                               GeometryArray.NORMALS);\n          Point3f[] points = new Point3f[alCoords.size()];\n          alCoords.toArray( points );\n          tile.setCoordinates(0, points);\n \n          // assign texture coords to each quad\n          // counter-clockwise, from bottom left\n          TexCoord2f[] tcoords = new TexCoord2f[alCoords.size()];\n          for(int i=0; i < alCoords.size(); i=i+4) \n            {\n            tcoords[i] = new TexCoord2f(0.0f, 0.0f);   // for 1 point\n            tcoords[i+1] = new TexCoord2f(1.0f, 0.0f);\n            tcoords[i+2] = new TexCoord2f(1.0f, 1.0f);\n            tcoords[i+3] = new TexCoord2f(0.0f, 1.0f);\n            }\n          tile.setTextureCoordinates(0, 0, tcoords);\n         \n          // set the surface normal\n          for(int i=0; i < alCoords.size(); i++)\n            tile.setNormal(i, upNorm);\n            \n          setGeometry(tile);\n          \n          Appearance app = new Appearance();\n\n          if (itexture>=0)\n            setAppearance(tileTextures[itexture]);\n          else\n            setAppearance(textureStone);\n\n          }\n        }\n*/\n    public void createLights() {\n        // simple ambient white light\n        Color3f cWhite = new Color3f(1.0f, 1.0f, 1.0f);\n        AmbientLight amb = new AmbientLight(cWhite);\n        amb.setInfluencingBounds(boundsMain);\n        bgMain.addChild(amb);\n        // add one directional light pointing straight down\n        Vector3f vLight1 = new Vector3f(-1.0f, 1.0f, -1.0f);\n        DirectionalLight light = new DirectionalLight(cWhite, vLight1);\n        light.setInfluencingBounds(boundsMain);\n        light.setDirection(new Vector3f(1.0f, -1.0f, 1.0f));\n        bgMain.addChild(light);\n    }\n\n    public void initViewPosition() {\n        ViewingPlatform vp = su.getViewingPlatform();\n        TransformGroup tgView = vp.getViewPlatformTransform();\n        Transform3D t3d = new Transform3D();\n        // setup the initial yaw pitch roll\n        t3d.rotY(Math.toRadians(-90.0));\n        t3dYPR.mul(t3d);\n        // set the initial view position and orientation\n        t3d.set(t3dYPR);\n        t3dTmp2.set(vViewPos);\n        t3d.mul(t3dTmp2);\n        //tgView.getTransform(t3d);\n        // look at the origin, orient up\n        //t3d.lookAt(vViewPos,new Point3d(0,0,0),vViewOri);\n        //t3d.invert();\n        tgView.setTransform(t3d);\n    }\n\n    public boolean adjustMoveDistance(Vector3f vMove) {\n        // NOTE: I do not like creating the point3d and v3d everytime in this method\n        // it will have problems with performance and will need to be addressed\n        // WWH\n        // create the pick tool on first distance check, reuse for all later checks\n        if (pickTool == null) {\n            // create the picktool to always use the map\n            pickTool = new PickTool(bgMap);\n            /*\n      pickCylinder = new PickCylinderRay(new Point3d(vViewPos.x,vViewPos.y,vViewPos.z), \n                                         new Vector3d(vMove.x,vMove.y,vMove.z), \n                                         0.10d);\n      */\n        }\n        // set the shape of the pick tool as a ray from the current location\n        // in the direction of the move\n        pickTool.setShapeRay(new Point3d(vViewPos.x, vViewPos.y, vViewPos.z), new Vector3d(vMove.x, vMove.y, vMove.z));\n        // get a pick to the closest shape\n        PickResult res = pickTool.pickClosest();\n        // if we got a result, check for the closest intersection distance\n        if (res != null) {\n            int j;\n            // a big number just in case\n            float closestIntersect = 10000000.0f;\n            for (j = 0; j < res.numIntersections(); j++) {\n                if ((j == 0) || (res.getIntersection(j).getDistance() < closestIntersect))\n                    closestIntersect = (float) res.getIntersection(j).getDistance();\n            }\n            //System.out.println(\"closestIntersect = \"+closestIntersect);\n            if (closestIntersect < 2.0) {\n                // collision, adjust accordingly\n                vMove.set(0.0f, 0.0f, 0.0f);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void checkSphereHit() {\n        boolean didHit = true;\n        // we keep checking because one bounce may lead to another until we\n        // are headed away from all the walls\n        while (didHit) {\n            didHit = false;\n            // we are sharing the pick tool\n            if (pickTool == null) {\n                // create the picktool to always use the map\n                pickTool = new PickTool(bgMap);\n            }\n            // check for collision with a wall\n            pickTool.setShapeRay(new Point3d(vSpherePos.x, vSpherePos.y, vSpherePos.z), new Vector3d(vSphereVel.x, vSphereVel.y, vSphereVel.z));\n            // get a pick to the closest shape\n            PickResult res = pickTool.pickClosest();\n            // if we got a result, check for the closest intersection distance\n            if (res != null) {\n                int j;\n                // a big number just in case\n                float closestIntersect = 10000000.0f;\n                for (j = 0; j < res.numIntersections(); j++) {\n                    if ((j == 0) || (res.getIntersection(j).getDistance() < closestIntersect))\n                        closestIntersect = (float) res.getIntersection(j).getDistance();\n                }\n                // bounce if we are going to move beyond the wall\n                float magVel = vSphereVel.length();\n                //System.out.println(\"closestIntersect = \"+closestIntersect+\" velLen=\"+magVel);\n                if (closestIntersect < magVel) {\n                    //System.out.println(\"sphere hit dist=\"+closestIntersect+\" node=\"+res.getObject());\n                    // need the surface normal for the object it just hit\n                    Node nd = res.getObject();\n                    // we have it as a node, make sure it is a shape 3d\n                    if (nd instanceof Shape3D) {\n                        Shape3D sh = (Shape3D) nd;\n                        Geometry geo = sh.getGeometry();\n                        // we have the geometry, make sure it is a GeometryArray we can get a surface normal from\n                        if (geo instanceof GeometryArray) {\n                            // finally!, after all that, we can get the surface normal\n                            // just use the normal from the first vertex.\n                            ((GeometryArray) geo).getNormal(0, v3fTmp);\n                            // get a unit vector from the velocity\n                            //v3fTmp3.normalize(vSphereVel);\n                            // I had to double normalize here because a 180 degree vector with value\n                            // = 0.99999994 caused the normal to not be unit length - very odd\n                            v3fTmp3.set(vSphereVel);\n                            v3fTmp3.normalize();\n                            v3fTmp3.normalize();\n                            // get the dot product between the two\n                            float f = (float) v3fTmp.dot(v3fTmp3);\n                            // -1 for the dot product means the vectors are parallel and 180 in direction\n                            if (f == -1.0f) {\n                                // direct hit, the vectors face each other exactly, just reverse the velocity\n                                //System.out.println(\"negate the velocity\");\n                                vSphereVel.negate();\n                                // subtract a little friction to make up for the fact that the\n                                // sphere didn't actually touch the wall\n                                vSphereVel.scale(0.90f);\n                                didHit = true;\n                                // set the sphere to that intersection point\n                                // WWH - exercise for later\n                            } else if (// obtuse angle dot product - headed towards object\n                            f < 0.0f) {\n                                /* now for the not so simple case of an arbitrary hit */\n                                /* dot < 0.0 means we are headed towards the object (obtuse angle) */\n                                /* what we do here is rotate the velocity vector around the\n                 * cross product of the two vectors\n                 */\n                                v3fTmp2.cross(v3fTmp, v3fTmp3);\n                                //System.out.println(\"Normal = \"+v3fTmp+\"  vel=\"+vSphereVel+\" normvel=\"+v3fTmp3+\"  dot=\"+v3fTmp.dot(v3fTmp3)+\" cross=\"+v3fTmp2);\n                                // convert it to an angle\n                                f = (float) Math.toDegrees(Math.acos(f));\n                                // ret ang is the angle from the surface normal and the new bounce/return angle\n                                // draw some pictures to decide why 180-f\n                                float retang = 180.0f - f;\n                                // reflect the velocity as we will rotate that through the surface normal\n                                vSphereVel.negate();\n                                // rotate that the angle between the normal *2\n                                float frot = retang * 2.0f;\n                                // reusing the temporary AxisAngle that YPR uses\n                                //System.out.println(\"rot ang = \"+frot);\n                                aaYPR.set(v3fTmp2, (float) Math.toRadians(frot));\n                                // create a matrix then transform with this rotate\n                                m3fTmp1.set(aaYPR);\n                                t3dTmp.set(m3fTmp1);\n                                // multiply the current velocity by that rotation\n                                t3dTmp.transform(vSphereVel);\n                                // subtract a little friction to make up for the fact that the\n                                // sphere didn't actually touch the wall\n                                // otherwise the bounce gets larger and larger. This is a kludge\n                                vSphereVel.scale(0.90f);\n                                //System.out.println(\" post bounce vel=\"+vSphereVel);\n                                didHit = true;\n                            }\n                        }\n                        //System.out.println(\"is a shape3d \"+((Shape3D)nd).getGeometry());\n                    }\n                }\n                // closest intersect\n            }\n            // check pick result\n        }\n        // while didHit\n    }\n\n    public void tickSphere() {\n        // add some gravity to the sphere\n        vSphereVel.y = vSphereVel.y - 0.05f;\n        checkSphereHit();\n        // add the current velocity to the sphere\n        vSpherePos.add(vSphereVel);\n        // create a location translation transform for the sphere\n        t3dTmp.setTranslation(vSpherePos);\n        // set the changed transform\n        tgSphere.setTransform(t3dTmp);\n    }\n\n    public void tick() {\n        tickSphere();\n        updateHud();\n        if ((keyForward == true) || (keyBackward == true)) {\n            if (keyForward)\n                v3fTmp.set(0.0f, 0.0f, -1.0f);\n            else\n                v3fTmp.set(0.0f, 0.0f, 1.0f);\n            // transform the unit vector\n            t3dYPR.transform(v3fTmp);\n            // don't want a full unit, or it goes too fast\n            v3fTmp.scale(0.1f);\n            // map collision detection\n            adjustMoveDistance(v3fTmp);\n            // add that direction to the current position\n            vViewPos.add(v3fTmp);\n        }\n        if (keyLeft == true) {\n            // create a vector in the y direction\n            v3fTmp.set(0.0f, 1.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // create axis to rotate around that y axis in our orientation coordinate space\n            aaYPR.set(v3fTmp, (float) Math.toRadians(TURNDELTA));\n            // set a temporary transform\n            m3fTmp1.set(aaYPR);\n            t3dTmp.set(m3fTmp1);\n            // multiply the current view by that rotation\n            t3dYPR.mul(t3dTmp);\n            t3dYPR.normalize();\n        }\n        if (keyRight == true) {\n            // create a vector in the y direction\n            v3fTmp.set(0.0f, 1.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // create axis to rotate around that y axis in our orientation coordinate space\n            aaYPR.set(v3fTmp, (float) -Math.toRadians(TURNDELTA));\n            // set a temporary transform\n            m3fTmp1.set(aaYPR);\n            t3dTmp.set(m3fTmp1);\n            // multiply the current view by that rotation\n            t3dYPR.mul(t3dTmp);\n            t3dYPR.normalize();\n        }\n        if (keyStrafeLeft == true) {\n            // movement in the -x direction\n            v3fTmp.set(-1.0f, 0.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // don't want a full unit, or it goes too fast\n            v3fTmp.scale(0.1f);\n            // map collision detection\n            adjustMoveDistance(v3fTmp);\n            // add that direction to the current position\n            vViewPos.add(v3fTmp);\n        }\n        if (keyStrafeRight == true) {\n            // movement in the x direction\n            v3fTmp.set(1.0f, 0.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // don't want a full unit, or it goes too fast\n            v3fTmp.scale(0.1f);\n            // map collision detection\n            adjustMoveDistance(v3fTmp);\n            // add that direction to the current position\n            vViewPos.add(v3fTmp);\n        }\n        if (keyLookDown == true) {\n            lookUpAngle = lookUpAngle + 0.5f;\n            if (lookUpAngle > 45.0f)\n                lookUpAngle = 45.0f;\n        }\n        if (keyLookUp == true) {\n            lookUpAngle = lookUpAngle - 0.5f;\n            if (lookUpAngle < -45.0f)\n                lookUpAngle = -45.0f;\n        }\n        // set the temporary transform to the view/camera location\n        t3dTmp.setIdentity();\n        t3dTmp.setTranslation(vViewPos);\n        // add the y lookup angle\n        // create a vector in the x direction\n        v3fTmp.set(1.0f, 0.0f, 0.0f);\n        // rotate that vector into the current orientation\n        t3dYPR.transform(v3fTmp);\n        // create axis to rotate around that y axis in our orientation coordinate space\n        aaYPR.set(v3fTmp, (float) -Math.toRadians(lookUpAngle));\n        // set a temporary transform\n        m3fTmp1.set(aaYPR);\n        t3dTmp2.set(m3fTmp1);\n        // multiply the current view by that rotation\n        t3dTmp.mul(t3dTmp2);\n        // multiply the transform by the current view orientation\n        t3dTmp2.set(t3dYPR);\n        t3dTmp.mul(t3dTmp2);\n        tgView.setTransform(t3dTmp);\n    }\n\n    public void doFire() {\n        // pick\n        v3fTmp.set(0.0f, 0.0f, -1.0f);\n        // rotate the pick vector into the current view\n        t3dYPR.transform(v3fTmp);\n        PickCanvas pickCanvas = new PickCanvas(c3d, bgMain);\n        pickCanvas.setMode(PickTool.GEOMETRY_INTERSECT_INFO);\n        pickCanvas.setTolerance(4.0f);\n        pickCanvas.setShapeLocation(getWidth() / 2, getHeight() / 2);\n        PickResult[] results = pickCanvas.pickAll();\n        if (results != null) {\n            // find the closest object that we clicked on\n            int i, j;\n            int idx = 0;\n            // a big number just in case\n            float dst = 100000000.0f;\n            for (i = 0; i < results.length; i++) {\n                // a big number just in case\n                float closestIntersect = 10000000.0f;\n                for (j = 0; j < results[i].numIntersections(); j++) {\n                    if ((j == 0) || (results[i].getIntersection(j).getDistance() < closestIntersect))\n                        closestIntersect = (float) results[i].getIntersection(j).getDistance();\n                }\n                if ((i == 0) || (closestIntersect < dst)) {\n                    idx = i;\n                    dst = closestIntersect;\n                }\n            }\n            // is the closest object the sphere\n            if (results[idx].getObject() == sphere.getShape()) {\n                // v3fTmp now contains the ray that we hit the sphere with\n                // we need to change the ball's velocity with it\n                v3fTmp.normalize();\n                vSphereVel.add(v3fTmp);\n            }\n        }\n    }\n\n    public void keyPressed(KeyEvent e) {\n        int keyCode = e.getKeyCode();\n        if ((keyCode == KeyEvent.VK_ESCAPE) || (keyCode == KeyEvent.VK_Q) || ((keyCode == KeyEvent.VK_C) && e.isControlDown())) {\n            parent.dispose();\n            // exit() alone isn't sufficient most of the time\n            System.exit(0);\n        }\n    }\n\n    public void keyReleased(KeyEvent e) {\n    }\n\n    public void keyTyped(KeyEvent e) {\n    }\n\n    protected void processKeyDown(int keycode) {\n        if (keycode == KeyEvent.VK_W)\n            keyForward = true;\n        else if (keycode == KeyEvent.VK_S)\n            keyBackward = true;\n        else if (keycode == KeyEvent.VK_LEFT)\n            keyLeft = true;\n        else if (keycode == KeyEvent.VK_RIGHT)\n            keyRight = true;\n        else if (keycode == KeyEvent.VK_A)\n            keyStrafeLeft = true;\n        else if (keycode == KeyEvent.VK_D)\n            keyStrafeRight = true;\n        else if (keycode == KeyEvent.VK_UP)\n            keyLookUp = true;\n        else if (keycode == KeyEvent.VK_DOWN)\n            keyLookDown = true;\n        else if (keycode == KeyEvent.VK_SPACE)\n            doFire();\n    }\n\n    protected void processKeyUp(int keycode) {\n        if (keycode == KeyEvent.VK_W)\n            keyForward = false;\n        else if (keycode == KeyEvent.VK_S)\n            keyBackward = false;\n        else if (keycode == KeyEvent.VK_LEFT)\n            keyLeft = false;\n        else if (keycode == KeyEvent.VK_RIGHT)\n            keyRight = false;\n        else if (keycode == KeyEvent.VK_A)\n            keyStrafeLeft = false;\n        else if (keycode == KeyEvent.VK_D)\n            keyStrafeRight = false;\n        else if (keycode == KeyEvent.VK_UP)\n            keyLookUp = false;\n        else if (keycode == KeyEvent.VK_DOWN)\n            keyLookDown = false;\n    }\n\n    protected void processMouseMove(MouseEvent me) {\n        //System.out.println(\"mex = \"+me.getX());\n        //System.out.println(\"mey = \"+me.getY());\n        diffx = lastMouseX - me.getX();\n        diffy = lastMouseY - me.getY();\n        //offcenterX = me.getX() - (getWidth()/2);\n        //offcenterY = me.getY() - (getHeight()/2);\n        offcenterX = me.getX() - lastMouseX;\n        offcenterY = me.getY() - lastMouseY;\n        lastMouseX = me.getX();\n        lastMouseY = me.getY();\n        lastMouseX = getWidth() / 2;\n        lastMouseY = getHeight() / 2;\n        // put the mouse back in the center\n        Point p = getLocationOnScreen();\n        robot.mouseMove(p.x + lastMouseX, p.y + lastMouseY);\n        // probably too much processing to use a float for this check\n        // fix later\n        float abs = Math.abs(offcenterX);\n        if (abs > 0.0f) {\n            // create a vector in the y direction\n            v3fTmp.set(0.0f, 1.0f, 0.0f);\n            // rotate that vector into the current orientation\n            t3dYPR.transform(v3fTmp);\n            // muck with the turn delta\n            // bigger offsets make bigger turns\n            float td = (float) -offcenterX * 0.0005f;\n            // maximum turns\n            if (Math.abs(td) > 0.02) {\n                if (td > 0.0f)\n                    td = 0.02f;\n                else\n                    td = -0.02f;\n            }\n            // create axis to rotate around that y axis in our orientation coordinate space\n            aaYPR.set(v3fTmp, td);\n            // set a temporary transform\n            m3fTmp1.set(aaYPR);\n            t3dTmp.set(m3fTmp1);\n            // multiply the current view by that rotation\n            t3dYPR.mul(t3dTmp);\n            t3dYPR.normalize();\n        }\n        abs = Math.abs(offcenterY);\n        if ((abs > 0.0f) && (abs < 120.0)) {\n            float rotAng = offcenterY * 0.05f;\n            //System.out.println(\"rotAng = \"+rotAng);\n            lookUpAngle = lookUpAngle + rotAng;\n            if (lookUpAngle > 45.0f)\n                lookUpAngle = 45.0f;\n            else if (lookUpAngle < -45.0f)\n                lookUpAngle = -45.0f;\n        }\n    }\n\n    protected void processMouseClicked(MouseEvent me) {\n        doFire();\n    }\n}\n\n// Fps370Panel\nclass KeyUpBehavior extends Behavior {\n\n    Fps370Panel t3p;\n\n    WakeupCondition keyRelease;\n\n    public KeyUpBehavior(Fps370Panel t3pInit) {\n        t3p = t3pInit;\n        keyRelease = new WakeupOnAWTEvent(KeyEvent.KEY_RELEASED);\n    }\n\n    public void initialize() {\n        wakeupOn(keyRelease);\n    }\n\n    public void processStimulus(Enumeration criteria) {\n        WakeupCriterion wakeup;\n        AWTEvent[] event;\n        boolean resetKeyDown = false;\n        boolean resetKeyUp = false;\n        //System.out.println(\"process stimulus: \"+criteria);\n        while (criteria.hasMoreElements()) {\n            wakeup = (WakeupCriterion) criteria.nextElement();\n            if (wakeup instanceof WakeupOnAWTEvent) {\n                event = ((WakeupOnAWTEvent) wakeup).getAWTEvent();\n                for (int i = 0; i < event.length; i++) {\n                    if (event[i].getID() == KeyEvent.KEY_RELEASED) {\n                        t3p.processKeyUp(((KeyEvent) event[i]).getKeyCode());\n                    }\n                }\n            }\n        }\n        wakeupOn(keyRelease);\n    }\n    // end of processStimulus()\n}\n\nclass KeyDownBehavior extends Behavior {\n\n    Fps370Panel t3p;\n\n    WakeupCondition keyPress;\n\n    public KeyDownBehavior(Fps370Panel t3pInit) {\n        t3p = t3pInit;\n        keyPress = new WakeupOnAWTEvent(KeyEvent.KEY_PRESSED);\n    }\n\n    public void initialize() {\n        wakeupOn(keyPress);\n    }\n\n    public void processStimulus(Enumeration criteria) {\n        WakeupCriterion wakeup;\n        AWTEvent[] event;\n        boolean resetKeyDown = false;\n        boolean resetKeyUp = false;\n        //System.out.println(\"process stimulus: \"+criteria);\n        while (criteria.hasMoreElements()) {\n            wakeup = (WakeupCriterion) criteria.nextElement();\n            if (wakeup instanceof WakeupOnAWTEvent) {\n                event = ((WakeupOnAWTEvent) wakeup).getAWTEvent();\n                for (int i = 0; i < event.length; i++) {\n                    if (event[i].getID() == KeyEvent.KEY_PRESSED) {\n                        t3p.processKeyDown(((KeyEvent) event[i]).getKeyCode());\n                    }\n                }\n            }\n        }\n        wakeupOn(keyPress);\n    }\n    // end of processStimulus()\n}\n\nclass MouseMoveBehavior extends MouseBehavior {\n\n    Fps370Panel t3p;\n\n    WakeupCondition mouseMove;\n\n    public MouseMoveBehavior(Fps370Panel t3pInit) {\n        super(t3pInit, MouseEvent.MOUSE_MOVED);\n        t3p = t3pInit;\n        mouseMove = new WakeupOnAWTEvent((long) (MouseEvent.MOUSE_MOVED | MouseEvent.MOUSE_CLICKED));\n    }\n\n    public void initialize() {\n        wakeupOn(mouseMove);\n    }\n\n    public void processStimulus(Enumeration criteria) {\n        WakeupCriterion wakeup;\n        AWTEvent[] event;\n        boolean resetKeyDown = false;\n        boolean resetKeyUp = false;\n        //System.out.println(\"process stimulus: \"+criteria);\n        while (criteria.hasMoreElements()) {\n            wakeup = (WakeupCriterion) criteria.nextElement();\n            if (wakeup instanceof WakeupOnAWTEvent) {\n                event = ((WakeupOnAWTEvent) wakeup).getAWTEvent();\n                for (int i = 0; i < event.length; i++) {\n                    if (event[i].getID() == MouseEvent.MOUSE_MOVED) {\n                        //System.out.println(\"Mouse moved\");\n                        t3p.processMouseMove(((MouseEvent) event[i]));\n                    } else if (event[i].getID() == MouseEvent.MOUSE_CLICKED) {\n                        //System.out.println(\"mouse clicked\");\n                        t3p.processMouseClicked((MouseEvent) event[i]);\n                    }\n                }\n            }\n        }\n        wakeupOn(mouseMove);\n    }\n    // end of processStimulus()\n}\n\nclass HudUpdater implements ImageComponent2D.Updater {\n\n    private Fps370Panel parent;\n\n    public HudUpdater(Fps370Panel parentInit) {\n        parent = parentInit;\n    }\n\n    public void updateData(ImageComponent2D icUpdate, int x, int y, int width, int height) {\n        //System.out.println(\"HUD Update Data x=\"+x+\" y=\"+y+\" w=\"+width+\" h=\"+height);\n        parent.drawHudImage();\n        //sicUpdate.set(parent.imgHud);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/fps370/Fps370PanelTest1.java",
		"test_prompt": "// Fps370PanelTest1.java\npackage fps370;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\nimport javax.media.j3d.*;\nimport javax.swing.*;\nimport javax.vecmath.*;\nimport com.sun.j3d.utils.universe.*;\nimport com.sun.j3d.utils.geometry.*;\nimport com.sun.j3d.utils.image.*;\nimport com.sun.j3d.utils.behaviors.mouse.*;\nimport com.sun.j3d.utils.picking.*;\nimport com.sun.j3d.loaders.*;\n//import com.mnstarfire.loaders3d.Loader3DS;\nimport com.glyphein.j3d.loaders.milkshape.MS3DLoader;\nimport teder.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Fps370Panel}.\n* It contains ten unit test cases for the {@link Fps370Panel#adjustMoveDistance(Vector3f)} method.\n*/\nclass Fps370PanelTest1 {"
	},
	{
		"original_code": "// TederFrame.java\npackage teder;\n\n/*\n * TederFrame - Game tile editor frame\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n *\n */\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.filechooser.*;\n\npublic class TederFrame extends JFrame implements ActionListener, WindowListener {\n\n    public static final int DEFAULT_WIDTH = 800;\n\n    public static final int DEFAULT_HEIGHT = 600;\n\n    public TederData ttd;\n\n    public TederPanel ttp;\n\n    // swing componenet for the menu bar\n    public JMenuBar mbar;\n\n    public JMenu fileMenu;\n\n    public JMenuItem openMenuItem;\n\n    public JMenuItem saveMenuItem;\n\n    public JMenuItem saveAsMenuItem;\n\n    public JMenuItem exitMenuItem;\n\n    public JMenu mapMenu;\n\n    public JMenuItem resizeMenuItem;\n\n    public JMenu tileMenu;\n\n    public JCheckBoxMenuItem[] tileItems;\n\n    public JScrollPane spMain;\n\n    // the path to the last file operation\n    public String lastPath;\n\n    public TederFrame() {\n        // get the program startup location\n        lastPath = System.getProperty(\"user.dir\");\n        ttd = new TederData(30, 30, 64, 64, \"images/tiles.gif\", this);\n        ttp = new TederPanel(ttd);\n        createMenuBar();\n        //this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n        addWindowListener(this);\n        setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n        //spMain = new JScrollPane(ttp,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n        //                             JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        spMain = new JScrollPane(ttp);\n        spMain.setPreferredSize(new Dimension(200, 200));\n        // add the panel to this frame\n        //add(ttp);\n        add(spMain);\n    }\n\n    /*------------------- WindowListener ---------------------*/\n    public void windowActivated(WindowEvent e) {\n    }\n\n    public void windowClosed(WindowEvent e) {\n        System.exit(0);\n    }\n\n    public void windowClosing(WindowEvent e) {\n        if (okayToClose()) {\n            System.exit(0);\n        }\n    }\n\n    public void windowDeactivated(WindowEvent e) {\n    }\n\n    public void windowDeiconified(WindowEvent e) {\n    }\n\n    public void windowIconified(WindowEvent e) {\n    }\n\n    public void windowOpened(WindowEvent e) {\n    }\n\n    /*------------------- WindowListener ---------------------*/\n    public boolean okayToClose() {\n        if (ttd.getHasChanged()) {\n            // need to pop up a dialog to see if it is okay to close\n            //Custom button text\n            Object[] options = { \"Yes\", \"No\", \"Cancel\" };\n            int n = JOptionPane.showOptionDialog(this, \"The map has changed would you like to save the file before proceeding?\", \"File Has Changed\", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[2]);\n            if (n == 0) {\n                return doSaveFile();\n            } else if (n == 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void createMenuBar() {\n        JMenuItem itmTmp;\n        mbar = new JMenuBar();\n        /*     FILE MENU     */\n        fileMenu = new JMenu(\"File\");\n        // new is one way to do it where we check for the string in the listener\n        // create the item\n        itmTmp = new JMenuItem(\"New\");\n        // add the event listener\n        itmTmp.addActionListener(this);\n        // add the item to the menu\n        fileMenu.add(itmTmp);\n        // the other way to do it is to save references to each item.\n        // this is better since you do less string processing, but it\n        // takes more memory. Always a trade off.\n        openMenuItem = new JMenuItem(\"Open...\");\n        openMenuItem.addActionListener(this);\n        fileMenu.add(openMenuItem);\n        saveMenuItem = new JMenuItem(\"Save\");\n        saveMenuItem.addActionListener(this);\n        fileMenu.add(saveMenuItem);\n        saveAsMenuItem = new JMenuItem(\"Save As...\");\n        saveAsMenuItem.addActionListener(this);\n        fileMenu.add(saveAsMenuItem);\n        // the last way is not demonstrated, that is a special object\n        // just for the individual item event handling. All the books show\n        // it as the correct way to handle events. It is the most\n        // memory/disk intensive. Not shown here.\n        // exit is the other way, we keep the object reference and check for that\n        exitMenuItem = new JMenuItem(\"Exit\");\n        exitMenuItem.addActionListener(this);\n        fileMenu.add(exitMenuItem);\n        mbar.add(fileMenu);\n        /*     EDIT MENU     */\n        /*     MAP MENU */\n        mapMenu = new JMenu(\"Map\");\n        resizeMenuItem = new JMenuItem(\"Resize\");\n        resizeMenuItem.addActionListener(this);\n        mapMenu.add(resizeMenuItem);\n        mbar.add(mapMenu);\n        /*     TILES MENU    */\n        tileMenu = new JMenu(\"Tile\");\n        tileItems = new JCheckBoxMenuItem[TederData.NUM_TILES];\n        int i;\n        for (i = 0; i < TederData.NUM_TILES; i++) {\n            tileItems[i] = new JCheckBoxMenuItem(\"Tile \" + i, new ImageIcon(\"images/tile_icons/tile\" + i + \".gif\"));\n            tileItems[i].addActionListener(this);\n            tileMenu.add(tileItems[i]);\n        }\n        mbar.add(tileMenu);\n        //mbar.addActionListener(this);\n        adjustMenus();\n        this.setJMenuBar(mbar);\n    }\n\n    // action listener handling\n    public void actionPerformed(ActionEvent evt) {\n        //System.out.println(\"evt=\"+evt);\n        if (evt.getActionCommand().equals(\"New\")) {\n            System.out.println(\"New command selected\");\n        } else if (evt.getSource() == exitMenuItem) {\n            System.out.println(\"Exit selected\");\n            if (okayToClose())\n                System.exit(0);\n        } else if (evt.getSource() == saveMenuItem) {\n            this.doSaveFile();\n            ttd.doSave();\n        } else if (evt.getSource() == saveAsMenuItem) {\n            this.doSaveAsFile();\n        } else if (evt.getSource() == openMenuItem) {\n            doLoadFile();\n            ttp.resetPreferredSize();\n            this.repaint();\n        } else if (evt.getSource() == resizeMenuItem) {\n            doMapSizeDialog();\n            this.repaint();\n        } else {\n            // may be one of the tiles\n            int i;\n            for (i = 0; i < TederData.NUM_TILES; i++) {\n                if (evt.getSource() == tileItems[i]) {\n                    ttp.curTile = i;\n                }\n            }\n            adjustMenus();\n        }\n    }\n\n    public void adjustMenus() {\n        int i;\n        for (i = 0; i < TederData.NUM_TILES; i++) {\n            if (i == ttp.curTile)\n                tileItems[i].setState(true);\n            else\n                tileItems[i].setState(false);\n        }\n    }\n\n    public void doLoadFile() {\n        JFileChooser chooser;\n        if (!okayToClose())\n            return;\n        if (lastPath == null) {\n            chooser = new JFileChooser();\n        } else {\n            File fiTmp = new File(lastPath);\n            chooser = new JFileChooser(fiTmp);\n        }\n        //chooser.setDialogType(JFileChooser.OPEN_DIALOG);\n        MapFileFilter filter = new MapFileFilter();\n        chooser.setFileFilter(filter);\n        int returnVal = chooser.showOpenDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File fiSelected = chooser.getSelectedFile();\n            lastPath = fiSelected.getPath();\n            ttd.setFileName(fiSelected.getAbsolutePath());\n            ttd.doLoad();\n            ttd.setHasChanged(false);\n        }\n    }\n\n    public boolean doSaveAsFile() {\n        JFileChooser chooser;\n        if (lastPath == null) {\n            chooser = new JFileChooser();\n        } else {\n            File fiTmp = new File(lastPath);\n            chooser = new JFileChooser(fiTmp);\n        }\n        //chooser.setDialogType(JFileChooser.SAVE_DIALOG);\n        //System.out.println(\"Save file type = SAVE_DIALOG\");\n        MapFileFilter filter = new MapFileFilter();\n        chooser.setFileFilter(filter);\n        int returnVal = chooser.showSaveDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File fiSelected = chooser.getSelectedFile();\n            if (fiSelected.exists()) {\n                // make sure they want to overwrite\n                // need to pop up a dialog to see if it is okay to close\n                //Custom button text\n                Object[] options = { \"Yes\", \"No\" };\n                int n = JOptionPane.showOptionDialog(this, \"The file already exists, would you like to overwrite?\", \"File Exists\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n                if (n == 1) {\n                    return false;\n                }\n            }\n            // exists\n            lastPath = fiSelected.getPath();\n            ttd.setFileName(fiSelected.getAbsolutePath());\n            ttd.doSave();\n            ttd.setHasChanged(false);\n            return true;\n        }\n        // user pressed cancel, return false that it did not save\n        return false;\n    }\n\n    public boolean doSaveFile() {\n        if (ttd.isValidFile()) {\n            ttd.doSave();\n        } else {\n            return doSaveAsFile();\n        }\n        return true;\n    }\n\n    public void setMapSize(int w, int h) {\n        ttd.resize(w, h);\n        ttp.resetPreferredSize();\n    }\n\n    public void doMapSizeDialog() {\n        MapSizeDialog msp = new MapSizeDialog(this, ttd.getWidth(), ttd.getHeight());\n        msp.setVisible(true);\n        /*\n      JDialog dialog = new JDialog(this,\n                                    \"Click a button\",\n                                    true);      \n      dialog.setContentPane(msp);\n\n\n      dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n      dialog.pack();\n      dialog.setLocationRelativeTo(this);\n      dialog.setVisible(true);\n       */\n    }\n\n    class MapFileFilter extends javax.swing.filechooser.FileFilter {\n\n        public MapFileFilter() {\n            super();\n        }\n\n        public boolean accept(File f) {\n            if ((f.getName().endsWith(\".dat\")) || (f.isDirectory())) {\n                return true;\n            }\n            return false;\n        }\n\n        public String getDescription() {\n            return \"Map .dat files\";\n        }\n    }\n\n    class MapSizeDialog extends JDialog {\n\n        TederFrame parent;\n\n        JButton okButton;\n\n        JButton cancelButton;\n\n        JTextField jtfWidth;\n\n        JTextField jtfHeight;\n\n        public MapSizeDialog(TederFrame parentInit, int wid, int hei) {\n            // create this as a modal dialog\n            super(parentInit, true);\n            parent = parentInit;\n            // create all the elements for the pane\n            JPanel inputPane = new JPanel();\n            inputPane.setLayout(new GridLayout(0, 2));\n            inputPane.add(new JLabel(\"Width:\"));\n            jtfWidth = new JTextField(\"\" + wid);\n            inputPane.add(jtfWidth);\n            inputPane.add(new JLabel(\"Height\"));\n            jtfHeight = new JTextField(\"\" + hei);\n            inputPane.add(jtfHeight);\n            inputPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n            JPanel buttonPane = new JPanel();\n            buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));\n            buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));\n            buttonPane.add(Box.createHorizontalGlue());\n            cancelButton = new JButton(\"Cancel\");\n            cancelButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e) {\n                    //pick one of many\n                    if (e.getSource() == cancelButton) {\n                        setVisible(false);\n                        dispose();\n                    }\n                }\n            });\n            buttonPane.add(cancelButton);\n            buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));\n            okButton = new JButton(\"Ok\");\n            okButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e) {\n                    //pick one of many\n                    if (e.getSource() == okButton) {\n                        try {\n                            int wid = Integer.parseInt(jtfWidth.getText());\n                            int hei = Integer.parseInt(jtfHeight.getText());\n                            parent.setMapSize(wid, hei);\n                        } catch (NumberFormatException ex) {\n                            ex.printStackTrace();\n                        }\n                        setVisible(false);\n                        dispose();\n                    }\n                }\n            });\n            buttonPane.add(okButton);\n            Container contentPane = getContentPane();\n            contentPane.add(inputPane, BorderLayout.CENTER);\n            contentPane.add(buttonPane, BorderLayout.PAGE_END);\n            this.pack();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/teder/TederFrameTest0.java",
		"test_prompt": "// TederFrameTest0.java\npackage teder;\n\n/*\n * TederFrame - Game tile editor frame\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n *\n */\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.filechooser.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TederFrame}.\n* It contains ten unit test cases for the {@link TederFrame#okayToClose()} method.\n*/\nclass TederFrameTest0 {"
	},
	{
		"original_code": "// TederFrame.java\npackage teder;\n\n/*\n * TederFrame - Game tile editor frame\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n *\n */\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.filechooser.*;\n\npublic class TederFrame extends JFrame implements ActionListener, WindowListener {\n\n    public static final int DEFAULT_WIDTH = 800;\n\n    public static final int DEFAULT_HEIGHT = 600;\n\n    public TederData ttd;\n\n    public TederPanel ttp;\n\n    // swing componenet for the menu bar\n    public JMenuBar mbar;\n\n    public JMenu fileMenu;\n\n    public JMenuItem openMenuItem;\n\n    public JMenuItem saveMenuItem;\n\n    public JMenuItem saveAsMenuItem;\n\n    public JMenuItem exitMenuItem;\n\n    public JMenu mapMenu;\n\n    public JMenuItem resizeMenuItem;\n\n    public JMenu tileMenu;\n\n    public JCheckBoxMenuItem[] tileItems;\n\n    public JScrollPane spMain;\n\n    // the path to the last file operation\n    public String lastPath;\n\n    public TederFrame() {\n        // get the program startup location\n        lastPath = System.getProperty(\"user.dir\");\n        ttd = new TederData(30, 30, 64, 64, \"images/tiles.gif\", this);\n        ttp = new TederPanel(ttd);\n        createMenuBar();\n        //this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n        addWindowListener(this);\n        setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n        //spMain = new JScrollPane(ttp,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n        //                             JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        spMain = new JScrollPane(ttp);\n        spMain.setPreferredSize(new Dimension(200, 200));\n        // add the panel to this frame\n        //add(ttp);\n        add(spMain);\n    }\n\n    /*------------------- WindowListener ---------------------*/\n    public void windowActivated(WindowEvent e) {\n    }\n\n    public void windowClosed(WindowEvent e) {\n        System.exit(0);\n    }\n\n    public void windowClosing(WindowEvent e) {\n        if (okayToClose()) {\n            System.exit(0);\n        }\n    }\n\n    public void windowDeactivated(WindowEvent e) {\n    }\n\n    public void windowDeiconified(WindowEvent e) {\n    }\n\n    public void windowIconified(WindowEvent e) {\n    }\n\n    public void windowOpened(WindowEvent e) {\n    }\n\n    /*------------------- WindowListener ---------------------*/\n    public boolean okayToClose() {\n        if (ttd.getHasChanged()) {\n            // need to pop up a dialog to see if it is okay to close\n            //Custom button text\n            Object[] options = { \"Yes\", \"No\", \"Cancel\" };\n            int n = JOptionPane.showOptionDialog(this, \"The map has changed would you like to save the file before proceeding?\", \"File Has Changed\", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[2]);\n            if (n == 0) {\n                return doSaveFile();\n            } else if (n == 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void createMenuBar() {\n        JMenuItem itmTmp;\n        mbar = new JMenuBar();\n        /*     FILE MENU     */\n        fileMenu = new JMenu(\"File\");\n        // new is one way to do it where we check for the string in the listener\n        // create the item\n        itmTmp = new JMenuItem(\"New\");\n        // add the event listener\n        itmTmp.addActionListener(this);\n        // add the item to the menu\n        fileMenu.add(itmTmp);\n        // the other way to do it is to save references to each item.\n        // this is better since you do less string processing, but it\n        // takes more memory. Always a trade off.\n        openMenuItem = new JMenuItem(\"Open...\");\n        openMenuItem.addActionListener(this);\n        fileMenu.add(openMenuItem);\n        saveMenuItem = new JMenuItem(\"Save\");\n        saveMenuItem.addActionListener(this);\n        fileMenu.add(saveMenuItem);\n        saveAsMenuItem = new JMenuItem(\"Save As...\");\n        saveAsMenuItem.addActionListener(this);\n        fileMenu.add(saveAsMenuItem);\n        // the last way is not demonstrated, that is a special object\n        // just for the individual item event handling. All the books show\n        // it as the correct way to handle events. It is the most\n        // memory/disk intensive. Not shown here.\n        // exit is the other way, we keep the object reference and check for that\n        exitMenuItem = new JMenuItem(\"Exit\");\n        exitMenuItem.addActionListener(this);\n        fileMenu.add(exitMenuItem);\n        mbar.add(fileMenu);\n        /*     EDIT MENU     */\n        /*     MAP MENU */\n        mapMenu = new JMenu(\"Map\");\n        resizeMenuItem = new JMenuItem(\"Resize\");\n        resizeMenuItem.addActionListener(this);\n        mapMenu.add(resizeMenuItem);\n        mbar.add(mapMenu);\n        /*     TILES MENU    */\n        tileMenu = new JMenu(\"Tile\");\n        tileItems = new JCheckBoxMenuItem[TederData.NUM_TILES];\n        int i;\n        for (i = 0; i < TederData.NUM_TILES; i++) {\n            tileItems[i] = new JCheckBoxMenuItem(\"Tile \" + i, new ImageIcon(\"images/tile_icons/tile\" + i + \".gif\"));\n            tileItems[i].addActionListener(this);\n            tileMenu.add(tileItems[i]);\n        }\n        mbar.add(tileMenu);\n        //mbar.addActionListener(this);\n        adjustMenus();\n        this.setJMenuBar(mbar);\n    }\n\n    // action listener handling\n    public void actionPerformed(ActionEvent evt) {\n        //System.out.println(\"evt=\"+evt);\n        if (evt.getActionCommand().equals(\"New\")) {\n            System.out.println(\"New command selected\");\n        } else if (evt.getSource() == exitMenuItem) {\n            System.out.println(\"Exit selected\");\n            if (okayToClose())\n                System.exit(0);\n        } else if (evt.getSource() == saveMenuItem) {\n            this.doSaveFile();\n            ttd.doSave();\n        } else if (evt.getSource() == saveAsMenuItem) {\n            this.doSaveAsFile();\n        } else if (evt.getSource() == openMenuItem) {\n            doLoadFile();\n            ttp.resetPreferredSize();\n            this.repaint();\n        } else if (evt.getSource() == resizeMenuItem) {\n            doMapSizeDialog();\n            this.repaint();\n        } else {\n            // may be one of the tiles\n            int i;\n            for (i = 0; i < TederData.NUM_TILES; i++) {\n                if (evt.getSource() == tileItems[i]) {\n                    ttp.curTile = i;\n                }\n            }\n            adjustMenus();\n        }\n    }\n\n    public void adjustMenus() {\n        int i;\n        for (i = 0; i < TederData.NUM_TILES; i++) {\n            if (i == ttp.curTile)\n                tileItems[i].setState(true);\n            else\n                tileItems[i].setState(false);\n        }\n    }\n\n    public void doLoadFile() {\n        JFileChooser chooser;\n        if (!okayToClose())\n            return;\n        if (lastPath == null) {\n            chooser = new JFileChooser();\n        } else {\n            File fiTmp = new File(lastPath);\n            chooser = new JFileChooser(fiTmp);\n        }\n        //chooser.setDialogType(JFileChooser.OPEN_DIALOG);\n        MapFileFilter filter = new MapFileFilter();\n        chooser.setFileFilter(filter);\n        int returnVal = chooser.showOpenDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File fiSelected = chooser.getSelectedFile();\n            lastPath = fiSelected.getPath();\n            ttd.setFileName(fiSelected.getAbsolutePath());\n            ttd.doLoad();\n            ttd.setHasChanged(false);\n        }\n    }\n\n    public boolean doSaveAsFile() {\n        JFileChooser chooser;\n        if (lastPath == null) {\n            chooser = new JFileChooser();\n        } else {\n            File fiTmp = new File(lastPath);\n            chooser = new JFileChooser(fiTmp);\n        }\n        //chooser.setDialogType(JFileChooser.SAVE_DIALOG);\n        //System.out.println(\"Save file type = SAVE_DIALOG\");\n        MapFileFilter filter = new MapFileFilter();\n        chooser.setFileFilter(filter);\n        int returnVal = chooser.showSaveDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File fiSelected = chooser.getSelectedFile();\n            if (fiSelected.exists()) {\n                // make sure they want to overwrite\n                // need to pop up a dialog to see if it is okay to close\n                //Custom button text\n                Object[] options = { \"Yes\", \"No\" };\n                int n = JOptionPane.showOptionDialog(this, \"The file already exists, would you like to overwrite?\", \"File Exists\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n                if (n == 1) {\n                    return false;\n                }\n            }\n            // exists\n            lastPath = fiSelected.getPath();\n            ttd.setFileName(fiSelected.getAbsolutePath());\n            ttd.doSave();\n            ttd.setHasChanged(false);\n            return true;\n        }\n        // user pressed cancel, return false that it did not save\n        return false;\n    }\n\n    public boolean doSaveFile() {\n        if (ttd.isValidFile()) {\n            ttd.doSave();\n        } else {\n            return doSaveAsFile();\n        }\n        return true;\n    }\n\n    public void setMapSize(int w, int h) {\n        ttd.resize(w, h);\n        ttp.resetPreferredSize();\n    }\n\n    public void doMapSizeDialog() {\n        MapSizeDialog msp = new MapSizeDialog(this, ttd.getWidth(), ttd.getHeight());\n        msp.setVisible(true);\n        /*\n      JDialog dialog = new JDialog(this,\n                                    \"Click a button\",\n                                    true);      \n      dialog.setContentPane(msp);\n\n\n      dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n      dialog.pack();\n      dialog.setLocationRelativeTo(this);\n      dialog.setVisible(true);\n       */\n    }\n\n    class MapFileFilter extends javax.swing.filechooser.FileFilter {\n\n        public MapFileFilter() {\n            super();\n        }\n\n        public boolean accept(File f) {\n            if ((f.getName().endsWith(\".dat\")) || (f.isDirectory())) {\n                return true;\n            }\n            return false;\n        }\n\n        public String getDescription() {\n            return \"Map .dat files\";\n        }\n    }\n\n    class MapSizeDialog extends JDialog {\n\n        TederFrame parent;\n\n        JButton okButton;\n\n        JButton cancelButton;\n\n        JTextField jtfWidth;\n\n        JTextField jtfHeight;\n\n        public MapSizeDialog(TederFrame parentInit, int wid, int hei) {\n            // create this as a modal dialog\n            super(parentInit, true);\n            parent = parentInit;\n            // create all the elements for the pane\n            JPanel inputPane = new JPanel();\n            inputPane.setLayout(new GridLayout(0, 2));\n            inputPane.add(new JLabel(\"Width:\"));\n            jtfWidth = new JTextField(\"\" + wid);\n            inputPane.add(jtfWidth);\n            inputPane.add(new JLabel(\"Height\"));\n            jtfHeight = new JTextField(\"\" + hei);\n            inputPane.add(jtfHeight);\n            inputPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n            JPanel buttonPane = new JPanel();\n            buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));\n            buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));\n            buttonPane.add(Box.createHorizontalGlue());\n            cancelButton = new JButton(\"Cancel\");\n            cancelButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e) {\n                    //pick one of many\n                    if (e.getSource() == cancelButton) {\n                        setVisible(false);\n                        dispose();\n                    }\n                }\n            });\n            buttonPane.add(cancelButton);\n            buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));\n            okButton = new JButton(\"Ok\");\n            okButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e) {\n                    //pick one of many\n                    if (e.getSource() == okButton) {\n                        try {\n                            int wid = Integer.parseInt(jtfWidth.getText());\n                            int hei = Integer.parseInt(jtfHeight.getText());\n                            parent.setMapSize(wid, hei);\n                        } catch (NumberFormatException ex) {\n                            ex.printStackTrace();\n                        }\n                        setVisible(false);\n                        dispose();\n                    }\n                }\n            });\n            buttonPane.add(okButton);\n            Container contentPane = getContentPane();\n            contentPane.add(inputPane, BorderLayout.CENTER);\n            contentPane.add(buttonPane, BorderLayout.PAGE_END);\n            this.pack();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/teder/TederFrameTest1.java",
		"test_prompt": "// TederFrameTest1.java\npackage teder;\n\n/*\n * TederFrame - Game tile editor frame\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n *\n */\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.filechooser.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TederFrame}.\n* It contains ten unit test cases for the {@link TederFrame#doSaveAsFile()} method.\n*/\nclass TederFrameTest1 {"
	},
	{
		"original_code": "// TederFrame.java\npackage teder;\n\n/*\n * TederFrame - Game tile editor frame\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n *\n */\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.filechooser.*;\n\npublic class TederFrame extends JFrame implements ActionListener, WindowListener {\n\n    public static final int DEFAULT_WIDTH = 800;\n\n    public static final int DEFAULT_HEIGHT = 600;\n\n    public TederData ttd;\n\n    public TederPanel ttp;\n\n    // swing componenet for the menu bar\n    public JMenuBar mbar;\n\n    public JMenu fileMenu;\n\n    public JMenuItem openMenuItem;\n\n    public JMenuItem saveMenuItem;\n\n    public JMenuItem saveAsMenuItem;\n\n    public JMenuItem exitMenuItem;\n\n    public JMenu mapMenu;\n\n    public JMenuItem resizeMenuItem;\n\n    public JMenu tileMenu;\n\n    public JCheckBoxMenuItem[] tileItems;\n\n    public JScrollPane spMain;\n\n    // the path to the last file operation\n    public String lastPath;\n\n    public TederFrame() {\n        // get the program startup location\n        lastPath = System.getProperty(\"user.dir\");\n        ttd = new TederData(30, 30, 64, 64, \"images/tiles.gif\", this);\n        ttp = new TederPanel(ttd);\n        createMenuBar();\n        //this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n        addWindowListener(this);\n        setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n        //spMain = new JScrollPane(ttp,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n        //                             JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        spMain = new JScrollPane(ttp);\n        spMain.setPreferredSize(new Dimension(200, 200));\n        // add the panel to this frame\n        //add(ttp);\n        add(spMain);\n    }\n\n    /*------------------- WindowListener ---------------------*/\n    public void windowActivated(WindowEvent e) {\n    }\n\n    public void windowClosed(WindowEvent e) {\n        System.exit(0);\n    }\n\n    public void windowClosing(WindowEvent e) {\n        if (okayToClose()) {\n            System.exit(0);\n        }\n    }\n\n    public void windowDeactivated(WindowEvent e) {\n    }\n\n    public void windowDeiconified(WindowEvent e) {\n    }\n\n    public void windowIconified(WindowEvent e) {\n    }\n\n    public void windowOpened(WindowEvent e) {\n    }\n\n    /*------------------- WindowListener ---------------------*/\n    public boolean okayToClose() {\n        if (ttd.getHasChanged()) {\n            // need to pop up a dialog to see if it is okay to close\n            //Custom button text\n            Object[] options = { \"Yes\", \"No\", \"Cancel\" };\n            int n = JOptionPane.showOptionDialog(this, \"The map has changed would you like to save the file before proceeding?\", \"File Has Changed\", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[2]);\n            if (n == 0) {\n                return doSaveFile();\n            } else if (n == 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void createMenuBar() {\n        JMenuItem itmTmp;\n        mbar = new JMenuBar();\n        /*     FILE MENU     */\n        fileMenu = new JMenu(\"File\");\n        // new is one way to do it where we check for the string in the listener\n        // create the item\n        itmTmp = new JMenuItem(\"New\");\n        // add the event listener\n        itmTmp.addActionListener(this);\n        // add the item to the menu\n        fileMenu.add(itmTmp);\n        // the other way to do it is to save references to each item.\n        // this is better since you do less string processing, but it\n        // takes more memory. Always a trade off.\n        openMenuItem = new JMenuItem(\"Open...\");\n        openMenuItem.addActionListener(this);\n        fileMenu.add(openMenuItem);\n        saveMenuItem = new JMenuItem(\"Save\");\n        saveMenuItem.addActionListener(this);\n        fileMenu.add(saveMenuItem);\n        saveAsMenuItem = new JMenuItem(\"Save As...\");\n        saveAsMenuItem.addActionListener(this);\n        fileMenu.add(saveAsMenuItem);\n        // the last way is not demonstrated, that is a special object\n        // just for the individual item event handling. All the books show\n        // it as the correct way to handle events. It is the most\n        // memory/disk intensive. Not shown here.\n        // exit is the other way, we keep the object reference and check for that\n        exitMenuItem = new JMenuItem(\"Exit\");\n        exitMenuItem.addActionListener(this);\n        fileMenu.add(exitMenuItem);\n        mbar.add(fileMenu);\n        /*     EDIT MENU     */\n        /*     MAP MENU */\n        mapMenu = new JMenu(\"Map\");\n        resizeMenuItem = new JMenuItem(\"Resize\");\n        resizeMenuItem.addActionListener(this);\n        mapMenu.add(resizeMenuItem);\n        mbar.add(mapMenu);\n        /*     TILES MENU    */\n        tileMenu = new JMenu(\"Tile\");\n        tileItems = new JCheckBoxMenuItem[TederData.NUM_TILES];\n        int i;\n        for (i = 0; i < TederData.NUM_TILES; i++) {\n            tileItems[i] = new JCheckBoxMenuItem(\"Tile \" + i, new ImageIcon(\"images/tile_icons/tile\" + i + \".gif\"));\n            tileItems[i].addActionListener(this);\n            tileMenu.add(tileItems[i]);\n        }\n        mbar.add(tileMenu);\n        //mbar.addActionListener(this);\n        adjustMenus();\n        this.setJMenuBar(mbar);\n    }\n\n    // action listener handling\n    public void actionPerformed(ActionEvent evt) {\n        //System.out.println(\"evt=\"+evt);\n        if (evt.getActionCommand().equals(\"New\")) {\n            System.out.println(\"New command selected\");\n        } else if (evt.getSource() == exitMenuItem) {\n            System.out.println(\"Exit selected\");\n            if (okayToClose())\n                System.exit(0);\n        } else if (evt.getSource() == saveMenuItem) {\n            this.doSaveFile();\n            ttd.doSave();\n        } else if (evt.getSource() == saveAsMenuItem) {\n            this.doSaveAsFile();\n        } else if (evt.getSource() == openMenuItem) {\n            doLoadFile();\n            ttp.resetPreferredSize();\n            this.repaint();\n        } else if (evt.getSource() == resizeMenuItem) {\n            doMapSizeDialog();\n            this.repaint();\n        } else {\n            // may be one of the tiles\n            int i;\n            for (i = 0; i < TederData.NUM_TILES; i++) {\n                if (evt.getSource() == tileItems[i]) {\n                    ttp.curTile = i;\n                }\n            }\n            adjustMenus();\n        }\n    }\n\n    public void adjustMenus() {\n        int i;\n        for (i = 0; i < TederData.NUM_TILES; i++) {\n            if (i == ttp.curTile)\n                tileItems[i].setState(true);\n            else\n                tileItems[i].setState(false);\n        }\n    }\n\n    public void doLoadFile() {\n        JFileChooser chooser;\n        if (!okayToClose())\n            return;\n        if (lastPath == null) {\n            chooser = new JFileChooser();\n        } else {\n            File fiTmp = new File(lastPath);\n            chooser = new JFileChooser(fiTmp);\n        }\n        //chooser.setDialogType(JFileChooser.OPEN_DIALOG);\n        MapFileFilter filter = new MapFileFilter();\n        chooser.setFileFilter(filter);\n        int returnVal = chooser.showOpenDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File fiSelected = chooser.getSelectedFile();\n            lastPath = fiSelected.getPath();\n            ttd.setFileName(fiSelected.getAbsolutePath());\n            ttd.doLoad();\n            ttd.setHasChanged(false);\n        }\n    }\n\n    public boolean doSaveAsFile() {\n        JFileChooser chooser;\n        if (lastPath == null) {\n            chooser = new JFileChooser();\n        } else {\n            File fiTmp = new File(lastPath);\n            chooser = new JFileChooser(fiTmp);\n        }\n        //chooser.setDialogType(JFileChooser.SAVE_DIALOG);\n        //System.out.println(\"Save file type = SAVE_DIALOG\");\n        MapFileFilter filter = new MapFileFilter();\n        chooser.setFileFilter(filter);\n        int returnVal = chooser.showSaveDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File fiSelected = chooser.getSelectedFile();\n            if (fiSelected.exists()) {\n                // make sure they want to overwrite\n                // need to pop up a dialog to see if it is okay to close\n                //Custom button text\n                Object[] options = { \"Yes\", \"No\" };\n                int n = JOptionPane.showOptionDialog(this, \"The file already exists, would you like to overwrite?\", \"File Exists\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n                if (n == 1) {\n                    return false;\n                }\n            }\n            // exists\n            lastPath = fiSelected.getPath();\n            ttd.setFileName(fiSelected.getAbsolutePath());\n            ttd.doSave();\n            ttd.setHasChanged(false);\n            return true;\n        }\n        // user pressed cancel, return false that it did not save\n        return false;\n    }\n\n    public boolean doSaveFile() {\n        if (ttd.isValidFile()) {\n            ttd.doSave();\n        } else {\n            return doSaveAsFile();\n        }\n        return true;\n    }\n\n    public void setMapSize(int w, int h) {\n        ttd.resize(w, h);\n        ttp.resetPreferredSize();\n    }\n\n    public void doMapSizeDialog() {\n        MapSizeDialog msp = new MapSizeDialog(this, ttd.getWidth(), ttd.getHeight());\n        msp.setVisible(true);\n        /*\n      JDialog dialog = new JDialog(this,\n                                    \"Click a button\",\n                                    true);      \n      dialog.setContentPane(msp);\n\n\n      dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n      dialog.pack();\n      dialog.setLocationRelativeTo(this);\n      dialog.setVisible(true);\n       */\n    }\n\n    class MapFileFilter extends javax.swing.filechooser.FileFilter {\n\n        public MapFileFilter() {\n            super();\n        }\n\n        public boolean accept(File f) {\n            if ((f.getName().endsWith(\".dat\")) || (f.isDirectory())) {\n                return true;\n            }\n            return false;\n        }\n\n        public String getDescription() {\n            return \"Map .dat files\";\n        }\n    }\n\n    class MapSizeDialog extends JDialog {\n\n        TederFrame parent;\n\n        JButton okButton;\n\n        JButton cancelButton;\n\n        JTextField jtfWidth;\n\n        JTextField jtfHeight;\n\n        public MapSizeDialog(TederFrame parentInit, int wid, int hei) {\n            // create this as a modal dialog\n            super(parentInit, true);\n            parent = parentInit;\n            // create all the elements for the pane\n            JPanel inputPane = new JPanel();\n            inputPane.setLayout(new GridLayout(0, 2));\n            inputPane.add(new JLabel(\"Width:\"));\n            jtfWidth = new JTextField(\"\" + wid);\n            inputPane.add(jtfWidth);\n            inputPane.add(new JLabel(\"Height\"));\n            jtfHeight = new JTextField(\"\" + hei);\n            inputPane.add(jtfHeight);\n            inputPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n            JPanel buttonPane = new JPanel();\n            buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));\n            buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));\n            buttonPane.add(Box.createHorizontalGlue());\n            cancelButton = new JButton(\"Cancel\");\n            cancelButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e) {\n                    //pick one of many\n                    if (e.getSource() == cancelButton) {\n                        setVisible(false);\n                        dispose();\n                    }\n                }\n            });\n            buttonPane.add(cancelButton);\n            buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));\n            okButton = new JButton(\"Ok\");\n            okButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e) {\n                    //pick one of many\n                    if (e.getSource() == okButton) {\n                        try {\n                            int wid = Integer.parseInt(jtfWidth.getText());\n                            int hei = Integer.parseInt(jtfHeight.getText());\n                            parent.setMapSize(wid, hei);\n                        } catch (NumberFormatException ex) {\n                            ex.printStackTrace();\n                        }\n                        setVisible(false);\n                        dispose();\n                    }\n                }\n            });\n            buttonPane.add(okButton);\n            Container contentPane = getContentPane();\n            contentPane.add(inputPane, BorderLayout.CENTER);\n            contentPane.add(buttonPane, BorderLayout.PAGE_END);\n            this.pack();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/teder/TederFrameTest2.java",
		"test_prompt": "// TederFrameTest2.java\npackage teder;\n\n/*\n * TederFrame - Game tile editor frame\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n *\n */\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.filechooser.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TederFrame}.\n* It contains ten unit test cases for the {@link TederFrame#doSaveFile()} method.\n*/\nclass TederFrameTest2 {"
	},
	{
		"original_code": "// TederData.java\npackage teder;\n\n/*\n * TederData - Game tile editor data\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n * \n */\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class TederData {\n\n    // height and width in tiles\n    private int gWidth;\n\n    private int gHeight;\n\n    private int tileWidth;\n\n    private int tileHeight;\n\n    ArrayList layers;\n\n    public static final int NUM_TILES = 10;\n\n    // a vertical row of images\n    Image tileImage;\n\n    public int[] hwalls;\n\n    public int[] vwalls;\n\n    public boolean validFile = false;\n\n    public String fileName;\n\n    public boolean hasChanged = false;\n\n    public TederData(int width, int height, int tileWidthInit, int tileHeightInit, String tileImageName, Component forTracking) {\n        gWidth = width;\n        gHeight = height;\n        tileWidth = tileWidthInit;\n        tileHeight = tileHeightInit;\n        layers = new ArrayList();\n        resize(gWidth, gHeight);\n        Toolkit tk = Toolkit.getDefaultToolkit();\n        tileImage = tk.getImage(tileImageName);\n        // set up the media tracker to wait for the image\n        MediaTracker tracker = new MediaTracker(forTracking);\n        tracker.addImage(tileImage, 0);\n        // wait for the image to load\n        try {\n            tracker.waitForID(0);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int getWidth() {\n        return gWidth;\n    }\n\n    public int getHeight() {\n        return gHeight;\n    }\n\n    public int size() {\n        return gWidth * gHeight;\n    }\n\n    public void resize(int w, int h) {\n        // loop through the layers and set the size on each layer\n        Iterator it = layers.iterator();\n        while (it.hasNext()) {\n            TederLayer ttl = (TederLayer) it.next();\n            ttl.resize(w, h);\n        }\n        gWidth = w;\n        gHeight = h;\n        hwalls = new int[gWidth * (gHeight + 1)];\n        vwalls = new int[(gWidth + 1) * gHeight];\n        hasChanged = true;\n    }\n\n    public TederLayer addLayer() {\n        TederLayer ttl = new TederLayer(gWidth, gHeight);\n        layers.add(ttl);\n        return ttl;\n    }\n\n    public ArrayList getLayers() {\n        return layers;\n    }\n\n    public int getTileWidth() {\n        return tileWidth;\n    }\n\n    public int getTileHeight() {\n        return tileHeight;\n    }\n\n    public int getMapPixelWidth() {\n        return gWidth * tileWidth;\n    }\n\n    public int getMapPixelHeight() {\n        return gHeight * tileHeight;\n    }\n\n    public void drawTileImage(Graphics g, int x, int y, int tnum, ImageObserver obs) {\n        if ((tileImage != null) && (tileImage.getWidth(obs) > 0)) {\n            //System.out.println(\"tileImage = \"+tileImage+\" wid=\"+tileImage.getWidth(obs)+\" x=\"+x+\" y=\"+y+\" twid=\"+tileWidth+\" thei=\"+tileHeight);\n            g.drawImage(tileImage, x, y, x + tileWidth, y + tileHeight, 0, tnum * tileHeight, tileWidth, tnum * tileHeight + tileHeight, obs);\n        }\n    }\n\n    public void setHasChanged(boolean b) {\n        hasChanged = b;\n    }\n\n    public boolean getHasChanged() {\n        return hasChanged;\n    }\n\n    public boolean isValidFile() {\n        return validFile;\n    }\n\n    public void setFileName(String fname) {\n        fileName = fname;\n    }\n\n    public void doSave() {\n        int i;\n        try {\n            FileOutputStream fos = new FileOutputStream(fileName);\n            DataOutputStream dos = new DataOutputStream(fos);\n            TederLayer tl = (TederLayer) layers.get(0);\n            dos.writeInt(tl.wid);\n            dos.writeInt(tl.hei);\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeByte(tl.tiles[i]);\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeInt(hwalls[i]);\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeInt(vwalls[i]);\n            }\n            fos.close();\n            dos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doLoad() {\n        doLoad(fileName);\n    }\n\n    public void doLoad(String fname) {\n        TederLayer tl = (TederLayer) layers.get(0);\n        doLoadSingleLayer(tl, fname);\n        validFile = true;\n    }\n\n    public void doLoadSingleLayer(TederLayer tl, String fname) {\n        int i;\n        try {\n            FileInputStream fis = new FileInputStream(fname);\n            DataInputStream dis = new DataInputStream(fis);\n            tl.wid = dis.readInt();\n            tl.hei = dis.readInt();\n            gWidth = tl.wid;\n            gHeight = tl.hei;\n            resize(tl.wid, tl.hei);\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                tl.tiles[i] = dis.readByte();\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                hwalls[i] = dis.readInt();\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                vwalls[i] = dis.readInt();\n            }\n            fis.close();\n            dis.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/teder/TederDataTest0.java",
		"test_prompt": "// TederDataTest0.java\npackage teder;\n\n/*\n * TederData - Game tile editor data\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n * \n */\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TederData}.\n* It contains ten unit test cases for the {@link TederData#size()} method.\n*/\nclass TederDataTest0 {"
	},
	{
		"original_code": "// TederData.java\npackage teder;\n\n/*\n * TederData - Game tile editor data\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n * \n */\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class TederData {\n\n    // height and width in tiles\n    private int gWidth;\n\n    private int gHeight;\n\n    private int tileWidth;\n\n    private int tileHeight;\n\n    ArrayList layers;\n\n    public static final int NUM_TILES = 10;\n\n    // a vertical row of images\n    Image tileImage;\n\n    public int[] hwalls;\n\n    public int[] vwalls;\n\n    public boolean validFile = false;\n\n    public String fileName;\n\n    public boolean hasChanged = false;\n\n    public TederData(int width, int height, int tileWidthInit, int tileHeightInit, String tileImageName, Component forTracking) {\n        gWidth = width;\n        gHeight = height;\n        tileWidth = tileWidthInit;\n        tileHeight = tileHeightInit;\n        layers = new ArrayList();\n        resize(gWidth, gHeight);\n        Toolkit tk = Toolkit.getDefaultToolkit();\n        tileImage = tk.getImage(tileImageName);\n        // set up the media tracker to wait for the image\n        MediaTracker tracker = new MediaTracker(forTracking);\n        tracker.addImage(tileImage, 0);\n        // wait for the image to load\n        try {\n            tracker.waitForID(0);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int getWidth() {\n        return gWidth;\n    }\n\n    public int getHeight() {\n        return gHeight;\n    }\n\n    public int size() {\n        return gWidth * gHeight;\n    }\n\n    public void resize(int w, int h) {\n        // loop through the layers and set the size on each layer\n        Iterator it = layers.iterator();\n        while (it.hasNext()) {\n            TederLayer ttl = (TederLayer) it.next();\n            ttl.resize(w, h);\n        }\n        gWidth = w;\n        gHeight = h;\n        hwalls = new int[gWidth * (gHeight + 1)];\n        vwalls = new int[(gWidth + 1) * gHeight];\n        hasChanged = true;\n    }\n\n    public TederLayer addLayer() {\n        TederLayer ttl = new TederLayer(gWidth, gHeight);\n        layers.add(ttl);\n        return ttl;\n    }\n\n    public ArrayList getLayers() {\n        return layers;\n    }\n\n    public int getTileWidth() {\n        return tileWidth;\n    }\n\n    public int getTileHeight() {\n        return tileHeight;\n    }\n\n    public int getMapPixelWidth() {\n        return gWidth * tileWidth;\n    }\n\n    public int getMapPixelHeight() {\n        return gHeight * tileHeight;\n    }\n\n    public void drawTileImage(Graphics g, int x, int y, int tnum, ImageObserver obs) {\n        if ((tileImage != null) && (tileImage.getWidth(obs) > 0)) {\n            //System.out.println(\"tileImage = \"+tileImage+\" wid=\"+tileImage.getWidth(obs)+\" x=\"+x+\" y=\"+y+\" twid=\"+tileWidth+\" thei=\"+tileHeight);\n            g.drawImage(tileImage, x, y, x + tileWidth, y + tileHeight, 0, tnum * tileHeight, tileWidth, tnum * tileHeight + tileHeight, obs);\n        }\n    }\n\n    public void setHasChanged(boolean b) {\n        hasChanged = b;\n    }\n\n    public boolean getHasChanged() {\n        return hasChanged;\n    }\n\n    public boolean isValidFile() {\n        return validFile;\n    }\n\n    public void setFileName(String fname) {\n        fileName = fname;\n    }\n\n    public void doSave() {\n        int i;\n        try {\n            FileOutputStream fos = new FileOutputStream(fileName);\n            DataOutputStream dos = new DataOutputStream(fos);\n            TederLayer tl = (TederLayer) layers.get(0);\n            dos.writeInt(tl.wid);\n            dos.writeInt(tl.hei);\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeByte(tl.tiles[i]);\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeInt(hwalls[i]);\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeInt(vwalls[i]);\n            }\n            fos.close();\n            dos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doLoad() {\n        doLoad(fileName);\n    }\n\n    public void doLoad(String fname) {\n        TederLayer tl = (TederLayer) layers.get(0);\n        doLoadSingleLayer(tl, fname);\n        validFile = true;\n    }\n\n    public void doLoadSingleLayer(TederLayer tl, String fname) {\n        int i;\n        try {\n            FileInputStream fis = new FileInputStream(fname);\n            DataInputStream dis = new DataInputStream(fis);\n            tl.wid = dis.readInt();\n            tl.hei = dis.readInt();\n            gWidth = tl.wid;\n            gHeight = tl.hei;\n            resize(tl.wid, tl.hei);\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                tl.tiles[i] = dis.readByte();\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                hwalls[i] = dis.readInt();\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                vwalls[i] = dis.readInt();\n            }\n            fis.close();\n            dis.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/teder/TederDataTest1.java",
		"test_prompt": "// TederDataTest1.java\npackage teder;\n\n/*\n * TederData - Game tile editor data\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n * \n */\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TederData}.\n* It contains ten unit test cases for the {@link TederData#addLayer()} method.\n*/\nclass TederDataTest1 {"
	},
	{
		"original_code": "// TederData.java\npackage teder;\n\n/*\n * TederData - Game tile editor data\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n * \n */\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class TederData {\n\n    // height and width in tiles\n    private int gWidth;\n\n    private int gHeight;\n\n    private int tileWidth;\n\n    private int tileHeight;\n\n    ArrayList layers;\n\n    public static final int NUM_TILES = 10;\n\n    // a vertical row of images\n    Image tileImage;\n\n    public int[] hwalls;\n\n    public int[] vwalls;\n\n    public boolean validFile = false;\n\n    public String fileName;\n\n    public boolean hasChanged = false;\n\n    public TederData(int width, int height, int tileWidthInit, int tileHeightInit, String tileImageName, Component forTracking) {\n        gWidth = width;\n        gHeight = height;\n        tileWidth = tileWidthInit;\n        tileHeight = tileHeightInit;\n        layers = new ArrayList();\n        resize(gWidth, gHeight);\n        Toolkit tk = Toolkit.getDefaultToolkit();\n        tileImage = tk.getImage(tileImageName);\n        // set up the media tracker to wait for the image\n        MediaTracker tracker = new MediaTracker(forTracking);\n        tracker.addImage(tileImage, 0);\n        // wait for the image to load\n        try {\n            tracker.waitForID(0);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int getWidth() {\n        return gWidth;\n    }\n\n    public int getHeight() {\n        return gHeight;\n    }\n\n    public int size() {\n        return gWidth * gHeight;\n    }\n\n    public void resize(int w, int h) {\n        // loop through the layers and set the size on each layer\n        Iterator it = layers.iterator();\n        while (it.hasNext()) {\n            TederLayer ttl = (TederLayer) it.next();\n            ttl.resize(w, h);\n        }\n        gWidth = w;\n        gHeight = h;\n        hwalls = new int[gWidth * (gHeight + 1)];\n        vwalls = new int[(gWidth + 1) * gHeight];\n        hasChanged = true;\n    }\n\n    public TederLayer addLayer() {\n        TederLayer ttl = new TederLayer(gWidth, gHeight);\n        layers.add(ttl);\n        return ttl;\n    }\n\n    public ArrayList getLayers() {\n        return layers;\n    }\n\n    public int getTileWidth() {\n        return tileWidth;\n    }\n\n    public int getTileHeight() {\n        return tileHeight;\n    }\n\n    public int getMapPixelWidth() {\n        return gWidth * tileWidth;\n    }\n\n    public int getMapPixelHeight() {\n        return gHeight * tileHeight;\n    }\n\n    public void drawTileImage(Graphics g, int x, int y, int tnum, ImageObserver obs) {\n        if ((tileImage != null) && (tileImage.getWidth(obs) > 0)) {\n            //System.out.println(\"tileImage = \"+tileImage+\" wid=\"+tileImage.getWidth(obs)+\" x=\"+x+\" y=\"+y+\" twid=\"+tileWidth+\" thei=\"+tileHeight);\n            g.drawImage(tileImage, x, y, x + tileWidth, y + tileHeight, 0, tnum * tileHeight, tileWidth, tnum * tileHeight + tileHeight, obs);\n        }\n    }\n\n    public void setHasChanged(boolean b) {\n        hasChanged = b;\n    }\n\n    public boolean getHasChanged() {\n        return hasChanged;\n    }\n\n    public boolean isValidFile() {\n        return validFile;\n    }\n\n    public void setFileName(String fname) {\n        fileName = fname;\n    }\n\n    public void doSave() {\n        int i;\n        try {\n            FileOutputStream fos = new FileOutputStream(fileName);\n            DataOutputStream dos = new DataOutputStream(fos);\n            TederLayer tl = (TederLayer) layers.get(0);\n            dos.writeInt(tl.wid);\n            dos.writeInt(tl.hei);\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeByte(tl.tiles[i]);\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeInt(hwalls[i]);\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                dos.writeInt(vwalls[i]);\n            }\n            fos.close();\n            dos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doLoad() {\n        doLoad(fileName);\n    }\n\n    public void doLoad(String fname) {\n        TederLayer tl = (TederLayer) layers.get(0);\n        doLoadSingleLayer(tl, fname);\n        validFile = true;\n    }\n\n    public void doLoadSingleLayer(TederLayer tl, String fname) {\n        int i;\n        try {\n            FileInputStream fis = new FileInputStream(fname);\n            DataInputStream dis = new DataInputStream(fis);\n            tl.wid = dis.readInt();\n            tl.hei = dis.readInt();\n            gWidth = tl.wid;\n            gHeight = tl.hei;\n            resize(tl.wid, tl.hei);\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                tl.tiles[i] = dis.readByte();\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                hwalls[i] = dis.readInt();\n            }\n            for (i = 0; i < tl.wid * tl.hei; i++) {\n                vwalls[i] = dis.readInt();\n            }\n            fis.close();\n            dis.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/58_fps370/src/main/java/teder/TederDataTest2.java",
		"test_prompt": "// TederDataTest2.java\npackage teder;\n\n/*\n * TederData - Game tile editor data\n *\n * By: Wood Harter - Feb 22, 2006\n * Created for cpsc370 at Chapman University\n * http://www.gamedev370.com\n * (c) copyright 2006 - W. Wood Harter\n *\n * Licensed under GNU General Public License\n * http://www.gnu.org\n *\n * \n */\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TederData}.\n* It contains ten unit test cases for the {@link TederData#isValidFile()} method.\n*/\nclass TederDataTest2 {"
	}
]