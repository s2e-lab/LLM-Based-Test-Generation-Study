[
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest0.java",
		"test_prompt": "// ChartUtilitiesTest0.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#performAutoScale(double, double)} method.\n*/\nclass ChartUtilitiesTest0 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest1.java",
		"test_prompt": "// ChartUtilitiesTest1.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#calculateTickSpacing(double, double)} method.\n*/\nclass ChartUtilitiesTest1 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest2.java",
		"test_prompt": "// ChartUtilitiesTest2.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#interpolate(double[], double[], double)} method.\n*/\nclass ChartUtilitiesTest2 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest3.java",
		"test_prompt": "// ChartUtilitiesTest3.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#floor(double, int)} method.\n*/\nclass ChartUtilitiesTest3 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest4.java",
		"test_prompt": "// ChartUtilitiesTest4.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#ceil(double, int)} method.\n*/\nclass ChartUtilitiesTest4 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest5.java",
		"test_prompt": "// ChartUtilitiesTest5.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#exp(double)} method.\n*/\nclass ChartUtilitiesTest5 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest6.java",
		"test_prompt": "// ChartUtilitiesTest6.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#transformArray(int[][])} method.\n*/\nclass ChartUtilitiesTest6 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest7.java",
		"test_prompt": "// ChartUtilitiesTest7.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#transformArray(double[][])} method.\n*/\nclass ChartUtilitiesTest7 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest8.java",
		"test_prompt": "// ChartUtilitiesTest8.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#transformArray(double[])} method.\n*/\nclass ChartUtilitiesTest8 {"
	},
	{
		"original_code": "// ChartUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartUtilities.java\n    Created on 21. September 2001, 17:42\n */\npackage de.progra.charting;\n\nimport java.util.*;\n\n/**\n * This class offers multiple static methods to perform mathematical\n * operations concerning the Chart, e.g. methods for rounding the minimal and\n * maximal x-values gracefully.\n * @author  mueller\n * @version 1.0\n */\npublic class ChartUtilities {\n\n    /**\n     * This method calculates the optimal rounding for the minimal and\n     * maximal ChartModel values. It computes the difference of the\n     * minimal and maximal value and rounds the values min and max according\n     * to the exponent of the difference.\n     * @param min the minimal column value of the ChartDataModel\n     * @param max the maximal column value of the ChartDataModel\n     * @return a double[] with the rounded minimal value at index 0 and\n     * the maximal value at index 1.\n     */\n    public static double[] performAutoScale(double min, double max) {\n        // d[0] = min d[1] = max\n        double[] d = new double[2];\n        double diff = max - min;\n        d[0] = floor(min, exp(diff));\n        d[1] = ceil(max, exp(diff));\n        return d;\n    }\n\n    /**\n     * Calculates the best tick spacing for the rounded minimal and maximal\n     * values.\n     * @param min the rounded minimal value\n     * @param max the rounded maximal value\n     * @return the spacing of ticks on the x-axis.\n     */\n    public static double calculateTickSpacing(double min, double max) {\n        double spacing = 1.0;\n        double diff = max - min;\n        int exp = exp(diff);\n        exp--;\n        spacing = 1.0 * Math.pow(10.0, (double) exp);\n        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.\n        // This should be reduced in a loop probably.\n        if ((diff / spacing) < 20)\n            return 0.5 * spacing;\n        else if ((diff / spacing) > 40)\n            return 2 * spacing;\n        else\n            return spacing;\n    }\n\n    /**\n     * This function performs a polynomial interpolation using a set of\n     * given x and y values. It uses Neville's interpolation algorithm.\n     * @param xa the array of known x-values\n     * @param ya the array of known y-values\n     * @param x the x value for which the y value will be computed\n     * @return the corresponding y value\n     */\n    public static double interpolate(double[] xa, double[] ya, double x) {\n        /*\n            Given arrays xa[1..n] and ya[1..n], and given a value x, \n            this routine returns a value y. \n            If P(x) is the polynomial of degree N ? 1 \n            such that P(xa[i]) = ya[i]; \n            i = 1...n, then the returned value y = P(x).\n         */\n        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {\n            System.out.println(\"** Invalid Parameter\");\n            return Double.NaN;\n        }\n        int n = xa.length;\n        double y = 0.0;\n        double dy = 0.0;\n        int i, m, ns = 1;\n        double den, dif, dift, ho, hp, w;\n        double[] c = new double[n];\n        double[] d = new double[n];\n        dif = Math.abs(x - xa[0]);\n        for (i = 0; i < n; i++) {\n            // Here we find the index ns of the closest table entry,\n            if ((dift = Math.abs(x - xa[i])) < dif) {\n                ns = i;\n                dif = dift;\n            }\n            // and initialize the tableau of c's and d's.\n            c[i] = ya[i];\n            d[i] = ya[i];\n        }\n        // This is the initial approximation to y.\n        y = ya[ns--];\n        //System.out.println(\"** y ~ \"+y);\n        for (m = 0; m < n - 1; m++) {\n            // For each column of the tableau,\n            for (i = 0; i < n - m - 1; i++) {\n                // we loop over the current c's and d's and update them.\n                //System.out.println(\"** m = \"+m+\", i = \"+i);\n                ho = xa[i] - x;\n                hp = xa[i + m + 1] - x;\n                w = c[i + 1] - d[i];\n                if ((den = ho - hp) == 0.0) {\n                    return Double.NaN;\n                }\n                // This error can occur only if two input xa's are (to within roundof identical.\n                //System.out.println(\"** ho = \"+ho+\", hp = \"+hp);\n                den = w / den;\n                // Here the c's and d's are updated.\n                d[i] = hp * den;\n                c[i] = ho * den;\n                //System.out.println(\"** c[i] = \"+c[i]+\", d[i] = \"+d[i]);\n            }\n            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));\n            //System.out.println(\"** dy = \"+dy+\", y = \"+y);\n            /*\n            After each column in the tableau is completed, we decide which correction, c or d,\n            we want to add to our accumulating value of y, i.e., which path to take through the\n            tableau forking up or down. We do this in such a way as to take the most \"straight\n            line\" route through the tableau to its apex, updating ns accordingly to keep track of\n            where we are. This route keeps the partial approximations centered (insofar as possible)\n            on the target x. The last dy added is thus the error indication.\n            */\n        }\n        return y;\n    }\n\n    /**\n     * This method returns the largest double value that is smaller than\n     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>\n     */\n    public static double floor(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.floor(d / x) * x;\n    }\n\n    /**\n     * This method returns the smallest double value that is smaller than\n     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to\n     * the closest integer.\n     * @param d the double value to be rounded\n     * @param exp the exponent of 10 to which d should be rounded\n     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>\n     */\n    public static double ceil(double d, int exp) {\n        double x = 1.0 * Math.pow(10.0, (double) exp);\n        return Math.ceil(d / x) * x;\n    }\n\n    /**\n     * A double value can be represented like\n     * <code>d = x * 10<sup>exp</sup></code> and this method returns\n     * the value of exp for a double d.\n     * @param d the double value\n     * @return the exponent of 10\n     */\n    public static int exp(double d) {\n        int exp = 0;\n        boolean positive = (d <= -1 || d >= 1);\n        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {\n            if (positive) {\n                d /= 10;\n                exp++;\n            } else {\n                d *= 10;\n                exp--;\n            }\n        }\n        return exp;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(int[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms a two-dimensional array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[][] transformArray(double[][] data) {\n        Number[][] n = new Number[data.length][data[0].length];\n        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(double[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);\n        return n;\n    }\n\n    /**\n     * Transforms an array of primitives\n     * to an array of Numbers.\n     */\n    public static Number[] transformArray(int[] data) {\n        Number[] n = new Number[data.length];\n        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);\n        return n;\n    }\n\n    /**\n     * Adds a two-dimensional array to a TreeSet.\n     */\n    public static void addDataToSet(TreeSet set, Number[][] data) {\n        for (int i = 0; i < data.length; i++) {\n            set.addAll(Arrays.asList(data[i]));\n        }\n    }\n\n    /**\n     * A test routine.\n     */\n    public static void main(String[] args) {\n        double min = -0.00337;\n        double max = 0.00745;\n        double[] d = performAutoScale(min, max);\n        System.out.println(\"** AutoScaling: (\" + min + \", \" + max + \") -> (\" + d[0] + \", \" + d[1] + \")\");\n        double s = calculateTickSpacing(d[0], d[1]);\n        System.out.print(\"** Ticks: \");\n        for (double i = d[0]; i <= d[1]; i += s) System.out.print(\" \" + i + \" \");\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 4*x^2\");\n        System.out.println(\"** Given values [-4, 64], [0, 0], [3, 36]\");\n        double[] xa = { -4.0, 0.0, 3.0 };\n        double[] ya = { 64.0, 0.0, 36.0 };\n        System.out.print(\"** Calculating values\");\n        //double f = interpolate(xa, ya, 1.0);\n        //System.out.println(\"** f(1) = \"+f);\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xa, ya, i) + \"]\");\n        }\n        System.out.println();\n        System.out.println(\"** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5\");\n        System.out.println(\"** Given values [-5, -740], [0, -5], [1, -2], [5, 530]\");\n        double[] xb = { -5.0, 0.0, 1.0, 5.0 };\n        double[] yb = { -740.0, -5.0, -2.0, 530.0 };\n        System.out.print(\"** Calculating values \");\n        for (double i = -5.0; i < 6.0; i += 0.5) {\n            System.out.print(\"[\" + i + \", \" + interpolate(xb, yb, i) + \"]\");\n        }\n        System.out.println();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilitiesTest9.java",
		"test_prompt": "// ChartUtilitiesTest9.java\npackage de.progra.charting;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartUtilities}.\n* It contains ten unit test cases for the {@link ChartUtilities#transformArray(int[])} method.\n*/\nclass ChartUtilitiesTest9 {"
	},
	{
		"original_code": "// Diamond2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Diamond2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a diamond like Shape object.\n * @author  mueller\n * @version 1.0\n */\npublic class Diamond2D extends RectangularShape {\n\n    protected double x, y, width, height;\n\n    /**\n     * Creates a Diamond shape with the specified coordinates.\n     */\n    public Diamond2D(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * Returns the height.\n     */\n    public double getHeight() {\n        return height;\n    }\n\n    /**\n     * Returns the width.\n     */\n    public double getWidth() {\n        return width;\n    }\n\n    /**\n     * Returns the x-coordinate.\n     */\n    public double getX() {\n        return x;\n    }\n\n    /**\n     * Returns the y-coordinate.\n     */\n    public double getY() {\n        return y;\n    }\n\n    /**\n     * Returns true if the bounding box is empty.\n     */\n    public boolean isEmpty() {\n        return (width <= 0.0) || (height <= 0.0);\n    }\n\n    /**\n     * Sets the framing rectangle.\n     */\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, height, width);\n    }\n\n    /**\n     * Returns the object's PathIterator.\n     */\n    public PathIterator getPathIterator(AffineTransform at) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 4;\n\n            float[][] fcurrentSegment = { { (float) (x + width / 2), (float) y, 0f, 0f, 0f, 0f }, { (float) x, (float) (y + height / 2), 0f, 0f, 0f, 0f }, { (float) (x + width / 2), (float) (y + height), 0f, 0f, 0f, 0f }, { (float) (x + width), (float) (y + height / 2), 0f, 0f, 0f, 0f }, { 0f, 0f, 0f, 0f, 0f, 0f } };\n\n            double[][] dcurrentSegment = { { x + width / 2, y, 0.0, 0.0, 0.0, 0.0 }, { x, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { x + width / 2, y + height, 0.0, 0.0, 0.0, 0.0 }, { x + width, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                coords[0] = dcurrentSegment[state][0];\n                coords[1] = dcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                coords[0] = fcurrentSegment[state][0];\n                coords[1] = fcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public boolean contains(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public boolean contains(double x, double y) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Diamond2DTest0.java",
		"test_prompt": "// Diamond2DTest0.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Diamond2D}.\n* It contains ten unit test cases for the {@link Diamond2D#isEmpty()} method.\n*/\nclass Diamond2DTest0 {"
	},
	{
		"original_code": "// Diamond2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Diamond2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a diamond like Shape object.\n * @author  mueller\n * @version 1.0\n */\npublic class Diamond2D extends RectangularShape {\n\n    protected double x, y, width, height;\n\n    /**\n     * Creates a Diamond shape with the specified coordinates.\n     */\n    public Diamond2D(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * Returns the height.\n     */\n    public double getHeight() {\n        return height;\n    }\n\n    /**\n     * Returns the width.\n     */\n    public double getWidth() {\n        return width;\n    }\n\n    /**\n     * Returns the x-coordinate.\n     */\n    public double getX() {\n        return x;\n    }\n\n    /**\n     * Returns the y-coordinate.\n     */\n    public double getY() {\n        return y;\n    }\n\n    /**\n     * Returns true if the bounding box is empty.\n     */\n    public boolean isEmpty() {\n        return (width <= 0.0) || (height <= 0.0);\n    }\n\n    /**\n     * Sets the framing rectangle.\n     */\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, height, width);\n    }\n\n    /**\n     * Returns the object's PathIterator.\n     */\n    public PathIterator getPathIterator(AffineTransform at) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 4;\n\n            float[][] fcurrentSegment = { { (float) (x + width / 2), (float) y, 0f, 0f, 0f, 0f }, { (float) x, (float) (y + height / 2), 0f, 0f, 0f, 0f }, { (float) (x + width / 2), (float) (y + height), 0f, 0f, 0f, 0f }, { (float) (x + width), (float) (y + height / 2), 0f, 0f, 0f, 0f }, { 0f, 0f, 0f, 0f, 0f, 0f } };\n\n            double[][] dcurrentSegment = { { x + width / 2, y, 0.0, 0.0, 0.0, 0.0 }, { x, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { x + width / 2, y + height, 0.0, 0.0, 0.0, 0.0 }, { x + width, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                coords[0] = dcurrentSegment[state][0];\n                coords[1] = dcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                coords[0] = fcurrentSegment[state][0];\n                coords[1] = fcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public boolean contains(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public boolean contains(double x, double y) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Diamond2DTest1.java",
		"test_prompt": "// Diamond2DTest1.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Diamond2D}.\n* It contains ten unit test cases for the {@link Diamond2D#contains(double, double, double, double)} method.\n*/\nclass Diamond2DTest1 {"
	},
	{
		"original_code": "// Diamond2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Diamond2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a diamond like Shape object.\n * @author  mueller\n * @version 1.0\n */\npublic class Diamond2D extends RectangularShape {\n\n    protected double x, y, width, height;\n\n    /**\n     * Creates a Diamond shape with the specified coordinates.\n     */\n    public Diamond2D(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * Returns the height.\n     */\n    public double getHeight() {\n        return height;\n    }\n\n    /**\n     * Returns the width.\n     */\n    public double getWidth() {\n        return width;\n    }\n\n    /**\n     * Returns the x-coordinate.\n     */\n    public double getX() {\n        return x;\n    }\n\n    /**\n     * Returns the y-coordinate.\n     */\n    public double getY() {\n        return y;\n    }\n\n    /**\n     * Returns true if the bounding box is empty.\n     */\n    public boolean isEmpty() {\n        return (width <= 0.0) || (height <= 0.0);\n    }\n\n    /**\n     * Sets the framing rectangle.\n     */\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, height, width);\n    }\n\n    /**\n     * Returns the object's PathIterator.\n     */\n    public PathIterator getPathIterator(AffineTransform at) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 4;\n\n            float[][] fcurrentSegment = { { (float) (x + width / 2), (float) y, 0f, 0f, 0f, 0f }, { (float) x, (float) (y + height / 2), 0f, 0f, 0f, 0f }, { (float) (x + width / 2), (float) (y + height), 0f, 0f, 0f, 0f }, { (float) (x + width), (float) (y + height / 2), 0f, 0f, 0f, 0f }, { 0f, 0f, 0f, 0f, 0f, 0f } };\n\n            double[][] dcurrentSegment = { { x + width / 2, y, 0.0, 0.0, 0.0, 0.0 }, { x, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { x + width / 2, y + height, 0.0, 0.0, 0.0, 0.0 }, { x + width, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                coords[0] = dcurrentSegment[state][0];\n                coords[1] = dcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                coords[0] = fcurrentSegment[state][0];\n                coords[1] = fcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public boolean contains(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public boolean contains(double x, double y) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Diamond2DTest2.java",
		"test_prompt": "// Diamond2DTest2.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Diamond2D}.\n* It contains ten unit test cases for the {@link Diamond2D#contains(double, double)} method.\n*/\nclass Diamond2DTest2 {"
	},
	{
		"original_code": "// Diamond2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Diamond2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a diamond like Shape object.\n * @author  mueller\n * @version 1.0\n */\npublic class Diamond2D extends RectangularShape {\n\n    protected double x, y, width, height;\n\n    /**\n     * Creates a Diamond shape with the specified coordinates.\n     */\n    public Diamond2D(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * Returns the height.\n     */\n    public double getHeight() {\n        return height;\n    }\n\n    /**\n     * Returns the width.\n     */\n    public double getWidth() {\n        return width;\n    }\n\n    /**\n     * Returns the x-coordinate.\n     */\n    public double getX() {\n        return x;\n    }\n\n    /**\n     * Returns the y-coordinate.\n     */\n    public double getY() {\n        return y;\n    }\n\n    /**\n     * Returns true if the bounding box is empty.\n     */\n    public boolean isEmpty() {\n        return (width <= 0.0) || (height <= 0.0);\n    }\n\n    /**\n     * Sets the framing rectangle.\n     */\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, height, width);\n    }\n\n    /**\n     * Returns the object's PathIterator.\n     */\n    public PathIterator getPathIterator(AffineTransform at) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 4;\n\n            float[][] fcurrentSegment = { { (float) (x + width / 2), (float) y, 0f, 0f, 0f, 0f }, { (float) x, (float) (y + height / 2), 0f, 0f, 0f, 0f }, { (float) (x + width / 2), (float) (y + height), 0f, 0f, 0f, 0f }, { (float) (x + width), (float) (y + height / 2), 0f, 0f, 0f, 0f }, { 0f, 0f, 0f, 0f, 0f, 0f } };\n\n            double[][] dcurrentSegment = { { x + width / 2, y, 0.0, 0.0, 0.0, 0.0 }, { x, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { x + width / 2, y + height, 0.0, 0.0, 0.0, 0.0 }, { x + width, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                coords[0] = dcurrentSegment[state][0];\n                coords[1] = dcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                coords[0] = fcurrentSegment[state][0];\n                coords[1] = fcurrentSegment[state][1];\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public boolean contains(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public boolean contains(double x, double y) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Diamond2DTest3.java",
		"test_prompt": "// Diamond2DTest3.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Diamond2D}.\n* It contains ten unit test cases for the {@link Diamond2D#intersects(double, double, double, double)} method.\n*/\nclass Diamond2DTest3 {"
	},
	{
		"original_code": "// Triangle2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Triangle2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a triangular shape.\n * @author  smueller\n */\npublic class Triangle2D extends RectangularShape {\n\n    protected double x = 0.0;\n\n    protected double y = 0.0;\n\n    protected double width = 0.0;\n\n    protected double height = 0.0;\n\n    protected boolean upsidedown = false;\n\n    /**\n     * Creates a new instance of Triangle2D\n     */\n    public Triangle2D(double x, double y, double width, double height, boolean upsidedown) {\n        setFrame(x, y, width, height);\n        this.upsidedown = upsidedown;\n    }\n\n    public boolean contains(double param, double param1) {\n        return false;\n    }\n\n    public boolean contains(double param, double param1, double param2, double param3) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, width, height);\n    }\n\n    public double getHeight() {\n        return height;\n    }\n\n    public PathIterator getPathIterator(AffineTransform affineTransform) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 3;\n\n            double[][] dcurrentSegment = { { x + width / 2, y }, { x, y + height }, { x + width, y + height }, { 0.0, 0.0 } };\n\n            double[][] ddowncurrentSegment = { { x, y }, { x + width / 2, y + height }, { x + width, y }, { 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                if (!upsidedown) {\n                    coords[0] = dcurrentSegment[state][0];\n                    coords[1] = dcurrentSegment[state][1];\n                } else {\n                    coords[0] = ddowncurrentSegment[state][0];\n                    coords[1] = ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                if (!upsidedown) {\n                    coords[0] = (float) dcurrentSegment[state][0];\n                    coords[1] = (float) dcurrentSegment[state][1];\n                } else {\n                    coords[0] = (float) ddowncurrentSegment[state][0];\n                    coords[1] = (float) ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public boolean isEmpty() {\n        return (width <= 0.0 || height <= 0.0);\n    }\n\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Triangle2DTest0.java",
		"test_prompt": "// Triangle2DTest0.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Triangle2D}.\n* It contains ten unit test cases for the {@link Triangle2D#contains(double, double)} method.\n*/\nclass Triangle2DTest0 {"
	},
	{
		"original_code": "// Triangle2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Triangle2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a triangular shape.\n * @author  smueller\n */\npublic class Triangle2D extends RectangularShape {\n\n    protected double x = 0.0;\n\n    protected double y = 0.0;\n\n    protected double width = 0.0;\n\n    protected double height = 0.0;\n\n    protected boolean upsidedown = false;\n\n    /**\n     * Creates a new instance of Triangle2D\n     */\n    public Triangle2D(double x, double y, double width, double height, boolean upsidedown) {\n        setFrame(x, y, width, height);\n        this.upsidedown = upsidedown;\n    }\n\n    public boolean contains(double param, double param1) {\n        return false;\n    }\n\n    public boolean contains(double param, double param1, double param2, double param3) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, width, height);\n    }\n\n    public double getHeight() {\n        return height;\n    }\n\n    public PathIterator getPathIterator(AffineTransform affineTransform) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 3;\n\n            double[][] dcurrentSegment = { { x + width / 2, y }, { x, y + height }, { x + width, y + height }, { 0.0, 0.0 } };\n\n            double[][] ddowncurrentSegment = { { x, y }, { x + width / 2, y + height }, { x + width, y }, { 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                if (!upsidedown) {\n                    coords[0] = dcurrentSegment[state][0];\n                    coords[1] = dcurrentSegment[state][1];\n                } else {\n                    coords[0] = ddowncurrentSegment[state][0];\n                    coords[1] = ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                if (!upsidedown) {\n                    coords[0] = (float) dcurrentSegment[state][0];\n                    coords[1] = (float) dcurrentSegment[state][1];\n                } else {\n                    coords[0] = (float) ddowncurrentSegment[state][0];\n                    coords[1] = (float) ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public boolean isEmpty() {\n        return (width <= 0.0 || height <= 0.0);\n    }\n\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Triangle2DTest1.java",
		"test_prompt": "// Triangle2DTest1.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Triangle2D}.\n* It contains ten unit test cases for the {@link Triangle2D#contains(double, double, double, double)} method.\n*/\nclass Triangle2DTest1 {"
	},
	{
		"original_code": "// Triangle2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Triangle2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a triangular shape.\n * @author  smueller\n */\npublic class Triangle2D extends RectangularShape {\n\n    protected double x = 0.0;\n\n    protected double y = 0.0;\n\n    protected double width = 0.0;\n\n    protected double height = 0.0;\n\n    protected boolean upsidedown = false;\n\n    /**\n     * Creates a new instance of Triangle2D\n     */\n    public Triangle2D(double x, double y, double width, double height, boolean upsidedown) {\n        setFrame(x, y, width, height);\n        this.upsidedown = upsidedown;\n    }\n\n    public boolean contains(double param, double param1) {\n        return false;\n    }\n\n    public boolean contains(double param, double param1, double param2, double param3) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, width, height);\n    }\n\n    public double getHeight() {\n        return height;\n    }\n\n    public PathIterator getPathIterator(AffineTransform affineTransform) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 3;\n\n            double[][] dcurrentSegment = { { x + width / 2, y }, { x, y + height }, { x + width, y + height }, { 0.0, 0.0 } };\n\n            double[][] ddowncurrentSegment = { { x, y }, { x + width / 2, y + height }, { x + width, y }, { 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                if (!upsidedown) {\n                    coords[0] = dcurrentSegment[state][0];\n                    coords[1] = dcurrentSegment[state][1];\n                } else {\n                    coords[0] = ddowncurrentSegment[state][0];\n                    coords[1] = ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                if (!upsidedown) {\n                    coords[0] = (float) dcurrentSegment[state][0];\n                    coords[1] = (float) dcurrentSegment[state][1];\n                } else {\n                    coords[0] = (float) ddowncurrentSegment[state][0];\n                    coords[1] = (float) ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public boolean isEmpty() {\n        return (width <= 0.0 || height <= 0.0);\n    }\n\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Triangle2DTest2.java",
		"test_prompt": "// Triangle2DTest2.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Triangle2D}.\n* It contains ten unit test cases for the {@link Triangle2D#intersects(double, double, double, double)} method.\n*/\nclass Triangle2DTest2 {"
	},
	{
		"original_code": "// Triangle2D.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    Triangle2D.java\n    Created on 11. September 2002, 22:01\n*/\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\n\n/**\n * This class implements a triangular shape.\n * @author  smueller\n */\npublic class Triangle2D extends RectangularShape {\n\n    protected double x = 0.0;\n\n    protected double y = 0.0;\n\n    protected double width = 0.0;\n\n    protected double height = 0.0;\n\n    protected boolean upsidedown = false;\n\n    /**\n     * Creates a new instance of Triangle2D\n     */\n    public Triangle2D(double x, double y, double width, double height, boolean upsidedown) {\n        setFrame(x, y, width, height);\n        this.upsidedown = upsidedown;\n    }\n\n    public boolean contains(double param, double param1) {\n        return false;\n    }\n\n    public boolean contains(double param, double param1, double param2, double param3) {\n        return false;\n    }\n\n    public boolean intersects(double x, double y, double w, double h) {\n        return false;\n    }\n\n    public Rectangle2D getBounds2D() {\n        return new Rectangle2D.Double(x, y, width, height);\n    }\n\n    public double getHeight() {\n        return height;\n    }\n\n    public PathIterator getPathIterator(AffineTransform affineTransform) {\n        return new PathIterator() {\n\n            int state = 0;\n\n            int maxstate = 3;\n\n            double[][] dcurrentSegment = { { x + width / 2, y }, { x, y + height }, { x + width, y + height }, { 0.0, 0.0 } };\n\n            double[][] ddowncurrentSegment = { { x, y }, { x + width / 2, y + height }, { x + width, y }, { 0.0, 0.0 } };\n\n            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };\n\n            public int currentSegment(double[] coords) {\n                if (!upsidedown) {\n                    coords[0] = dcurrentSegment[state][0];\n                    coords[1] = dcurrentSegment[state][1];\n                } else {\n                    coords[0] = ddowncurrentSegment[state][0];\n                    coords[1] = ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int currentSegment(float[] coords) {\n                if (!upsidedown) {\n                    coords[0] = (float) dcurrentSegment[state][0];\n                    coords[1] = (float) dcurrentSegment[state][1];\n                } else {\n                    coords[0] = (float) ddowncurrentSegment[state][0];\n                    coords[1] = (float) ddowncurrentSegment[state][1];\n                }\n                return segment[state];\n            }\n\n            public int getWindingRule() {\n                return PathIterator.WIND_NON_ZERO;\n            }\n\n            public boolean isDone() {\n                return (state == maxstate);\n            }\n\n            public void next() {\n                state++;\n            }\n        };\n    }\n\n    public double getWidth() {\n        return width;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public boolean isEmpty() {\n        return (width <= 0.0 || height <= 0.0);\n    }\n\n    public void setFrame(double x, double y, double width, double height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Triangle2DTest3.java",
		"test_prompt": "// Triangle2DTest3.java\npackage de.progra.charting.render.shape;\n\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.AffineTransform;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Triangle2D}.\n* It contains ten unit test cases for the {@link Triangle2D#isEmpty()} method.\n*/\nclass Triangle2DTest3 {"
	},
	{
		"original_code": "// RowColorModel.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    RowColorModel.java\n    Created on 28. August 2001, 20:02\n*/\npackage de.progra.charting.render;\n\nimport java.awt.Color;\nimport de.progra.charting.model.ChartDataModel;\nimport java.util.HashMap;\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Rectangle2D;\nimport de.progra.charting.render.shape.Diamond2D;\nimport de.progra.charting.render.shape.Triangle2D;\n\n/**\n * This class implements the correspondence between the DataSets and the\n * colors used for rendering the charts and the legend.\n * @author mueller\n * @version 1.0\n */\npublic class RowColorModel {\n\n    private static RowColorModel instance;\n\n    protected ChartDataModel model;\n\n    protected final static Color[] predefinedColors = { Color.blue, Color.cyan, Color.red, Color.pink, Color.yellow, Color.green, Color.magenta, Color.orange, Color.darkGray, Color.gray, Color.lightGray };\n\n    public static final Ellipse2D ELLIPSE_SHAPE = new Ellipse2D.Float(0f, 0f, 5f, 5f);\n\n    public static final Rectangle2D SQUARE_SHAPE = new Rectangle2D.Float(0f, 0f, 5f, 5f);\n\n    public static final Diamond2D DIAMOND_SHAPE = new Diamond2D(0f, 0f, 5f, 5f);\n\n    public static final Triangle2D TRIANGLE_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, false);\n\n    public static final Triangle2D TRIANGLEDOWN_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, true);\n\n    protected final static RectangularShape[] predefinedShapes = { ELLIPSE_SHAPE, SQUARE_SHAPE, DIAMOND_SHAPE, TRIANGLE_SHAPE, TRIANGLEDOWN_SHAPE };\n\n    protected int predefinedColorsIdx = 0;\n\n    protected HashMap customColors = new HashMap();\n\n    protected HashMap customShapes = new HashMap();\n\n    /**\n     * Creates new RowColorModel.\n     * @param model the ChartDataModel which contains the information about all the DataSets\n     */\n    public RowColorModel(ChartDataModel model) {\n        this.model = model;\n    }\n\n    /**\n     * Use this method to get an instance of the chart's RowColorModel.\n     * @param model the ChartDataModel whose data sets will be mapped to\n     * colors.\n     * @return a new instance of RowColorModel if there's no instance\n     * of if the model has changed (esp. useful if you create multiple charts\n     * after one another).\n     * @deprecated\n     */\n    public static RowColorModel getInstance(ChartDataModel model) {\n        if (instance == null || !model.equals(instance.model))\n            instance = new RowColorModel(model);\n        return instance;\n    }\n\n    /**\n     * Computes the amount of all Legend entries, ie. DataSets.\n     * @return the amount of all rows, ie. DataSets.\n     */\n    public int getRowCount() {\n        return model.getDataSetNumber();\n    }\n\n    /**\n     * Returns the row title of a specific DataSet.\n     * @param i the DataSet index\n     * @return the String title\n     */\n    public String getRow(int i) {\n        return model.getDataSetName(i);\n    }\n\n    /**\n     * Computes the Color for a DataSet. For the first DataSets the stored Colors like <CODE>Color.red</CODE> etc are used. If there are more DataSets than stored colors, random colors are used.\n     * @param row the row for which the Color should be returned\n     * @return the Color stored for the given row.\n     */\n    public Color getColor(int row) {\n        // get the custom color\n        Color c = (Color) customColors.get(new Integer(row));\n        // if no custom color\n        if (c == null) {\n            // see if there is a predefined color for this row\n            if (predefinedColorsIdx < predefinedColors.length) {\n                c = predefinedColors[predefinedColorsIdx++];\n            } else {\n                c = new Color((float) Math.random(), (float) Math.random(), (float) Math.random());\n            }\n            // remember this\n            customColors.put(new Integer(row), c);\n        }\n        // done\n        return c;\n    }\n\n    /**\n     * Returns the Shape for a DataSet. By default, the Shapes from\n     * the <code>predefinedShapes</code> array are cycled through unless you define\n     * your own shape to data binding using\n     * <code>setShape(int row, RectangularShape shape)</code>.\n     * @param row the row for which the Shape should be returned\n     * @return the Shape stored for the given row.\n     */\n    public RectangularShape getShape(int row) {\n        // get the custom color\n        RectangularShape c = (RectangularShape) customShapes.get(new Integer(row));\n        // if no custom color\n        if (c == null) {\n            // calculate the matching predefined shape by a modulo operation\n            c = predefinedShapes[row % predefinedShapes.length];\n            // remember this\n            customShapes.put(new Integer(row), c);\n        }\n        // done\n        return c;\n    }\n\n    /**\n     * Force a certain color for a row\n     * @param row the row for which the Color should be set\n     * @param color the color that is associated with the row\n     */\n    public void setColor(int row, Color color) {\n        customColors.put(new Integer(row), color);\n    }\n\n    /**\n     * Force a certain Shape for a row\n     * @param row the row for which the Shape should be set\n     * @param shape the RectangularShape that is associated with the row\n     */\n    public void setShape(int row, RectangularShape shape) {\n        customShapes.put(new Integer(row), shape);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/RowColorModelTest.java",
		"test_prompt": "// RowColorModelTest.java\npackage de.progra.charting.render;\n\nimport java.awt.Color;\nimport de.progra.charting.model.ChartDataModel;\nimport java.util.HashMap;\nimport java.awt.geom.RectangularShape;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Rectangle2D;\nimport de.progra.charting.render.shape.Diamond2D;\nimport de.progra.charting.render.shape.Triangle2D;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RowColorModel}.\n* It contains ten unit test cases for the {@link RowColorModel#getInstance(ChartDataModel)} method.\n*/\nclass RowColorModelTest {"
	},
	{
		"original_code": "// CoordSystem.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystem.java\n    Created on 26. Juni 2001, 22:49\n */\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\n\n/**\n * This class defines a coordinate system. The CoordSystem class computes\n * an AffineTransform for each y-axis, which translates the user space\n * coordinates (ie. the data value coordinates) into pixel space coordinates.\n * These AffineTransform classes make the PixelToPointTranslator obsolete,\n * since it provides more flexibility. <code>getDefaultTransform</code> always\n * computes the default transformation, whereas you can set another\n * transformation via <code>setTransform</code>. This will be used to implement\n * zooming and panning in the Swing classes.<p>\n * All classes incl. this one, which render data will use the transformations\n * to translate the coordinates. The transformations are not set up on\n * instantiation of a CoordSystem, instead they're computed when setBounds\n * is called, because they need this information of course. Afterwards you\n * can set your own transformation or even better you can manipulate the\n * existing ones by pre- or postconcatenating another AffineTransform.\n */\npublic class CoordSystem extends AbstractRenderer {\n\n    /**\n     * The x-axis caption string.\n     */\n    protected String xaxis_unit = \"x\";\n\n    /**\n     * The y-axis caption string.\n     */\n    protected String yaxis_unit = \"y\";\n\n    /**\n     * The Font used in the CoordSystem.\n     */\n    protected Font font = new Font(\"sans\", Font.PLAIN, 9);\n\n    /**\n     * FontRenderContext used througout the CoordSystem\n     */\n    protected final FontRenderContext frc = new FontRenderContext(null, false, false);\n\n    /**\n     * DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    protected DecimalFormat dfY;\n\n    /**\n     * DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    protected DecimalFormat dfX;\n\n    /**\n     * if true, the arrows will be drawn at the end of the axi\n     */\n    protected boolean shouldDrawArrows = true;\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    protected boolean shouldPaintAltTick = true;\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately, if false, a\n     * light grey line will paint across the background of the chart.\n     */\n    protected boolean shouldPaintOnlyTick = true;\n\n    /**\n     * If true, the labels will be painted. If false, only the ticks will display.\n     */\n    protected boolean shouldPaintLabels = true;\n\n    /**\n     * The left margin\n     */\n    protected int leftmargin = 50;\n\n    /**\n     * The top margin.\n     */\n    protected int topmargin = 20;\n\n    /**\n     * The right margin.\n     */\n    protected int rightmargin = 30;\n\n    /**\n     * The bottom margin.\n     */\n    protected int bottommargin = 30;\n\n    /**\n     * The minimal margin constant.\n     */\n    public final int MINIMALMARGIN = 20;\n\n    /**\n     * The arrow length constant.\n     */\n    public final int ARROWLENGTH = 15;\n\n    /**\n     * The ChartDataModel constraints of the first y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints;\n\n    /**\n     * The ChartDataModel constraints of the second y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints2;\n\n    /**\n     * The DataModel class.\n     */\n    protected ChartDataModel model;\n\n    /**\n     * The utilities class, which contains all the rendering methods etc.\n     */\n    protected CoordSystemUtilities c;\n\n    /**\n     * The xaxis.\n     */\n    protected Axis xaxis;\n\n    /**\n     * The first y-axis.\n     */\n    protected Axis yaxis;\n\n    /**\n     * The second y-axis.\n     */\n    protected Axis yaxis2;\n\n    /**\n     * The multiplication matrix for the first y-axis and the x-axis.\n     */\n    protected AffineTransform y1transform;\n\n    /**\n     * The multiplication matrix for the second y-axis and the x-axis.\n     */\n    protected AffineTransform y2transform;\n\n    /**\n     * the axis binding constant for the first y-axis\n     */\n    public static final int FIRST_YAXIS = 0;\n\n    /**\n     * the axis binding constant for the second y-axis\n     */\n    public static final int SECOND_YAXIS = 1;\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     */\n    public CoordSystem(ChartDataModel cdm) {\n        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);\n        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);\n        this.model = cdm;\n        xaxis = new Axis(Axis.HORIZONTAL, constraints);\n        yaxis = new Axis(Axis.VERTICAL, constraints);\n        c = new CoordSystemUtilities(this, constraints, constraints2, model);\n        dfY = new DecimalFormat();\n        dfX = new DecimalFormat();\n    }\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param xtext the x-axis unit\n     * @param ytext the y-axis unit\n     */\n    public CoordSystem(ChartDataModel c, String xunit, String yunit) {\n        this(c);\n        setXAxisUnit(xunit);\n        setYAxisUnit(yunit);\n    }\n\n    /**\n     * Create a new CoordSystem with alternate painting parameters.\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param drawArrows if true the arrows will be drawn at the end of the axis\n     * @param paintAltYTick if true the caption will paint on alternate ticks of the\n     * yaxis instead of on every one.\n     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>\n     * appear behind the chart at each yaxis tick mark.\n     */\n    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {\n        this(c);\n        dfY = yAxisFormat;\n        shouldDrawArrows = drawArrows;\n        shouldPaintAltTick = paintAltYTick;\n        shouldPaintOnlyTick = paintOnlyYTick;\n    }\n\n    /**\n     * Sets the coordinate transformation for any y-coordinate.\n     * @param at the AffineTransform that transforms the coordinates into pixel\n     * space\n     * @axis defines for which y-axis the transform is computed\n     */\n    public void setTransform(AffineTransform at, int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                y1transform = at;\n                break;\n            case (SECOND_YAXIS):\n                y2transform = at;\n                break;\n        }\n    }\n\n    /**\n     * Returns the currently defined AffineTransform for any y-axis.\n     * @param axis the y-axis to be used.\n     */\n    public AffineTransform getTransform(int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                return y1transform;\n            case (SECOND_YAXIS):\n                return y2transform;\n        }\n        return null;\n    }\n\n    /**\n     * This method computes the default transform which transforms the\n     * user space coordinates of this coordinate system to the pixel\n     * space coordinates used in the Graphics object.\n     * All rendering in the CoordinateSystem and the ChartRenderers\n     * will rely on this transform.\n     * @param axis defines which y-axis to use.\n     */\n    public AffineTransform getDefaultTransform(int axis) {\n        double x_pt2px = 0;\n        double y_pt2px = 0;\n        double xcoord0 = 0;\n        double ycoord0 = 0;\n        x_pt2px = 1 / getXAxis().getPointToPixelRatio();\n        //System.out.println(\"** x_pt2px = \"+getXAxis().getPointToPixelRatio());\n        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);\n        switch(axis) {\n            case FIRST_YAXIS:\n                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);\n                break;\n            case SECOND_YAXIS:\n                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);\n                break;\n        }\n        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);\n    }\n\n    /**\n     * Sets the x-axis.\n     * @param a the x-axis\n     */\n    public void setXAxis(Axis a) {\n        xaxis = a;\n    }\n\n    /**\n     * Returns the x axis.\n     * @return the x-axis\n     */\n    public Axis getXAxis() {\n        return xaxis;\n    }\n\n    /**\n     * Sets the x-axis unit string.\n     * @param xtext the unit string\n     */\n    public void setXAxisUnit(String xunit) {\n        this.xaxis_unit = xunit;\n    }\n\n    /**\n     * Gets the x-axis unit string.\n     * @return the label String\n     */\n    public String getXAxisUnit() {\n        return xaxis_unit;\n    }\n\n    /**\n     * Sets the y-axis unit string.\n     * @param ytext the unit string\n     */\n    public void setYAxisUnit(String yunit) {\n        this.yaxis_unit = yunit;\n    }\n\n    /**\n     * Gets the y-axis label.\n     * @return the label String\n     */\n    public String getYAxisUnit() {\n        return yaxis_unit;\n    }\n\n    /**\n     * Sets the font for the axis labels.\n     * @param f the Font to be used\n     */\n    public void setFont(Font f) {\n        font = f;\n    }\n\n    /**\n     * Returns the font used for the axis labels.\n     * @return the Font object\n     */\n    public Font getFont() {\n        return font;\n    }\n\n    /**\n     * Sets the left y-axis and computes the matrix transformation.\n     * @param a the left y-axis\n     */\n    public void setFirstYAxis(Axis a) {\n        yaxis = a;\n    }\n\n    /**\n     * Returns the first y-axis.\n     * @return the left y-axis\n     */\n    public Axis getFirstYAxis() {\n        return yaxis;\n    }\n\n    /**\n     * Sets the second y-axis and computes the matrix transformation.\n     * @param a the right y-axis\n     */\n    public void setSecondYAxis(Axis a) {\n        yaxis2 = a;\n    }\n\n    /**\n     * Returns the second y-axis.\n     * @return the right y-axis\n     */\n    public Axis getSecondYAxis() {\n        return yaxis2;\n    }\n\n    /**\n     * Returns the inner margin, ie the bounds minus the margins.\n     * @return a Rectangle object defining the inner bounds.\n     */\n    public Rectangle getInnerBounds() {\n        Rectangle b = getBounds();\n        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);\n        return i;\n    }\n\n    /**\n     * Computes all margins, initializes the length of the Axis and\n     * calls <code>super.setBounds</code>. Additionally, it sets the\n     * default AffineTransforms for every y-axis.\n     * @param bounds <CODE>Rectangle</CODE> object defining the bounds\n     */\n    public void setBounds(Rectangle bounds) {\n        super.setBounds(bounds);\n        setRightMargin(c.computeRightMargin());\n        setLeftMargin(c.computeLeftMargin());\n        setTopMargin(c.computeTopMargin());\n        setBottomMargin(c.computeBottomMargin());\n        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());\n        //System.out.println(\"** xaxis.length = \"+xaxis.getLength());\n        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n        //System.out.println(\"** yaxis.length = \"+yaxis.getLength());\n        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);\n        if (yaxis2 != null) {\n            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);\n        }\n    }\n\n    /**\n     * Returns the preferred size needed for the renderer.\n     * @return a Dimension with the minimum Integer values.\n     */\n    public Dimension getPreferredSize() {\n        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);\n    }\n\n    /**\n     * Overrides the method to just call <code>paintDefault</code>.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void render(Graphics2D g) {\n        paintDefault(g);\n    }\n\n    /**\n     * This method is called by the paint method to do the actual painting.\n     * The painting is supposed to start at point (0,0) and the size is\n     * always the same as the preferred size. The paint method performs\n     * the possible scaling.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void paintDefault(Graphics2D g) {\n        g.setColor(Color.black);\n        Line2D x = c.getXAxisLine2D();\n        Line2D y = c.getYAxisLine2D();\n        g.draw(x);\n        g.draw(y);\n        // draw X-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());\n            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);\n        }\n        // draw X-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);\n        // draw Y-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);\n            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);\n        }\n        // draw Y-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);\n        if (getSecondYAxis() != null) {\n            Line2D y2 = c.getSecondYAxisLine2D();\n            g.draw(y2);\n        }\n        if (model.isColumnNumeric())\n            c.drawNumericalXAxisTicks(g);\n        else\n            c.drawXAxisTicks(g);\n        c.drawYAxisTicks(g);\n    }\n\n    /**\n     * Returns a new PointToPixelTranslator for the given axis.\n     * Please notice that this method is deprecated since release 0.92.\n     * The PointToPixelTranslator interface has been replaced with\n     * AffineTransforms.\n     * @param y the y-axis identifier used to choose the right Point / Pixel ratio\n     * @return a PointToPixelTranslator object or null if the resulting\n     * Point is not within the Bounds of the Coordinate System\n     * @deprecated\n     */\n    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {\n        final Axis x = this.getXAxis();\n        final Axis y;\n        if (yaxis == CoordSystem.FIRST_YAXIS)\n            y = this.getFirstYAxis();\n        else\n            y = this.getSecondYAxis();\n        return new PointToPixelTranslator() {\n\n            public Point2D getPixelCoord(Point2D pt) {\n                double x0 = 0.0;\n                double y0 = 0.0;\n                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());\n                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());\n                Point2D p = new Point2D.Double(x0, y0);\n                if (getInnerBounds().contains(p))\n                    return p;\n                else\n                    return null;\n            }\n        };\n    }\n\n    /**\n     * Returns the left margin.\n     */\n    protected int getLeftMargin() {\n        return leftmargin;\n    }\n\n    /**\n     * Returns the right margin.\n     */\n    protected int getRightMargin() {\n        return rightmargin;\n    }\n\n    /**\n     * Returns the top margin.\n     */\n    protected int getTopMargin() {\n        return topmargin;\n    }\n\n    /**\n     * Returns the bottom margin.\n     */\n    protected int getBottomMargin() {\n        return bottommargin;\n    }\n\n    /**\n     * Sets the left margin.\n     * @param margin the new margin value\n     */\n    protected void setLeftMargin(int margin) {\n        leftmargin = margin;\n    }\n\n    /**\n     * Sets the right margin.\n     * @param margin the new margin value\n     */\n    protected void setRightMargin(int margin) {\n        rightmargin = margin;\n    }\n\n    /**\n     * Sets the top margin.\n     * @param margin the new margin value\n     */\n    protected void setTopMargin(int margin) {\n        topmargin = margin;\n    }\n\n    /**\n     * Sets the bottom margin.\n     * @param margin the new margin value\n     */\n    public void setBottomMargin(int margin) {\n        bottommargin = margin;\n    }\n\n    /**\n     * Returns the FontRenderContext used througout the CoordSystem\n     */\n    public FontRenderContext getFontRenderContext() {\n        return frc;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    public DecimalFormat getYDecimalFormat() {\n        return dfY;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    public DecimalFormat getXDecimalFormat() {\n        return dfX;\n    }\n\n    /**\n     * if true, the arrows will be drawn at the end of the axis\n     */\n    public boolean isDrawArrows() {\n        return shouldDrawArrows;\n    }\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    public boolean isPaintAltTick() {\n        return shouldPaintAltTick;\n    }\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately a\n     * light grey line will paint across the background of the chart.\n     */\n    public boolean isPaintOnlyTick() {\n        return shouldPaintOnlyTick;\n    }\n\n    public boolean isPaintLabels() {\n        return shouldPaintLabels;\n    }\n\n    public void setPaintLabels(boolean label) {\n        shouldPaintLabels = label;\n    }\n\n    /**\n     * Returns the used ChartDataModelConstraints.\n     */\n    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {\n        if (axis == FIRST_YAXIS)\n            return constraints;\n        else if (axis == SECOND_YAXIS)\n            return constraints2;\n        else\n            return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemTest0.java",
		"test_prompt": "// CoordSystemTest0.java\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystem}.\n* It contains ten unit test cases for the {@link CoordSystem#isDrawArrows()} method.\n*/\nclass CoordSystemTest0 {"
	},
	{
		"original_code": "// CoordSystem.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystem.java\n    Created on 26. Juni 2001, 22:49\n */\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\n\n/**\n * This class defines a coordinate system. The CoordSystem class computes\n * an AffineTransform for each y-axis, which translates the user space\n * coordinates (ie. the data value coordinates) into pixel space coordinates.\n * These AffineTransform classes make the PixelToPointTranslator obsolete,\n * since it provides more flexibility. <code>getDefaultTransform</code> always\n * computes the default transformation, whereas you can set another\n * transformation via <code>setTransform</code>. This will be used to implement\n * zooming and panning in the Swing classes.<p>\n * All classes incl. this one, which render data will use the transformations\n * to translate the coordinates. The transformations are not set up on\n * instantiation of a CoordSystem, instead they're computed when setBounds\n * is called, because they need this information of course. Afterwards you\n * can set your own transformation or even better you can manipulate the\n * existing ones by pre- or postconcatenating another AffineTransform.\n */\npublic class CoordSystem extends AbstractRenderer {\n\n    /**\n     * The x-axis caption string.\n     */\n    protected String xaxis_unit = \"x\";\n\n    /**\n     * The y-axis caption string.\n     */\n    protected String yaxis_unit = \"y\";\n\n    /**\n     * The Font used in the CoordSystem.\n     */\n    protected Font font = new Font(\"sans\", Font.PLAIN, 9);\n\n    /**\n     * FontRenderContext used througout the CoordSystem\n     */\n    protected final FontRenderContext frc = new FontRenderContext(null, false, false);\n\n    /**\n     * DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    protected DecimalFormat dfY;\n\n    /**\n     * DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    protected DecimalFormat dfX;\n\n    /**\n     * if true, the arrows will be drawn at the end of the axi\n     */\n    protected boolean shouldDrawArrows = true;\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    protected boolean shouldPaintAltTick = true;\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately, if false, a\n     * light grey line will paint across the background of the chart.\n     */\n    protected boolean shouldPaintOnlyTick = true;\n\n    /**\n     * If true, the labels will be painted. If false, only the ticks will display.\n     */\n    protected boolean shouldPaintLabels = true;\n\n    /**\n     * The left margin\n     */\n    protected int leftmargin = 50;\n\n    /**\n     * The top margin.\n     */\n    protected int topmargin = 20;\n\n    /**\n     * The right margin.\n     */\n    protected int rightmargin = 30;\n\n    /**\n     * The bottom margin.\n     */\n    protected int bottommargin = 30;\n\n    /**\n     * The minimal margin constant.\n     */\n    public final int MINIMALMARGIN = 20;\n\n    /**\n     * The arrow length constant.\n     */\n    public final int ARROWLENGTH = 15;\n\n    /**\n     * The ChartDataModel constraints of the first y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints;\n\n    /**\n     * The ChartDataModel constraints of the second y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints2;\n\n    /**\n     * The DataModel class.\n     */\n    protected ChartDataModel model;\n\n    /**\n     * The utilities class, which contains all the rendering methods etc.\n     */\n    protected CoordSystemUtilities c;\n\n    /**\n     * The xaxis.\n     */\n    protected Axis xaxis;\n\n    /**\n     * The first y-axis.\n     */\n    protected Axis yaxis;\n\n    /**\n     * The second y-axis.\n     */\n    protected Axis yaxis2;\n\n    /**\n     * The multiplication matrix for the first y-axis and the x-axis.\n     */\n    protected AffineTransform y1transform;\n\n    /**\n     * The multiplication matrix for the second y-axis and the x-axis.\n     */\n    protected AffineTransform y2transform;\n\n    /**\n     * the axis binding constant for the first y-axis\n     */\n    public static final int FIRST_YAXIS = 0;\n\n    /**\n     * the axis binding constant for the second y-axis\n     */\n    public static final int SECOND_YAXIS = 1;\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     */\n    public CoordSystem(ChartDataModel cdm) {\n        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);\n        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);\n        this.model = cdm;\n        xaxis = new Axis(Axis.HORIZONTAL, constraints);\n        yaxis = new Axis(Axis.VERTICAL, constraints);\n        c = new CoordSystemUtilities(this, constraints, constraints2, model);\n        dfY = new DecimalFormat();\n        dfX = new DecimalFormat();\n    }\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param xtext the x-axis unit\n     * @param ytext the y-axis unit\n     */\n    public CoordSystem(ChartDataModel c, String xunit, String yunit) {\n        this(c);\n        setXAxisUnit(xunit);\n        setYAxisUnit(yunit);\n    }\n\n    /**\n     * Create a new CoordSystem with alternate painting parameters.\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param drawArrows if true the arrows will be drawn at the end of the axis\n     * @param paintAltYTick if true the caption will paint on alternate ticks of the\n     * yaxis instead of on every one.\n     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>\n     * appear behind the chart at each yaxis tick mark.\n     */\n    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {\n        this(c);\n        dfY = yAxisFormat;\n        shouldDrawArrows = drawArrows;\n        shouldPaintAltTick = paintAltYTick;\n        shouldPaintOnlyTick = paintOnlyYTick;\n    }\n\n    /**\n     * Sets the coordinate transformation for any y-coordinate.\n     * @param at the AffineTransform that transforms the coordinates into pixel\n     * space\n     * @axis defines for which y-axis the transform is computed\n     */\n    public void setTransform(AffineTransform at, int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                y1transform = at;\n                break;\n            case (SECOND_YAXIS):\n                y2transform = at;\n                break;\n        }\n    }\n\n    /**\n     * Returns the currently defined AffineTransform for any y-axis.\n     * @param axis the y-axis to be used.\n     */\n    public AffineTransform getTransform(int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                return y1transform;\n            case (SECOND_YAXIS):\n                return y2transform;\n        }\n        return null;\n    }\n\n    /**\n     * This method computes the default transform which transforms the\n     * user space coordinates of this coordinate system to the pixel\n     * space coordinates used in the Graphics object.\n     * All rendering in the CoordinateSystem and the ChartRenderers\n     * will rely on this transform.\n     * @param axis defines which y-axis to use.\n     */\n    public AffineTransform getDefaultTransform(int axis) {\n        double x_pt2px = 0;\n        double y_pt2px = 0;\n        double xcoord0 = 0;\n        double ycoord0 = 0;\n        x_pt2px = 1 / getXAxis().getPointToPixelRatio();\n        //System.out.println(\"** x_pt2px = \"+getXAxis().getPointToPixelRatio());\n        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);\n        switch(axis) {\n            case FIRST_YAXIS:\n                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);\n                break;\n            case SECOND_YAXIS:\n                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);\n                break;\n        }\n        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);\n    }\n\n    /**\n     * Sets the x-axis.\n     * @param a the x-axis\n     */\n    public void setXAxis(Axis a) {\n        xaxis = a;\n    }\n\n    /**\n     * Returns the x axis.\n     * @return the x-axis\n     */\n    public Axis getXAxis() {\n        return xaxis;\n    }\n\n    /**\n     * Sets the x-axis unit string.\n     * @param xtext the unit string\n     */\n    public void setXAxisUnit(String xunit) {\n        this.xaxis_unit = xunit;\n    }\n\n    /**\n     * Gets the x-axis unit string.\n     * @return the label String\n     */\n    public String getXAxisUnit() {\n        return xaxis_unit;\n    }\n\n    /**\n     * Sets the y-axis unit string.\n     * @param ytext the unit string\n     */\n    public void setYAxisUnit(String yunit) {\n        this.yaxis_unit = yunit;\n    }\n\n    /**\n     * Gets the y-axis label.\n     * @return the label String\n     */\n    public String getYAxisUnit() {\n        return yaxis_unit;\n    }\n\n    /**\n     * Sets the font for the axis labels.\n     * @param f the Font to be used\n     */\n    public void setFont(Font f) {\n        font = f;\n    }\n\n    /**\n     * Returns the font used for the axis labels.\n     * @return the Font object\n     */\n    public Font getFont() {\n        return font;\n    }\n\n    /**\n     * Sets the left y-axis and computes the matrix transformation.\n     * @param a the left y-axis\n     */\n    public void setFirstYAxis(Axis a) {\n        yaxis = a;\n    }\n\n    /**\n     * Returns the first y-axis.\n     * @return the left y-axis\n     */\n    public Axis getFirstYAxis() {\n        return yaxis;\n    }\n\n    /**\n     * Sets the second y-axis and computes the matrix transformation.\n     * @param a the right y-axis\n     */\n    public void setSecondYAxis(Axis a) {\n        yaxis2 = a;\n    }\n\n    /**\n     * Returns the second y-axis.\n     * @return the right y-axis\n     */\n    public Axis getSecondYAxis() {\n        return yaxis2;\n    }\n\n    /**\n     * Returns the inner margin, ie the bounds minus the margins.\n     * @return a Rectangle object defining the inner bounds.\n     */\n    public Rectangle getInnerBounds() {\n        Rectangle b = getBounds();\n        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);\n        return i;\n    }\n\n    /**\n     * Computes all margins, initializes the length of the Axis and\n     * calls <code>super.setBounds</code>. Additionally, it sets the\n     * default AffineTransforms for every y-axis.\n     * @param bounds <CODE>Rectangle</CODE> object defining the bounds\n     */\n    public void setBounds(Rectangle bounds) {\n        super.setBounds(bounds);\n        setRightMargin(c.computeRightMargin());\n        setLeftMargin(c.computeLeftMargin());\n        setTopMargin(c.computeTopMargin());\n        setBottomMargin(c.computeBottomMargin());\n        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());\n        //System.out.println(\"** xaxis.length = \"+xaxis.getLength());\n        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n        //System.out.println(\"** yaxis.length = \"+yaxis.getLength());\n        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);\n        if (yaxis2 != null) {\n            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);\n        }\n    }\n\n    /**\n     * Returns the preferred size needed for the renderer.\n     * @return a Dimension with the minimum Integer values.\n     */\n    public Dimension getPreferredSize() {\n        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);\n    }\n\n    /**\n     * Overrides the method to just call <code>paintDefault</code>.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void render(Graphics2D g) {\n        paintDefault(g);\n    }\n\n    /**\n     * This method is called by the paint method to do the actual painting.\n     * The painting is supposed to start at point (0,0) and the size is\n     * always the same as the preferred size. The paint method performs\n     * the possible scaling.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void paintDefault(Graphics2D g) {\n        g.setColor(Color.black);\n        Line2D x = c.getXAxisLine2D();\n        Line2D y = c.getYAxisLine2D();\n        g.draw(x);\n        g.draw(y);\n        // draw X-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());\n            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);\n        }\n        // draw X-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);\n        // draw Y-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);\n            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);\n        }\n        // draw Y-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);\n        if (getSecondYAxis() != null) {\n            Line2D y2 = c.getSecondYAxisLine2D();\n            g.draw(y2);\n        }\n        if (model.isColumnNumeric())\n            c.drawNumericalXAxisTicks(g);\n        else\n            c.drawXAxisTicks(g);\n        c.drawYAxisTicks(g);\n    }\n\n    /**\n     * Returns a new PointToPixelTranslator for the given axis.\n     * Please notice that this method is deprecated since release 0.92.\n     * The PointToPixelTranslator interface has been replaced with\n     * AffineTransforms.\n     * @param y the y-axis identifier used to choose the right Point / Pixel ratio\n     * @return a PointToPixelTranslator object or null if the resulting\n     * Point is not within the Bounds of the Coordinate System\n     * @deprecated\n     */\n    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {\n        final Axis x = this.getXAxis();\n        final Axis y;\n        if (yaxis == CoordSystem.FIRST_YAXIS)\n            y = this.getFirstYAxis();\n        else\n            y = this.getSecondYAxis();\n        return new PointToPixelTranslator() {\n\n            public Point2D getPixelCoord(Point2D pt) {\n                double x0 = 0.0;\n                double y0 = 0.0;\n                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());\n                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());\n                Point2D p = new Point2D.Double(x0, y0);\n                if (getInnerBounds().contains(p))\n                    return p;\n                else\n                    return null;\n            }\n        };\n    }\n\n    /**\n     * Returns the left margin.\n     */\n    protected int getLeftMargin() {\n        return leftmargin;\n    }\n\n    /**\n     * Returns the right margin.\n     */\n    protected int getRightMargin() {\n        return rightmargin;\n    }\n\n    /**\n     * Returns the top margin.\n     */\n    protected int getTopMargin() {\n        return topmargin;\n    }\n\n    /**\n     * Returns the bottom margin.\n     */\n    protected int getBottomMargin() {\n        return bottommargin;\n    }\n\n    /**\n     * Sets the left margin.\n     * @param margin the new margin value\n     */\n    protected void setLeftMargin(int margin) {\n        leftmargin = margin;\n    }\n\n    /**\n     * Sets the right margin.\n     * @param margin the new margin value\n     */\n    protected void setRightMargin(int margin) {\n        rightmargin = margin;\n    }\n\n    /**\n     * Sets the top margin.\n     * @param margin the new margin value\n     */\n    protected void setTopMargin(int margin) {\n        topmargin = margin;\n    }\n\n    /**\n     * Sets the bottom margin.\n     * @param margin the new margin value\n     */\n    public void setBottomMargin(int margin) {\n        bottommargin = margin;\n    }\n\n    /**\n     * Returns the FontRenderContext used througout the CoordSystem\n     */\n    public FontRenderContext getFontRenderContext() {\n        return frc;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    public DecimalFormat getYDecimalFormat() {\n        return dfY;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    public DecimalFormat getXDecimalFormat() {\n        return dfX;\n    }\n\n    /**\n     * if true, the arrows will be drawn at the end of the axis\n     */\n    public boolean isDrawArrows() {\n        return shouldDrawArrows;\n    }\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    public boolean isPaintAltTick() {\n        return shouldPaintAltTick;\n    }\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately a\n     * light grey line will paint across the background of the chart.\n     */\n    public boolean isPaintOnlyTick() {\n        return shouldPaintOnlyTick;\n    }\n\n    public boolean isPaintLabels() {\n        return shouldPaintLabels;\n    }\n\n    public void setPaintLabels(boolean label) {\n        shouldPaintLabels = label;\n    }\n\n    /**\n     * Returns the used ChartDataModelConstraints.\n     */\n    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {\n        if (axis == FIRST_YAXIS)\n            return constraints;\n        else if (axis == SECOND_YAXIS)\n            return constraints2;\n        else\n            return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemTest1.java",
		"test_prompt": "// CoordSystemTest1.java\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystem}.\n* It contains ten unit test cases for the {@link CoordSystem#isPaintAltTick()} method.\n*/\nclass CoordSystemTest1 {"
	},
	{
		"original_code": "// CoordSystem.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystem.java\n    Created on 26. Juni 2001, 22:49\n */\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\n\n/**\n * This class defines a coordinate system. The CoordSystem class computes\n * an AffineTransform for each y-axis, which translates the user space\n * coordinates (ie. the data value coordinates) into pixel space coordinates.\n * These AffineTransform classes make the PixelToPointTranslator obsolete,\n * since it provides more flexibility. <code>getDefaultTransform</code> always\n * computes the default transformation, whereas you can set another\n * transformation via <code>setTransform</code>. This will be used to implement\n * zooming and panning in the Swing classes.<p>\n * All classes incl. this one, which render data will use the transformations\n * to translate the coordinates. The transformations are not set up on\n * instantiation of a CoordSystem, instead they're computed when setBounds\n * is called, because they need this information of course. Afterwards you\n * can set your own transformation or even better you can manipulate the\n * existing ones by pre- or postconcatenating another AffineTransform.\n */\npublic class CoordSystem extends AbstractRenderer {\n\n    /**\n     * The x-axis caption string.\n     */\n    protected String xaxis_unit = \"x\";\n\n    /**\n     * The y-axis caption string.\n     */\n    protected String yaxis_unit = \"y\";\n\n    /**\n     * The Font used in the CoordSystem.\n     */\n    protected Font font = new Font(\"sans\", Font.PLAIN, 9);\n\n    /**\n     * FontRenderContext used througout the CoordSystem\n     */\n    protected final FontRenderContext frc = new FontRenderContext(null, false, false);\n\n    /**\n     * DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    protected DecimalFormat dfY;\n\n    /**\n     * DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    protected DecimalFormat dfX;\n\n    /**\n     * if true, the arrows will be drawn at the end of the axi\n     */\n    protected boolean shouldDrawArrows = true;\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    protected boolean shouldPaintAltTick = true;\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately, if false, a\n     * light grey line will paint across the background of the chart.\n     */\n    protected boolean shouldPaintOnlyTick = true;\n\n    /**\n     * If true, the labels will be painted. If false, only the ticks will display.\n     */\n    protected boolean shouldPaintLabels = true;\n\n    /**\n     * The left margin\n     */\n    protected int leftmargin = 50;\n\n    /**\n     * The top margin.\n     */\n    protected int topmargin = 20;\n\n    /**\n     * The right margin.\n     */\n    protected int rightmargin = 30;\n\n    /**\n     * The bottom margin.\n     */\n    protected int bottommargin = 30;\n\n    /**\n     * The minimal margin constant.\n     */\n    public final int MINIMALMARGIN = 20;\n\n    /**\n     * The arrow length constant.\n     */\n    public final int ARROWLENGTH = 15;\n\n    /**\n     * The ChartDataModel constraints of the first y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints;\n\n    /**\n     * The ChartDataModel constraints of the second y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints2;\n\n    /**\n     * The DataModel class.\n     */\n    protected ChartDataModel model;\n\n    /**\n     * The utilities class, which contains all the rendering methods etc.\n     */\n    protected CoordSystemUtilities c;\n\n    /**\n     * The xaxis.\n     */\n    protected Axis xaxis;\n\n    /**\n     * The first y-axis.\n     */\n    protected Axis yaxis;\n\n    /**\n     * The second y-axis.\n     */\n    protected Axis yaxis2;\n\n    /**\n     * The multiplication matrix for the first y-axis and the x-axis.\n     */\n    protected AffineTransform y1transform;\n\n    /**\n     * The multiplication matrix for the second y-axis and the x-axis.\n     */\n    protected AffineTransform y2transform;\n\n    /**\n     * the axis binding constant for the first y-axis\n     */\n    public static final int FIRST_YAXIS = 0;\n\n    /**\n     * the axis binding constant for the second y-axis\n     */\n    public static final int SECOND_YAXIS = 1;\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     */\n    public CoordSystem(ChartDataModel cdm) {\n        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);\n        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);\n        this.model = cdm;\n        xaxis = new Axis(Axis.HORIZONTAL, constraints);\n        yaxis = new Axis(Axis.VERTICAL, constraints);\n        c = new CoordSystemUtilities(this, constraints, constraints2, model);\n        dfY = new DecimalFormat();\n        dfX = new DecimalFormat();\n    }\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param xtext the x-axis unit\n     * @param ytext the y-axis unit\n     */\n    public CoordSystem(ChartDataModel c, String xunit, String yunit) {\n        this(c);\n        setXAxisUnit(xunit);\n        setYAxisUnit(yunit);\n    }\n\n    /**\n     * Create a new CoordSystem with alternate painting parameters.\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param drawArrows if true the arrows will be drawn at the end of the axis\n     * @param paintAltYTick if true the caption will paint on alternate ticks of the\n     * yaxis instead of on every one.\n     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>\n     * appear behind the chart at each yaxis tick mark.\n     */\n    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {\n        this(c);\n        dfY = yAxisFormat;\n        shouldDrawArrows = drawArrows;\n        shouldPaintAltTick = paintAltYTick;\n        shouldPaintOnlyTick = paintOnlyYTick;\n    }\n\n    /**\n     * Sets the coordinate transformation for any y-coordinate.\n     * @param at the AffineTransform that transforms the coordinates into pixel\n     * space\n     * @axis defines for which y-axis the transform is computed\n     */\n    public void setTransform(AffineTransform at, int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                y1transform = at;\n                break;\n            case (SECOND_YAXIS):\n                y2transform = at;\n                break;\n        }\n    }\n\n    /**\n     * Returns the currently defined AffineTransform for any y-axis.\n     * @param axis the y-axis to be used.\n     */\n    public AffineTransform getTransform(int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                return y1transform;\n            case (SECOND_YAXIS):\n                return y2transform;\n        }\n        return null;\n    }\n\n    /**\n     * This method computes the default transform which transforms the\n     * user space coordinates of this coordinate system to the pixel\n     * space coordinates used in the Graphics object.\n     * All rendering in the CoordinateSystem and the ChartRenderers\n     * will rely on this transform.\n     * @param axis defines which y-axis to use.\n     */\n    public AffineTransform getDefaultTransform(int axis) {\n        double x_pt2px = 0;\n        double y_pt2px = 0;\n        double xcoord0 = 0;\n        double ycoord0 = 0;\n        x_pt2px = 1 / getXAxis().getPointToPixelRatio();\n        //System.out.println(\"** x_pt2px = \"+getXAxis().getPointToPixelRatio());\n        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);\n        switch(axis) {\n            case FIRST_YAXIS:\n                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);\n                break;\n            case SECOND_YAXIS:\n                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);\n                break;\n        }\n        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);\n    }\n\n    /**\n     * Sets the x-axis.\n     * @param a the x-axis\n     */\n    public void setXAxis(Axis a) {\n        xaxis = a;\n    }\n\n    /**\n     * Returns the x axis.\n     * @return the x-axis\n     */\n    public Axis getXAxis() {\n        return xaxis;\n    }\n\n    /**\n     * Sets the x-axis unit string.\n     * @param xtext the unit string\n     */\n    public void setXAxisUnit(String xunit) {\n        this.xaxis_unit = xunit;\n    }\n\n    /**\n     * Gets the x-axis unit string.\n     * @return the label String\n     */\n    public String getXAxisUnit() {\n        return xaxis_unit;\n    }\n\n    /**\n     * Sets the y-axis unit string.\n     * @param ytext the unit string\n     */\n    public void setYAxisUnit(String yunit) {\n        this.yaxis_unit = yunit;\n    }\n\n    /**\n     * Gets the y-axis label.\n     * @return the label String\n     */\n    public String getYAxisUnit() {\n        return yaxis_unit;\n    }\n\n    /**\n     * Sets the font for the axis labels.\n     * @param f the Font to be used\n     */\n    public void setFont(Font f) {\n        font = f;\n    }\n\n    /**\n     * Returns the font used for the axis labels.\n     * @return the Font object\n     */\n    public Font getFont() {\n        return font;\n    }\n\n    /**\n     * Sets the left y-axis and computes the matrix transformation.\n     * @param a the left y-axis\n     */\n    public void setFirstYAxis(Axis a) {\n        yaxis = a;\n    }\n\n    /**\n     * Returns the first y-axis.\n     * @return the left y-axis\n     */\n    public Axis getFirstYAxis() {\n        return yaxis;\n    }\n\n    /**\n     * Sets the second y-axis and computes the matrix transformation.\n     * @param a the right y-axis\n     */\n    public void setSecondYAxis(Axis a) {\n        yaxis2 = a;\n    }\n\n    /**\n     * Returns the second y-axis.\n     * @return the right y-axis\n     */\n    public Axis getSecondYAxis() {\n        return yaxis2;\n    }\n\n    /**\n     * Returns the inner margin, ie the bounds minus the margins.\n     * @return a Rectangle object defining the inner bounds.\n     */\n    public Rectangle getInnerBounds() {\n        Rectangle b = getBounds();\n        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);\n        return i;\n    }\n\n    /**\n     * Computes all margins, initializes the length of the Axis and\n     * calls <code>super.setBounds</code>. Additionally, it sets the\n     * default AffineTransforms for every y-axis.\n     * @param bounds <CODE>Rectangle</CODE> object defining the bounds\n     */\n    public void setBounds(Rectangle bounds) {\n        super.setBounds(bounds);\n        setRightMargin(c.computeRightMargin());\n        setLeftMargin(c.computeLeftMargin());\n        setTopMargin(c.computeTopMargin());\n        setBottomMargin(c.computeBottomMargin());\n        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());\n        //System.out.println(\"** xaxis.length = \"+xaxis.getLength());\n        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n        //System.out.println(\"** yaxis.length = \"+yaxis.getLength());\n        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);\n        if (yaxis2 != null) {\n            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);\n        }\n    }\n\n    /**\n     * Returns the preferred size needed for the renderer.\n     * @return a Dimension with the minimum Integer values.\n     */\n    public Dimension getPreferredSize() {\n        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);\n    }\n\n    /**\n     * Overrides the method to just call <code>paintDefault</code>.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void render(Graphics2D g) {\n        paintDefault(g);\n    }\n\n    /**\n     * This method is called by the paint method to do the actual painting.\n     * The painting is supposed to start at point (0,0) and the size is\n     * always the same as the preferred size. The paint method performs\n     * the possible scaling.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void paintDefault(Graphics2D g) {\n        g.setColor(Color.black);\n        Line2D x = c.getXAxisLine2D();\n        Line2D y = c.getYAxisLine2D();\n        g.draw(x);\n        g.draw(y);\n        // draw X-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());\n            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);\n        }\n        // draw X-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);\n        // draw Y-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);\n            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);\n        }\n        // draw Y-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);\n        if (getSecondYAxis() != null) {\n            Line2D y2 = c.getSecondYAxisLine2D();\n            g.draw(y2);\n        }\n        if (model.isColumnNumeric())\n            c.drawNumericalXAxisTicks(g);\n        else\n            c.drawXAxisTicks(g);\n        c.drawYAxisTicks(g);\n    }\n\n    /**\n     * Returns a new PointToPixelTranslator for the given axis.\n     * Please notice that this method is deprecated since release 0.92.\n     * The PointToPixelTranslator interface has been replaced with\n     * AffineTransforms.\n     * @param y the y-axis identifier used to choose the right Point / Pixel ratio\n     * @return a PointToPixelTranslator object or null if the resulting\n     * Point is not within the Bounds of the Coordinate System\n     * @deprecated\n     */\n    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {\n        final Axis x = this.getXAxis();\n        final Axis y;\n        if (yaxis == CoordSystem.FIRST_YAXIS)\n            y = this.getFirstYAxis();\n        else\n            y = this.getSecondYAxis();\n        return new PointToPixelTranslator() {\n\n            public Point2D getPixelCoord(Point2D pt) {\n                double x0 = 0.0;\n                double y0 = 0.0;\n                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());\n                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());\n                Point2D p = new Point2D.Double(x0, y0);\n                if (getInnerBounds().contains(p))\n                    return p;\n                else\n                    return null;\n            }\n        };\n    }\n\n    /**\n     * Returns the left margin.\n     */\n    protected int getLeftMargin() {\n        return leftmargin;\n    }\n\n    /**\n     * Returns the right margin.\n     */\n    protected int getRightMargin() {\n        return rightmargin;\n    }\n\n    /**\n     * Returns the top margin.\n     */\n    protected int getTopMargin() {\n        return topmargin;\n    }\n\n    /**\n     * Returns the bottom margin.\n     */\n    protected int getBottomMargin() {\n        return bottommargin;\n    }\n\n    /**\n     * Sets the left margin.\n     * @param margin the new margin value\n     */\n    protected void setLeftMargin(int margin) {\n        leftmargin = margin;\n    }\n\n    /**\n     * Sets the right margin.\n     * @param margin the new margin value\n     */\n    protected void setRightMargin(int margin) {\n        rightmargin = margin;\n    }\n\n    /**\n     * Sets the top margin.\n     * @param margin the new margin value\n     */\n    protected void setTopMargin(int margin) {\n        topmargin = margin;\n    }\n\n    /**\n     * Sets the bottom margin.\n     * @param margin the new margin value\n     */\n    public void setBottomMargin(int margin) {\n        bottommargin = margin;\n    }\n\n    /**\n     * Returns the FontRenderContext used througout the CoordSystem\n     */\n    public FontRenderContext getFontRenderContext() {\n        return frc;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    public DecimalFormat getYDecimalFormat() {\n        return dfY;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    public DecimalFormat getXDecimalFormat() {\n        return dfX;\n    }\n\n    /**\n     * if true, the arrows will be drawn at the end of the axis\n     */\n    public boolean isDrawArrows() {\n        return shouldDrawArrows;\n    }\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    public boolean isPaintAltTick() {\n        return shouldPaintAltTick;\n    }\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately a\n     * light grey line will paint across the background of the chart.\n     */\n    public boolean isPaintOnlyTick() {\n        return shouldPaintOnlyTick;\n    }\n\n    public boolean isPaintLabels() {\n        return shouldPaintLabels;\n    }\n\n    public void setPaintLabels(boolean label) {\n        shouldPaintLabels = label;\n    }\n\n    /**\n     * Returns the used ChartDataModelConstraints.\n     */\n    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {\n        if (axis == FIRST_YAXIS)\n            return constraints;\n        else if (axis == SECOND_YAXIS)\n            return constraints2;\n        else\n            return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemTest2.java",
		"test_prompt": "// CoordSystemTest2.java\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystem}.\n* It contains ten unit test cases for the {@link CoordSystem#isPaintOnlyTick()} method.\n*/\nclass CoordSystemTest2 {"
	},
	{
		"original_code": "// CoordSystem.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystem.java\n    Created on 26. Juni 2001, 22:49\n */\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\n\n/**\n * This class defines a coordinate system. The CoordSystem class computes\n * an AffineTransform for each y-axis, which translates the user space\n * coordinates (ie. the data value coordinates) into pixel space coordinates.\n * These AffineTransform classes make the PixelToPointTranslator obsolete,\n * since it provides more flexibility. <code>getDefaultTransform</code> always\n * computes the default transformation, whereas you can set another\n * transformation via <code>setTransform</code>. This will be used to implement\n * zooming and panning in the Swing classes.<p>\n * All classes incl. this one, which render data will use the transformations\n * to translate the coordinates. The transformations are not set up on\n * instantiation of a CoordSystem, instead they're computed when setBounds\n * is called, because they need this information of course. Afterwards you\n * can set your own transformation or even better you can manipulate the\n * existing ones by pre- or postconcatenating another AffineTransform.\n */\npublic class CoordSystem extends AbstractRenderer {\n\n    /**\n     * The x-axis caption string.\n     */\n    protected String xaxis_unit = \"x\";\n\n    /**\n     * The y-axis caption string.\n     */\n    protected String yaxis_unit = \"y\";\n\n    /**\n     * The Font used in the CoordSystem.\n     */\n    protected Font font = new Font(\"sans\", Font.PLAIN, 9);\n\n    /**\n     * FontRenderContext used througout the CoordSystem\n     */\n    protected final FontRenderContext frc = new FontRenderContext(null, false, false);\n\n    /**\n     * DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    protected DecimalFormat dfY;\n\n    /**\n     * DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    protected DecimalFormat dfX;\n\n    /**\n     * if true, the arrows will be drawn at the end of the axi\n     */\n    protected boolean shouldDrawArrows = true;\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    protected boolean shouldPaintAltTick = true;\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately, if false, a\n     * light grey line will paint across the background of the chart.\n     */\n    protected boolean shouldPaintOnlyTick = true;\n\n    /**\n     * If true, the labels will be painted. If false, only the ticks will display.\n     */\n    protected boolean shouldPaintLabels = true;\n\n    /**\n     * The left margin\n     */\n    protected int leftmargin = 50;\n\n    /**\n     * The top margin.\n     */\n    protected int topmargin = 20;\n\n    /**\n     * The right margin.\n     */\n    protected int rightmargin = 30;\n\n    /**\n     * The bottom margin.\n     */\n    protected int bottommargin = 30;\n\n    /**\n     * The minimal margin constant.\n     */\n    public final int MINIMALMARGIN = 20;\n\n    /**\n     * The arrow length constant.\n     */\n    public final int ARROWLENGTH = 15;\n\n    /**\n     * The ChartDataModel constraints of the first y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints;\n\n    /**\n     * The ChartDataModel constraints of the second y-axis and the x-axis.\n     */\n    protected ChartDataModelConstraints constraints2;\n\n    /**\n     * The DataModel class.\n     */\n    protected ChartDataModel model;\n\n    /**\n     * The utilities class, which contains all the rendering methods etc.\n     */\n    protected CoordSystemUtilities c;\n\n    /**\n     * The xaxis.\n     */\n    protected Axis xaxis;\n\n    /**\n     * The first y-axis.\n     */\n    protected Axis yaxis;\n\n    /**\n     * The second y-axis.\n     */\n    protected Axis yaxis2;\n\n    /**\n     * The multiplication matrix for the first y-axis and the x-axis.\n     */\n    protected AffineTransform y1transform;\n\n    /**\n     * The multiplication matrix for the second y-axis and the x-axis.\n     */\n    protected AffineTransform y2transform;\n\n    /**\n     * the axis binding constant for the first y-axis\n     */\n    public static final int FIRST_YAXIS = 0;\n\n    /**\n     * the axis binding constant for the second y-axis\n     */\n    public static final int SECOND_YAXIS = 1;\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     */\n    public CoordSystem(ChartDataModel cdm) {\n        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);\n        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);\n        this.model = cdm;\n        xaxis = new Axis(Axis.HORIZONTAL, constraints);\n        yaxis = new Axis(Axis.VERTICAL, constraints);\n        c = new CoordSystemUtilities(this, constraints, constraints2, model);\n        dfY = new DecimalFormat();\n        dfX = new DecimalFormat();\n    }\n\n    /**\n     * Creates a new CoordSystem using the given model constraints.\n     * Also creates default linear x and y-axis. Note that the length\n     * of the axis are set on the first call to\n     * setBounds().\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param xtext the x-axis unit\n     * @param ytext the y-axis unit\n     */\n    public CoordSystem(ChartDataModel c, String xunit, String yunit) {\n        this(c);\n        setXAxisUnit(xunit);\n        setYAxisUnit(yunit);\n    }\n\n    /**\n     * Create a new CoordSystem with alternate painting parameters.\n     * @param c the ChartDataModel needed to compute the DataConstraints.\n     * @param drawArrows if true the arrows will be drawn at the end of the axis\n     * @param paintAltYTick if true the caption will paint on alternate ticks of the\n     * yaxis instead of on every one.\n     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>\n     * appear behind the chart at each yaxis tick mark.\n     */\n    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {\n        this(c);\n        dfY = yAxisFormat;\n        shouldDrawArrows = drawArrows;\n        shouldPaintAltTick = paintAltYTick;\n        shouldPaintOnlyTick = paintOnlyYTick;\n    }\n\n    /**\n     * Sets the coordinate transformation for any y-coordinate.\n     * @param at the AffineTransform that transforms the coordinates into pixel\n     * space\n     * @axis defines for which y-axis the transform is computed\n     */\n    public void setTransform(AffineTransform at, int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                y1transform = at;\n                break;\n            case (SECOND_YAXIS):\n                y2transform = at;\n                break;\n        }\n    }\n\n    /**\n     * Returns the currently defined AffineTransform for any y-axis.\n     * @param axis the y-axis to be used.\n     */\n    public AffineTransform getTransform(int axis) {\n        switch(axis) {\n            case (FIRST_YAXIS):\n                return y1transform;\n            case (SECOND_YAXIS):\n                return y2transform;\n        }\n        return null;\n    }\n\n    /**\n     * This method computes the default transform which transforms the\n     * user space coordinates of this coordinate system to the pixel\n     * space coordinates used in the Graphics object.\n     * All rendering in the CoordinateSystem and the ChartRenderers\n     * will rely on this transform.\n     * @param axis defines which y-axis to use.\n     */\n    public AffineTransform getDefaultTransform(int axis) {\n        double x_pt2px = 0;\n        double y_pt2px = 0;\n        double xcoord0 = 0;\n        double ycoord0 = 0;\n        x_pt2px = 1 / getXAxis().getPointToPixelRatio();\n        //System.out.println(\"** x_pt2px = \"+getXAxis().getPointToPixelRatio());\n        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);\n        switch(axis) {\n            case FIRST_YAXIS:\n                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);\n                break;\n            case SECOND_YAXIS:\n                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();\n                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);\n                break;\n        }\n        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);\n    }\n\n    /**\n     * Sets the x-axis.\n     * @param a the x-axis\n     */\n    public void setXAxis(Axis a) {\n        xaxis = a;\n    }\n\n    /**\n     * Returns the x axis.\n     * @return the x-axis\n     */\n    public Axis getXAxis() {\n        return xaxis;\n    }\n\n    /**\n     * Sets the x-axis unit string.\n     * @param xtext the unit string\n     */\n    public void setXAxisUnit(String xunit) {\n        this.xaxis_unit = xunit;\n    }\n\n    /**\n     * Gets the x-axis unit string.\n     * @return the label String\n     */\n    public String getXAxisUnit() {\n        return xaxis_unit;\n    }\n\n    /**\n     * Sets the y-axis unit string.\n     * @param ytext the unit string\n     */\n    public void setYAxisUnit(String yunit) {\n        this.yaxis_unit = yunit;\n    }\n\n    /**\n     * Gets the y-axis label.\n     * @return the label String\n     */\n    public String getYAxisUnit() {\n        return yaxis_unit;\n    }\n\n    /**\n     * Sets the font for the axis labels.\n     * @param f the Font to be used\n     */\n    public void setFont(Font f) {\n        font = f;\n    }\n\n    /**\n     * Returns the font used for the axis labels.\n     * @return the Font object\n     */\n    public Font getFont() {\n        return font;\n    }\n\n    /**\n     * Sets the left y-axis and computes the matrix transformation.\n     * @param a the left y-axis\n     */\n    public void setFirstYAxis(Axis a) {\n        yaxis = a;\n    }\n\n    /**\n     * Returns the first y-axis.\n     * @return the left y-axis\n     */\n    public Axis getFirstYAxis() {\n        return yaxis;\n    }\n\n    /**\n     * Sets the second y-axis and computes the matrix transformation.\n     * @param a the right y-axis\n     */\n    public void setSecondYAxis(Axis a) {\n        yaxis2 = a;\n    }\n\n    /**\n     * Returns the second y-axis.\n     * @return the right y-axis\n     */\n    public Axis getSecondYAxis() {\n        return yaxis2;\n    }\n\n    /**\n     * Returns the inner margin, ie the bounds minus the margins.\n     * @return a Rectangle object defining the inner bounds.\n     */\n    public Rectangle getInnerBounds() {\n        Rectangle b = getBounds();\n        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);\n        return i;\n    }\n\n    /**\n     * Computes all margins, initializes the length of the Axis and\n     * calls <code>super.setBounds</code>. Additionally, it sets the\n     * default AffineTransforms for every y-axis.\n     * @param bounds <CODE>Rectangle</CODE> object defining the bounds\n     */\n    public void setBounds(Rectangle bounds) {\n        super.setBounds(bounds);\n        setRightMargin(c.computeRightMargin());\n        setLeftMargin(c.computeLeftMargin());\n        setTopMargin(c.computeTopMargin());\n        setBottomMargin(c.computeBottomMargin());\n        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());\n        //System.out.println(\"** xaxis.length = \"+xaxis.getLength());\n        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n        //System.out.println(\"** yaxis.length = \"+yaxis.getLength());\n        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);\n        if (yaxis2 != null) {\n            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());\n            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);\n        }\n    }\n\n    /**\n     * Returns the preferred size needed for the renderer.\n     * @return a Dimension with the minimum Integer values.\n     */\n    public Dimension getPreferredSize() {\n        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);\n    }\n\n    /**\n     * Overrides the method to just call <code>paintDefault</code>.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void render(Graphics2D g) {\n        paintDefault(g);\n    }\n\n    /**\n     * This method is called by the paint method to do the actual painting.\n     * The painting is supposed to start at point (0,0) and the size is\n     * always the same as the preferred size. The paint method performs\n     * the possible scaling.\n     * @param g the <CODE>Graphics2D</CODE> object to paint in\n     */\n    public void paintDefault(Graphics2D g) {\n        g.setColor(Color.black);\n        Line2D x = c.getXAxisLine2D();\n        Line2D y = c.getYAxisLine2D();\n        g.draw(x);\n        g.draw(y);\n        // draw X-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());\n            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);\n        }\n        // draw X-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);\n        // draw Y-Axis Arrow\n        if (shouldDrawArrows) {\n            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);\n            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);\n        }\n        // draw Y-Axis label right below the Arrow ?!\n        g.setColor(Color.black);\n        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));\n        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);\n        if (getSecondYAxis() != null) {\n            Line2D y2 = c.getSecondYAxisLine2D();\n            g.draw(y2);\n        }\n        if (model.isColumnNumeric())\n            c.drawNumericalXAxisTicks(g);\n        else\n            c.drawXAxisTicks(g);\n        c.drawYAxisTicks(g);\n    }\n\n    /**\n     * Returns a new PointToPixelTranslator for the given axis.\n     * Please notice that this method is deprecated since release 0.92.\n     * The PointToPixelTranslator interface has been replaced with\n     * AffineTransforms.\n     * @param y the y-axis identifier used to choose the right Point / Pixel ratio\n     * @return a PointToPixelTranslator object or null if the resulting\n     * Point is not within the Bounds of the Coordinate System\n     * @deprecated\n     */\n    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {\n        final Axis x = this.getXAxis();\n        final Axis y;\n        if (yaxis == CoordSystem.FIRST_YAXIS)\n            y = this.getFirstYAxis();\n        else\n            y = this.getSecondYAxis();\n        return new PointToPixelTranslator() {\n\n            public Point2D getPixelCoord(Point2D pt) {\n                double x0 = 0.0;\n                double y0 = 0.0;\n                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());\n                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());\n                Point2D p = new Point2D.Double(x0, y0);\n                if (getInnerBounds().contains(p))\n                    return p;\n                else\n                    return null;\n            }\n        };\n    }\n\n    /**\n     * Returns the left margin.\n     */\n    protected int getLeftMargin() {\n        return leftmargin;\n    }\n\n    /**\n     * Returns the right margin.\n     */\n    protected int getRightMargin() {\n        return rightmargin;\n    }\n\n    /**\n     * Returns the top margin.\n     */\n    protected int getTopMargin() {\n        return topmargin;\n    }\n\n    /**\n     * Returns the bottom margin.\n     */\n    protected int getBottomMargin() {\n        return bottommargin;\n    }\n\n    /**\n     * Sets the left margin.\n     * @param margin the new margin value\n     */\n    protected void setLeftMargin(int margin) {\n        leftmargin = margin;\n    }\n\n    /**\n     * Sets the right margin.\n     * @param margin the new margin value\n     */\n    protected void setRightMargin(int margin) {\n        rightmargin = margin;\n    }\n\n    /**\n     * Sets the top margin.\n     * @param margin the new margin value\n     */\n    protected void setTopMargin(int margin) {\n        topmargin = margin;\n    }\n\n    /**\n     * Sets the bottom margin.\n     * @param margin the new margin value\n     */\n    public void setBottomMargin(int margin) {\n        bottommargin = margin;\n    }\n\n    /**\n     * Returns the FontRenderContext used througout the CoordSystem\n     */\n    public FontRenderContext getFontRenderContext() {\n        return frc;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem\n     */\n    public DecimalFormat getYDecimalFormat() {\n        return dfY;\n    }\n\n    /**\n     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem\n     */\n    public DecimalFormat getXDecimalFormat() {\n        return dfX;\n    }\n\n    /**\n     * if true, the arrows will be drawn at the end of the axis\n     */\n    public boolean isDrawArrows() {\n        return shouldDrawArrows;\n    }\n\n    /**\n     * if true, the increment will be painted at each tick mark\n     */\n    public boolean isPaintAltTick() {\n        return shouldPaintAltTick;\n    }\n\n    /**\n     * if true only the tick will be painted on the yaxis.  Alternately a\n     * light grey line will paint across the background of the chart.\n     */\n    public boolean isPaintOnlyTick() {\n        return shouldPaintOnlyTick;\n    }\n\n    public boolean isPaintLabels() {\n        return shouldPaintLabels;\n    }\n\n    public void setPaintLabels(boolean label) {\n        shouldPaintLabels = label;\n    }\n\n    /**\n     * Returns the used ChartDataModelConstraints.\n     */\n    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {\n        if (axis == FIRST_YAXIS)\n            return constraints;\n        else if (axis == SECOND_YAXIS)\n            return constraints2;\n        else\n            return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemTest3.java",
		"test_prompt": "// CoordSystemTest3.java\npackage de.progra.charting;\n\nimport de.progra.charting.render.AbstractRenderer;\nimport de.progra.charting.render.ChartRenderingHints;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.TextLayout;\nimport java.text.DecimalFormat;\nimport de.progra.charting.model.ChartDataModel;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystem}.\n* It contains ten unit test cases for the {@link CoordSystem#isPaintLabels()} method.\n*/\nclass CoordSystemTest3 {"
	},
	{
		"original_code": "// CoordSystemUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystemUtilities.java \n    Created on 4. April 2002, 22:28\n */\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\n\n/**\n * This class provides some utility functions for a CoordSystem. They were\n * externalized to make the CoordSystem class clearer.\n * @author  mueller\n * @version 1.0\n */\npublic class CoordSystemUtilities {\n\n    /**\n     * used for the offset on the y axis for the size of a \"tick\"\n     */\n    protected final int marginOffset = 6;\n\n    protected CoordSystem c;\n\n    protected ChartDataModelConstraints constraints;\n\n    protected ChartDataModelConstraints constraints2;\n\n    protected ChartDataModel model;\n\n    /**\n     * Creates a new instance of CoordSystemUtilities\n     */\n    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {\n        c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n\n    /**\n     * Computes the left margin.\n     */\n    public int computeLeftMargin() {\n        double xmin = constraints.getMinimumColumnValue();\n        double xmax = constraints.getMaximumColumnValue();\n        if (xmin <= 0 && xmax > 0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // yaxis label width\n            // + yaxis title width\n            int maxlmargin = computeYAxisLabelWidth() + marginOffset;\n            // unit width\n            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);\n            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));\n            // just for good looking\n            margin += 5;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the right margin.\n     */\n    public int computeRightMargin() {\n        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the top margin.\n     */\n    public int computeTopMargin() {\n        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the bottom margin.\n     */\n    public int computeBottomMargin() {\n        double ymin = constraints.getMinimumValue().doubleValue();\n        double ymax = constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0 && ymax > 0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // xaxis label height\n            // + xaxis title height\n            int maxbmargin = computeXAxisLabelHeight() + marginOffset;\n            // unit height\n            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);\n            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));\n            // just for good looking\n            margin += 10;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the maximum height of all x-axis labels.\n     */\n    public int computeXAxisLabelHeight() {\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        int height = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        boolean paint = false;\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int) r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n\n    /**\n     * Computes the maximum width of all y-axis labels.\n     */\n    public int computeYAxisLabelWidth() {\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        int width = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int) r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for numerical x-axis values.\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawNumericalXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for non-numerical x-axis values..\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        int min = (int) constraints.getMinimumColumnValue();\n        int max = (int) constraints.getMaximumColumnValue();\n        double tick = 1.0;\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        boolean paintLabels = c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; i++) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            if (i + 1 < max)\n                g.draw(ticks);\n            // Draw Strings between ticks\n            if (oldv != null && paintLabels) {\n                String sb = (String) model.getColumnValueAt(i);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            oldv = v;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * y-axis.\n     * @param g the Graphics2D context in which to draw\n     */\n    public void drawYAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        Color backupColor = g.getColor();\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());\n            g.draw(ticks);\n            if (d != min && !c.isPaintOnlyTick()) {\n                Line2D xax = getXAxisLine2D();\n                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !c.isPaintAltTick())) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * Computes the Line2D object of the x-axis using the DataConstraints.\n     */\n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        // shift the x-axis according to the max and min y-values\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);\n        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n\n    /**\n     * Computes the Line2D object of the y-axis using the DataConstraints.\n     */\n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);\n        //System.out.println(\"** Y-Axis (\"+o+\", \"+u+\")\");\n        return new Line2D.Double(o, u);\n    }\n\n    /**\n     * Computes the Line2D object of the second y-axis using the DataConstraints.\n     */\n    public Line2D getSecondYAxisLine2D() {\n        double xpt = constraints2.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilitiesTest0.java",
		"test_prompt": "// CoordSystemUtilitiesTest0.java\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystemUtilities}.\n* It contains ten unit test cases for the {@link CoordSystemUtilities#computeLeftMargin()} method.\n*/\nclass CoordSystemUtilitiesTest0 {"
	},
	{
		"original_code": "// CoordSystemUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystemUtilities.java \n    Created on 4. April 2002, 22:28\n */\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\n\n/**\n * This class provides some utility functions for a CoordSystem. They were\n * externalized to make the CoordSystem class clearer.\n * @author  mueller\n * @version 1.0\n */\npublic class CoordSystemUtilities {\n\n    /**\n     * used for the offset on the y axis for the size of a \"tick\"\n     */\n    protected final int marginOffset = 6;\n\n    protected CoordSystem c;\n\n    protected ChartDataModelConstraints constraints;\n\n    protected ChartDataModelConstraints constraints2;\n\n    protected ChartDataModel model;\n\n    /**\n     * Creates a new instance of CoordSystemUtilities\n     */\n    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {\n        c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n\n    /**\n     * Computes the left margin.\n     */\n    public int computeLeftMargin() {\n        double xmin = constraints.getMinimumColumnValue();\n        double xmax = constraints.getMaximumColumnValue();\n        if (xmin <= 0 && xmax > 0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // yaxis label width\n            // + yaxis title width\n            int maxlmargin = computeYAxisLabelWidth() + marginOffset;\n            // unit width\n            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);\n            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));\n            // just for good looking\n            margin += 5;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the right margin.\n     */\n    public int computeRightMargin() {\n        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the top margin.\n     */\n    public int computeTopMargin() {\n        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the bottom margin.\n     */\n    public int computeBottomMargin() {\n        double ymin = constraints.getMinimumValue().doubleValue();\n        double ymax = constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0 && ymax > 0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // xaxis label height\n            // + xaxis title height\n            int maxbmargin = computeXAxisLabelHeight() + marginOffset;\n            // unit height\n            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);\n            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));\n            // just for good looking\n            margin += 10;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the maximum height of all x-axis labels.\n     */\n    public int computeXAxisLabelHeight() {\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        int height = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        boolean paint = false;\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int) r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n\n    /**\n     * Computes the maximum width of all y-axis labels.\n     */\n    public int computeYAxisLabelWidth() {\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        int width = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int) r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for numerical x-axis values.\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawNumericalXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for non-numerical x-axis values..\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        int min = (int) constraints.getMinimumColumnValue();\n        int max = (int) constraints.getMaximumColumnValue();\n        double tick = 1.0;\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        boolean paintLabels = c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; i++) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            if (i + 1 < max)\n                g.draw(ticks);\n            // Draw Strings between ticks\n            if (oldv != null && paintLabels) {\n                String sb = (String) model.getColumnValueAt(i);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            oldv = v;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * y-axis.\n     * @param g the Graphics2D context in which to draw\n     */\n    public void drawYAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        Color backupColor = g.getColor();\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());\n            g.draw(ticks);\n            if (d != min && !c.isPaintOnlyTick()) {\n                Line2D xax = getXAxisLine2D();\n                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !c.isPaintAltTick())) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * Computes the Line2D object of the x-axis using the DataConstraints.\n     */\n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        // shift the x-axis according to the max and min y-values\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);\n        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n\n    /**\n     * Computes the Line2D object of the y-axis using the DataConstraints.\n     */\n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);\n        //System.out.println(\"** Y-Axis (\"+o+\", \"+u+\")\");\n        return new Line2D.Double(o, u);\n    }\n\n    /**\n     * Computes the Line2D object of the second y-axis using the DataConstraints.\n     */\n    public Line2D getSecondYAxisLine2D() {\n        double xpt = constraints2.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilitiesTest1.java",
		"test_prompt": "// CoordSystemUtilitiesTest1.java\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystemUtilities}.\n* It contains ten unit test cases for the {@link CoordSystemUtilities#computeRightMargin()} method.\n*/\nclass CoordSystemUtilitiesTest1 {"
	},
	{
		"original_code": "// CoordSystemUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystemUtilities.java \n    Created on 4. April 2002, 22:28\n */\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\n\n/**\n * This class provides some utility functions for a CoordSystem. They were\n * externalized to make the CoordSystem class clearer.\n * @author  mueller\n * @version 1.0\n */\npublic class CoordSystemUtilities {\n\n    /**\n     * used for the offset on the y axis for the size of a \"tick\"\n     */\n    protected final int marginOffset = 6;\n\n    protected CoordSystem c;\n\n    protected ChartDataModelConstraints constraints;\n\n    protected ChartDataModelConstraints constraints2;\n\n    protected ChartDataModel model;\n\n    /**\n     * Creates a new instance of CoordSystemUtilities\n     */\n    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {\n        c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n\n    /**\n     * Computes the left margin.\n     */\n    public int computeLeftMargin() {\n        double xmin = constraints.getMinimumColumnValue();\n        double xmax = constraints.getMaximumColumnValue();\n        if (xmin <= 0 && xmax > 0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // yaxis label width\n            // + yaxis title width\n            int maxlmargin = computeYAxisLabelWidth() + marginOffset;\n            // unit width\n            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);\n            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));\n            // just for good looking\n            margin += 5;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the right margin.\n     */\n    public int computeRightMargin() {\n        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the top margin.\n     */\n    public int computeTopMargin() {\n        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the bottom margin.\n     */\n    public int computeBottomMargin() {\n        double ymin = constraints.getMinimumValue().doubleValue();\n        double ymax = constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0 && ymax > 0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // xaxis label height\n            // + xaxis title height\n            int maxbmargin = computeXAxisLabelHeight() + marginOffset;\n            // unit height\n            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);\n            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));\n            // just for good looking\n            margin += 10;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the maximum height of all x-axis labels.\n     */\n    public int computeXAxisLabelHeight() {\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        int height = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        boolean paint = false;\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int) r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n\n    /**\n     * Computes the maximum width of all y-axis labels.\n     */\n    public int computeYAxisLabelWidth() {\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        int width = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int) r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for numerical x-axis values.\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawNumericalXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for non-numerical x-axis values..\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        int min = (int) constraints.getMinimumColumnValue();\n        int max = (int) constraints.getMaximumColumnValue();\n        double tick = 1.0;\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        boolean paintLabels = c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; i++) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            if (i + 1 < max)\n                g.draw(ticks);\n            // Draw Strings between ticks\n            if (oldv != null && paintLabels) {\n                String sb = (String) model.getColumnValueAt(i);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            oldv = v;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * y-axis.\n     * @param g the Graphics2D context in which to draw\n     */\n    public void drawYAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        Color backupColor = g.getColor();\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());\n            g.draw(ticks);\n            if (d != min && !c.isPaintOnlyTick()) {\n                Line2D xax = getXAxisLine2D();\n                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !c.isPaintAltTick())) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * Computes the Line2D object of the x-axis using the DataConstraints.\n     */\n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        // shift the x-axis according to the max and min y-values\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);\n        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n\n    /**\n     * Computes the Line2D object of the y-axis using the DataConstraints.\n     */\n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);\n        //System.out.println(\"** Y-Axis (\"+o+\", \"+u+\")\");\n        return new Line2D.Double(o, u);\n    }\n\n    /**\n     * Computes the Line2D object of the second y-axis using the DataConstraints.\n     */\n    public Line2D getSecondYAxisLine2D() {\n        double xpt = constraints2.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilitiesTest2.java",
		"test_prompt": "// CoordSystemUtilitiesTest2.java\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystemUtilities}.\n* It contains ten unit test cases for the {@link CoordSystemUtilities#computeTopMargin()} method.\n*/\nclass CoordSystemUtilitiesTest2 {"
	},
	{
		"original_code": "// CoordSystemUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystemUtilities.java \n    Created on 4. April 2002, 22:28\n */\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\n\n/**\n * This class provides some utility functions for a CoordSystem. They were\n * externalized to make the CoordSystem class clearer.\n * @author  mueller\n * @version 1.0\n */\npublic class CoordSystemUtilities {\n\n    /**\n     * used for the offset on the y axis for the size of a \"tick\"\n     */\n    protected final int marginOffset = 6;\n\n    protected CoordSystem c;\n\n    protected ChartDataModelConstraints constraints;\n\n    protected ChartDataModelConstraints constraints2;\n\n    protected ChartDataModel model;\n\n    /**\n     * Creates a new instance of CoordSystemUtilities\n     */\n    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {\n        c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n\n    /**\n     * Computes the left margin.\n     */\n    public int computeLeftMargin() {\n        double xmin = constraints.getMinimumColumnValue();\n        double xmax = constraints.getMaximumColumnValue();\n        if (xmin <= 0 && xmax > 0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // yaxis label width\n            // + yaxis title width\n            int maxlmargin = computeYAxisLabelWidth() + marginOffset;\n            // unit width\n            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);\n            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));\n            // just for good looking\n            margin += 5;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the right margin.\n     */\n    public int computeRightMargin() {\n        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the top margin.\n     */\n    public int computeTopMargin() {\n        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the bottom margin.\n     */\n    public int computeBottomMargin() {\n        double ymin = constraints.getMinimumValue().doubleValue();\n        double ymax = constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0 && ymax > 0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // xaxis label height\n            // + xaxis title height\n            int maxbmargin = computeXAxisLabelHeight() + marginOffset;\n            // unit height\n            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);\n            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));\n            // just for good looking\n            margin += 10;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the maximum height of all x-axis labels.\n     */\n    public int computeXAxisLabelHeight() {\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        int height = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        boolean paint = false;\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int) r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n\n    /**\n     * Computes the maximum width of all y-axis labels.\n     */\n    public int computeYAxisLabelWidth() {\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        int width = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int) r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for numerical x-axis values.\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawNumericalXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for non-numerical x-axis values..\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        int min = (int) constraints.getMinimumColumnValue();\n        int max = (int) constraints.getMaximumColumnValue();\n        double tick = 1.0;\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        boolean paintLabels = c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; i++) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            if (i + 1 < max)\n                g.draw(ticks);\n            // Draw Strings between ticks\n            if (oldv != null && paintLabels) {\n                String sb = (String) model.getColumnValueAt(i);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            oldv = v;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * y-axis.\n     * @param g the Graphics2D context in which to draw\n     */\n    public void drawYAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        Color backupColor = g.getColor();\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());\n            g.draw(ticks);\n            if (d != min && !c.isPaintOnlyTick()) {\n                Line2D xax = getXAxisLine2D();\n                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !c.isPaintAltTick())) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * Computes the Line2D object of the x-axis using the DataConstraints.\n     */\n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        // shift the x-axis according to the max and min y-values\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);\n        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n\n    /**\n     * Computes the Line2D object of the y-axis using the DataConstraints.\n     */\n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);\n        //System.out.println(\"** Y-Axis (\"+o+\", \"+u+\")\");\n        return new Line2D.Double(o, u);\n    }\n\n    /**\n     * Computes the Line2D object of the second y-axis using the DataConstraints.\n     */\n    public Line2D getSecondYAxisLine2D() {\n        double xpt = constraints2.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilitiesTest3.java",
		"test_prompt": "// CoordSystemUtilitiesTest3.java\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystemUtilities}.\n* It contains ten unit test cases for the {@link CoordSystemUtilities#computeBottomMargin()} method.\n*/\nclass CoordSystemUtilitiesTest3 {"
	},
	{
		"original_code": "// CoordSystemUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystemUtilities.java \n    Created on 4. April 2002, 22:28\n */\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\n\n/**\n * This class provides some utility functions for a CoordSystem. They were\n * externalized to make the CoordSystem class clearer.\n * @author  mueller\n * @version 1.0\n */\npublic class CoordSystemUtilities {\n\n    /**\n     * used for the offset on the y axis for the size of a \"tick\"\n     */\n    protected final int marginOffset = 6;\n\n    protected CoordSystem c;\n\n    protected ChartDataModelConstraints constraints;\n\n    protected ChartDataModelConstraints constraints2;\n\n    protected ChartDataModel model;\n\n    /**\n     * Creates a new instance of CoordSystemUtilities\n     */\n    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {\n        c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n\n    /**\n     * Computes the left margin.\n     */\n    public int computeLeftMargin() {\n        double xmin = constraints.getMinimumColumnValue();\n        double xmax = constraints.getMaximumColumnValue();\n        if (xmin <= 0 && xmax > 0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // yaxis label width\n            // + yaxis title width\n            int maxlmargin = computeYAxisLabelWidth() + marginOffset;\n            // unit width\n            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);\n            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));\n            // just for good looking\n            margin += 5;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the right margin.\n     */\n    public int computeRightMargin() {\n        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the top margin.\n     */\n    public int computeTopMargin() {\n        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the bottom margin.\n     */\n    public int computeBottomMargin() {\n        double ymin = constraints.getMinimumValue().doubleValue();\n        double ymax = constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0 && ymax > 0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // xaxis label height\n            // + xaxis title height\n            int maxbmargin = computeXAxisLabelHeight() + marginOffset;\n            // unit height\n            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);\n            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));\n            // just for good looking\n            margin += 10;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the maximum height of all x-axis labels.\n     */\n    public int computeXAxisLabelHeight() {\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        int height = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        boolean paint = false;\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int) r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n\n    /**\n     * Computes the maximum width of all y-axis labels.\n     */\n    public int computeYAxisLabelWidth() {\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        int width = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int) r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for numerical x-axis values.\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawNumericalXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for non-numerical x-axis values..\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        int min = (int) constraints.getMinimumColumnValue();\n        int max = (int) constraints.getMaximumColumnValue();\n        double tick = 1.0;\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        boolean paintLabels = c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; i++) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            if (i + 1 < max)\n                g.draw(ticks);\n            // Draw Strings between ticks\n            if (oldv != null && paintLabels) {\n                String sb = (String) model.getColumnValueAt(i);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            oldv = v;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * y-axis.\n     * @param g the Graphics2D context in which to draw\n     */\n    public void drawYAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        Color backupColor = g.getColor();\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());\n            g.draw(ticks);\n            if (d != min && !c.isPaintOnlyTick()) {\n                Line2D xax = getXAxisLine2D();\n                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !c.isPaintAltTick())) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * Computes the Line2D object of the x-axis using the DataConstraints.\n     */\n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        // shift the x-axis according to the max and min y-values\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);\n        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n\n    /**\n     * Computes the Line2D object of the y-axis using the DataConstraints.\n     */\n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);\n        //System.out.println(\"** Y-Axis (\"+o+\", \"+u+\")\");\n        return new Line2D.Double(o, u);\n    }\n\n    /**\n     * Computes the Line2D object of the second y-axis using the DataConstraints.\n     */\n    public Line2D getSecondYAxisLine2D() {\n        double xpt = constraints2.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilitiesTest4.java",
		"test_prompt": "// CoordSystemUtilitiesTest4.java\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystemUtilities}.\n* It contains ten unit test cases for the {@link CoordSystemUtilities#computeXAxisLabelHeight()} method.\n*/\nclass CoordSystemUtilitiesTest4 {"
	},
	{
		"original_code": "// CoordSystemUtilities.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    CoordSystemUtilities.java \n    Created on 4. April 2002, 22:28\n */\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\n\n/**\n * This class provides some utility functions for a CoordSystem. They were\n * externalized to make the CoordSystem class clearer.\n * @author  mueller\n * @version 1.0\n */\npublic class CoordSystemUtilities {\n\n    /**\n     * used for the offset on the y axis for the size of a \"tick\"\n     */\n    protected final int marginOffset = 6;\n\n    protected CoordSystem c;\n\n    protected ChartDataModelConstraints constraints;\n\n    protected ChartDataModelConstraints constraints2;\n\n    protected ChartDataModel model;\n\n    /**\n     * Creates a new instance of CoordSystemUtilities\n     */\n    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {\n        c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n\n    /**\n     * Computes the left margin.\n     */\n    public int computeLeftMargin() {\n        double xmin = constraints.getMinimumColumnValue();\n        double xmax = constraints.getMaximumColumnValue();\n        if (xmin <= 0 && xmax > 0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // yaxis label width\n            // + yaxis title width\n            int maxlmargin = computeYAxisLabelWidth() + marginOffset;\n            // unit width\n            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);\n            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));\n            // just for good looking\n            margin += 5;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the right margin.\n     */\n    public int computeRightMargin() {\n        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the top margin.\n     */\n    public int computeTopMargin() {\n        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());\n        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);\n    }\n\n    /**\n     * Computes the bottom margin.\n     */\n    public int computeBottomMargin() {\n        double ymin = constraints.getMinimumValue().doubleValue();\n        double ymax = constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0 && ymax > 0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());\n            // xaxis label height\n            // + xaxis title height\n            int maxbmargin = computeXAxisLabelHeight() + marginOffset;\n            // unit height\n            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);\n            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));\n            // just for good looking\n            margin += 10;\n            if (margin < c.MINIMALMARGIN)\n                margin = c.MINIMALMARGIN;\n            return margin;\n        } else {\n            return c.MINIMALMARGIN;\n        }\n    }\n\n    /**\n     * Computes the maximum height of all x-axis labels.\n     */\n    public int computeXAxisLabelHeight() {\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        int height = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        boolean paint = false;\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int) r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n\n    /**\n     * Computes the maximum width of all y-axis labels.\n     */\n    public int computeYAxisLabelWidth() {\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        int width = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int) r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for numerical x-axis values.\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawNumericalXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumColumnValue();\n        double max = constraints.getMaximumColumnValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * x-axis for non-numerical x-axis values..\n     * @param g the Graphics2D context to paint in\n     */\n    public void drawXAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        int min = (int) constraints.getMinimumColumnValue();\n        int max = (int) constraints.getMaximumColumnValue();\n        double tick = 1.0;\n        double ypt = 0;\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        DecimalFormat df = c.getXDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        boolean paint = false;\n        boolean paintLabels = c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; i++) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);\n            if (i + 1 < max)\n                g.draw(ticks);\n            // Draw Strings between ticks\n            if (oldv != null && paintLabels) {\n                String sb = (String) model.getColumnValueAt(i);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));\n            }\n            oldv = v;\n        }\n    }\n\n    /**\n     * This method is called by paintDefault to paint the ticks on the\n     * y-axis.\n     * @param g the Graphics2D context in which to draw\n     */\n    public void drawYAxisTicks(Graphics2D g) {\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        double min = constraints.getMinimumValue().doubleValue();\n        double max = constraints.getMaximumValue().doubleValue();\n        double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v;\n        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        DecimalFormat df = c.getYDecimalFormat();\n        FontRenderContext frc = c.getFontRenderContext();\n        Font f = c.getFont();\n        Color backupColor = g.getColor();\n        g.setFont(f);\n        boolean paintLabels = c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());\n            g.draw(ticks);\n            if (d != min && !c.isPaintOnlyTick()) {\n                Line2D xax = getXAxisLine2D();\n                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !c.isPaintAltTick())) {\n                String sb = df.format(d);\n                Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));\n            }\n            paint = !paint;\n        }\n    }\n\n    /**\n     * Computes the Line2D object of the x-axis using the DataConstraints.\n     */\n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        // shift the x-axis according to the max and min y-values\n        if (constraints.getMinimumValue().doubleValue() > 0)\n            ypt = constraints.getMinimumValue().doubleValue();\n        else if (constraints.getMaximumValue().doubleValue() < 0)\n            ypt = constraints.getMaximumValue().doubleValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);\n        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n\n    /**\n     * Computes the Line2D object of the y-axis using the DataConstraints.\n     */\n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        // shift the y-axis according to the max and min x-values\n        if (constraints.getMinimumColumnValue() > 0)\n            xpt = constraints.getMinimumColumnValue();\n        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)\n            xpt = constraints.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);\n        //System.out.println(\"** Y-Axis (\"+o+\", \"+u+\")\");\n        return new Line2D.Double(o, u);\n    }\n\n    /**\n     * Computes the Line2D object of the second y-axis using the DataConstraints.\n     */\n    public Line2D getSecondYAxisLine2D() {\n        double xpt = constraints2.getMaximumColumnValue();\n        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);\n        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);\n        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilitiesTest5.java",
		"test_prompt": "// CoordSystemUtilitiesTest5.java\npackage de.progra.charting;\n\nimport java.awt.font.FontRenderContext;\nimport java.text.DecimalFormat;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.font.TextLayout;\nimport de.progra.charting.model.ChartDataModelConstraints;\nimport de.progra.charting.model.ChartDataModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoordSystemUtilities}.\n* It contains ten unit test cases for the {@link CoordSystemUtilities#computeYAxisLabelWidth()} method.\n*/\nclass CoordSystemUtilitiesTest5 {"
	},
	{
		"original_code": "// JDBCPlotter.java\n/*\r\n JOpenChart Java Charting Library and Toolkit\r\n Copyright (C) 2001  Sebastian M�ller\r\n http://jopenchart.sourceforge.net\r\n\r\n This library is free software; you can redistribute it and/or\r\n modify it under the terms of the GNU Lesser General Public\r\n License as published by the Free Software Foundation; either\r\n version 2.1 of the License, or (at your option) any later version.\r\n\r\n This library is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public\r\n License along with this library; if not, write to the Free Software\r\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\n JDBCPlotter.java\r\n Created on 9. October 2002\r\n Based on SQLPlotter.java, created on 29. December 2001\r\n \r\n */\r\npackage de.progra.charting.model;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The class is used to convert database queries into ChartDataModels.\r\n * You can initialize the Plotter with database parameters and afterwards\r\n * you can run consecutive queries resulting in a new database.\r\n */\r\npublic class JDBCPlotter {\r\n\r\n    /**\r\n     * The SQL connection.\r\n     */\r\n    protected Connection conn;\r\n\r\n    /**\r\n     * Creates a new JDBCPlotter using the given driver and URL.\r\n     * @param jdbcDriver the fully qualified classname of the SQL driver class.\r\n     * @param jdbcURL the URL of the JDBC database to connect to.\r\n     * @param username the username for the JDBC resource\r\n     * @param password the user's password\r\n     */\r\n    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {\r\n        try {\r\n            Class.forName(jdbcDriver);\r\n            conn = DriverManager.getConnection(jdbcURL, username, password);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while creating a database connection.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            double x = 0.0;\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(x));\r\n                x += 1.0;\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(sqlResult.getDouble(columnRow)));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.\r\n     * The columns are initialized with values from row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.\r\n     * The columns are initialized with values of row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(sqlResult.getString(columnRow));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            String[] columns = (String[]) columnList.toArray(new String[0]);\r\n            return new ObjectChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotterTest0.java",
		"test_prompt": "// JDBCPlotterTest0.java\npackage de.progra.charting.model;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JDBCPlotter}.\n* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String[])} method.\n*/\nclass JDBCPlotterTest0 {"
	},
	{
		"original_code": "// JDBCPlotter.java\n/*\r\n JOpenChart Java Charting Library and Toolkit\r\n Copyright (C) 2001  Sebastian M�ller\r\n http://jopenchart.sourceforge.net\r\n\r\n This library is free software; you can redistribute it and/or\r\n modify it under the terms of the GNU Lesser General Public\r\n License as published by the Free Software Foundation; either\r\n version 2.1 of the License, or (at your option) any later version.\r\n\r\n This library is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public\r\n License along with this library; if not, write to the Free Software\r\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\n JDBCPlotter.java\r\n Created on 9. October 2002\r\n Based on SQLPlotter.java, created on 29. December 2001\r\n \r\n */\r\npackage de.progra.charting.model;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The class is used to convert database queries into ChartDataModels.\r\n * You can initialize the Plotter with database parameters and afterwards\r\n * you can run consecutive queries resulting in a new database.\r\n */\r\npublic class JDBCPlotter {\r\n\r\n    /**\r\n     * The SQL connection.\r\n     */\r\n    protected Connection conn;\r\n\r\n    /**\r\n     * Creates a new JDBCPlotter using the given driver and URL.\r\n     * @param jdbcDriver the fully qualified classname of the SQL driver class.\r\n     * @param jdbcURL the URL of the JDBC database to connect to.\r\n     * @param username the username for the JDBC resource\r\n     * @param password the user's password\r\n     */\r\n    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {\r\n        try {\r\n            Class.forName(jdbcDriver);\r\n            conn = DriverManager.getConnection(jdbcURL, username, password);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while creating a database connection.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            double x = 0.0;\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(x));\r\n                x += 1.0;\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(sqlResult.getDouble(columnRow)));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.\r\n     * The columns are initialized with values from row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.\r\n     * The columns are initialized with values of row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(sqlResult.getString(columnRow));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            String[] columns = (String[]) columnList.toArray(new String[0]);\r\n            return new ObjectChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotterTest1.java",
		"test_prompt": "// JDBCPlotterTest1.java\npackage de.progra.charting.model;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JDBCPlotter}.\n* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String[], String[])} method.\n*/\nclass JDBCPlotterTest1 {"
	},
	{
		"original_code": "// JDBCPlotter.java\n/*\r\n JOpenChart Java Charting Library and Toolkit\r\n Copyright (C) 2001  Sebastian M�ller\r\n http://jopenchart.sourceforge.net\r\n\r\n This library is free software; you can redistribute it and/or\r\n modify it under the terms of the GNU Lesser General Public\r\n License as published by the Free Software Foundation; either\r\n version 2.1 of the License, or (at your option) any later version.\r\n\r\n This library is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public\r\n License along with this library; if not, write to the Free Software\r\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\n JDBCPlotter.java\r\n Created on 9. October 2002\r\n Based on SQLPlotter.java, created on 29. December 2001\r\n \r\n */\r\npackage de.progra.charting.model;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The class is used to convert database queries into ChartDataModels.\r\n * You can initialize the Plotter with database parameters and afterwards\r\n * you can run consecutive queries resulting in a new database.\r\n */\r\npublic class JDBCPlotter {\r\n\r\n    /**\r\n     * The SQL connection.\r\n     */\r\n    protected Connection conn;\r\n\r\n    /**\r\n     * Creates a new JDBCPlotter using the given driver and URL.\r\n     * @param jdbcDriver the fully qualified classname of the SQL driver class.\r\n     * @param jdbcURL the URL of the JDBC database to connect to.\r\n     * @param username the username for the JDBC resource\r\n     * @param password the user's password\r\n     */\r\n    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {\r\n        try {\r\n            Class.forName(jdbcDriver);\r\n            conn = DriverManager.getConnection(jdbcURL, username, password);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while creating a database connection.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            double x = 0.0;\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(x));\r\n                x += 1.0;\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(sqlResult.getDouble(columnRow)));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.\r\n     * The columns are initialized with values from row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.\r\n     * The columns are initialized with values of row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(sqlResult.getString(columnRow));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            String[] columns = (String[]) columnList.toArray(new String[0]);\r\n            return new ObjectChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotterTest2.java",
		"test_prompt": "// JDBCPlotterTest2.java\npackage de.progra.charting.model;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JDBCPlotter}.\n* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[])} method.\n*/\nclass JDBCPlotterTest2 {"
	},
	{
		"original_code": "// JDBCPlotter.java\n/*\r\n JOpenChart Java Charting Library and Toolkit\r\n Copyright (C) 2001  Sebastian M�ller\r\n http://jopenchart.sourceforge.net\r\n\r\n This library is free software; you can redistribute it and/or\r\n modify it under the terms of the GNU Lesser General Public\r\n License as published by the Free Software Foundation; either\r\n version 2.1 of the License, or (at your option) any later version.\r\n\r\n This library is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public\r\n License along with this library; if not, write to the Free Software\r\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\n JDBCPlotter.java\r\n Created on 9. October 2002\r\n Based on SQLPlotter.java, created on 29. December 2001\r\n \r\n */\r\npackage de.progra.charting.model;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The class is used to convert database queries into ChartDataModels.\r\n * You can initialize the Plotter with database parameters and afterwards\r\n * you can run consecutive queries resulting in a new database.\r\n */\r\npublic class JDBCPlotter {\r\n\r\n    /**\r\n     * The SQL connection.\r\n     */\r\n    protected Connection conn;\r\n\r\n    /**\r\n     * Creates a new JDBCPlotter using the given driver and URL.\r\n     * @param jdbcDriver the fully qualified classname of the SQL driver class.\r\n     * @param jdbcURL the URL of the JDBC database to connect to.\r\n     * @param username the username for the JDBC resource\r\n     * @param password the user's password\r\n     */\r\n    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {\r\n        try {\r\n            Class.forName(jdbcDriver);\r\n            conn = DriverManager.getConnection(jdbcURL, username, password);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while creating a database connection.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            double x = 0.0;\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(x));\r\n                x += 1.0;\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(sqlResult.getDouble(columnRow)));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.\r\n     * The columns are initialized with values from row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.\r\n     * The columns are initialized with values of row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(sqlResult.getString(columnRow));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            String[] columns = (String[]) columnList.toArray(new String[0]);\r\n            return new ObjectChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotterTest3.java",
		"test_prompt": "// JDBCPlotterTest3.java\npackage de.progra.charting.model;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JDBCPlotter}.\n* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[], String[])} method.\n*/\nclass JDBCPlotterTest3 {"
	},
	{
		"original_code": "// JDBCPlotter.java\n/*\r\n JOpenChart Java Charting Library and Toolkit\r\n Copyright (C) 2001  Sebastian M�ller\r\n http://jopenchart.sourceforge.net\r\n\r\n This library is free software; you can redistribute it and/or\r\n modify it under the terms of the GNU Lesser General Public\r\n License as published by the Free Software Foundation; either\r\n version 2.1 of the License, or (at your option) any later version.\r\n\r\n This library is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public\r\n License along with this library; if not, write to the Free Software\r\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\n JDBCPlotter.java\r\n Created on 9. October 2002\r\n Based on SQLPlotter.java, created on 29. December 2001\r\n \r\n */\r\npackage de.progra.charting.model;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The class is used to convert database queries into ChartDataModels.\r\n * You can initialize the Plotter with database parameters and afterwards\r\n * you can run consecutive queries resulting in a new database.\r\n */\r\npublic class JDBCPlotter {\r\n\r\n    /**\r\n     * The SQL connection.\r\n     */\r\n    protected Connection conn;\r\n\r\n    /**\r\n     * Creates a new JDBCPlotter using the given driver and URL.\r\n     * @param jdbcDriver the fully qualified classname of the SQL driver class.\r\n     * @param jdbcURL the URL of the JDBC database to connect to.\r\n     * @param username the username for the JDBC resource\r\n     * @param password the user's password\r\n     */\r\n    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {\r\n        try {\r\n            Class.forName(jdbcDriver);\r\n            conn = DriverManager.getConnection(jdbcURL, username, password);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while creating a database connection.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            double x = 0.0;\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(x));\r\n                x += 1.0;\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(sqlResult.getDouble(columnRow)));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.\r\n     * The columns are initialized with values from row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.\r\n     * The columns are initialized with values of row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(sqlResult.getString(columnRow));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            String[] columns = (String[]) columnList.toArray(new String[0]);\r\n            return new ObjectChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotterTest4.java",
		"test_prompt": "// JDBCPlotterTest4.java\npackage de.progra.charting.model;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JDBCPlotter}.\n* It contains ten unit test cases for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.\n*/\nclass JDBCPlotterTest4 {"
	},
	{
		"original_code": "// JDBCPlotter.java\n/*\r\n JOpenChart Java Charting Library and Toolkit\r\n Copyright (C) 2001  Sebastian M�ller\r\n http://jopenchart.sourceforge.net\r\n\r\n This library is free software; you can redistribute it and/or\r\n modify it under the terms of the GNU Lesser General Public\r\n License as published by the Free Software Foundation; either\r\n version 2.1 of the License, or (at your option) any later version.\r\n\r\n This library is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n Lesser General Public License for more details.\r\n\r\n You should have received a copy of the GNU Lesser General Public\r\n License along with this library; if not, write to the Free Software\r\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\n JDBCPlotter.java\r\n Created on 9. October 2002\r\n Based on SQLPlotter.java, created on 29. December 2001\r\n \r\n */\r\npackage de.progra.charting.model;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The class is used to convert database queries into ChartDataModels.\r\n * You can initialize the Plotter with database parameters and afterwards\r\n * you can run consecutive queries resulting in a new database.\r\n */\r\npublic class JDBCPlotter {\r\n\r\n    /**\r\n     * The SQL connection.\r\n     */\r\n    protected Connection conn;\r\n\r\n    /**\r\n     * Creates a new JDBCPlotter using the given driver and URL.\r\n     * @param jdbcDriver the fully qualified classname of the SQL driver class.\r\n     * @param jdbcURL the URL of the JDBC database to connect to.\r\n     * @param username the username for the JDBC resource\r\n     * @param password the user's password\r\n     */\r\n    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {\r\n        try {\r\n            Class.forName(jdbcDriver);\r\n            conn = DriverManager.getConnection(jdbcURL, username, password);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while creating a database connection.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values starting from 0.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            double x = 0.0;\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(x));\r\n                x += 1.0;\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.\r\n     * The columns are initialized with values from columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(new Double(sqlResult.getDouble(columnRow)));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            double[] columns = new double[columnList.size()];\r\n            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();\r\n            return new DefaultChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.\r\n     * The columns are initialized with values from row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which\r\n     * will be used as the DataSet titles.\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {\r\n        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);\r\n    }\r\n\r\n    /**\r\n     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.\r\n     * The columns are initialized with values of row columnRow.\r\n     * @param sqlQuery the SQL query to be performed\r\n     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values\r\n     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel\r\n     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles\r\n     */\r\n    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {\r\n        try {\r\n            Statement stmt = conn.createStatement();\r\n            ResultSet sqlResult = stmt.executeQuery(sqlQuery);\r\n            ArrayList[] model = new ArrayList[sqlRows.length];\r\n            ArrayList columnList = new ArrayList();\r\n            for (int i = 0; i < model.length; i++) {\r\n                model[i] = new ArrayList();\r\n            }\r\n            while (sqlResult.next()) {\r\n                columnList.add(sqlResult.getString(columnRow));\r\n                for (int i = 0; i < sqlRows.length; i++) {\r\n                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));\r\n                }\r\n            }\r\n            Number[][] modelArray = new Number[model.length][];\r\n            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);\r\n            String[] columns = (String[]) columnList.toArray(new String[0]);\r\n            return new ObjectChartDataModel(modelArray, columns, dataSets);\r\n        } catch (Exception e) {\r\n            throw new JDBCPlotterException(\"Exception while performing task.\", e);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotterTest5.java",
		"test_prompt": "// JDBCPlotterTest5.java\npackage de.progra.charting.model;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JDBCPlotter}.\n* It contains ten unit test cases for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[], String[])} method.\n*/\nclass JDBCPlotterTest5 {"
	},
	{
		"original_code": "// DefaultChartDataModel.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    DefaultChartDataModel.java\n    Created on 28. Juni 2001, 20:41\n*/\npackage de.progra.charting.model;\n\nimport de.progra.charting.CoordSystem;\nimport de.progra.charting.ChartUtilities;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\n\n/**\n * Implements a default ChartModel. It uses a DataSet[] and the columns\n * are numeric. It's purely read-only.\n * @author  mueller\n * @version 1.0\n */\npublic class DefaultChartDataModel extends AbstractChartDataModel {\n\n    /**\n     * The sorted x-axis values used for calculating the constraints.\n     */\n    protected TreeSet columnSet = new TreeSet();\n\n    /**\n     * The DataSet list.\n     */\n    protected ArrayList data = new ArrayList();\n\n    /**\n     * A HashMap containing the ordered data used for calculating the constraints.\n     */\n    protected HashMap valuesbyaxis = new HashMap();\n\n    /**\n     * The constraints for the first and second y-axes.\n     */\n    protected ChartDataModelConstraints constraints1, constraints2;\n\n    /**\n     * Creates a new empty DefaultChartDataModel.\n     */\n    public DefaultChartDataModel() {\n        TreeSet set1 = new TreeSet();\n        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);\n        TreeSet set2 = new TreeSet();\n        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);\n        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);\n        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);\n    }\n\n    /**\n     * Creates new DefaultChartDataModel with the default axis binding.\n     * @param data the array of values. The first index specifies the\n     * datasets, the last one is the value index.\n     * @param columns the array of x-axis values. The length of the\n     * datasets and the length of the column should be equal and the columns should\n     * be ordered.\n     * @param rows the array of DataSet titles. It has to have the same\n     * length as the number of DataSets.\n     */\n    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {\n        this();\n        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));\n        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));\n        ChartUtilities.addDataToSet(set, data);\n        trimSet(set);\n        for (int i = 0; i < data.length; i++) {\n            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));\n        }\n    }\n\n    /**\n     * Creates new DefaultChartDataModel.\n     * @param data the array of values. The first index specifies the\n     * datasets, the last one is the value index.\n     * @param columns the array of x-axis values. The length of the\n     * datasets and the length of the column should be equal and\n     * the columns should be ordered.\n     * @param rows the array of DataSet titles. It has to have the same\n     * length as the number of DataSets.\n     */\n    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {\n        this();\n        Number[][] numdata = ChartUtilities.transformArray(data);\n        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));\n        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));\n        ChartUtilities.addDataToSet(set, numdata);\n        trimSet(set);\n        for (int i = 0; i < data.length; i++) {\n            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));\n        }\n    }\n\n    /**\n     * Creates new DefaultChartDataModel.\n     * @param data the array of values. The first index specifies the\n     * datasets, the last one is the value index.\n     * @param columns the array of x-axis values. The length of the\n     * datasets and the length of the column should be equal and\n     * the columns should be ordered.\n     * @param rows the array of DataSet titles. It has to have the same\n     * length as the number of DataSets.\n     */\n    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {\n        this();\n        Number[][] numdata = ChartUtilities.transformArray(data);\n        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));\n        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));\n        ChartUtilities.addDataToSet(set, numdata);\n        trimSet(set);\n        for (int i = 0; i < data.length; i++) {\n            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));\n        }\n    }\n\n    /**\n     * Creates a new DefaultChartDataModel using the\n     * given array of DataSets, effectively enabling the creation\n     * of DataModels with differently sized DataSets.\n     * @param ds the array of DataSets to be used.\n     */\n    public DefaultChartDataModel(DataSet[] ds) {\n        this();\n        TreeSet set;\n        for (int i = 0; i < ds.length; i++) {\n            data.add(ds[i]);\n            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));\n            for (int j = 0; j < ds[i].getDataSetLength(); j++) {\n                columnSet.add(ds[i].getColumnValueAt(j));\n                set.add(ds[i].getValueAt(j));\n                trimSet(set);\n            }\n        }\n    }\n\n    /**\n     * Returns the length of a certain dataset.\n     * @param set the DataSet\n     * @return the length of the DataSet\n     */\n    public int getDataSetLength(int set) {\n        return ((DataSet) data.get(set)).getDataSetLength();\n    }\n\n    /**\n     * Returns the total amount of datasets.\n     * @return the amount of DataSets\n     */\n    public int getDataSetNumber() {\n        return data.size();\n    }\n\n    /**\n     * Returns the title of the DataSet. This is the number of\n     * the DataSet per default.\n     * @param set the DataSet index\n     * @return the String title\n     */\n    public String getDataSetName(int set) {\n        return ((DataSet) data.get(set)).getTitle();\n    }\n\n    /**\n     * Returns the axis binding for a DataSet\n     * @param set the DataSet index\n     * @return an axis binding constant\n     */\n    public int getAxisBinding(int set) {\n        return ((DataSet) data.get(set)).getYAxis();\n    }\n\n    /**\n     * Returns true if the columns are numeric.\n     * @return <CODE>true</CODE>\n     */\n    public boolean isColumnNumeric() {\n        return true;\n    }\n\n    /**\n     * Returns the class of the column values.\n     * @return <CODE>Double.class</CODE>\n     */\n    public Class getColumnClass() {\n        return Double.class;\n    }\n\n    /**\n     * Returns the Value in a specific dataset at a certain index.      *\n     * @param set the DataSet index\n     * @param index the value index\n     * @return the Number value at the specified position\n     */\n    public Number getValueAt(int set, int index) {\n        return (Number) ((DataSet) data.get(set)).getValueAt(index);\n    }\n\n    /**\n     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel\n     * can contain DataSets with different lengths and column values.\n     * @return null\n     */\n    public Object getColumnValueAt(int col) {\n        return null;\n    }\n\n    /**\n     * Returns a specific column value.\n     * @return the column value or <code>null</code> if the column doesn't exist.\n     * @param col the column index\n     * @param set the DataSet of which the column value is desired\n     */\n    public Object getColumnValueAt(int set, int col) {\n        // PENDING: Why do we create a new Double here?\n        if (col < getDataSetLength(set))\n            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());\n        else\n            return null;\n    }\n\n    /**\n     * Returns a ChartDataModelConstraints Object for a given axis.\n     * This way, there are different constraints for the first and for\n     * the second y-axis. If the model is empty, the maximum values are 1 and\n     * the minimum values are 0, thus enabling proper rendering.\n     * @param axis the axis constant.\n     * @return a ChartDataModelConstraints object with the constraints\n     * for the specified y-axis.\n     */\n    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {\n        if (axis == CoordSystem.FIRST_YAXIS)\n            return constraints1;\n        else\n            return constraints2;\n    }\n\n    /**\n     * Sets the ChartDataModelConstraints object for the given\n     * axis binding.\n     * @param axis the Axis constant\n     * @param constraints the ChartDataModelConstraints object\n     * @return a ChartDataModelConstraints object.\n     */\n    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {\n        if (axis == CoordSystem.FIRST_YAXIS)\n            constraints1 = constraints;\n        else\n            constraints2 = constraints;\n    }\n\n    /**\n     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet\n     * containing all values. If asymptotic functions are plotted, infinite values\n     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,\n     * these values are omitted from these calculations.\n     */\n    protected void trimSet(TreeSet s) {\n        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {\n            s.remove(s.first());\n        }\n        double last = ((Number) s.last()).doubleValue();\n        while (last == Double.POSITIVE_INFINITY || last != last) {\n            s.remove(s.last());\n            last = ((Number) s.last()).doubleValue();\n        }\n    }\n\n    /**\n     * Returns an ordered set of all data values for the specified axis.\n     * This is called by the ChartDataModelConstraints classes.\n     */\n    protected TreeSet getOrderedValues(int axis) {\n        return (TreeSet) valuesbyaxis.get(new Integer(axis));\n    }\n\n    /**\n     * Returns the first ordered column value for use by the ChartDataModelConstraints.\n     */\n    protected double getFirstColumnValue() {\n        return ((Number) columnSet.first()).doubleValue();\n    }\n\n    /**\n     * Returns the last ordered column value for use by the ChartDataModelConstraints.\n     */\n    protected double getLastColumnValue() {\n        return ((Number) columnSet.last()).doubleValue();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModelTest.java",
		"test_prompt": "// DefaultChartDataModelTest.java\npackage de.progra.charting.model;\n\nimport de.progra.charting.CoordSystem;\nimport de.progra.charting.ChartUtilities;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultChartDataModel}.\n* It contains ten unit test cases for the {@link DefaultChartDataModel#isColumnNumeric()} method.\n*/\nclass DefaultChartDataModelTest {"
	},
	{
		"original_code": "// AbstractChartDataModel.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    AbstractChartDataModel.java\n    Created on 28. Juni 2001, 18:58\n*/\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\n\n/**\n * This class implements the event-handling methods for a chart model.\n * @author  mueller\n * @version 1.0\n */\npublic abstract class AbstractChartDataModel implements ChartDataModel {\n\n    /**\n     * The listener list.\n     */\n    protected EventListenerList listener = new EventListenerList();\n\n    /**\n     * Flag defining the automatic scaling of max and min values.\n     */\n    protected boolean autoscale = false;\n\n    /**\n     * Flag defining the manual scaling of max and min values.\n     */\n    protected boolean manualscale = false;\n\n    /**\n     * Maximum and minimum column values to be displayed.\n     */\n    protected double maxcolumn, mincolumn;\n\n    /**\n     * Maximum and minimum values to be displayed.\n     */\n    protected Number maxvalue, minvalue;\n\n    /**\n     * Creates new AbstractChartDataModel\n     */\n    public AbstractChartDataModel() {\n    }\n\n    /**\n     * Removes a ChartDataModelListener.\n     * @param l the ChartDataListener\n     */\n    public void removeChartDataModelListener(ChartDataModelListener l) {\n        listener.remove(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Adds a ChartDataModelListener.\n     * @param l the ChartDataModelListener\n     */\n    public void addChartDataModelListener(ChartDataModelListener l) {\n        listener.add(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Determines if the column values are numeric.\n     * @return <CODE>false</CODE> per default\n     */\n    public boolean isColumnNumeric() {\n        return false;\n    }\n\n    /**\n     * Provides an empty implementation for not-editable DataModels.\n     * @param set the DataSet in which the value should be set\n     * @param index the index in the DataSet where the value should be stored\n     * @param value the value object\n     */\n    public void setValueAt(int set, int index, Object value) {\n    }\n\n    /**\n     * Returns the class of the column values.\n     * @return <CODE>Object.class</CODE> per default\n     */\n    public Class getColumnClass() {\n        return Object.class;\n    }\n\n    /**\n     * Promotes a new ChartDataModelEvent.\n     * @param src the source object of the event.\n     */\n    public void fireChartDataModelChangedEvent(Object src) {\n        ChartDataModelEvent e = new ChartDataModelEvent(src);\n        Object[] ls = listener.getListenerList();\n        for (int i = (ls.length - 2); i >= 0; i -= 2) {\n            if (ls[i] == ChartDataModelListener.class) {\n                ((ChartDataModelListener) ls[i + 1]).chartDataChanged(e);\n            }\n        }\n    }\n\n    /**\n     * Returns the Axis Binding for a specific DataSet, ie the Axis on\n     * which the DataSet should be plotted\n     * @param set the DataSet whose Axis binding should be determined\n     * @return <code>DataSet.FIRST_YAXIS</code> by default.\n     */\n    public int getAxisBinding(int set) {\n        return CoordSystem.FIRST_YAXIS;\n    }\n\n    /**\n     * Provides a default empty implementation.\n     * @param set the DataSet\n     * @param axis the Axis binding\n     */\n    public void setAxisBinding(int set, int axis) {\n    }\n\n    public void setAutoScale(boolean b) {\n        autoscale = b;\n    }\n\n    public boolean isAutoScale() {\n        return autoscale;\n    }\n\n    /**\n     * Enables the manual axis scaling. Set the desired\n     * maximum and minimum values using the setMaximum...Value\n     * functions.\n     */\n    public void setManualScale(boolean b) {\n        manualscale = b;\n    }\n\n    /**\n     * Returns true if the manual axis scaling is enabled. This overrides\n     * the enabled automatic axis scaling.\n     */\n    public boolean isManualScale() {\n        return manualscale;\n    }\n\n    /**\n     * Sets the maximum x-axis value.\n     */\n    public void setMaximumColumnValue(double d) {\n        maxcolumn = d;\n    }\n\n    /**\n     * Sets the minimum x-axis value.\n     */\n    public void setMinimumColumnValue(double d) {\n        mincolumn = d;\n    }\n\n    /**\n     * Sets the maximum y-axis value.\n     */\n    public void setMaximumValue(Number n) {\n        maxvalue = n;\n    }\n\n    /**\n     * Sets the minimum y-axis value.\n     */\n    public void setMinimumValue(Number n) {\n        minvalue = n;\n    }\n\n    public double getManualMaximumColumnValue() {\n        return maxcolumn;\n    }\n\n    public double getManualMinimumColumnValue() {\n        return mincolumn;\n    }\n\n    public Number getManualMaximumValue() {\n        return maxvalue;\n    }\n\n    public Number getManualMinimumValue() {\n        return minvalue;\n    }\n\n    /**\n     * Returns the title of the DataSet.\n     * @param set the DataSet identifier\n     * @return the the number of\n     * the DataSet per default.\n     */\n    public String getDataSetName(int set) {\n        return \"Dataset \" + set;\n    }\n\n    /**\n     * Compares this ChartDataModel with another object.\n     * @param o the object to compare with\n     * @return true, if o is an AbstractChartDataModel, the number of\n     * DataSets is equal and all DataSet names and column values are equal.\n     */\n    public boolean equals(Object o) {\n        if (o == null)\n            return false;\n        try {\n            AbstractChartDataModel model = (AbstractChartDataModel) o;\n            if (getDataSetNumber() != model.getDataSetNumber()) {\n                return false;\n            }\n            for (int i = 0; i < getDataSetNumber(); i++) {\n                if (!getDataSetName(i).equals(model.getDataSetName(i))) {\n                    return false;\n                }\n                for (int j = 0; j < getDataSetLength(j); j++) {\n                    if (!getColumnValueAt(j).equals(model.getColumnValueAt(j))) {\n                        return false;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected abstract TreeSet getOrderedValues(int axis);\n\n    protected abstract double getFirstColumnValue();\n\n    protected abstract double getLastColumnValue();\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/AbstractChartDataModelTest0.java",
		"test_prompt": "// AbstractChartDataModelTest0.java\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractChartDataModel}.\n* It contains ten unit test cases for the {@link AbstractChartDataModel#isColumnNumeric()} method.\n*/\nclass AbstractChartDataModelTest0 {"
	},
	{
		"original_code": "// AbstractChartDataModel.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    AbstractChartDataModel.java\n    Created on 28. Juni 2001, 18:58\n*/\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\n\n/**\n * This class implements the event-handling methods for a chart model.\n * @author  mueller\n * @version 1.0\n */\npublic abstract class AbstractChartDataModel implements ChartDataModel {\n\n    /**\n     * The listener list.\n     */\n    protected EventListenerList listener = new EventListenerList();\n\n    /**\n     * Flag defining the automatic scaling of max and min values.\n     */\n    protected boolean autoscale = false;\n\n    /**\n     * Flag defining the manual scaling of max and min values.\n     */\n    protected boolean manualscale = false;\n\n    /**\n     * Maximum and minimum column values to be displayed.\n     */\n    protected double maxcolumn, mincolumn;\n\n    /**\n     * Maximum and minimum values to be displayed.\n     */\n    protected Number maxvalue, minvalue;\n\n    /**\n     * Creates new AbstractChartDataModel\n     */\n    public AbstractChartDataModel() {\n    }\n\n    /**\n     * Removes a ChartDataModelListener.\n     * @param l the ChartDataListener\n     */\n    public void removeChartDataModelListener(ChartDataModelListener l) {\n        listener.remove(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Adds a ChartDataModelListener.\n     * @param l the ChartDataModelListener\n     */\n    public void addChartDataModelListener(ChartDataModelListener l) {\n        listener.add(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Determines if the column values are numeric.\n     * @return <CODE>false</CODE> per default\n     */\n    public boolean isColumnNumeric() {\n        return false;\n    }\n\n    /**\n     * Provides an empty implementation for not-editable DataModels.\n     * @param set the DataSet in which the value should be set\n     * @param index the index in the DataSet where the value should be stored\n     * @param value the value object\n     */\n    public void setValueAt(int set, int index, Object value) {\n    }\n\n    /**\n     * Returns the class of the column values.\n     * @return <CODE>Object.class</CODE> per default\n     */\n    public Class getColumnClass() {\n        return Object.class;\n    }\n\n    /**\n     * Promotes a new ChartDataModelEvent.\n     * @param src the source object of the event.\n     */\n    public void fireChartDataModelChangedEvent(Object src) {\n        ChartDataModelEvent e = new ChartDataModelEvent(src);\n        Object[] ls = listener.getListenerList();\n        for (int i = (ls.length - 2); i >= 0; i -= 2) {\n            if (ls[i] == ChartDataModelListener.class) {\n                ((ChartDataModelListener) ls[i + 1]).chartDataChanged(e);\n            }\n        }\n    }\n\n    /**\n     * Returns the Axis Binding for a specific DataSet, ie the Axis on\n     * which the DataSet should be plotted\n     * @param set the DataSet whose Axis binding should be determined\n     * @return <code>DataSet.FIRST_YAXIS</code> by default.\n     */\n    public int getAxisBinding(int set) {\n        return CoordSystem.FIRST_YAXIS;\n    }\n\n    /**\n     * Provides a default empty implementation.\n     * @param set the DataSet\n     * @param axis the Axis binding\n     */\n    public void setAxisBinding(int set, int axis) {\n    }\n\n    public void setAutoScale(boolean b) {\n        autoscale = b;\n    }\n\n    public boolean isAutoScale() {\n        return autoscale;\n    }\n\n    /**\n     * Enables the manual axis scaling. Set the desired\n     * maximum and minimum values using the setMaximum...Value\n     * functions.\n     */\n    public void setManualScale(boolean b) {\n        manualscale = b;\n    }\n\n    /**\n     * Returns true if the manual axis scaling is enabled. This overrides\n     * the enabled automatic axis scaling.\n     */\n    public boolean isManualScale() {\n        return manualscale;\n    }\n\n    /**\n     * Sets the maximum x-axis value.\n     */\n    public void setMaximumColumnValue(double d) {\n        maxcolumn = d;\n    }\n\n    /**\n     * Sets the minimum x-axis value.\n     */\n    public void setMinimumColumnValue(double d) {\n        mincolumn = d;\n    }\n\n    /**\n     * Sets the maximum y-axis value.\n     */\n    public void setMaximumValue(Number n) {\n        maxvalue = n;\n    }\n\n    /**\n     * Sets the minimum y-axis value.\n     */\n    public void setMinimumValue(Number n) {\n        minvalue = n;\n    }\n\n    public double getManualMaximumColumnValue() {\n        return maxcolumn;\n    }\n\n    public double getManualMinimumColumnValue() {\n        return mincolumn;\n    }\n\n    public Number getManualMaximumValue() {\n        return maxvalue;\n    }\n\n    public Number getManualMinimumValue() {\n        return minvalue;\n    }\n\n    /**\n     * Returns the title of the DataSet.\n     * @param set the DataSet identifier\n     * @return the the number of\n     * the DataSet per default.\n     */\n    public String getDataSetName(int set) {\n        return \"Dataset \" + set;\n    }\n\n    /**\n     * Compares this ChartDataModel with another object.\n     * @param o the object to compare with\n     * @return true, if o is an AbstractChartDataModel, the number of\n     * DataSets is equal and all DataSet names and column values are equal.\n     */\n    public boolean equals(Object o) {\n        if (o == null)\n            return false;\n        try {\n            AbstractChartDataModel model = (AbstractChartDataModel) o;\n            if (getDataSetNumber() != model.getDataSetNumber()) {\n                return false;\n            }\n            for (int i = 0; i < getDataSetNumber(); i++) {\n                if (!getDataSetName(i).equals(model.getDataSetName(i))) {\n                    return false;\n                }\n                for (int j = 0; j < getDataSetLength(j); j++) {\n                    if (!getColumnValueAt(j).equals(model.getColumnValueAt(j))) {\n                        return false;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected abstract TreeSet getOrderedValues(int axis);\n\n    protected abstract double getFirstColumnValue();\n\n    protected abstract double getLastColumnValue();\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/AbstractChartDataModelTest1.java",
		"test_prompt": "// AbstractChartDataModelTest1.java\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractChartDataModel}.\n* It contains ten unit test cases for the {@link AbstractChartDataModel#isAutoScale()} method.\n*/\nclass AbstractChartDataModelTest1 {"
	},
	{
		"original_code": "// AbstractChartDataModel.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    AbstractChartDataModel.java\n    Created on 28. Juni 2001, 18:58\n*/\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\n\n/**\n * This class implements the event-handling methods for a chart model.\n * @author  mueller\n * @version 1.0\n */\npublic abstract class AbstractChartDataModel implements ChartDataModel {\n\n    /**\n     * The listener list.\n     */\n    protected EventListenerList listener = new EventListenerList();\n\n    /**\n     * Flag defining the automatic scaling of max and min values.\n     */\n    protected boolean autoscale = false;\n\n    /**\n     * Flag defining the manual scaling of max and min values.\n     */\n    protected boolean manualscale = false;\n\n    /**\n     * Maximum and minimum column values to be displayed.\n     */\n    protected double maxcolumn, mincolumn;\n\n    /**\n     * Maximum and minimum values to be displayed.\n     */\n    protected Number maxvalue, minvalue;\n\n    /**\n     * Creates new AbstractChartDataModel\n     */\n    public AbstractChartDataModel() {\n    }\n\n    /**\n     * Removes a ChartDataModelListener.\n     * @param l the ChartDataListener\n     */\n    public void removeChartDataModelListener(ChartDataModelListener l) {\n        listener.remove(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Adds a ChartDataModelListener.\n     * @param l the ChartDataModelListener\n     */\n    public void addChartDataModelListener(ChartDataModelListener l) {\n        listener.add(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Determines if the column values are numeric.\n     * @return <CODE>false</CODE> per default\n     */\n    public boolean isColumnNumeric() {\n        return false;\n    }\n\n    /**\n     * Provides an empty implementation for not-editable DataModels.\n     * @param set the DataSet in which the value should be set\n     * @param index the index in the DataSet where the value should be stored\n     * @param value the value object\n     */\n    public void setValueAt(int set, int index, Object value) {\n    }\n\n    /**\n     * Returns the class of the column values.\n     * @return <CODE>Object.class</CODE> per default\n     */\n    public Class getColumnClass() {\n        return Object.class;\n    }\n\n    /**\n     * Promotes a new ChartDataModelEvent.\n     * @param src the source object of the event.\n     */\n    public void fireChartDataModelChangedEvent(Object src) {\n        ChartDataModelEvent e = new ChartDataModelEvent(src);\n        Object[] ls = listener.getListenerList();\n        for (int i = (ls.length - 2); i >= 0; i -= 2) {\n            if (ls[i] == ChartDataModelListener.class) {\n                ((ChartDataModelListener) ls[i + 1]).chartDataChanged(e);\n            }\n        }\n    }\n\n    /**\n     * Returns the Axis Binding for a specific DataSet, ie the Axis on\n     * which the DataSet should be plotted\n     * @param set the DataSet whose Axis binding should be determined\n     * @return <code>DataSet.FIRST_YAXIS</code> by default.\n     */\n    public int getAxisBinding(int set) {\n        return CoordSystem.FIRST_YAXIS;\n    }\n\n    /**\n     * Provides a default empty implementation.\n     * @param set the DataSet\n     * @param axis the Axis binding\n     */\n    public void setAxisBinding(int set, int axis) {\n    }\n\n    public void setAutoScale(boolean b) {\n        autoscale = b;\n    }\n\n    public boolean isAutoScale() {\n        return autoscale;\n    }\n\n    /**\n     * Enables the manual axis scaling. Set the desired\n     * maximum and minimum values using the setMaximum...Value\n     * functions.\n     */\n    public void setManualScale(boolean b) {\n        manualscale = b;\n    }\n\n    /**\n     * Returns true if the manual axis scaling is enabled. This overrides\n     * the enabled automatic axis scaling.\n     */\n    public boolean isManualScale() {\n        return manualscale;\n    }\n\n    /**\n     * Sets the maximum x-axis value.\n     */\n    public void setMaximumColumnValue(double d) {\n        maxcolumn = d;\n    }\n\n    /**\n     * Sets the minimum x-axis value.\n     */\n    public void setMinimumColumnValue(double d) {\n        mincolumn = d;\n    }\n\n    /**\n     * Sets the maximum y-axis value.\n     */\n    public void setMaximumValue(Number n) {\n        maxvalue = n;\n    }\n\n    /**\n     * Sets the minimum y-axis value.\n     */\n    public void setMinimumValue(Number n) {\n        minvalue = n;\n    }\n\n    public double getManualMaximumColumnValue() {\n        return maxcolumn;\n    }\n\n    public double getManualMinimumColumnValue() {\n        return mincolumn;\n    }\n\n    public Number getManualMaximumValue() {\n        return maxvalue;\n    }\n\n    public Number getManualMinimumValue() {\n        return minvalue;\n    }\n\n    /**\n     * Returns the title of the DataSet.\n     * @param set the DataSet identifier\n     * @return the the number of\n     * the DataSet per default.\n     */\n    public String getDataSetName(int set) {\n        return \"Dataset \" + set;\n    }\n\n    /**\n     * Compares this ChartDataModel with another object.\n     * @param o the object to compare with\n     * @return true, if o is an AbstractChartDataModel, the number of\n     * DataSets is equal and all DataSet names and column values are equal.\n     */\n    public boolean equals(Object o) {\n        if (o == null)\n            return false;\n        try {\n            AbstractChartDataModel model = (AbstractChartDataModel) o;\n            if (getDataSetNumber() != model.getDataSetNumber()) {\n                return false;\n            }\n            for (int i = 0; i < getDataSetNumber(); i++) {\n                if (!getDataSetName(i).equals(model.getDataSetName(i))) {\n                    return false;\n                }\n                for (int j = 0; j < getDataSetLength(j); j++) {\n                    if (!getColumnValueAt(j).equals(model.getColumnValueAt(j))) {\n                        return false;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected abstract TreeSet getOrderedValues(int axis);\n\n    protected abstract double getFirstColumnValue();\n\n    protected abstract double getLastColumnValue();\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/AbstractChartDataModelTest2.java",
		"test_prompt": "// AbstractChartDataModelTest2.java\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractChartDataModel}.\n* It contains ten unit test cases for the {@link AbstractChartDataModel#isManualScale()} method.\n*/\nclass AbstractChartDataModelTest2 {"
	},
	{
		"original_code": "// AbstractChartDataModel.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    AbstractChartDataModel.java\n    Created on 28. Juni 2001, 18:58\n*/\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\n\n/**\n * This class implements the event-handling methods for a chart model.\n * @author  mueller\n * @version 1.0\n */\npublic abstract class AbstractChartDataModel implements ChartDataModel {\n\n    /**\n     * The listener list.\n     */\n    protected EventListenerList listener = new EventListenerList();\n\n    /**\n     * Flag defining the automatic scaling of max and min values.\n     */\n    protected boolean autoscale = false;\n\n    /**\n     * Flag defining the manual scaling of max and min values.\n     */\n    protected boolean manualscale = false;\n\n    /**\n     * Maximum and minimum column values to be displayed.\n     */\n    protected double maxcolumn, mincolumn;\n\n    /**\n     * Maximum and minimum values to be displayed.\n     */\n    protected Number maxvalue, minvalue;\n\n    /**\n     * Creates new AbstractChartDataModel\n     */\n    public AbstractChartDataModel() {\n    }\n\n    /**\n     * Removes a ChartDataModelListener.\n     * @param l the ChartDataListener\n     */\n    public void removeChartDataModelListener(ChartDataModelListener l) {\n        listener.remove(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Adds a ChartDataModelListener.\n     * @param l the ChartDataModelListener\n     */\n    public void addChartDataModelListener(ChartDataModelListener l) {\n        listener.add(ChartDataModelListener.class, l);\n    }\n\n    /**\n     * Determines if the column values are numeric.\n     * @return <CODE>false</CODE> per default\n     */\n    public boolean isColumnNumeric() {\n        return false;\n    }\n\n    /**\n     * Provides an empty implementation for not-editable DataModels.\n     * @param set the DataSet in which the value should be set\n     * @param index the index in the DataSet where the value should be stored\n     * @param value the value object\n     */\n    public void setValueAt(int set, int index, Object value) {\n    }\n\n    /**\n     * Returns the class of the column values.\n     * @return <CODE>Object.class</CODE> per default\n     */\n    public Class getColumnClass() {\n        return Object.class;\n    }\n\n    /**\n     * Promotes a new ChartDataModelEvent.\n     * @param src the source object of the event.\n     */\n    public void fireChartDataModelChangedEvent(Object src) {\n        ChartDataModelEvent e = new ChartDataModelEvent(src);\n        Object[] ls = listener.getListenerList();\n        for (int i = (ls.length - 2); i >= 0; i -= 2) {\n            if (ls[i] == ChartDataModelListener.class) {\n                ((ChartDataModelListener) ls[i + 1]).chartDataChanged(e);\n            }\n        }\n    }\n\n    /**\n     * Returns the Axis Binding for a specific DataSet, ie the Axis on\n     * which the DataSet should be plotted\n     * @param set the DataSet whose Axis binding should be determined\n     * @return <code>DataSet.FIRST_YAXIS</code> by default.\n     */\n    public int getAxisBinding(int set) {\n        return CoordSystem.FIRST_YAXIS;\n    }\n\n    /**\n     * Provides a default empty implementation.\n     * @param set the DataSet\n     * @param axis the Axis binding\n     */\n    public void setAxisBinding(int set, int axis) {\n    }\n\n    public void setAutoScale(boolean b) {\n        autoscale = b;\n    }\n\n    public boolean isAutoScale() {\n        return autoscale;\n    }\n\n    /**\n     * Enables the manual axis scaling. Set the desired\n     * maximum and minimum values using the setMaximum...Value\n     * functions.\n     */\n    public void setManualScale(boolean b) {\n        manualscale = b;\n    }\n\n    /**\n     * Returns true if the manual axis scaling is enabled. This overrides\n     * the enabled automatic axis scaling.\n     */\n    public boolean isManualScale() {\n        return manualscale;\n    }\n\n    /**\n     * Sets the maximum x-axis value.\n     */\n    public void setMaximumColumnValue(double d) {\n        maxcolumn = d;\n    }\n\n    /**\n     * Sets the minimum x-axis value.\n     */\n    public void setMinimumColumnValue(double d) {\n        mincolumn = d;\n    }\n\n    /**\n     * Sets the maximum y-axis value.\n     */\n    public void setMaximumValue(Number n) {\n        maxvalue = n;\n    }\n\n    /**\n     * Sets the minimum y-axis value.\n     */\n    public void setMinimumValue(Number n) {\n        minvalue = n;\n    }\n\n    public double getManualMaximumColumnValue() {\n        return maxcolumn;\n    }\n\n    public double getManualMinimumColumnValue() {\n        return mincolumn;\n    }\n\n    public Number getManualMaximumValue() {\n        return maxvalue;\n    }\n\n    public Number getManualMinimumValue() {\n        return minvalue;\n    }\n\n    /**\n     * Returns the title of the DataSet.\n     * @param set the DataSet identifier\n     * @return the the number of\n     * the DataSet per default.\n     */\n    public String getDataSetName(int set) {\n        return \"Dataset \" + set;\n    }\n\n    /**\n     * Compares this ChartDataModel with another object.\n     * @param o the object to compare with\n     * @return true, if o is an AbstractChartDataModel, the number of\n     * DataSets is equal and all DataSet names and column values are equal.\n     */\n    public boolean equals(Object o) {\n        if (o == null)\n            return false;\n        try {\n            AbstractChartDataModel model = (AbstractChartDataModel) o;\n            if (getDataSetNumber() != model.getDataSetNumber()) {\n                return false;\n            }\n            for (int i = 0; i < getDataSetNumber(); i++) {\n                if (!getDataSetName(i).equals(model.getDataSetName(i))) {\n                    return false;\n                }\n                for (int j = 0; j < getDataSetLength(j); j++) {\n                    if (!getColumnValueAt(j).equals(model.getColumnValueAt(j))) {\n                        return false;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected abstract TreeSet getOrderedValues(int axis);\n\n    protected abstract double getFirstColumnValue();\n\n    protected abstract double getLastColumnValue();\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/AbstractChartDataModelTest3.java",
		"test_prompt": "// AbstractChartDataModelTest3.java\npackage de.progra.charting.model;\n\nimport de.progra.charting.event.ChartDataModelListener;\nimport de.progra.charting.event.ChartDataModelEvent;\nimport javax.swing.event.EventListenerList;\nimport de.progra.charting.CoordSystem;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\nimport java.util.Set;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractChartDataModel}.\n* It contains ten unit test cases for the {@link AbstractChartDataModel#equals(Object)} method.\n*/\nclass AbstractChartDataModelTest3 {"
	},
	{
		"original_code": "// FunctionPlotter.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    FunctionPlotter.java\n    Created on 7. September 2001, 17:14\n*/\npackage de.progra.charting.model;\n\nimport org.nfunk.jep.JEP;\n\n/**\n * This class can be used to create a ChartDataModel from a mathematical\n * function. A Python interpreter implemented in Java is called to calculate\n * the function values. Therefore, I didn't need to implement a parsing\n * algorithm. Of course, you need to know the Python syntax for mathematical\n * functions. The quadratical function <code>5x<sup>2</sup>-3x+4</code> e.g.\n * would be written as <code>5*x**2-3*x+4</code>. Please note, that it takes\n * approx. 1 s to plot a quadratical function like this computing 2000 single\n * values.\n * @author  mueller\n * @version 1.0\n */\npublic class FunctionPlotter {\n\n    /**\n     * Creates new FunctionPlot\n     */\n    private FunctionPlotter() {\n    }\n\n    /**\n     * This method creates a new ChartDataModel from the computed\n     * function data. In order to compute the needed values, a Python script is\n     * created using the provided parameters and is executed afterwards:<p>\n     *       <pre><code>\n     *        String pyfile = \"\" +\n     *        \"AMOUNT = \"+amount+\"\\n\"+\n     *        \"columns = []\\n\"+\n     *        \"model = []\\n\"+\n     *        \"lowrange = \"+lowrange+\"\\n\"+\n     *        \"highrange = \"+highrange+\"\\n\"+\n     *        \"for i in range(AMOUNT) :\\n\"+\n     *        \"   x = lowrange + i * (float(abs(highrange - lowrange)) / AMOUNT)\\n\"+\n     *        \"   columns.append(x)\\n\"+\n     *        \"   model.append(\"+function+\")\\n\";\n     *\n     *        interp.exec(pyfile);\n     *       </code></pre>\n     *       Finally the values are extracted via the PythonInterpreter:<p>\n     *       <pre><code>\n     *       pymodel[0] = (double[])interp.get(\"model\", double[].class);\n     *       pycolumns = (double[])interp.get(\"columns\", double[].class);\n     *       </code></pre>\n     * @param lowrange the lower x-value to begin from\n     * @param highrange the highest x-value to reach\n     * @param amount the amount of values that should be computed (2000 is\n     * a good value for smooth curves)\n     * @param function the mathematical function in Python notation\n     * @param rows the array with the DataSet title\n     * @throws IllegalArgumentException if the function contains more than\n     * one variable.\n     */\n    public static DefaultChartDataModel createChartDataModelInstance(double lowrange, double highrange, int amount, String function, String[] rows) {\n        double x = 0.0;\n        JEP jep = new JEP();\n        jep.addStandardConstants();\n        jep.addStandardFunctions();\n        jep.parseExpression(function);\n        String[] vars = jep.getVariables();\n        String var = \"x\";\n        if (vars.length > 1)\n            throw new IllegalArgumentException(\"The supplied function contains more than one variable.\");\n        if (vars.length == 1)\n            var = vars[0];\n        double[][] model = new double[1][amount];\n        double[] columns = new double[amount];\n        for (int i = 1; i <= amount; i++) {\n            x = lowrange + i * ((double) Math.abs(highrange - lowrange) / amount);\n            columns[i - 1] = x;\n            jep.addVariable(var, x);\n            model[0][i - 1] = jep.getValue();\n            //System.out.println(\"** Calc(\"+columns[i-1]+\") = \"+model[0][i-1]);\n        }\n        return new DefaultChartDataModel(model, columns, rows);\n    }\n\n    /**\n     * This method creates a new ChartDataModel from the computed\n     * function data. This implementation automatically uses the function\n     * as DataSet title.\n     * @param lowrange the lower x-value to begin from\n     * @param hirange the highest x-value to reach\n     * @param amount the amount of values that should be computed (2000 is\n     * a good value for smooth curves)\n     * @param function the mathematical function in Python notation\n     */\n    public static DefaultChartDataModel createChartDataModelInstance(double lowrange, double hirange, int amount, String function) {\n        return createChartDataModelInstance(lowrange, hirange, amount, function, new String[] { function });\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/FunctionPlotterTest0.java",
		"test_prompt": "// FunctionPlotterTest0.java\npackage de.progra.charting.model;\n\nimport org.nfunk.jep.JEP;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FunctionPlotter}.\n* It contains ten unit test cases for the {@link FunctionPlotter#createChartDataModelInstance(double, double, int, String, String[])} method.\n*/\nclass FunctionPlotterTest0 {"
	},
	{
		"original_code": "// FunctionPlotter.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    FunctionPlotter.java\n    Created on 7. September 2001, 17:14\n*/\npackage de.progra.charting.model;\n\nimport org.nfunk.jep.JEP;\n\n/**\n * This class can be used to create a ChartDataModel from a mathematical\n * function. A Python interpreter implemented in Java is called to calculate\n * the function values. Therefore, I didn't need to implement a parsing\n * algorithm. Of course, you need to know the Python syntax for mathematical\n * functions. The quadratical function <code>5x<sup>2</sup>-3x+4</code> e.g.\n * would be written as <code>5*x**2-3*x+4</code>. Please note, that it takes\n * approx. 1 s to plot a quadratical function like this computing 2000 single\n * values.\n * @author  mueller\n * @version 1.0\n */\npublic class FunctionPlotter {\n\n    /**\n     * Creates new FunctionPlot\n     */\n    private FunctionPlotter() {\n    }\n\n    /**\n     * This method creates a new ChartDataModel from the computed\n     * function data. In order to compute the needed values, a Python script is\n     * created using the provided parameters and is executed afterwards:<p>\n     *       <pre><code>\n     *        String pyfile = \"\" +\n     *        \"AMOUNT = \"+amount+\"\\n\"+\n     *        \"columns = []\\n\"+\n     *        \"model = []\\n\"+\n     *        \"lowrange = \"+lowrange+\"\\n\"+\n     *        \"highrange = \"+highrange+\"\\n\"+\n     *        \"for i in range(AMOUNT) :\\n\"+\n     *        \"   x = lowrange + i * (float(abs(highrange - lowrange)) / AMOUNT)\\n\"+\n     *        \"   columns.append(x)\\n\"+\n     *        \"   model.append(\"+function+\")\\n\";\n     *\n     *        interp.exec(pyfile);\n     *       </code></pre>\n     *       Finally the values are extracted via the PythonInterpreter:<p>\n     *       <pre><code>\n     *       pymodel[0] = (double[])interp.get(\"model\", double[].class);\n     *       pycolumns = (double[])interp.get(\"columns\", double[].class);\n     *       </code></pre>\n     * @param lowrange the lower x-value to begin from\n     * @param highrange the highest x-value to reach\n     * @param amount the amount of values that should be computed (2000 is\n     * a good value for smooth curves)\n     * @param function the mathematical function in Python notation\n     * @param rows the array with the DataSet title\n     * @throws IllegalArgumentException if the function contains more than\n     * one variable.\n     */\n    public static DefaultChartDataModel createChartDataModelInstance(double lowrange, double highrange, int amount, String function, String[] rows) {\n        double x = 0.0;\n        JEP jep = new JEP();\n        jep.addStandardConstants();\n        jep.addStandardFunctions();\n        jep.parseExpression(function);\n        String[] vars = jep.getVariables();\n        String var = \"x\";\n        if (vars.length > 1)\n            throw new IllegalArgumentException(\"The supplied function contains more than one variable.\");\n        if (vars.length == 1)\n            var = vars[0];\n        double[][] model = new double[1][amount];\n        double[] columns = new double[amount];\n        for (int i = 1; i <= amount; i++) {\n            x = lowrange + i * ((double) Math.abs(highrange - lowrange) / amount);\n            columns[i - 1] = x;\n            jep.addVariable(var, x);\n            model[0][i - 1] = jep.getValue();\n            //System.out.println(\"** Calc(\"+columns[i-1]+\") = \"+model[0][i-1]);\n        }\n        return new DefaultChartDataModel(model, columns, rows);\n    }\n\n    /**\n     * This method creates a new ChartDataModel from the computed\n     * function data. This implementation automatically uses the function\n     * as DataSet title.\n     * @param lowrange the lower x-value to begin from\n     * @param hirange the highest x-value to reach\n     * @param amount the amount of values that should be computed (2000 is\n     * a good value for smooth curves)\n     * @param function the mathematical function in Python notation\n     */\n    public static DefaultChartDataModel createChartDataModelInstance(double lowrange, double hirange, int amount, String function) {\n        return createChartDataModelInstance(lowrange, hirange, amount, function, new String[] { function });\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/FunctionPlotterTest1.java",
		"test_prompt": "// FunctionPlotterTest1.java\npackage de.progra.charting.model;\n\nimport org.nfunk.jep.JEP;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FunctionPlotter}.\n* It contains ten unit test cases for the {@link FunctionPlotter#createChartDataModelInstance(double, double, int, String)} method.\n*/\nclass FunctionPlotterTest1 {"
	},
	{
		"original_code": "// ChartEncoder.java\n/*\n    JOpenChart Java Charting Library and Toolkit\n    Copyright (C) 2001  Sebastian M�ller\n    http://jopenchart.sourceforge.net\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n    ChartEncoder.java\n    Created on 11. November 2001, 18:23\n */\npackage de.progra.charting;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.awt.Rectangle;\nimport java.awt.Graphics2D;\n\n/**\n * The ChartEncoder class provides several static methods to encode\n * charts to an OutputStream. It uses the Java Advanced Imaging Library\n * which is part of the JDK 1.4 release. The list of supported Image Formats\n * may vary depending on the actual release. Quoting from the current\n * webpage as of 28.1.2002: \"As of JAI-1.1.1, the latest public version of JAI,\n * the image formats supported by these ancillary codec classes are:\n * BMP, GIF (decoder only), FlashPix (decoder only), JPEG, PNG, PNM, and TIFF.\"\n * For the actual list of supported image formats call\n * <code>{@link #getSupportedFormats}</code>.\n * @author mueller\n * @version 1.0\n */\npublic class ChartEncoder {\n\n    /**\n     * Prints the JPEG encoded image to an output stream.\n     * @param os the OutputStream where the image will be printed to.\n     * @param chart the Chart which will be printed to the output stream\n     * @throws EncodingException if an error occurred accessing the Stream\n     */\n    public static void createJPEG(OutputStream os, Chart chart) throws EncodingException {\n        boolean success = true;\n        try {\n            Rectangle r = chart.getBounds();\n            BufferedImage img = new BufferedImage((int) r.getWidth(), (int) r.getHeight(), BufferedImage.TYPE_INT_RGB);\n            Graphics2D grafx = img.createGraphics();\n            chart.render(grafx);\n            success = ImageIO.write(img, \"jpeg\", os);\n            os.flush();\n        } catch (Throwable t) {\n            throw new EncodingException(t.getMessage(), t);\n        }\n        if (!success)\n            throw new EncodingException(\"No ImageWriter for writing JPEGs found.\");\n    }\n\n    /**\n     * Prints the GIF encoded image to an output stream.\n     * @param os the OutputStream where the image will be printed to.\n     * @param chart the Chart which will be printed to the output stream\n     * @throws EncodingException if an error occurred accessing the Stream\n     * @deprecated GIF encoding is no longer supported, use PNG instead\n     */\n    public static void createGIF(OutputStream os, Chart chart) throws EncodingException {\n    }\n\n    /**\n     * Prints the PNG encoded image to an output stream.\n     * @param os the OutputStream where the image will be printed to.\n     * @param chart the Chart which will be printed to the output stream\n     * @throws EncodingException if an error occurred accessing the Stream\n     */\n    public static void createPNG(OutputStream os, Chart chart) throws EncodingException {\n        boolean success = true;\n        try {\n            Rectangle r = chart.getBounds();\n            BufferedImage img = new BufferedImage((int) r.getWidth(), (int) r.getHeight(), BufferedImage.TYPE_INT_RGB);\n            Graphics2D grafx = img.createGraphics();\n            chart.render(grafx);\n            success = ImageIO.write(img, \"png\", os);\n            os.flush();\n        } catch (Throwable t) {\n            t.printStackTrace();\n            throw new EncodingException(t.getMessage(), t);\n        }\n        if (!success)\n            throw new EncodingException(\"No ImageWriter for writing PNGs found.\");\n    }\n\n    /**\n     * Prints the encoded image to an output stream.\n     * @param os the OutputStream where the image will be printed to.\n     * @param chart the Chart which will be printed to the output stream\n     * @param format the informal format name\n     * @throws EncodingException if an error occurred accessing the Stream\n     */\n    public static void createEncodedImage(OutputStream os, Chart chart, String format) throws EncodingException {\n        boolean success = true;\n        try {\n            Rectangle r = chart.getBounds();\n            BufferedImage img = new BufferedImage((int) r.getWidth(), (int) r.getHeight(), BufferedImage.TYPE_INT_RGB);\n            Graphics2D grafx = img.createGraphics();\n            chart.render(grafx);\n            success = ImageIO.write(img, format, os);\n            os.flush();\n        } catch (Throwable t) {\n            throw new EncodingException(t.getMessage(), t);\n        }\n        if (!success)\n            throw new EncodingException(\"No ImageWriter for writing \" + format + \" images found.\");\n    }\n\n    /**\n     * Returns a String array containing the informal format names for\n     * all supported image encodings.\n     */\n    public static String[] getSupportedFormats() {\n        return ImageIO.getWriterFormatNames();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartEncoderTest.java",
		"test_prompt": "// ChartEncoderTest.java\npackage de.progra.charting;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.awt.Rectangle;\nimport java.awt.Graphics2D;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChartEncoder}.\n* It contains ten unit test cases for the {@link ChartEncoder#getSupportedFormats()} method.\n*/\nclass ChartEncoderTest {"
	}
]