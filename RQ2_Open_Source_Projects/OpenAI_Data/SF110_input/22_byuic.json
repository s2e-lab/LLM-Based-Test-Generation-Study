[
	{
		"original_code": "// Parser.java\n/* ***** BEGIN LICENSE BLOCK *****\n*\n* Version: MPL 1.1\n*\n* The contents of this file are subject to the Mozilla Public License\n* Version 1.1 (the \"License\"); you may not use this file except in\n* compliance with the License. You may obtain a copy of the License\n* at http://www.mozilla.org/MPL/\n*\n* Software distributed under the License is distributed on an \"AS IS\"\n* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n* See the License for the specific language governing rights and\n* limitations under the License.\n*\n* The Original Code is org/mozilla/javascript/Parser.java,\n* a component of the Rhino Library ( http://www.mozilla.org/rhino/ )\n* This file is a modification of the Original Code developed\n* for YUI Compressor.\n*\n* The Initial Developer of the Original Code is Mozilla Foundation\n*\n* Copyright (c) 2009 Mozilla Foundation. All Rights Reserved.\n*\n* Contributor(s): Yahoo! Inc. 2009\n*\n* ***** END LICENSE BLOCK ***** */\npackage org.mozilla.javascript;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\npublic class Parser {\n\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int // mask to clear token information bits\n    CLEAR_TI_MASK = 0xFFFF, // first token of the source line\n    TI_AFTER_EOL = 1 << 16, // indicates to check for label\n    TI_CHECK_LABEL = 1 << 17;\n\n    CompilerEnvirons compilerEnv;\n\n    private ErrorReporter errorReporter;\n\n    private String sourceURI;\n\n    boolean calledByCompileFunction;\n\n    private TokenStream ts;\n\n    private int currentFlaggedToken;\n\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n\n    private String encodedSource;\n\n    // The following are per function variables and should be saved/restored\n    // during function parsing.\n    // XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n\n    Node.Scope currentScope;\n\n    private int nestingOfWith;\n\n    // map of label names into nodes\n    private Map<String, Node> labelSet;\n\n    private ObjArray loopSet;\n\n    private ObjArray loopAndSwitchSet;\n\n    private int endFlags;\n\n    // end of per function variables\n    public int getCurrentLineNumber() {\n        return ts.getLineno();\n    }\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException {\n\n        static final long serialVersionUID = 5882582646773765630L;\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {\n        return new Decompiler();\n    }\n\n    void addStrictWarning(String messageId, String messageArg) {\n        if (compilerEnv.isStrictMode())\n            addWarning(messageId, messageArg);\n    }\n\n    void addWarning(String messageId, String messageArg) {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        if (compilerEnv.reportWarningAsError()) {\n            ++syntaxErrorCount;\n            errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n        } else\n            errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId) {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId, String messageArg) {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId) {\n        addError(messageId);\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken() throws IOException {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken() throws IOException {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken() {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken() throws IOException {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken() throws IOException {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch) throws IOException {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL() throws IOException {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel() {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML() {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource() {\n        return encodedSource;\n    }\n\n    public boolean eof() {\n        return ts.eof();\n    }\n\n    boolean insideFunction() {\n        return nestingOfFunction != 0;\n    }\n\n    void pushScope(Node node) {\n        Node.Scope scopeNode = (Node.Scope) node;\n        if (scopeNode.getParentScope() != null)\n            throw Kit.codeBug();\n        scopeNode.setParent(currentScope);\n        currentScope = scopeNode;\n    }\n\n    void popScope() {\n        currentScope = currentScope.getParentScope();\n    }\n\n    private Node enterLoop(Node loopLabel, boolean doPushScope) {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        if (doPushScope) {\n            pushScope(loop);\n        }\n        return loop;\n    }\n\n    private void exitLoop(boolean doPopScope) {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n        if (doPopScope) {\n            popScope();\n        }\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno) {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch() {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse() throws IOException {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        currentScope = currentScriptOrFn;\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n        // line number where source starts\n        int baseLineno = ts.getLineno();\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n        try {\n            for (; ; ) {\n                int tt = peekToken();\n                if (tt <= Token.EOF) {\n                    break;\n                }\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(calledByCompileFunction ? FunctionNode.FUNCTION_EXPRESSION : FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\"msg.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);\n        }\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);\n        }\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);\n        nf.initScript(currentScriptOrFn, pn);\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        // It helps GC\n        this.decompiler = null;\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody() throws IOException {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (; ; ) {\n                Node n;\n                int tt = peekToken();\n                switch(tt) {\n                    case Token.ERROR:\n                    case Token.EOF:\n                    case Token.RC:\n                        break bodyLoop;\n                    case Token.FUNCTION:\n                        consumeToken();\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                        break;\n                    default:\n                        n = statement();\n                        break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n        return pn;\n    }\n\n    private Node function(int functionType) throws IOException, ParserException {\n        int syntheticType = functionType;\n        // line number where source starts\n        int baseLineno = ts.getLineno();\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n        if (syntheticType != FunctionNode.FUNCTION_EXPRESSION && name.length() > 0) {\n            // Function statements define a symbol in the enclosing scope\n            defineSymbol(Token.FUNCTION, false, name);\n        }\n        boolean nested = insideFunction();\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n        int functionSourceEnd;\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        Node.Scope savedCurrentScope = currentScope;\n        currentScope = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Map<String, Node> savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n        int savedFunctionEndFlags = endFlags;\n        endFlags = 0;\n        Node destructuring = null;\n        Node body;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    int tt = peekToken();\n                    if (tt == Token.LB || tt == Token.LC) {\n                        // Destructuring assignment for parameters: add a\n                        // dummy parameter name, and add a statement to the\n                        // body to initialize variables from the destructuring\n                        // assignment\n                        if (destructuring == null) {\n                            destructuring = new Node(Token.COMMA);\n                        }\n                        String parmName = currentScriptOrFn.getNextTempName();\n                        defineSymbol(Token.LP, false, parmName);\n                        destructuring.addChildToBack(nf.createDestructuringAssignment(Token.VAR, primaryExpr(), nf.createName(parmName)));\n                    } else {\n                        mustMatchToken(Token.NAME, \"msg.no.parm\");\n                        String s = ts.getString();\n                        defineSymbol(Token.LP, false, s);\n                        decompiler.addName(s);\n                    }\n                } while (matchToken(Token.COMMA));\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            if (destructuring != null) {\n                body.addChildToFront(new Node(Token.EXPR_VOID, destructuring, ts.getLineno()));\n            }\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n            if (compilerEnv.isStrictMode() && !body.hasConsistentReturnUsage()) {\n                String msg = name.length() > 0 ? \"msg.no.return.value\" : \"msg.anon.no.return.value\";\n                addStrictWarning(msg, name);\n            }\n            if (syntheticType == FunctionNode.FUNCTION_EXPRESSION && name.length() > 0 && currentScope.getSymbol(name) == null) {\n                // Function expressions define a name only in the body of the\n                // function, and only if not hidden by a parameter name\n                defineSymbol(Token.FUNCTION, false, name);\n            }\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        } finally {\n            endFlags = savedFunctionEndFlags;\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n            currentScope = savedCurrentScope;\n        }\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements(Node scope) throws IOException {\n        Node pn = scope != null ? scope : nf.createBlock(ts.getLineno());\n        int tt;\n        while ((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n        return pn;\n    }\n\n    private Node condition() throws IOException, ParserException {\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        Node pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n        // Report strict warning on code like \"if (a = 7) ...\". Suppress the\n        // warning if the condition is parenthesized, like \"if ((a = 7)) ...\".\n        if (pn.getProp(Node.PARENTHESIZED_PROP) == null && (pn.getType() == Token.SETNAME || pn.getType() == Token.SETPROP || pn.getType() == Token.SETELEM)) {\n            addStrictWarning(\"msg.equal.as.assign\", \"\");\n        }\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName() throws IOException, ParserException {\n        Node label = null;\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n        return label;\n    }\n\n    private Node statement() throws IOException {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                if (compilerEnv.isStrictMode() && !pn.hasSideEffects())\n                    addStrictWarning(\"msg.no.side.effects\", \"\");\n                return pn;\n            }\n        } catch (ParserException e) {\n        }\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (; ; ) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch(tt) {\n                case Token.ERROR:\n                case Token.EOF:\n                case Token.EOL:\n                case Token.SEMI:\n                    break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    private Node statementHelper(Node statementLabel) throws IOException, ParserException {\n        Node pn = null;\n        int tt = peekToken();\n        switch(tt) {\n            case Token.IF:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.IF);\n                    int lineno = ts.getLineno();\n                    Node cond = condition();\n                    decompiler.addEOL(Token.LC);\n                    Node ifTrue = statement();\n                    Node ifFalse = null;\n                    if (matchToken(Token.ELSE)) {\n                        decompiler.addToken(Token.RC);\n                        decompiler.addToken(Token.ELSE);\n                        decompiler.addEOL(Token.LC);\n                        ifFalse = statement();\n                    }\n                    decompiler.addEOL(Token.RC);\n                    pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n                    return pn;\n                }\n            case Token.SWITCH:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.SWITCH);\n                    int lineno = ts.getLineno();\n                    mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n                    decompiler.addToken(Token.LP);\n                    pn = enterSwitch(expr(false), lineno);\n                    try {\n                        mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                        decompiler.addToken(Token.RP);\n                        mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                        decompiler.addEOL(Token.LC);\n                        boolean hasDefault = false;\n                        switchLoop: for (; ; ) {\n                            tt = nextToken();\n                            Node caseExpression;\n                            switch(tt) {\n                                case Token.RC:\n                                    break switchLoop;\n                                case Token.CASE:\n                                    decompiler.addToken(Token.CASE);\n                                    caseExpression = expr(false);\n                                    mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                                    decompiler.addEOL(Token.COLON);\n                                    break;\n                                case Token.DEFAULT:\n                                    if (hasDefault) {\n                                        reportError(\"msg.double.switch.default\");\n                                    }\n                                    decompiler.addToken(Token.DEFAULT);\n                                    hasDefault = true;\n                                    caseExpression = null;\n                                    mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                                    decompiler.addEOL(Token.COLON);\n                                    break;\n                                default:\n                                    reportError(\"msg.bad.switch\");\n                                    break switchLoop;\n                            }\n                            Node block = nf.createLeaf(Token.BLOCK);\n                            while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {\n                                nf.addChildToBack(block, statement());\n                            }\n                            // caseExpression == null => add default label\n                            nf.addSwitchCase(pn, caseExpression, block);\n                        }\n                        decompiler.addEOL(Token.RC);\n                        nf.closeSwitch(pn);\n                    } finally {\n                        exitSwitch();\n                    }\n                    return pn;\n                }\n            case Token.WHILE:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.WHILE);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        Node cond = condition();\n                        decompiler.addEOL(Token.LC);\n                        Node body = statement();\n                        decompiler.addEOL(Token.RC);\n                        pn = nf.createWhile(loop, cond, body);\n                    } finally {\n                        exitLoop(true);\n                    }\n                    return pn;\n                }\n            case Token.DO:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.DO);\n                    decompiler.addEOL(Token.LC);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        Node body = statement();\n                        decompiler.addToken(Token.RC);\n                        mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                        decompiler.addToken(Token.WHILE);\n                        Node cond = condition();\n                        pn = nf.createDoWhile(loop, body, cond);\n                    } finally {\n                        exitLoop(true);\n                    }\n                    // Always auto-insert semicolon to follow SpiderMonkey:\n                    // It is required by ECMAScript but is ignored by the rest of\n                    // world, see bug 238945\n                    matchToken(Token.SEMI);\n                    decompiler.addEOL(Token.SEMI);\n                    return pn;\n                }\n            case Token.FOR:\n                {\n                    consumeToken();\n                    boolean isForEach = false;\n                    decompiler.addToken(Token.FOR);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        // Node init is also foo in 'foo in object'\n                        Node init;\n                        // Node cond is also object in 'foo in object'\n                        Node cond;\n                        Node incr = null;\n                        Node body;\n                        int declType = -1;\n                        // See if this is a for each () instead of just a for ()\n                        if (matchToken(Token.NAME)) {\n                            decompiler.addName(ts.getString());\n                            if (ts.getString().equals(\"each\")) {\n                                isForEach = true;\n                            } else {\n                                reportError(\"msg.no.paren.for\");\n                            }\n                        }\n                        mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                        decompiler.addToken(Token.LP);\n                        tt = peekToken();\n                        if (tt == Token.SEMI) {\n                            init = nf.createLeaf(Token.EMPTY);\n                        } else {\n                            if (tt == Token.VAR || tt == Token.LET) {\n                                // set init to a var list or initial\n                                // consume the token\n                                consumeToken();\n                                decompiler.addToken(tt);\n                                init = variables(true, tt);\n                                declType = tt;\n                            } else {\n                                init = expr(true);\n                            }\n                        }\n                        if (matchToken(Token.IN)) {\n                            decompiler.addToken(Token.IN);\n                            // 'cond' is the object over which we're iterating\n                            cond = expr(false);\n                        } else {\n                            // ordinary for loop\n                            mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                            decompiler.addToken(Token.SEMI);\n                            if (peekToken() == Token.SEMI) {\n                                // no loop condition\n                                cond = nf.createLeaf(Token.EMPTY);\n                            } else {\n                                cond = expr(false);\n                            }\n                            mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                            decompiler.addToken(Token.SEMI);\n                            if (peekToken() == Token.RP) {\n                                incr = nf.createLeaf(Token.EMPTY);\n                            } else {\n                                incr = expr(false);\n                            }\n                        }\n                        mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                        decompiler.addToken(Token.RP);\n                        decompiler.addEOL(Token.LC);\n                        body = statement();\n                        decompiler.addEOL(Token.RC);\n                        if (incr == null) {\n                            // cond could be null if 'in obj' got eaten\n                            // by the init node.\n                            pn = nf.createForIn(declType, loop, init, cond, body, isForEach);\n                        } else {\n                            pn = nf.createFor(loop, init, cond, incr, body);\n                        }\n                    } finally {\n                        exitLoop(true);\n                    }\n                    return pn;\n                }\n            case Token.TRY:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    Node tryblock;\n                    Node catchblocks = null;\n                    Node finallyblock = null;\n                    decompiler.addToken(Token.TRY);\n                    if (peekToken() != Token.LC) {\n                        reportError(\"msg.no.brace.try\");\n                    }\n                    decompiler.addEOL(Token.LC);\n                    tryblock = statement();\n                    decompiler.addEOL(Token.RC);\n                    catchblocks = nf.createLeaf(Token.BLOCK);\n                    boolean sawDefaultCatch = false;\n                    int peek = peekToken();\n                    if (peek == Token.CATCH) {\n                        while (matchToken(Token.CATCH)) {\n                            if (sawDefaultCatch) {\n                                reportError(\"msg.catch.unreachable\");\n                            }\n                            decompiler.addToken(Token.CATCH);\n                            mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                            decompiler.addToken(Token.LP);\n                            mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                            String varName = ts.getString();\n                            decompiler.addName(varName);\n                            Node catchCond = null;\n                            if (matchToken(Token.IF)) {\n                                decompiler.addToken(Token.IF);\n                                catchCond = expr(false);\n                            } else {\n                                sawDefaultCatch = true;\n                            }\n                            mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                            decompiler.addToken(Token.RP);\n                            mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                            decompiler.addEOL(Token.LC);\n                            nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(null), ts.getLineno()));\n                            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                            decompiler.addEOL(Token.RC);\n                        }\n                    } else if (peek != Token.FINALLY) {\n                        mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n                    }\n                    if (matchToken(Token.FINALLY)) {\n                        decompiler.addToken(Token.FINALLY);\n                        decompiler.addEOL(Token.LC);\n                        finallyblock = statement();\n                        decompiler.addEOL(Token.RC);\n                    }\n                    pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);\n                    return pn;\n                }\n            case Token.THROW:\n                {\n                    consumeToken();\n                    if (peekTokenOrEOL() == Token.EOL) {\n                        // ECMAScript does not allow new lines before throw expression,\n                        // see bug 256617\n                        reportError(\"msg.bad.throw.eol\");\n                    }\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.THROW);\n                    pn = nf.createThrow(expr(false), lineno);\n                    break;\n                }\n            case Token.BREAK:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.BREAK);\n                    // matchJumpLabelName only matches if there is one\n                    Node breakStatement = matchJumpLabelName();\n                    if (breakStatement == null) {\n                        if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                            reportError(\"msg.bad.break\");\n                            return null;\n                        }\n                        breakStatement = (Node) loopAndSwitchSet.peek();\n                    }\n                    pn = nf.createBreak(breakStatement, lineno);\n                    break;\n                }\n            case Token.CONTINUE:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.CONTINUE);\n                    Node loop;\n                    // matchJumpLabelName only matches if there is one\n                    Node label = matchJumpLabelName();\n                    if (label == null) {\n                        if (loopSet == null || loopSet.size() == 0) {\n                            reportError(\"msg.continue.outside\");\n                            return null;\n                        }\n                        loop = (Node) loopSet.peek();\n                    } else {\n                        loop = nf.getLabelLoop(label);\n                        if (loop == null) {\n                            reportError(\"msg.continue.nonloop\");\n                            return null;\n                        }\n                    }\n                    pn = nf.createContinue(loop, lineno);\n                    break;\n                }\n            case Token.WITH:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.WITH);\n                    int lineno = ts.getLineno();\n                    mustMatchToken(Token.LP, \"msg.no.paren.with\");\n                    decompiler.addToken(Token.LP);\n                    Node obj = expr(false);\n                    mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n                    decompiler.addToken(Token.RP);\n                    decompiler.addEOL(Token.LC);\n                    ++nestingOfWith;\n                    Node body;\n                    try {\n                        body = statement();\n                    } finally {\n                        --nestingOfWith;\n                    }\n                    decompiler.addEOL(Token.RC);\n                    pn = nf.createWith(obj, body, lineno);\n                    return pn;\n                }\n            case Token.CONST:\n            case Token.VAR:\n                {\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = variables(false, tt);\n                    break;\n                }\n            case Token.LET:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.LET);\n                    if (peekToken() == Token.LP) {\n                        return let(true);\n                    } else {\n                        pn = variables(false, tt);\n                        if (peekToken() == Token.SEMI)\n                            break;\n                        return pn;\n                    }\n                }\n            case Token.RETURN:\n            case Token.YIELD:\n                {\n                    pn = returnOrYield(tt, false);\n                    break;\n                }\n            case Token.DEBUGGER:\n                consumeToken();\n                decompiler.addToken(Token.DEBUGGER);\n                pn = nf.createDebugger(ts.getLineno());\n                break;\n            case Token.LC:\n                consumeToken();\n                if (statementLabel != null) {\n                    decompiler.addToken(Token.LC);\n                }\n                Node scope = nf.createScopeNode(Token.BLOCK, ts.getLineno());\n                pushScope(scope);\n                try {\n                    statements(scope);\n                    mustMatchToken(Token.RC, \"msg.no.brace.block\");\n                    if (statementLabel != null) {\n                        decompiler.addEOL(Token.RC);\n                    }\n                    return scope;\n                } finally {\n                    popScope();\n                }\n            case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n            case Token.SEMI:\n                consumeToken();\n                pn = nf.createLeaf(Token.EMPTY);\n                return pn;\n            case Token.FUNCTION:\n                {\n                    consumeToken();\n                    pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n                    return pn;\n                }\n            case Token.DEFAULT:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DEFAULT);\n                int nsLine = ts.getLineno();\n                if (!(matchToken(Token.NAME) && ts.getString().equals(\"xml\"))) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addName(\" xml\");\n                if (!(matchToken(Token.NAME) && ts.getString().equals(\"namespace\"))) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addName(\" namespace\");\n                if (!matchToken(Token.ASSIGN)) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addToken(Token.ASSIGN);\n                Node expr = expr(false);\n                pn = nf.createDefaultNamespace(expr, nsLine);\n                break;\n            case Token.NAME:\n                {\n                    int lineno = ts.getLineno();\n                    String name = ts.getString();\n                    setCheckForLabel();\n                    pn = expr(false);\n                    if (pn.getType() != Token.LABEL) {\n                        pn = nf.createExprStatement(pn, lineno);\n                    } else {\n                        // Parsed the label: push back token should be\n                        // colon that primaryExpr left untouched.\n                        if (peekToken() != Token.COLON)\n                            Kit.codeBug();\n                        consumeToken();\n                        // depend on decompiling lookahead to guess that that\n                        // last name was a label.\n                        decompiler.addName(name);\n                        decompiler.addEOL(Token.COLON);\n                        if (labelSet == null) {\n                            labelSet = new HashMap<String, Node>();\n                        } else if (labelSet.containsKey(name)) {\n                            reportError(\"msg.dup.label\");\n                        }\n                        boolean firstLabel;\n                        if (statementLabel == null) {\n                            firstLabel = true;\n                            statementLabel = pn;\n                        } else {\n                            // Discard multiple label nodes and use only\n                            // the first: it allows to simplify IRFactory\n                            firstLabel = false;\n                        }\n                        labelSet.put(name, statementLabel);\n                        try {\n                            pn = statementHelper(statementLabel);\n                        } finally {\n                            labelSet.remove(name);\n                        }\n                        if (firstLabel) {\n                            pn = nf.createLabeledStatement(statementLabel, pn);\n                        }\n                        return pn;\n                    }\n                    break;\n                }\n            default:\n                {\n                    int lineno = ts.getLineno();\n                    pn = expr(false);\n                    pn = nf.createExprStatement(pn, lineno);\n                    break;\n                }\n        }\n        int ttFlagged = peekFlaggedToken();\n        switch(ttFlagged & CLEAR_TI_MASK) {\n            case Token.SEMI:\n                // Consume ';' as a part of expression\n                consumeToken();\n                break;\n            case Token.ERROR:\n            case Token.EOF:\n            case Token.RC:\n                // Autoinsert ;\n                break;\n            default:\n                if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                    // Report error if no EOL or autoinsert ; otherwise\n                    reportError(\"msg.no.semi.stmt\");\n                }\n                break;\n        }\n        decompiler.addEOL(Token.SEMI);\n        return pn;\n    }\n\n    /**\n     * Returns whether or not the bits in the mask have changed to all set.\n     * @param before bits before change\n     * @param after bits after change\n     * @param mask mask for bits\n     * @return true if all the bits in the mask are set in \"after\" but not\n     *              \"before\"\n     */\n    private static final boolean nowAllSet(int before, int after, int mask) {\n        return ((before & mask) != mask) && ((after & mask) == mask);\n    }\n\n    private Node returnOrYield(int tt, boolean exprContext) throws IOException, ParserException {\n        if (!insideFunction()) {\n            reportError(tt == Token.RETURN ? \"msg.bad.return\" : \"msg.bad.yield\");\n        }\n        consumeToken();\n        decompiler.addToken(tt);\n        int lineno = ts.getLineno();\n        Node e;\n        /* This is ugly, but we don't want to require a semicolon. */\n        switch(peekTokenOrEOL()) {\n            case Token.SEMI:\n            case Token.RC:\n            case Token.EOF:\n            case Token.EOL:\n            case Token.ERROR:\n            case Token.RB:\n            case Token.RP:\n            case Token.YIELD:\n                e = null;\n                break;\n            default:\n                e = expr(false);\n                break;\n        }\n        int before = endFlags;\n        Node ret;\n        if (tt == Token.RETURN) {\n            if (e == null) {\n                endFlags |= Node.END_RETURNS;\n            } else {\n                endFlags |= Node.END_RETURNS_VALUE;\n            }\n            ret = nf.createReturn(e, lineno);\n            // see if we need a strict mode warning\n            if (nowAllSet(before, endFlags, Node.END_RETURNS | Node.END_RETURNS_VALUE)) {\n                addStrictWarning(\"msg.return.inconsistent\", \"\");\n            }\n        } else {\n            endFlags |= Node.END_YIELDS;\n            ret = nf.createYield(e, lineno);\n            if (!exprContext)\n                ret = new Node(Token.EXPR_VOID, ret, lineno);\n        }\n        // see if we are mixing yields and value returns.\n        if (nowAllSet(before, endFlags, Node.END_YIELDS | Node.END_RETURNS_VALUE)) {\n            String name = ((FunctionNode) currentScriptOrFn).getFunctionName();\n            if (name.length() == 0)\n                addError(\"msg.anon.generator.returns\", \"\");\n            else\n                addError(\"msg.generator.returns\", name);\n        }\n        return ret;\n    }\n\n    /**\n     * Parse a 'var' or 'const' statement, or a 'var' init list in a for\n     * statement.\n     * @param inFor true if we are currently in the midst of the init\n     * clause of a for.\n     * @param declType A token value: either VAR, CONST, or LET depending on\n     * context.\n     * @return The parsed statement\n     * @throws IOException\n     * @throws ParserException\n     */\n    private Node variables(boolean inFor, int declType) throws IOException, ParserException {\n        Node result = nf.createVariables(declType, ts.getLineno());\n        boolean first = true;\n        for (; ; ) {\n            Node destructuring = null;\n            String s = null;\n            int tt = peekToken();\n            if (tt == Token.LB || tt == Token.LC) {\n                // Destructuring assignment, e.g., var [a,b] = ...\n                destructuring = primaryExpr();\n            } else {\n                // Simple variable name\n                mustMatchToken(Token.NAME, \"msg.bad.var\");\n                s = ts.getString();\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                decompiler.addName(s);\n                defineSymbol(declType, inFor, s);\n            }\n            Node init = null;\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n                init = assignExpr(inFor);\n            }\n            if (destructuring != null) {\n                if (init == null) {\n                    if (!inFor)\n                        reportError(\"msg.destruct.assign.no.init\");\n                    nf.addChildToBack(result, destructuring);\n                } else {\n                    nf.addChildToBack(result, nf.createDestructuringAssignment(declType, destructuring, init));\n                }\n            } else {\n                Node name = nf.createName(s);\n                if (init != null)\n                    nf.addChildToBack(name, init);\n                nf.addChildToBack(result, name);\n            }\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return result;\n    }\n\n    private Node let(boolean isStatement) throws IOException, ParserException {\n        mustMatchToken(Token.LP, \"msg.no.paren.after.let\");\n        decompiler.addToken(Token.LP);\n        Node result = nf.createScopeNode(Token.LET, ts.getLineno());\n        pushScope(result);\n        try {\n            Node vars = variables(false, Token.LET);\n            nf.addChildToBack(result, vars);\n            mustMatchToken(Token.RP, \"msg.no.paren.let\");\n            decompiler.addToken(Token.RP);\n            if (isStatement && peekToken() == Token.LC) {\n                // let statement\n                consumeToken();\n                decompiler.addEOL(Token.LC);\n                nf.addChildToBack(result, statements(null));\n                mustMatchToken(Token.RC, \"msg.no.curly.let\");\n                decompiler.addToken(Token.RC);\n            } else {\n                // let expression\n                result.setType(Token.LETEXPR);\n                nf.addChildToBack(result, expr(false));\n                if (isStatement) {\n                    // let expression in statement context\n                    result = nf.createExprStatement(result, ts.getLineno());\n                }\n            }\n        } finally {\n            popScope();\n        }\n        return result;\n    }\n\n    void defineSymbol(int declType, boolean ignoreNotInBlock, String name) {\n        Node.Scope definingScope = currentScope.getDefiningScope(name);\n        Node.Scope.Symbol symbol = definingScope != null ? definingScope.getSymbol(name) : null;\n        boolean error = false;\n        if (symbol != null && (symbol.declType == Token.CONST || declType == Token.CONST)) {\n            error = true;\n        } else {\n            switch(declType) {\n                case Token.LET:\n                    if (symbol != null && definingScope == currentScope) {\n                        error = symbol.declType == Token.LET;\n                    }\n                    int currentScopeType = currentScope.getType();\n                    if (!ignoreNotInBlock && ((currentScopeType == Token.LOOP) || (currentScopeType == Token.IF))) {\n                        addError(\"msg.let.decl.not.in.block\");\n                    }\n                    currentScope.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    break;\n                case Token.VAR:\n                case Token.CONST:\n                case Token.FUNCTION:\n                    if (symbol != null) {\n                        if (symbol.declType == Token.VAR)\n                            addStrictWarning(\"msg.var.redecl\", name);\n                        else if (symbol.declType == Token.LP) {\n                            addStrictWarning(\"msg.var.hides.arg\", name);\n                        }\n                    } else {\n                        currentScriptOrFn.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    }\n                    break;\n                case Token.LP:\n                    if (symbol != null) {\n                        // must be duplicate parameter. Second parameter hides the\n                        // first, so go ahead and add the second pararameter\n                        addWarning(\"msg.dup.parms\", name);\n                    }\n                    currentScriptOrFn.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    break;\n                default:\n                    throw Kit.codeBug();\n            }\n        }\n        if (error) {\n            addError(symbol.declType == Token.CONST ? \"msg.const.redecl\" : symbol.declType == Token.LET ? \"msg.let.redecl\" : symbol.declType == Token.VAR ? \"msg.var.redecl\" : symbol.declType == Token.FUNCTION ? \"msg.fn.redecl\" : \"msg.parm.redecl\", name);\n        }\n    }\n\n    private Node expr(boolean inForInit) throws IOException, ParserException {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            if (compilerEnv.isStrictMode() && !pn.hasSideEffects())\n                addStrictWarning(\"msg.no.side.effects\", \"\");\n            if (peekToken() == Token.YIELD) {\n                reportError(\"msg.yield.parenthesized\");\n            }\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit) throws IOException, ParserException {\n        int tt = peekToken();\n        if (tt == Token.YIELD) {\n            consumeToken();\n            return returnOrYield(tt, true);\n        }\n        Node pn = condExpr(inForInit);\n        tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = orExpr(inForInit);\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            Node ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            Node ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = relExpr(inForInit);\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.EQ:\n                case Token.NE:\n                case Token.SHEQ:\n                case Token.SHNE:\n                    consumeToken();\n                    int decompilerToken = tt;\n                    int parseToken = tt;\n                    if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                        // JavaScript 1.2 uses shallow equality for == and != .\n                        // In addition, convert === and !== for decompiler into\n                        // == and != since the decompiler is supposed to show\n                        // canonical source and in 1.2 ===, !== are allowed\n                        // only as an alias to ==, !=.\n                        switch(tt) {\n                            case Token.EQ:\n                                parseToken = Token.SHEQ;\n                                break;\n                            case Token.NE:\n                                parseToken = Token.SHNE;\n                                break;\n                            case Token.SHEQ:\n                                decompilerToken = Token.EQ;\n                                break;\n                            case Token.SHNE:\n                                decompilerToken = Token.NE;\n                                break;\n                        }\n                    }\n                    decompiler.addToken(decompilerToken);\n                    pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = shiftExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.IN:\n                    if (inForInit)\n                        break;\n                // fall through\n                case Token.INSTANCEOF:\n                case Token.LE:\n                case Token.LT:\n                case Token.GE:\n                case Token.GT:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, shiftExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr() throws IOException, ParserException {\n        Node pn = addExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.LSH:\n                case Token.URSH:\n                case Token.RSH:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, addExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr() throws IOException, ParserException {\n        Node pn = mulExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node mulExpr() throws IOException, ParserException {\n        Node pn = unaryExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.MUL:\n                case Token.DIV:\n                case Token.MOD:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, unaryExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node unaryExpr() throws IOException, ParserException {\n        int tt;\n        tt = peekToken();\n        switch(tt) {\n            case Token.VOID:\n            case Token.NOT:\n            case Token.BITNOT:\n            case Token.TYPEOF:\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createUnary(tt, unaryExpr());\n            case Token.ADD:\n                consumeToken();\n                // Convert to special POS token in decompiler and parse tree\n                decompiler.addToken(Token.POS);\n                return nf.createUnary(Token.POS, unaryExpr());\n            case Token.SUB:\n                consumeToken();\n                // Convert to special NEG token in decompiler and parse tree\n                decompiler.addToken(Token.NEG);\n                return nf.createUnary(Token.NEG, unaryExpr());\n            case Token.INC:\n            case Token.DEC:\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, false, memberExpr(true));\n            case Token.DELPROP:\n                consumeToken();\n                decompiler.addToken(Token.DELPROP);\n                return nf.createUnary(Token.DELPROP, unaryExpr());\n            case Token.ERROR:\n                consumeToken();\n                break;\n            // XML stream encountered in expression.\n            case Token.LT:\n                if (compilerEnv.isXmlAvailable()) {\n                    consumeToken();\n                    Node pn = xmlInitializer();\n                    return memberExprTail(true, pn);\n                }\n            // Fall thru to the default handling of RELOP\n            default:\n                Node pn = memberExpr(true);\n                // Don't look across a newline boundary for a postfix incop.\n                tt = peekTokenOrEOL();\n                if (tt == Token.INC || tt == Token.DEC) {\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    return nf.createIncDec(tt, true, pn);\n                }\n                return pn;\n        }\n        // Only reached on error.Try to continue.\n        return nf.createName(\"error\");\n    }\n\n    private Node xmlInitializer() throws IOException {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n        pn = null;\n        Node expr;\n        for (; ; tt = ts.getNextXMLToken()) {\n            switch(tt) {\n                case Token.XML:\n                    xml = ts.getString();\n                    decompiler.addName(xml);\n                    mustMatchToken(Token.LC, \"msg.syntax\");\n                    decompiler.addToken(Token.LC);\n                    expr = (peekToken() == Token.RC) ? nf.createString(\"\") : expr(false);\n                    mustMatchToken(Token.RC, \"msg.syntax\");\n                    decompiler.addToken(Token.RC);\n                    if (pn == null) {\n                        pn = nf.createString(xml);\n                    } else {\n                        pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                    }\n                    if (ts.isXMLAttribute()) {\n                        /* Need to put the result in double quotes */\n                        expr = nf.createUnary(Token.ESCXMLATTR, expr);\n                        Node prepend = nf.createBinary(Token.ADD, nf.createString(\"\\\"\"), expr);\n                        expr = nf.createBinary(Token.ADD, prepend, nf.createString(\"\\\"\"));\n                    } else {\n                        expr = nf.createUnary(Token.ESCXMLTEXT, expr);\n                    }\n                    pn = nf.createBinary(Token.ADD, pn, expr);\n                    break;\n                case Token.XMLEND:\n                    xml = ts.getString();\n                    decompiler.addName(xml);\n                    if (pn == null) {\n                        pn = nf.createString(xml);\n                    } else {\n                        pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                    }\n                    nf.addChildToBack(pnXML, pn);\n                    return pnXML;\n                default:\n                    reportError(\"msg.syntax\");\n                    return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode) throws IOException, ParserException {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                if (peekToken() == Token.YIELD) {\n                    reportError(\"msg.yield.parenthesized\");\n                }\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {\n        int tt;\n        Node pn;\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {\n        tailLoop: for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.DOT:\n                case Token.DOTDOT:\n                    {\n                        int memberTypeFlags;\n                        String s;\n                        consumeToken();\n                        decompiler.addToken(tt);\n                        memberTypeFlags = 0;\n                        if (tt == Token.DOTDOT) {\n                            mustHaveXML();\n                            memberTypeFlags = Node.DESCENDANTS_FLAG;\n                        }\n                        if (!compilerEnv.isXmlAvailable()) {\n                            mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                            s = ts.getString();\n                            decompiler.addName(s);\n                            pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                            break;\n                        }\n                        tt = nextToken();\n                        switch(tt) {\n                            // needed for generator.throw();\n                            case Token.THROW:\n                                decompiler.addName(\"throw\");\n                                pn = propertyName(pn, \"throw\", memberTypeFlags);\n                                break;\n                            // handles: name, ns::name, ns::*, ns::[expr]\n                            case Token.NAME:\n                                s = ts.getString();\n                                decompiler.addName(s);\n                                pn = propertyName(pn, s, memberTypeFlags);\n                                break;\n                            // handles: *, *::name, *::*, *::[expr]\n                            case Token.MUL:\n                                decompiler.addName(\"*\");\n                                pn = propertyName(pn, \"*\", memberTypeFlags);\n                                break;\n                            // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                            //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                            case Token.XMLATTR:\n                                decompiler.addToken(Token.XMLATTR);\n                                pn = attributeAccess(pn, memberTypeFlags);\n                                break;\n                            default:\n                                reportError(\"msg.no.name.after.dot\");\n                        }\n                    }\n                    break;\n                case Token.DOTQUERY:\n                    consumeToken();\n                    mustHaveXML();\n                    decompiler.addToken(Token.DOTQUERY);\n                    pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                    mustMatchToken(Token.RP, \"msg.no.paren\");\n                    decompiler.addToken(Token.RP);\n                    break;\n                case Token.LB:\n                    consumeToken();\n                    decompiler.addToken(Token.LB);\n                    pn = nf.createElementGet(pn, null, expr(false), 0);\n                    mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                    decompiler.addToken(Token.RB);\n                    break;\n                case Token.LP:\n                    if (!allowCallSyntax) {\n                        break tailLoop;\n                    }\n                    consumeToken();\n                    decompiler.addToken(Token.LP);\n                    pn = nf.createCallOrNew(Token.CALL, pn);\n                    /* Add the arguments to pn, if any are supplied. */\n                    argumentList(pn);\n                    break;\n                default:\n                    break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n        switch(tt) {\n            // handles: @name, @ns::name, @ns::*, @ns::[expr]\n            case Token.NAME:\n                {\n                    String s = ts.getString();\n                    decompiler.addName(s);\n                    pn = propertyName(pn, s, memberTypeFlags);\n                }\n                break;\n            // handles: @*, @*::name, @*::*, @*::[expr]\n            case Token.MUL:\n                decompiler.addName(\"*\");\n                pn = propertyName(pn, \"*\", memberTypeFlags);\n                break;\n            // handles @[expr]\n            case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n            default:\n                reportError(\"msg.no.name.after.xmlAttr\");\n                pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n                break;\n        }\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n            int tt = nextToken();\n            switch(tt) {\n                // handles name::name\n                case Token.NAME:\n                    name = ts.getString();\n                    decompiler.addName(name);\n                    break;\n                // handles name::*\n                case Token.MUL:\n                    decompiler.addName(\"*\");\n                    name = \"*\";\n                    break;\n                // handles name::[expr]\n                case Token.LB:\n                    decompiler.addToken(Token.LB);\n                    pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);\n                    mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                    decompiler.addToken(Token.RB);\n                    return pn;\n                default:\n                    reportError(\"msg.no.name.after.coloncolon\");\n                    name = \"?\";\n            }\n        }\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node arrayComprehension(String arrayName, Node expr) throws IOException, ParserException {\n        if (nextToken() != Token.FOR)\n            // shouldn't be here if next token isn't 'for'\n            throw Kit.codeBug();\n        // space after array literal expr\n        decompiler.addName(\" \");\n        decompiler.addToken(Token.FOR);\n        boolean isForEach = false;\n        if (matchToken(Token.NAME)) {\n            decompiler.addName(ts.getString());\n            if (ts.getString().equals(\"each\")) {\n                isForEach = true;\n            } else {\n                reportError(\"msg.no.paren.for\");\n            }\n        }\n        mustMatchToken(Token.LP, \"msg.no.paren.for\");\n        decompiler.addToken(Token.LP);\n        String name;\n        int tt = peekToken();\n        if (tt == Token.LB || tt == Token.LC) {\n            // handle destructuring assignment\n            name = currentScriptOrFn.getNextTempName();\n            defineSymbol(Token.LP, false, name);\n            expr = nf.createBinary(Token.COMMA, nf.createAssignment(Token.ASSIGN, primaryExpr(), nf.createName(name)), expr);\n        } else if (tt == Token.NAME) {\n            consumeToken();\n            name = ts.getString();\n            decompiler.addName(name);\n        } else {\n            reportError(\"msg.bad.var\");\n            return nf.createNumber(0);\n        }\n        Node init = nf.createName(name);\n        // Define as a let since we want the scope of the variable to\n        // be restricted to the array comprehension\n        defineSymbol(Token.LET, false, name);\n        mustMatchToken(Token.IN, \"msg.in.after.for.name\");\n        decompiler.addToken(Token.IN);\n        Node iterator = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n        decompiler.addToken(Token.RP);\n        Node body;\n        tt = peekToken();\n        if (tt == Token.FOR) {\n            body = arrayComprehension(arrayName, expr);\n        } else {\n            Node call = nf.createCallOrNew(Token.CALL, nf.createPropertyGet(nf.createName(arrayName), null, \"push\", 0));\n            call.addChildToBack(expr);\n            body = new Node(Token.EXPR_VOID, call, ts.getLineno());\n            if (tt == Token.IF) {\n                consumeToken();\n                decompiler.addToken(Token.IF);\n                int lineno = ts.getLineno();\n                Node cond = condition();\n                body = nf.createIf(cond, body, null, lineno);\n            }\n            mustMatchToken(Token.RB, \"msg.no.bracket.arg\");\n            decompiler.addToken(Token.RB);\n        }\n        Node loop = enterLoop(null, true);\n        try {\n            return nf.createForIn(Token.LET, loop, init, iterator, body, isForEach);\n        } finally {\n            exitLoop(false);\n        }\n    }\n\n    private Node primaryExpr() throws IOException, ParserException {\n        Node pn;\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n        switch(tt) {\n            case Token.FUNCTION:\n                return function(FunctionNode.FUNCTION_EXPRESSION);\n            case Token.LB:\n                {\n                    ObjArray elems = new ObjArray();\n                    int skipCount = 0;\n                    int destructuringLen = 0;\n                    decompiler.addToken(Token.LB);\n                    boolean after_lb_or_comma = true;\n                    for (; ; ) {\n                        tt = peekToken();\n                        if (tt == Token.COMMA) {\n                            consumeToken();\n                            decompiler.addToken(Token.COMMA);\n                            if (!after_lb_or_comma) {\n                                after_lb_or_comma = true;\n                            } else {\n                                elems.add(null);\n                                ++skipCount;\n                            }\n                        } else if (tt == Token.RB) {\n                            consumeToken();\n                            decompiler.addToken(Token.RB);\n                            // for ([a,] in obj) is legal, but for ([a] in obj) is\n                            // not since we have both key and value supplied. The\n                            // trick is that [a,] and [a] are equivalent in other\n                            // array literal contexts. So we calculate a special\n                            // length value just for destructuring assignment.\n                            destructuringLen = elems.size() + (after_lb_or_comma ? 1 : 0);\n                            break;\n                        } else if (skipCount == 0 && elems.size() == 1 && tt == Token.FOR) {\n                            Node scopeNode = nf.createScopeNode(Token.ARRAYCOMP, ts.getLineno());\n                            String tempName = currentScriptOrFn.getNextTempName();\n                            pushScope(scopeNode);\n                            try {\n                                defineSymbol(Token.LET, false, tempName);\n                                Node expr = (Node) elems.get(0);\n                                Node block = nf.createBlock(ts.getLineno());\n                                Node init = new Node(Token.EXPR_VOID, nf.createAssignment(Token.ASSIGN, nf.createName(tempName), nf.createCallOrNew(Token.NEW, nf.createName(\"Array\"))), ts.getLineno());\n                                block.addChildToBack(init);\n                                block.addChildToBack(arrayComprehension(tempName, expr));\n                                scopeNode.addChildToBack(block);\n                                scopeNode.addChildToBack(nf.createName(tempName));\n                                return scopeNode;\n                            } finally {\n                                popScope();\n                            }\n                        } else {\n                            if (!after_lb_or_comma) {\n                                reportError(\"msg.no.bracket.arg\");\n                            }\n                            elems.add(assignExpr(false));\n                            after_lb_or_comma = false;\n                        }\n                    }\n                    return nf.createArrayLiteral(elems, skipCount, destructuringLen);\n                }\n            case Token.LC:\n                {\n                    ObjArray elems = new ObjArray();\n                    decompiler.addToken(Token.LC);\n                    if (!matchToken(Token.RC)) {\n                        boolean first = true;\n                        commaloop: do {\n                            Object property;\n                            if (!first)\n                                decompiler.addToken(Token.COMMA);\n                            else\n                                first = false;\n                            tt = peekToken();\n                            switch(tt) {\n                                case Token.NAME:\n                                case Token.STRING:\n                                    consumeToken();\n                                    // map NAMEs to STRINGs in object literal context\n                                    // but tell the decompiler the proper type\n                                    String s = ts.getString();\n                                    if (tt == Token.NAME) {\n                                        if (s.equals(\"get\") && peekToken() == Token.NAME) {\n                                            decompiler.addToken(Token.GET);\n                                            consumeToken();\n                                            s = ts.getString();\n                                            decompiler.addName(s);\n                                            property = ScriptRuntime.getIndexObject(s);\n                                            if (!getterSetterProperty(elems, property, true))\n                                                break commaloop;\n                                            break;\n                                        } else if (s.equals(\"set\") && peekToken() == Token.NAME) {\n                                            decompiler.addToken(Token.SET);\n                                            consumeToken();\n                                            s = ts.getString();\n                                            decompiler.addName(s);\n                                            property = ScriptRuntime.getIndexObject(s);\n                                            if (!getterSetterProperty(elems, property, false))\n                                                break commaloop;\n                                            break;\n                                        }\n                                        decompiler.addName(s);\n                                    } else {\n                                        decompiler.addString(s);\n                                    }\n                                    property = ScriptRuntime.getIndexObject(s);\n                                    plainProperty(elems, property);\n                                    break;\n                                case Token.NUMBER:\n                                    consumeToken();\n                                    double n = ts.getNumber();\n                                    decompiler.addNumber(n);\n                                    property = ScriptRuntime.getIndexObject(n);\n                                    plainProperty(elems, property);\n                                    break;\n                                case Token.RC:\n                                    // trailing comma is OK.\n                                    break commaloop;\n                                default:\n                                    reportError(\"msg.bad.prop\");\n                                    break commaloop;\n                            }\n                        } while (matchToken(Token.COMMA));\n                        mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n                    }\n                    decompiler.addToken(Token.RC);\n                    return nf.createObjectLiteral(elems);\n                }\n            case Token.LET:\n                decompiler.addToken(Token.LET);\n                return let(false);\n            case Token.LP:\n                /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n                decompiler.addToken(Token.LP);\n                pn = expr(false);\n                pn.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                return pn;\n            case Token.XMLATTR:\n                mustHaveXML();\n                decompiler.addToken(Token.XMLATTR);\n                pn = attributeAccess(null, 0);\n                return pn;\n            case Token.NAME:\n                {\n                    String name = ts.getString();\n                    if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                        if (peekToken() == Token.COLON) {\n                            // Do not consume colon, it is used as unwind indicator\n                            // to return to statementHelper.\n                            // XXX Better way?\n                            return nf.createLabel(ts.getLineno());\n                        }\n                    }\n                    decompiler.addName(name);\n                    if (compilerEnv.isXmlAvailable()) {\n                        pn = propertyName(null, name, 0);\n                    } else {\n                        pn = nf.createName(name);\n                    }\n                    return pn;\n                }\n            case Token.NUMBER:\n                {\n                    double n = ts.getNumber();\n                    decompiler.addNumber(n);\n                    return nf.createNumber(n);\n                }\n            case Token.STRING:\n                {\n                    String s = ts.getString();\n                    decompiler.addString(s);\n                    return nf.createString(s);\n                }\n            case Token.DIV:\n            case Token.ASSIGN_DIV:\n                {\n                    // Got / or /= which should be treated as regexp in fact\n                    ts.readRegExp(tt);\n                    String flags = ts.regExpFlags;\n                    ts.regExpFlags = null;\n                    String re = ts.getString();\n                    decompiler.addRegexp(re, flags);\n                    int index = currentScriptOrFn.addRegexp(re, flags);\n                    return nf.createRegExp(index);\n                }\n            case Token.NULL:\n            case Token.THIS:\n            case Token.FALSE:\n            case Token.TRUE:\n                decompiler.addToken(tt);\n                return nf.createLeaf(tt);\n            case Token.RESERVED:\n                reportError(\"msg.reserved.id\");\n                break;\n            case Token.ERROR:\n                /* the scanner or one of its subroutines reported the error. */\n                break;\n            case Token.EOF:\n                reportError(\"msg.unexpected.eof\");\n                break;\n            case Token.CONDCOMMENT:\n                String condComment = ts.getString();\n                decompiler.addJScriptConditionalComment(condComment);\n                return nf.createString(condComment);\n            case Token.KEEPCOMMENT:\n                String keepComment = ts.getString();\n                decompiler.addPreservedComment(keepComment);\n                return nf.createString(keepComment);\n            default:\n                reportError(\"msg.syntax\");\n                break;\n        }\n        // should never reach here\n        return null;\n    }\n\n    private void plainProperty(ObjArray elems, Object property) throws IOException {\n        mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n        // OBJLIT is used as ':' in object literal for\n        // decompilation to solve spacing ambiguity.\n        decompiler.addToken(Token.OBJECTLIT);\n        elems.add(property);\n        elems.add(assignExpr(false));\n    }\n\n    private boolean getterSetterProperty(ObjArray elems, Object property, boolean isGetter) throws IOException {\n        Node f = function(FunctionNode.FUNCTION_EXPRESSION);\n        if (f.getType() != Token.FUNCTION) {\n            reportError(\"msg.bad.prop\");\n            return false;\n        }\n        int fnIndex = f.getExistingIntProp(Node.FUNCTION_PROP);\n        FunctionNode fn = currentScriptOrFn.getFunctionNode(fnIndex);\n        if (fn.getFunctionName().length() != 0) {\n            reportError(\"msg.bad.prop\");\n            return false;\n        }\n        elems.add(property);\n        if (isGetter) {\n            elems.add(nf.createUnary(Token.GET, f));\n        } else {\n            elems.add(nf.createUnary(Token.SET, f));\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/22_byuic/src/main/java/org/mozilla/javascript/ParserTest0.java",
		"test_prompt": "// ParserTest0.java\npackage org.mozilla.javascript;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Parser}.\n* It contains ten unit test cases for the {@link Parser#eof()} method.\n*/\nclass ParserTest0 {"
	},
	{
		"original_code": "// Parser.java\n/* ***** BEGIN LICENSE BLOCK *****\n*\n* Version: MPL 1.1\n*\n* The contents of this file are subject to the Mozilla Public License\n* Version 1.1 (the \"License\"); you may not use this file except in\n* compliance with the License. You may obtain a copy of the License\n* at http://www.mozilla.org/MPL/\n*\n* Software distributed under the License is distributed on an \"AS IS\"\n* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n* See the License for the specific language governing rights and\n* limitations under the License.\n*\n* The Original Code is org/mozilla/javascript/Parser.java,\n* a component of the Rhino Library ( http://www.mozilla.org/rhino/ )\n* This file is a modification of the Original Code developed\n* for YUI Compressor.\n*\n* The Initial Developer of the Original Code is Mozilla Foundation\n*\n* Copyright (c) 2009 Mozilla Foundation. All Rights Reserved.\n*\n* Contributor(s): Yahoo! Inc. 2009\n*\n* ***** END LICENSE BLOCK ***** */\npackage org.mozilla.javascript;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\npublic class Parser {\n\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int // mask to clear token information bits\n    CLEAR_TI_MASK = 0xFFFF, // first token of the source line\n    TI_AFTER_EOL = 1 << 16, // indicates to check for label\n    TI_CHECK_LABEL = 1 << 17;\n\n    CompilerEnvirons compilerEnv;\n\n    private ErrorReporter errorReporter;\n\n    private String sourceURI;\n\n    boolean calledByCompileFunction;\n\n    private TokenStream ts;\n\n    private int currentFlaggedToken;\n\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n\n    private String encodedSource;\n\n    // The following are per function variables and should be saved/restored\n    // during function parsing.\n    // XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n\n    Node.Scope currentScope;\n\n    private int nestingOfWith;\n\n    // map of label names into nodes\n    private Map<String, Node> labelSet;\n\n    private ObjArray loopSet;\n\n    private ObjArray loopAndSwitchSet;\n\n    private int endFlags;\n\n    // end of per function variables\n    public int getCurrentLineNumber() {\n        return ts.getLineno();\n    }\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException {\n\n        static final long serialVersionUID = 5882582646773765630L;\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {\n        return new Decompiler();\n    }\n\n    void addStrictWarning(String messageId, String messageArg) {\n        if (compilerEnv.isStrictMode())\n            addWarning(messageId, messageArg);\n    }\n\n    void addWarning(String messageId, String messageArg) {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        if (compilerEnv.reportWarningAsError()) {\n            ++syntaxErrorCount;\n            errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n        } else\n            errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId) {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId, String messageArg) {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId) {\n        addError(messageId);\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken() throws IOException {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken() throws IOException {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken() {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken() throws IOException {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken() throws IOException {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch) throws IOException {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL() throws IOException {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel() {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML() {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource() {\n        return encodedSource;\n    }\n\n    public boolean eof() {\n        return ts.eof();\n    }\n\n    boolean insideFunction() {\n        return nestingOfFunction != 0;\n    }\n\n    void pushScope(Node node) {\n        Node.Scope scopeNode = (Node.Scope) node;\n        if (scopeNode.getParentScope() != null)\n            throw Kit.codeBug();\n        scopeNode.setParent(currentScope);\n        currentScope = scopeNode;\n    }\n\n    void popScope() {\n        currentScope = currentScope.getParentScope();\n    }\n\n    private Node enterLoop(Node loopLabel, boolean doPushScope) {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        if (doPushScope) {\n            pushScope(loop);\n        }\n        return loop;\n    }\n\n    private void exitLoop(boolean doPopScope) {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n        if (doPopScope) {\n            popScope();\n        }\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno) {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch() {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse() throws IOException {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        currentScope = currentScriptOrFn;\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n        // line number where source starts\n        int baseLineno = ts.getLineno();\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n        try {\n            for (; ; ) {\n                int tt = peekToken();\n                if (tt <= Token.EOF) {\n                    break;\n                }\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(calledByCompileFunction ? FunctionNode.FUNCTION_EXPRESSION : FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\"msg.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);\n        }\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);\n        }\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);\n        nf.initScript(currentScriptOrFn, pn);\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        // It helps GC\n        this.decompiler = null;\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody() throws IOException {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (; ; ) {\n                Node n;\n                int tt = peekToken();\n                switch(tt) {\n                    case Token.ERROR:\n                    case Token.EOF:\n                    case Token.RC:\n                        break bodyLoop;\n                    case Token.FUNCTION:\n                        consumeToken();\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                        break;\n                    default:\n                        n = statement();\n                        break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n        return pn;\n    }\n\n    private Node function(int functionType) throws IOException, ParserException {\n        int syntheticType = functionType;\n        // line number where source starts\n        int baseLineno = ts.getLineno();\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n        if (syntheticType != FunctionNode.FUNCTION_EXPRESSION && name.length() > 0) {\n            // Function statements define a symbol in the enclosing scope\n            defineSymbol(Token.FUNCTION, false, name);\n        }\n        boolean nested = insideFunction();\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n        int functionSourceEnd;\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        Node.Scope savedCurrentScope = currentScope;\n        currentScope = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Map<String, Node> savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n        int savedFunctionEndFlags = endFlags;\n        endFlags = 0;\n        Node destructuring = null;\n        Node body;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    int tt = peekToken();\n                    if (tt == Token.LB || tt == Token.LC) {\n                        // Destructuring assignment for parameters: add a\n                        // dummy parameter name, and add a statement to the\n                        // body to initialize variables from the destructuring\n                        // assignment\n                        if (destructuring == null) {\n                            destructuring = new Node(Token.COMMA);\n                        }\n                        String parmName = currentScriptOrFn.getNextTempName();\n                        defineSymbol(Token.LP, false, parmName);\n                        destructuring.addChildToBack(nf.createDestructuringAssignment(Token.VAR, primaryExpr(), nf.createName(parmName)));\n                    } else {\n                        mustMatchToken(Token.NAME, \"msg.no.parm\");\n                        String s = ts.getString();\n                        defineSymbol(Token.LP, false, s);\n                        decompiler.addName(s);\n                    }\n                } while (matchToken(Token.COMMA));\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            if (destructuring != null) {\n                body.addChildToFront(new Node(Token.EXPR_VOID, destructuring, ts.getLineno()));\n            }\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n            if (compilerEnv.isStrictMode() && !body.hasConsistentReturnUsage()) {\n                String msg = name.length() > 0 ? \"msg.no.return.value\" : \"msg.anon.no.return.value\";\n                addStrictWarning(msg, name);\n            }\n            if (syntheticType == FunctionNode.FUNCTION_EXPRESSION && name.length() > 0 && currentScope.getSymbol(name) == null) {\n                // Function expressions define a name only in the body of the\n                // function, and only if not hidden by a parameter name\n                defineSymbol(Token.FUNCTION, false, name);\n            }\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        } finally {\n            endFlags = savedFunctionEndFlags;\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n            currentScope = savedCurrentScope;\n        }\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements(Node scope) throws IOException {\n        Node pn = scope != null ? scope : nf.createBlock(ts.getLineno());\n        int tt;\n        while ((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n        return pn;\n    }\n\n    private Node condition() throws IOException, ParserException {\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        Node pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n        // Report strict warning on code like \"if (a = 7) ...\". Suppress the\n        // warning if the condition is parenthesized, like \"if ((a = 7)) ...\".\n        if (pn.getProp(Node.PARENTHESIZED_PROP) == null && (pn.getType() == Token.SETNAME || pn.getType() == Token.SETPROP || pn.getType() == Token.SETELEM)) {\n            addStrictWarning(\"msg.equal.as.assign\", \"\");\n        }\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName() throws IOException, ParserException {\n        Node label = null;\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n        return label;\n    }\n\n    private Node statement() throws IOException {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                if (compilerEnv.isStrictMode() && !pn.hasSideEffects())\n                    addStrictWarning(\"msg.no.side.effects\", \"\");\n                return pn;\n            }\n        } catch (ParserException e) {\n        }\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (; ; ) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch(tt) {\n                case Token.ERROR:\n                case Token.EOF:\n                case Token.EOL:\n                case Token.SEMI:\n                    break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    private Node statementHelper(Node statementLabel) throws IOException, ParserException {\n        Node pn = null;\n        int tt = peekToken();\n        switch(tt) {\n            case Token.IF:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.IF);\n                    int lineno = ts.getLineno();\n                    Node cond = condition();\n                    decompiler.addEOL(Token.LC);\n                    Node ifTrue = statement();\n                    Node ifFalse = null;\n                    if (matchToken(Token.ELSE)) {\n                        decompiler.addToken(Token.RC);\n                        decompiler.addToken(Token.ELSE);\n                        decompiler.addEOL(Token.LC);\n                        ifFalse = statement();\n                    }\n                    decompiler.addEOL(Token.RC);\n                    pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n                    return pn;\n                }\n            case Token.SWITCH:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.SWITCH);\n                    int lineno = ts.getLineno();\n                    mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n                    decompiler.addToken(Token.LP);\n                    pn = enterSwitch(expr(false), lineno);\n                    try {\n                        mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                        decompiler.addToken(Token.RP);\n                        mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                        decompiler.addEOL(Token.LC);\n                        boolean hasDefault = false;\n                        switchLoop: for (; ; ) {\n                            tt = nextToken();\n                            Node caseExpression;\n                            switch(tt) {\n                                case Token.RC:\n                                    break switchLoop;\n                                case Token.CASE:\n                                    decompiler.addToken(Token.CASE);\n                                    caseExpression = expr(false);\n                                    mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                                    decompiler.addEOL(Token.COLON);\n                                    break;\n                                case Token.DEFAULT:\n                                    if (hasDefault) {\n                                        reportError(\"msg.double.switch.default\");\n                                    }\n                                    decompiler.addToken(Token.DEFAULT);\n                                    hasDefault = true;\n                                    caseExpression = null;\n                                    mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                                    decompiler.addEOL(Token.COLON);\n                                    break;\n                                default:\n                                    reportError(\"msg.bad.switch\");\n                                    break switchLoop;\n                            }\n                            Node block = nf.createLeaf(Token.BLOCK);\n                            while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {\n                                nf.addChildToBack(block, statement());\n                            }\n                            // caseExpression == null => add default label\n                            nf.addSwitchCase(pn, caseExpression, block);\n                        }\n                        decompiler.addEOL(Token.RC);\n                        nf.closeSwitch(pn);\n                    } finally {\n                        exitSwitch();\n                    }\n                    return pn;\n                }\n            case Token.WHILE:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.WHILE);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        Node cond = condition();\n                        decompiler.addEOL(Token.LC);\n                        Node body = statement();\n                        decompiler.addEOL(Token.RC);\n                        pn = nf.createWhile(loop, cond, body);\n                    } finally {\n                        exitLoop(true);\n                    }\n                    return pn;\n                }\n            case Token.DO:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.DO);\n                    decompiler.addEOL(Token.LC);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        Node body = statement();\n                        decompiler.addToken(Token.RC);\n                        mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                        decompiler.addToken(Token.WHILE);\n                        Node cond = condition();\n                        pn = nf.createDoWhile(loop, body, cond);\n                    } finally {\n                        exitLoop(true);\n                    }\n                    // Always auto-insert semicolon to follow SpiderMonkey:\n                    // It is required by ECMAScript but is ignored by the rest of\n                    // world, see bug 238945\n                    matchToken(Token.SEMI);\n                    decompiler.addEOL(Token.SEMI);\n                    return pn;\n                }\n            case Token.FOR:\n                {\n                    consumeToken();\n                    boolean isForEach = false;\n                    decompiler.addToken(Token.FOR);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        // Node init is also foo in 'foo in object'\n                        Node init;\n                        // Node cond is also object in 'foo in object'\n                        Node cond;\n                        Node incr = null;\n                        Node body;\n                        int declType = -1;\n                        // See if this is a for each () instead of just a for ()\n                        if (matchToken(Token.NAME)) {\n                            decompiler.addName(ts.getString());\n                            if (ts.getString().equals(\"each\")) {\n                                isForEach = true;\n                            } else {\n                                reportError(\"msg.no.paren.for\");\n                            }\n                        }\n                        mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                        decompiler.addToken(Token.LP);\n                        tt = peekToken();\n                        if (tt == Token.SEMI) {\n                            init = nf.createLeaf(Token.EMPTY);\n                        } else {\n                            if (tt == Token.VAR || tt == Token.LET) {\n                                // set init to a var list or initial\n                                // consume the token\n                                consumeToken();\n                                decompiler.addToken(tt);\n                                init = variables(true, tt);\n                                declType = tt;\n                            } else {\n                                init = expr(true);\n                            }\n                        }\n                        if (matchToken(Token.IN)) {\n                            decompiler.addToken(Token.IN);\n                            // 'cond' is the object over which we're iterating\n                            cond = expr(false);\n                        } else {\n                            // ordinary for loop\n                            mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                            decompiler.addToken(Token.SEMI);\n                            if (peekToken() == Token.SEMI) {\n                                // no loop condition\n                                cond = nf.createLeaf(Token.EMPTY);\n                            } else {\n                                cond = expr(false);\n                            }\n                            mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                            decompiler.addToken(Token.SEMI);\n                            if (peekToken() == Token.RP) {\n                                incr = nf.createLeaf(Token.EMPTY);\n                            } else {\n                                incr = expr(false);\n                            }\n                        }\n                        mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                        decompiler.addToken(Token.RP);\n                        decompiler.addEOL(Token.LC);\n                        body = statement();\n                        decompiler.addEOL(Token.RC);\n                        if (incr == null) {\n                            // cond could be null if 'in obj' got eaten\n                            // by the init node.\n                            pn = nf.createForIn(declType, loop, init, cond, body, isForEach);\n                        } else {\n                            pn = nf.createFor(loop, init, cond, incr, body);\n                        }\n                    } finally {\n                        exitLoop(true);\n                    }\n                    return pn;\n                }\n            case Token.TRY:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    Node tryblock;\n                    Node catchblocks = null;\n                    Node finallyblock = null;\n                    decompiler.addToken(Token.TRY);\n                    if (peekToken() != Token.LC) {\n                        reportError(\"msg.no.brace.try\");\n                    }\n                    decompiler.addEOL(Token.LC);\n                    tryblock = statement();\n                    decompiler.addEOL(Token.RC);\n                    catchblocks = nf.createLeaf(Token.BLOCK);\n                    boolean sawDefaultCatch = false;\n                    int peek = peekToken();\n                    if (peek == Token.CATCH) {\n                        while (matchToken(Token.CATCH)) {\n                            if (sawDefaultCatch) {\n                                reportError(\"msg.catch.unreachable\");\n                            }\n                            decompiler.addToken(Token.CATCH);\n                            mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                            decompiler.addToken(Token.LP);\n                            mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                            String varName = ts.getString();\n                            decompiler.addName(varName);\n                            Node catchCond = null;\n                            if (matchToken(Token.IF)) {\n                                decompiler.addToken(Token.IF);\n                                catchCond = expr(false);\n                            } else {\n                                sawDefaultCatch = true;\n                            }\n                            mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                            decompiler.addToken(Token.RP);\n                            mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                            decompiler.addEOL(Token.LC);\n                            nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(null), ts.getLineno()));\n                            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                            decompiler.addEOL(Token.RC);\n                        }\n                    } else if (peek != Token.FINALLY) {\n                        mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n                    }\n                    if (matchToken(Token.FINALLY)) {\n                        decompiler.addToken(Token.FINALLY);\n                        decompiler.addEOL(Token.LC);\n                        finallyblock = statement();\n                        decompiler.addEOL(Token.RC);\n                    }\n                    pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);\n                    return pn;\n                }\n            case Token.THROW:\n                {\n                    consumeToken();\n                    if (peekTokenOrEOL() == Token.EOL) {\n                        // ECMAScript does not allow new lines before throw expression,\n                        // see bug 256617\n                        reportError(\"msg.bad.throw.eol\");\n                    }\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.THROW);\n                    pn = nf.createThrow(expr(false), lineno);\n                    break;\n                }\n            case Token.BREAK:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.BREAK);\n                    // matchJumpLabelName only matches if there is one\n                    Node breakStatement = matchJumpLabelName();\n                    if (breakStatement == null) {\n                        if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                            reportError(\"msg.bad.break\");\n                            return null;\n                        }\n                        breakStatement = (Node) loopAndSwitchSet.peek();\n                    }\n                    pn = nf.createBreak(breakStatement, lineno);\n                    break;\n                }\n            case Token.CONTINUE:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.CONTINUE);\n                    Node loop;\n                    // matchJumpLabelName only matches if there is one\n                    Node label = matchJumpLabelName();\n                    if (label == null) {\n                        if (loopSet == null || loopSet.size() == 0) {\n                            reportError(\"msg.continue.outside\");\n                            return null;\n                        }\n                        loop = (Node) loopSet.peek();\n                    } else {\n                        loop = nf.getLabelLoop(label);\n                        if (loop == null) {\n                            reportError(\"msg.continue.nonloop\");\n                            return null;\n                        }\n                    }\n                    pn = nf.createContinue(loop, lineno);\n                    break;\n                }\n            case Token.WITH:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.WITH);\n                    int lineno = ts.getLineno();\n                    mustMatchToken(Token.LP, \"msg.no.paren.with\");\n                    decompiler.addToken(Token.LP);\n                    Node obj = expr(false);\n                    mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n                    decompiler.addToken(Token.RP);\n                    decompiler.addEOL(Token.LC);\n                    ++nestingOfWith;\n                    Node body;\n                    try {\n                        body = statement();\n                    } finally {\n                        --nestingOfWith;\n                    }\n                    decompiler.addEOL(Token.RC);\n                    pn = nf.createWith(obj, body, lineno);\n                    return pn;\n                }\n            case Token.CONST:\n            case Token.VAR:\n                {\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = variables(false, tt);\n                    break;\n                }\n            case Token.LET:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.LET);\n                    if (peekToken() == Token.LP) {\n                        return let(true);\n                    } else {\n                        pn = variables(false, tt);\n                        if (peekToken() == Token.SEMI)\n                            break;\n                        return pn;\n                    }\n                }\n            case Token.RETURN:\n            case Token.YIELD:\n                {\n                    pn = returnOrYield(tt, false);\n                    break;\n                }\n            case Token.DEBUGGER:\n                consumeToken();\n                decompiler.addToken(Token.DEBUGGER);\n                pn = nf.createDebugger(ts.getLineno());\n                break;\n            case Token.LC:\n                consumeToken();\n                if (statementLabel != null) {\n                    decompiler.addToken(Token.LC);\n                }\n                Node scope = nf.createScopeNode(Token.BLOCK, ts.getLineno());\n                pushScope(scope);\n                try {\n                    statements(scope);\n                    mustMatchToken(Token.RC, \"msg.no.brace.block\");\n                    if (statementLabel != null) {\n                        decompiler.addEOL(Token.RC);\n                    }\n                    return scope;\n                } finally {\n                    popScope();\n                }\n            case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n            case Token.SEMI:\n                consumeToken();\n                pn = nf.createLeaf(Token.EMPTY);\n                return pn;\n            case Token.FUNCTION:\n                {\n                    consumeToken();\n                    pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n                    return pn;\n                }\n            case Token.DEFAULT:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DEFAULT);\n                int nsLine = ts.getLineno();\n                if (!(matchToken(Token.NAME) && ts.getString().equals(\"xml\"))) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addName(\" xml\");\n                if (!(matchToken(Token.NAME) && ts.getString().equals(\"namespace\"))) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addName(\" namespace\");\n                if (!matchToken(Token.ASSIGN)) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addToken(Token.ASSIGN);\n                Node expr = expr(false);\n                pn = nf.createDefaultNamespace(expr, nsLine);\n                break;\n            case Token.NAME:\n                {\n                    int lineno = ts.getLineno();\n                    String name = ts.getString();\n                    setCheckForLabel();\n                    pn = expr(false);\n                    if (pn.getType() != Token.LABEL) {\n                        pn = nf.createExprStatement(pn, lineno);\n                    } else {\n                        // Parsed the label: push back token should be\n                        // colon that primaryExpr left untouched.\n                        if (peekToken() != Token.COLON)\n                            Kit.codeBug();\n                        consumeToken();\n                        // depend on decompiling lookahead to guess that that\n                        // last name was a label.\n                        decompiler.addName(name);\n                        decompiler.addEOL(Token.COLON);\n                        if (labelSet == null) {\n                            labelSet = new HashMap<String, Node>();\n                        } else if (labelSet.containsKey(name)) {\n                            reportError(\"msg.dup.label\");\n                        }\n                        boolean firstLabel;\n                        if (statementLabel == null) {\n                            firstLabel = true;\n                            statementLabel = pn;\n                        } else {\n                            // Discard multiple label nodes and use only\n                            // the first: it allows to simplify IRFactory\n                            firstLabel = false;\n                        }\n                        labelSet.put(name, statementLabel);\n                        try {\n                            pn = statementHelper(statementLabel);\n                        } finally {\n                            labelSet.remove(name);\n                        }\n                        if (firstLabel) {\n                            pn = nf.createLabeledStatement(statementLabel, pn);\n                        }\n                        return pn;\n                    }\n                    break;\n                }\n            default:\n                {\n                    int lineno = ts.getLineno();\n                    pn = expr(false);\n                    pn = nf.createExprStatement(pn, lineno);\n                    break;\n                }\n        }\n        int ttFlagged = peekFlaggedToken();\n        switch(ttFlagged & CLEAR_TI_MASK) {\n            case Token.SEMI:\n                // Consume ';' as a part of expression\n                consumeToken();\n                break;\n            case Token.ERROR:\n            case Token.EOF:\n            case Token.RC:\n                // Autoinsert ;\n                break;\n            default:\n                if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                    // Report error if no EOL or autoinsert ; otherwise\n                    reportError(\"msg.no.semi.stmt\");\n                }\n                break;\n        }\n        decompiler.addEOL(Token.SEMI);\n        return pn;\n    }\n\n    /**\n     * Returns whether or not the bits in the mask have changed to all set.\n     * @param before bits before change\n     * @param after bits after change\n     * @param mask mask for bits\n     * @return true if all the bits in the mask are set in \"after\" but not\n     *              \"before\"\n     */\n    private static final boolean nowAllSet(int before, int after, int mask) {\n        return ((before & mask) != mask) && ((after & mask) == mask);\n    }\n\n    private Node returnOrYield(int tt, boolean exprContext) throws IOException, ParserException {\n        if (!insideFunction()) {\n            reportError(tt == Token.RETURN ? \"msg.bad.return\" : \"msg.bad.yield\");\n        }\n        consumeToken();\n        decompiler.addToken(tt);\n        int lineno = ts.getLineno();\n        Node e;\n        /* This is ugly, but we don't want to require a semicolon. */\n        switch(peekTokenOrEOL()) {\n            case Token.SEMI:\n            case Token.RC:\n            case Token.EOF:\n            case Token.EOL:\n            case Token.ERROR:\n            case Token.RB:\n            case Token.RP:\n            case Token.YIELD:\n                e = null;\n                break;\n            default:\n                e = expr(false);\n                break;\n        }\n        int before = endFlags;\n        Node ret;\n        if (tt == Token.RETURN) {\n            if (e == null) {\n                endFlags |= Node.END_RETURNS;\n            } else {\n                endFlags |= Node.END_RETURNS_VALUE;\n            }\n            ret = nf.createReturn(e, lineno);\n            // see if we need a strict mode warning\n            if (nowAllSet(before, endFlags, Node.END_RETURNS | Node.END_RETURNS_VALUE)) {\n                addStrictWarning(\"msg.return.inconsistent\", \"\");\n            }\n        } else {\n            endFlags |= Node.END_YIELDS;\n            ret = nf.createYield(e, lineno);\n            if (!exprContext)\n                ret = new Node(Token.EXPR_VOID, ret, lineno);\n        }\n        // see if we are mixing yields and value returns.\n        if (nowAllSet(before, endFlags, Node.END_YIELDS | Node.END_RETURNS_VALUE)) {\n            String name = ((FunctionNode) currentScriptOrFn).getFunctionName();\n            if (name.length() == 0)\n                addError(\"msg.anon.generator.returns\", \"\");\n            else\n                addError(\"msg.generator.returns\", name);\n        }\n        return ret;\n    }\n\n    /**\n     * Parse a 'var' or 'const' statement, or a 'var' init list in a for\n     * statement.\n     * @param inFor true if we are currently in the midst of the init\n     * clause of a for.\n     * @param declType A token value: either VAR, CONST, or LET depending on\n     * context.\n     * @return The parsed statement\n     * @throws IOException\n     * @throws ParserException\n     */\n    private Node variables(boolean inFor, int declType) throws IOException, ParserException {\n        Node result = nf.createVariables(declType, ts.getLineno());\n        boolean first = true;\n        for (; ; ) {\n            Node destructuring = null;\n            String s = null;\n            int tt = peekToken();\n            if (tt == Token.LB || tt == Token.LC) {\n                // Destructuring assignment, e.g., var [a,b] = ...\n                destructuring = primaryExpr();\n            } else {\n                // Simple variable name\n                mustMatchToken(Token.NAME, \"msg.bad.var\");\n                s = ts.getString();\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                decompiler.addName(s);\n                defineSymbol(declType, inFor, s);\n            }\n            Node init = null;\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n                init = assignExpr(inFor);\n            }\n            if (destructuring != null) {\n                if (init == null) {\n                    if (!inFor)\n                        reportError(\"msg.destruct.assign.no.init\");\n                    nf.addChildToBack(result, destructuring);\n                } else {\n                    nf.addChildToBack(result, nf.createDestructuringAssignment(declType, destructuring, init));\n                }\n            } else {\n                Node name = nf.createName(s);\n                if (init != null)\n                    nf.addChildToBack(name, init);\n                nf.addChildToBack(result, name);\n            }\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return result;\n    }\n\n    private Node let(boolean isStatement) throws IOException, ParserException {\n        mustMatchToken(Token.LP, \"msg.no.paren.after.let\");\n        decompiler.addToken(Token.LP);\n        Node result = nf.createScopeNode(Token.LET, ts.getLineno());\n        pushScope(result);\n        try {\n            Node vars = variables(false, Token.LET);\n            nf.addChildToBack(result, vars);\n            mustMatchToken(Token.RP, \"msg.no.paren.let\");\n            decompiler.addToken(Token.RP);\n            if (isStatement && peekToken() == Token.LC) {\n                // let statement\n                consumeToken();\n                decompiler.addEOL(Token.LC);\n                nf.addChildToBack(result, statements(null));\n                mustMatchToken(Token.RC, \"msg.no.curly.let\");\n                decompiler.addToken(Token.RC);\n            } else {\n                // let expression\n                result.setType(Token.LETEXPR);\n                nf.addChildToBack(result, expr(false));\n                if (isStatement) {\n                    // let expression in statement context\n                    result = nf.createExprStatement(result, ts.getLineno());\n                }\n            }\n        } finally {\n            popScope();\n        }\n        return result;\n    }\n\n    void defineSymbol(int declType, boolean ignoreNotInBlock, String name) {\n        Node.Scope definingScope = currentScope.getDefiningScope(name);\n        Node.Scope.Symbol symbol = definingScope != null ? definingScope.getSymbol(name) : null;\n        boolean error = false;\n        if (symbol != null && (symbol.declType == Token.CONST || declType == Token.CONST)) {\n            error = true;\n        } else {\n            switch(declType) {\n                case Token.LET:\n                    if (symbol != null && definingScope == currentScope) {\n                        error = symbol.declType == Token.LET;\n                    }\n                    int currentScopeType = currentScope.getType();\n                    if (!ignoreNotInBlock && ((currentScopeType == Token.LOOP) || (currentScopeType == Token.IF))) {\n                        addError(\"msg.let.decl.not.in.block\");\n                    }\n                    currentScope.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    break;\n                case Token.VAR:\n                case Token.CONST:\n                case Token.FUNCTION:\n                    if (symbol != null) {\n                        if (symbol.declType == Token.VAR)\n                            addStrictWarning(\"msg.var.redecl\", name);\n                        else if (symbol.declType == Token.LP) {\n                            addStrictWarning(\"msg.var.hides.arg\", name);\n                        }\n                    } else {\n                        currentScriptOrFn.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    }\n                    break;\n                case Token.LP:\n                    if (symbol != null) {\n                        // must be duplicate parameter. Second parameter hides the\n                        // first, so go ahead and add the second pararameter\n                        addWarning(\"msg.dup.parms\", name);\n                    }\n                    currentScriptOrFn.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    break;\n                default:\n                    throw Kit.codeBug();\n            }\n        }\n        if (error) {\n            addError(symbol.declType == Token.CONST ? \"msg.const.redecl\" : symbol.declType == Token.LET ? \"msg.let.redecl\" : symbol.declType == Token.VAR ? \"msg.var.redecl\" : symbol.declType == Token.FUNCTION ? \"msg.fn.redecl\" : \"msg.parm.redecl\", name);\n        }\n    }\n\n    private Node expr(boolean inForInit) throws IOException, ParserException {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            if (compilerEnv.isStrictMode() && !pn.hasSideEffects())\n                addStrictWarning(\"msg.no.side.effects\", \"\");\n            if (peekToken() == Token.YIELD) {\n                reportError(\"msg.yield.parenthesized\");\n            }\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit) throws IOException, ParserException {\n        int tt = peekToken();\n        if (tt == Token.YIELD) {\n            consumeToken();\n            return returnOrYield(tt, true);\n        }\n        Node pn = condExpr(inForInit);\n        tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = orExpr(inForInit);\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            Node ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            Node ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = relExpr(inForInit);\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.EQ:\n                case Token.NE:\n                case Token.SHEQ:\n                case Token.SHNE:\n                    consumeToken();\n                    int decompilerToken = tt;\n                    int parseToken = tt;\n                    if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                        // JavaScript 1.2 uses shallow equality for == and != .\n                        // In addition, convert === and !== for decompiler into\n                        // == and != since the decompiler is supposed to show\n                        // canonical source and in 1.2 ===, !== are allowed\n                        // only as an alias to ==, !=.\n                        switch(tt) {\n                            case Token.EQ:\n                                parseToken = Token.SHEQ;\n                                break;\n                            case Token.NE:\n                                parseToken = Token.SHNE;\n                                break;\n                            case Token.SHEQ:\n                                decompilerToken = Token.EQ;\n                                break;\n                            case Token.SHNE:\n                                decompilerToken = Token.NE;\n                                break;\n                        }\n                    }\n                    decompiler.addToken(decompilerToken);\n                    pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = shiftExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.IN:\n                    if (inForInit)\n                        break;\n                // fall through\n                case Token.INSTANCEOF:\n                case Token.LE:\n                case Token.LT:\n                case Token.GE:\n                case Token.GT:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, shiftExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr() throws IOException, ParserException {\n        Node pn = addExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.LSH:\n                case Token.URSH:\n                case Token.RSH:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, addExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr() throws IOException, ParserException {\n        Node pn = mulExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node mulExpr() throws IOException, ParserException {\n        Node pn = unaryExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.MUL:\n                case Token.DIV:\n                case Token.MOD:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, unaryExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node unaryExpr() throws IOException, ParserException {\n        int tt;\n        tt = peekToken();\n        switch(tt) {\n            case Token.VOID:\n            case Token.NOT:\n            case Token.BITNOT:\n            case Token.TYPEOF:\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createUnary(tt, unaryExpr());\n            case Token.ADD:\n                consumeToken();\n                // Convert to special POS token in decompiler and parse tree\n                decompiler.addToken(Token.POS);\n                return nf.createUnary(Token.POS, unaryExpr());\n            case Token.SUB:\n                consumeToken();\n                // Convert to special NEG token in decompiler and parse tree\n                decompiler.addToken(Token.NEG);\n                return nf.createUnary(Token.NEG, unaryExpr());\n            case Token.INC:\n            case Token.DEC:\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, false, memberExpr(true));\n            case Token.DELPROP:\n                consumeToken();\n                decompiler.addToken(Token.DELPROP);\n                return nf.createUnary(Token.DELPROP, unaryExpr());\n            case Token.ERROR:\n                consumeToken();\n                break;\n            // XML stream encountered in expression.\n            case Token.LT:\n                if (compilerEnv.isXmlAvailable()) {\n                    consumeToken();\n                    Node pn = xmlInitializer();\n                    return memberExprTail(true, pn);\n                }\n            // Fall thru to the default handling of RELOP\n            default:\n                Node pn = memberExpr(true);\n                // Don't look across a newline boundary for a postfix incop.\n                tt = peekTokenOrEOL();\n                if (tt == Token.INC || tt == Token.DEC) {\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    return nf.createIncDec(tt, true, pn);\n                }\n                return pn;\n        }\n        // Only reached on error.Try to continue.\n        return nf.createName(\"error\");\n    }\n\n    private Node xmlInitializer() throws IOException {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n        pn = null;\n        Node expr;\n        for (; ; tt = ts.getNextXMLToken()) {\n            switch(tt) {\n                case Token.XML:\n                    xml = ts.getString();\n                    decompiler.addName(xml);\n                    mustMatchToken(Token.LC, \"msg.syntax\");\n                    decompiler.addToken(Token.LC);\n                    expr = (peekToken() == Token.RC) ? nf.createString(\"\") : expr(false);\n                    mustMatchToken(Token.RC, \"msg.syntax\");\n                    decompiler.addToken(Token.RC);\n                    if (pn == null) {\n                        pn = nf.createString(xml);\n                    } else {\n                        pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                    }\n                    if (ts.isXMLAttribute()) {\n                        /* Need to put the result in double quotes */\n                        expr = nf.createUnary(Token.ESCXMLATTR, expr);\n                        Node prepend = nf.createBinary(Token.ADD, nf.createString(\"\\\"\"), expr);\n                        expr = nf.createBinary(Token.ADD, prepend, nf.createString(\"\\\"\"));\n                    } else {\n                        expr = nf.createUnary(Token.ESCXMLTEXT, expr);\n                    }\n                    pn = nf.createBinary(Token.ADD, pn, expr);\n                    break;\n                case Token.XMLEND:\n                    xml = ts.getString();\n                    decompiler.addName(xml);\n                    if (pn == null) {\n                        pn = nf.createString(xml);\n                    } else {\n                        pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                    }\n                    nf.addChildToBack(pnXML, pn);\n                    return pnXML;\n                default:\n                    reportError(\"msg.syntax\");\n                    return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode) throws IOException, ParserException {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                if (peekToken() == Token.YIELD) {\n                    reportError(\"msg.yield.parenthesized\");\n                }\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {\n        int tt;\n        Node pn;\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {\n        tailLoop: for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.DOT:\n                case Token.DOTDOT:\n                    {\n                        int memberTypeFlags;\n                        String s;\n                        consumeToken();\n                        decompiler.addToken(tt);\n                        memberTypeFlags = 0;\n                        if (tt == Token.DOTDOT) {\n                            mustHaveXML();\n                            memberTypeFlags = Node.DESCENDANTS_FLAG;\n                        }\n                        if (!compilerEnv.isXmlAvailable()) {\n                            mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                            s = ts.getString();\n                            decompiler.addName(s);\n                            pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                            break;\n                        }\n                        tt = nextToken();\n                        switch(tt) {\n                            // needed for generator.throw();\n                            case Token.THROW:\n                                decompiler.addName(\"throw\");\n                                pn = propertyName(pn, \"throw\", memberTypeFlags);\n                                break;\n                            // handles: name, ns::name, ns::*, ns::[expr]\n                            case Token.NAME:\n                                s = ts.getString();\n                                decompiler.addName(s);\n                                pn = propertyName(pn, s, memberTypeFlags);\n                                break;\n                            // handles: *, *::name, *::*, *::[expr]\n                            case Token.MUL:\n                                decompiler.addName(\"*\");\n                                pn = propertyName(pn, \"*\", memberTypeFlags);\n                                break;\n                            // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                            //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                            case Token.XMLATTR:\n                                decompiler.addToken(Token.XMLATTR);\n                                pn = attributeAccess(pn, memberTypeFlags);\n                                break;\n                            default:\n                                reportError(\"msg.no.name.after.dot\");\n                        }\n                    }\n                    break;\n                case Token.DOTQUERY:\n                    consumeToken();\n                    mustHaveXML();\n                    decompiler.addToken(Token.DOTQUERY);\n                    pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                    mustMatchToken(Token.RP, \"msg.no.paren\");\n                    decompiler.addToken(Token.RP);\n                    break;\n                case Token.LB:\n                    consumeToken();\n                    decompiler.addToken(Token.LB);\n                    pn = nf.createElementGet(pn, null, expr(false), 0);\n                    mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                    decompiler.addToken(Token.RB);\n                    break;\n                case Token.LP:\n                    if (!allowCallSyntax) {\n                        break tailLoop;\n                    }\n                    consumeToken();\n                    decompiler.addToken(Token.LP);\n                    pn = nf.createCallOrNew(Token.CALL, pn);\n                    /* Add the arguments to pn, if any are supplied. */\n                    argumentList(pn);\n                    break;\n                default:\n                    break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n        switch(tt) {\n            // handles: @name, @ns::name, @ns::*, @ns::[expr]\n            case Token.NAME:\n                {\n                    String s = ts.getString();\n                    decompiler.addName(s);\n                    pn = propertyName(pn, s, memberTypeFlags);\n                }\n                break;\n            // handles: @*, @*::name, @*::*, @*::[expr]\n            case Token.MUL:\n                decompiler.addName(\"*\");\n                pn = propertyName(pn, \"*\", memberTypeFlags);\n                break;\n            // handles @[expr]\n            case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n            default:\n                reportError(\"msg.no.name.after.xmlAttr\");\n                pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n                break;\n        }\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n            int tt = nextToken();\n            switch(tt) {\n                // handles name::name\n                case Token.NAME:\n                    name = ts.getString();\n                    decompiler.addName(name);\n                    break;\n                // handles name::*\n                case Token.MUL:\n                    decompiler.addName(\"*\");\n                    name = \"*\";\n                    break;\n                // handles name::[expr]\n                case Token.LB:\n                    decompiler.addToken(Token.LB);\n                    pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);\n                    mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                    decompiler.addToken(Token.RB);\n                    return pn;\n                default:\n                    reportError(\"msg.no.name.after.coloncolon\");\n                    name = \"?\";\n            }\n        }\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node arrayComprehension(String arrayName, Node expr) throws IOException, ParserException {\n        if (nextToken() != Token.FOR)\n            // shouldn't be here if next token isn't 'for'\n            throw Kit.codeBug();\n        // space after array literal expr\n        decompiler.addName(\" \");\n        decompiler.addToken(Token.FOR);\n        boolean isForEach = false;\n        if (matchToken(Token.NAME)) {\n            decompiler.addName(ts.getString());\n            if (ts.getString().equals(\"each\")) {\n                isForEach = true;\n            } else {\n                reportError(\"msg.no.paren.for\");\n            }\n        }\n        mustMatchToken(Token.LP, \"msg.no.paren.for\");\n        decompiler.addToken(Token.LP);\n        String name;\n        int tt = peekToken();\n        if (tt == Token.LB || tt == Token.LC) {\n            // handle destructuring assignment\n            name = currentScriptOrFn.getNextTempName();\n            defineSymbol(Token.LP, false, name);\n            expr = nf.createBinary(Token.COMMA, nf.createAssignment(Token.ASSIGN, primaryExpr(), nf.createName(name)), expr);\n        } else if (tt == Token.NAME) {\n            consumeToken();\n            name = ts.getString();\n            decompiler.addName(name);\n        } else {\n            reportError(\"msg.bad.var\");\n            return nf.createNumber(0);\n        }\n        Node init = nf.createName(name);\n        // Define as a let since we want the scope of the variable to\n        // be restricted to the array comprehension\n        defineSymbol(Token.LET, false, name);\n        mustMatchToken(Token.IN, \"msg.in.after.for.name\");\n        decompiler.addToken(Token.IN);\n        Node iterator = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n        decompiler.addToken(Token.RP);\n        Node body;\n        tt = peekToken();\n        if (tt == Token.FOR) {\n            body = arrayComprehension(arrayName, expr);\n        } else {\n            Node call = nf.createCallOrNew(Token.CALL, nf.createPropertyGet(nf.createName(arrayName), null, \"push\", 0));\n            call.addChildToBack(expr);\n            body = new Node(Token.EXPR_VOID, call, ts.getLineno());\n            if (tt == Token.IF) {\n                consumeToken();\n                decompiler.addToken(Token.IF);\n                int lineno = ts.getLineno();\n                Node cond = condition();\n                body = nf.createIf(cond, body, null, lineno);\n            }\n            mustMatchToken(Token.RB, \"msg.no.bracket.arg\");\n            decompiler.addToken(Token.RB);\n        }\n        Node loop = enterLoop(null, true);\n        try {\n            return nf.createForIn(Token.LET, loop, init, iterator, body, isForEach);\n        } finally {\n            exitLoop(false);\n        }\n    }\n\n    private Node primaryExpr() throws IOException, ParserException {\n        Node pn;\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n        switch(tt) {\n            case Token.FUNCTION:\n                return function(FunctionNode.FUNCTION_EXPRESSION);\n            case Token.LB:\n                {\n                    ObjArray elems = new ObjArray();\n                    int skipCount = 0;\n                    int destructuringLen = 0;\n                    decompiler.addToken(Token.LB);\n                    boolean after_lb_or_comma = true;\n                    for (; ; ) {\n                        tt = peekToken();\n                        if (tt == Token.COMMA) {\n                            consumeToken();\n                            decompiler.addToken(Token.COMMA);\n                            if (!after_lb_or_comma) {\n                                after_lb_or_comma = true;\n                            } else {\n                                elems.add(null);\n                                ++skipCount;\n                            }\n                        } else if (tt == Token.RB) {\n                            consumeToken();\n                            decompiler.addToken(Token.RB);\n                            // for ([a,] in obj) is legal, but for ([a] in obj) is\n                            // not since we have both key and value supplied. The\n                            // trick is that [a,] and [a] are equivalent in other\n                            // array literal contexts. So we calculate a special\n                            // length value just for destructuring assignment.\n                            destructuringLen = elems.size() + (after_lb_or_comma ? 1 : 0);\n                            break;\n                        } else if (skipCount == 0 && elems.size() == 1 && tt == Token.FOR) {\n                            Node scopeNode = nf.createScopeNode(Token.ARRAYCOMP, ts.getLineno());\n                            String tempName = currentScriptOrFn.getNextTempName();\n                            pushScope(scopeNode);\n                            try {\n                                defineSymbol(Token.LET, false, tempName);\n                                Node expr = (Node) elems.get(0);\n                                Node block = nf.createBlock(ts.getLineno());\n                                Node init = new Node(Token.EXPR_VOID, nf.createAssignment(Token.ASSIGN, nf.createName(tempName), nf.createCallOrNew(Token.NEW, nf.createName(\"Array\"))), ts.getLineno());\n                                block.addChildToBack(init);\n                                block.addChildToBack(arrayComprehension(tempName, expr));\n                                scopeNode.addChildToBack(block);\n                                scopeNode.addChildToBack(nf.createName(tempName));\n                                return scopeNode;\n                            } finally {\n                                popScope();\n                            }\n                        } else {\n                            if (!after_lb_or_comma) {\n                                reportError(\"msg.no.bracket.arg\");\n                            }\n                            elems.add(assignExpr(false));\n                            after_lb_or_comma = false;\n                        }\n                    }\n                    return nf.createArrayLiteral(elems, skipCount, destructuringLen);\n                }\n            case Token.LC:\n                {\n                    ObjArray elems = new ObjArray();\n                    decompiler.addToken(Token.LC);\n                    if (!matchToken(Token.RC)) {\n                        boolean first = true;\n                        commaloop: do {\n                            Object property;\n                            if (!first)\n                                decompiler.addToken(Token.COMMA);\n                            else\n                                first = false;\n                            tt = peekToken();\n                            switch(tt) {\n                                case Token.NAME:\n                                case Token.STRING:\n                                    consumeToken();\n                                    // map NAMEs to STRINGs in object literal context\n                                    // but tell the decompiler the proper type\n                                    String s = ts.getString();\n                                    if (tt == Token.NAME) {\n                                        if (s.equals(\"get\") && peekToken() == Token.NAME) {\n                                            decompiler.addToken(Token.GET);\n                                            consumeToken();\n                                            s = ts.getString();\n                                            decompiler.addName(s);\n                                            property = ScriptRuntime.getIndexObject(s);\n                                            if (!getterSetterProperty(elems, property, true))\n                                                break commaloop;\n                                            break;\n                                        } else if (s.equals(\"set\") && peekToken() == Token.NAME) {\n                                            decompiler.addToken(Token.SET);\n                                            consumeToken();\n                                            s = ts.getString();\n                                            decompiler.addName(s);\n                                            property = ScriptRuntime.getIndexObject(s);\n                                            if (!getterSetterProperty(elems, property, false))\n                                                break commaloop;\n                                            break;\n                                        }\n                                        decompiler.addName(s);\n                                    } else {\n                                        decompiler.addString(s);\n                                    }\n                                    property = ScriptRuntime.getIndexObject(s);\n                                    plainProperty(elems, property);\n                                    break;\n                                case Token.NUMBER:\n                                    consumeToken();\n                                    double n = ts.getNumber();\n                                    decompiler.addNumber(n);\n                                    property = ScriptRuntime.getIndexObject(n);\n                                    plainProperty(elems, property);\n                                    break;\n                                case Token.RC:\n                                    // trailing comma is OK.\n                                    break commaloop;\n                                default:\n                                    reportError(\"msg.bad.prop\");\n                                    break commaloop;\n                            }\n                        } while (matchToken(Token.COMMA));\n                        mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n                    }\n                    decompiler.addToken(Token.RC);\n                    return nf.createObjectLiteral(elems);\n                }\n            case Token.LET:\n                decompiler.addToken(Token.LET);\n                return let(false);\n            case Token.LP:\n                /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n                decompiler.addToken(Token.LP);\n                pn = expr(false);\n                pn.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                return pn;\n            case Token.XMLATTR:\n                mustHaveXML();\n                decompiler.addToken(Token.XMLATTR);\n                pn = attributeAccess(null, 0);\n                return pn;\n            case Token.NAME:\n                {\n                    String name = ts.getString();\n                    if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                        if (peekToken() == Token.COLON) {\n                            // Do not consume colon, it is used as unwind indicator\n                            // to return to statementHelper.\n                            // XXX Better way?\n                            return nf.createLabel(ts.getLineno());\n                        }\n                    }\n                    decompiler.addName(name);\n                    if (compilerEnv.isXmlAvailable()) {\n                        pn = propertyName(null, name, 0);\n                    } else {\n                        pn = nf.createName(name);\n                    }\n                    return pn;\n                }\n            case Token.NUMBER:\n                {\n                    double n = ts.getNumber();\n                    decompiler.addNumber(n);\n                    return nf.createNumber(n);\n                }\n            case Token.STRING:\n                {\n                    String s = ts.getString();\n                    decompiler.addString(s);\n                    return nf.createString(s);\n                }\n            case Token.DIV:\n            case Token.ASSIGN_DIV:\n                {\n                    // Got / or /= which should be treated as regexp in fact\n                    ts.readRegExp(tt);\n                    String flags = ts.regExpFlags;\n                    ts.regExpFlags = null;\n                    String re = ts.getString();\n                    decompiler.addRegexp(re, flags);\n                    int index = currentScriptOrFn.addRegexp(re, flags);\n                    return nf.createRegExp(index);\n                }\n            case Token.NULL:\n            case Token.THIS:\n            case Token.FALSE:\n            case Token.TRUE:\n                decompiler.addToken(tt);\n                return nf.createLeaf(tt);\n            case Token.RESERVED:\n                reportError(\"msg.reserved.id\");\n                break;\n            case Token.ERROR:\n                /* the scanner or one of its subroutines reported the error. */\n                break;\n            case Token.EOF:\n                reportError(\"msg.unexpected.eof\");\n                break;\n            case Token.CONDCOMMENT:\n                String condComment = ts.getString();\n                decompiler.addJScriptConditionalComment(condComment);\n                return nf.createString(condComment);\n            case Token.KEEPCOMMENT:\n                String keepComment = ts.getString();\n                decompiler.addPreservedComment(keepComment);\n                return nf.createString(keepComment);\n            default:\n                reportError(\"msg.syntax\");\n                break;\n        }\n        // should never reach here\n        return null;\n    }\n\n    private void plainProperty(ObjArray elems, Object property) throws IOException {\n        mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n        // OBJLIT is used as ':' in object literal for\n        // decompilation to solve spacing ambiguity.\n        decompiler.addToken(Token.OBJECTLIT);\n        elems.add(property);\n        elems.add(assignExpr(false));\n    }\n\n    private boolean getterSetterProperty(ObjArray elems, Object property, boolean isGetter) throws IOException {\n        Node f = function(FunctionNode.FUNCTION_EXPRESSION);\n        if (f.getType() != Token.FUNCTION) {\n            reportError(\"msg.bad.prop\");\n            return false;\n        }\n        int fnIndex = f.getExistingIntProp(Node.FUNCTION_PROP);\n        FunctionNode fn = currentScriptOrFn.getFunctionNode(fnIndex);\n        if (fn.getFunctionName().length() != 0) {\n            reportError(\"msg.bad.prop\");\n            return false;\n        }\n        elems.add(property);\n        if (isGetter) {\n            elems.add(nf.createUnary(Token.GET, f));\n        } else {\n            elems.add(nf.createUnary(Token.SET, f));\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/22_byuic/src/main/java/org/mozilla/javascript/ParserTest1.java",
		"test_prompt": "// ParserTest1.java\npackage org.mozilla.javascript;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Parser}.\n* It contains ten unit test cases for the {@link Parser#parse(String, String, int)} method.\n*/\nclass ParserTest1 {"
	},
	{
		"original_code": "// Parser.java\n/* ***** BEGIN LICENSE BLOCK *****\n*\n* Version: MPL 1.1\n*\n* The contents of this file are subject to the Mozilla Public License\n* Version 1.1 (the \"License\"); you may not use this file except in\n* compliance with the License. You may obtain a copy of the License\n* at http://www.mozilla.org/MPL/\n*\n* Software distributed under the License is distributed on an \"AS IS\"\n* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n* See the License for the specific language governing rights and\n* limitations under the License.\n*\n* The Original Code is org/mozilla/javascript/Parser.java,\n* a component of the Rhino Library ( http://www.mozilla.org/rhino/ )\n* This file is a modification of the Original Code developed\n* for YUI Compressor.\n*\n* The Initial Developer of the Original Code is Mozilla Foundation\n*\n* Copyright (c) 2009 Mozilla Foundation. All Rights Reserved.\n*\n* Contributor(s): Yahoo! Inc. 2009\n*\n* ***** END LICENSE BLOCK ***** */\npackage org.mozilla.javascript;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\npublic class Parser {\n\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int // mask to clear token information bits\n    CLEAR_TI_MASK = 0xFFFF, // first token of the source line\n    TI_AFTER_EOL = 1 << 16, // indicates to check for label\n    TI_CHECK_LABEL = 1 << 17;\n\n    CompilerEnvirons compilerEnv;\n\n    private ErrorReporter errorReporter;\n\n    private String sourceURI;\n\n    boolean calledByCompileFunction;\n\n    private TokenStream ts;\n\n    private int currentFlaggedToken;\n\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n\n    private String encodedSource;\n\n    // The following are per function variables and should be saved/restored\n    // during function parsing.\n    // XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n\n    Node.Scope currentScope;\n\n    private int nestingOfWith;\n\n    // map of label names into nodes\n    private Map<String, Node> labelSet;\n\n    private ObjArray loopSet;\n\n    private ObjArray loopAndSwitchSet;\n\n    private int endFlags;\n\n    // end of per function variables\n    public int getCurrentLineNumber() {\n        return ts.getLineno();\n    }\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException {\n\n        static final long serialVersionUID = 5882582646773765630L;\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {\n        return new Decompiler();\n    }\n\n    void addStrictWarning(String messageId, String messageArg) {\n        if (compilerEnv.isStrictMode())\n            addWarning(messageId, messageArg);\n    }\n\n    void addWarning(String messageId, String messageArg) {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        if (compilerEnv.reportWarningAsError()) {\n            ++syntaxErrorCount;\n            errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n        } else\n            errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId) {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId, String messageArg) {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId) {\n        addError(messageId);\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken() throws IOException {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken() throws IOException {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken() {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken() throws IOException {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken() throws IOException {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch) throws IOException {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL() throws IOException {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel() {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML() {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource() {\n        return encodedSource;\n    }\n\n    public boolean eof() {\n        return ts.eof();\n    }\n\n    boolean insideFunction() {\n        return nestingOfFunction != 0;\n    }\n\n    void pushScope(Node node) {\n        Node.Scope scopeNode = (Node.Scope) node;\n        if (scopeNode.getParentScope() != null)\n            throw Kit.codeBug();\n        scopeNode.setParent(currentScope);\n        currentScope = scopeNode;\n    }\n\n    void popScope() {\n        currentScope = currentScope.getParentScope();\n    }\n\n    private Node enterLoop(Node loopLabel, boolean doPushScope) {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        if (doPushScope) {\n            pushScope(loop);\n        }\n        return loop;\n    }\n\n    private void exitLoop(boolean doPopScope) {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n        if (doPopScope) {\n            popScope();\n        }\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno) {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch() {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse() throws IOException {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        currentScope = currentScriptOrFn;\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n        // line number where source starts\n        int baseLineno = ts.getLineno();\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n        try {\n            for (; ; ) {\n                int tt = peekToken();\n                if (tt <= Token.EOF) {\n                    break;\n                }\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(calledByCompileFunction ? FunctionNode.FUNCTION_EXPRESSION : FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\"msg.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);\n        }\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);\n        }\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);\n        nf.initScript(currentScriptOrFn, pn);\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        // It helps GC\n        this.decompiler = null;\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody() throws IOException {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (; ; ) {\n                Node n;\n                int tt = peekToken();\n                switch(tt) {\n                    case Token.ERROR:\n                    case Token.EOF:\n                    case Token.RC:\n                        break bodyLoop;\n                    case Token.FUNCTION:\n                        consumeToken();\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                        break;\n                    default:\n                        n = statement();\n                        break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n        return pn;\n    }\n\n    private Node function(int functionType) throws IOException, ParserException {\n        int syntheticType = functionType;\n        // line number where source starts\n        int baseLineno = ts.getLineno();\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n        if (syntheticType != FunctionNode.FUNCTION_EXPRESSION && name.length() > 0) {\n            // Function statements define a symbol in the enclosing scope\n            defineSymbol(Token.FUNCTION, false, name);\n        }\n        boolean nested = insideFunction();\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n        int functionSourceEnd;\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        Node.Scope savedCurrentScope = currentScope;\n        currentScope = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Map<String, Node> savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n        int savedFunctionEndFlags = endFlags;\n        endFlags = 0;\n        Node destructuring = null;\n        Node body;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    int tt = peekToken();\n                    if (tt == Token.LB || tt == Token.LC) {\n                        // Destructuring assignment for parameters: add a\n                        // dummy parameter name, and add a statement to the\n                        // body to initialize variables from the destructuring\n                        // assignment\n                        if (destructuring == null) {\n                            destructuring = new Node(Token.COMMA);\n                        }\n                        String parmName = currentScriptOrFn.getNextTempName();\n                        defineSymbol(Token.LP, false, parmName);\n                        destructuring.addChildToBack(nf.createDestructuringAssignment(Token.VAR, primaryExpr(), nf.createName(parmName)));\n                    } else {\n                        mustMatchToken(Token.NAME, \"msg.no.parm\");\n                        String s = ts.getString();\n                        defineSymbol(Token.LP, false, s);\n                        decompiler.addName(s);\n                    }\n                } while (matchToken(Token.COMMA));\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            if (destructuring != null) {\n                body.addChildToFront(new Node(Token.EXPR_VOID, destructuring, ts.getLineno()));\n            }\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n            if (compilerEnv.isStrictMode() && !body.hasConsistentReturnUsage()) {\n                String msg = name.length() > 0 ? \"msg.no.return.value\" : \"msg.anon.no.return.value\";\n                addStrictWarning(msg, name);\n            }\n            if (syntheticType == FunctionNode.FUNCTION_EXPRESSION && name.length() > 0 && currentScope.getSymbol(name) == null) {\n                // Function expressions define a name only in the body of the\n                // function, and only if not hidden by a parameter name\n                defineSymbol(Token.FUNCTION, false, name);\n            }\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        } finally {\n            endFlags = savedFunctionEndFlags;\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n            currentScope = savedCurrentScope;\n        }\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements(Node scope) throws IOException {\n        Node pn = scope != null ? scope : nf.createBlock(ts.getLineno());\n        int tt;\n        while ((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n        return pn;\n    }\n\n    private Node condition() throws IOException, ParserException {\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        Node pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n        // Report strict warning on code like \"if (a = 7) ...\". Suppress the\n        // warning if the condition is parenthesized, like \"if ((a = 7)) ...\".\n        if (pn.getProp(Node.PARENTHESIZED_PROP) == null && (pn.getType() == Token.SETNAME || pn.getType() == Token.SETPROP || pn.getType() == Token.SETELEM)) {\n            addStrictWarning(\"msg.equal.as.assign\", \"\");\n        }\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName() throws IOException, ParserException {\n        Node label = null;\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n        return label;\n    }\n\n    private Node statement() throws IOException {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                if (compilerEnv.isStrictMode() && !pn.hasSideEffects())\n                    addStrictWarning(\"msg.no.side.effects\", \"\");\n                return pn;\n            }\n        } catch (ParserException e) {\n        }\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (; ; ) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch(tt) {\n                case Token.ERROR:\n                case Token.EOF:\n                case Token.EOL:\n                case Token.SEMI:\n                    break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    private Node statementHelper(Node statementLabel) throws IOException, ParserException {\n        Node pn = null;\n        int tt = peekToken();\n        switch(tt) {\n            case Token.IF:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.IF);\n                    int lineno = ts.getLineno();\n                    Node cond = condition();\n                    decompiler.addEOL(Token.LC);\n                    Node ifTrue = statement();\n                    Node ifFalse = null;\n                    if (matchToken(Token.ELSE)) {\n                        decompiler.addToken(Token.RC);\n                        decompiler.addToken(Token.ELSE);\n                        decompiler.addEOL(Token.LC);\n                        ifFalse = statement();\n                    }\n                    decompiler.addEOL(Token.RC);\n                    pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n                    return pn;\n                }\n            case Token.SWITCH:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.SWITCH);\n                    int lineno = ts.getLineno();\n                    mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n                    decompiler.addToken(Token.LP);\n                    pn = enterSwitch(expr(false), lineno);\n                    try {\n                        mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                        decompiler.addToken(Token.RP);\n                        mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                        decompiler.addEOL(Token.LC);\n                        boolean hasDefault = false;\n                        switchLoop: for (; ; ) {\n                            tt = nextToken();\n                            Node caseExpression;\n                            switch(tt) {\n                                case Token.RC:\n                                    break switchLoop;\n                                case Token.CASE:\n                                    decompiler.addToken(Token.CASE);\n                                    caseExpression = expr(false);\n                                    mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                                    decompiler.addEOL(Token.COLON);\n                                    break;\n                                case Token.DEFAULT:\n                                    if (hasDefault) {\n                                        reportError(\"msg.double.switch.default\");\n                                    }\n                                    decompiler.addToken(Token.DEFAULT);\n                                    hasDefault = true;\n                                    caseExpression = null;\n                                    mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                                    decompiler.addEOL(Token.COLON);\n                                    break;\n                                default:\n                                    reportError(\"msg.bad.switch\");\n                                    break switchLoop;\n                            }\n                            Node block = nf.createLeaf(Token.BLOCK);\n                            while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {\n                                nf.addChildToBack(block, statement());\n                            }\n                            // caseExpression == null => add default label\n                            nf.addSwitchCase(pn, caseExpression, block);\n                        }\n                        decompiler.addEOL(Token.RC);\n                        nf.closeSwitch(pn);\n                    } finally {\n                        exitSwitch();\n                    }\n                    return pn;\n                }\n            case Token.WHILE:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.WHILE);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        Node cond = condition();\n                        decompiler.addEOL(Token.LC);\n                        Node body = statement();\n                        decompiler.addEOL(Token.RC);\n                        pn = nf.createWhile(loop, cond, body);\n                    } finally {\n                        exitLoop(true);\n                    }\n                    return pn;\n                }\n            case Token.DO:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.DO);\n                    decompiler.addEOL(Token.LC);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        Node body = statement();\n                        decompiler.addToken(Token.RC);\n                        mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                        decompiler.addToken(Token.WHILE);\n                        Node cond = condition();\n                        pn = nf.createDoWhile(loop, body, cond);\n                    } finally {\n                        exitLoop(true);\n                    }\n                    // Always auto-insert semicolon to follow SpiderMonkey:\n                    // It is required by ECMAScript but is ignored by the rest of\n                    // world, see bug 238945\n                    matchToken(Token.SEMI);\n                    decompiler.addEOL(Token.SEMI);\n                    return pn;\n                }\n            case Token.FOR:\n                {\n                    consumeToken();\n                    boolean isForEach = false;\n                    decompiler.addToken(Token.FOR);\n                    Node loop = enterLoop(statementLabel, true);\n                    try {\n                        // Node init is also foo in 'foo in object'\n                        Node init;\n                        // Node cond is also object in 'foo in object'\n                        Node cond;\n                        Node incr = null;\n                        Node body;\n                        int declType = -1;\n                        // See if this is a for each () instead of just a for ()\n                        if (matchToken(Token.NAME)) {\n                            decompiler.addName(ts.getString());\n                            if (ts.getString().equals(\"each\")) {\n                                isForEach = true;\n                            } else {\n                                reportError(\"msg.no.paren.for\");\n                            }\n                        }\n                        mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                        decompiler.addToken(Token.LP);\n                        tt = peekToken();\n                        if (tt == Token.SEMI) {\n                            init = nf.createLeaf(Token.EMPTY);\n                        } else {\n                            if (tt == Token.VAR || tt == Token.LET) {\n                                // set init to a var list or initial\n                                // consume the token\n                                consumeToken();\n                                decompiler.addToken(tt);\n                                init = variables(true, tt);\n                                declType = tt;\n                            } else {\n                                init = expr(true);\n                            }\n                        }\n                        if (matchToken(Token.IN)) {\n                            decompiler.addToken(Token.IN);\n                            // 'cond' is the object over which we're iterating\n                            cond = expr(false);\n                        } else {\n                            // ordinary for loop\n                            mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                            decompiler.addToken(Token.SEMI);\n                            if (peekToken() == Token.SEMI) {\n                                // no loop condition\n                                cond = nf.createLeaf(Token.EMPTY);\n                            } else {\n                                cond = expr(false);\n                            }\n                            mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                            decompiler.addToken(Token.SEMI);\n                            if (peekToken() == Token.RP) {\n                                incr = nf.createLeaf(Token.EMPTY);\n                            } else {\n                                incr = expr(false);\n                            }\n                        }\n                        mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                        decompiler.addToken(Token.RP);\n                        decompiler.addEOL(Token.LC);\n                        body = statement();\n                        decompiler.addEOL(Token.RC);\n                        if (incr == null) {\n                            // cond could be null if 'in obj' got eaten\n                            // by the init node.\n                            pn = nf.createForIn(declType, loop, init, cond, body, isForEach);\n                        } else {\n                            pn = nf.createFor(loop, init, cond, incr, body);\n                        }\n                    } finally {\n                        exitLoop(true);\n                    }\n                    return pn;\n                }\n            case Token.TRY:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    Node tryblock;\n                    Node catchblocks = null;\n                    Node finallyblock = null;\n                    decompiler.addToken(Token.TRY);\n                    if (peekToken() != Token.LC) {\n                        reportError(\"msg.no.brace.try\");\n                    }\n                    decompiler.addEOL(Token.LC);\n                    tryblock = statement();\n                    decompiler.addEOL(Token.RC);\n                    catchblocks = nf.createLeaf(Token.BLOCK);\n                    boolean sawDefaultCatch = false;\n                    int peek = peekToken();\n                    if (peek == Token.CATCH) {\n                        while (matchToken(Token.CATCH)) {\n                            if (sawDefaultCatch) {\n                                reportError(\"msg.catch.unreachable\");\n                            }\n                            decompiler.addToken(Token.CATCH);\n                            mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                            decompiler.addToken(Token.LP);\n                            mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                            String varName = ts.getString();\n                            decompiler.addName(varName);\n                            Node catchCond = null;\n                            if (matchToken(Token.IF)) {\n                                decompiler.addToken(Token.IF);\n                                catchCond = expr(false);\n                            } else {\n                                sawDefaultCatch = true;\n                            }\n                            mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                            decompiler.addToken(Token.RP);\n                            mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                            decompiler.addEOL(Token.LC);\n                            nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(null), ts.getLineno()));\n                            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                            decompiler.addEOL(Token.RC);\n                        }\n                    } else if (peek != Token.FINALLY) {\n                        mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n                    }\n                    if (matchToken(Token.FINALLY)) {\n                        decompiler.addToken(Token.FINALLY);\n                        decompiler.addEOL(Token.LC);\n                        finallyblock = statement();\n                        decompiler.addEOL(Token.RC);\n                    }\n                    pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);\n                    return pn;\n                }\n            case Token.THROW:\n                {\n                    consumeToken();\n                    if (peekTokenOrEOL() == Token.EOL) {\n                        // ECMAScript does not allow new lines before throw expression,\n                        // see bug 256617\n                        reportError(\"msg.bad.throw.eol\");\n                    }\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.THROW);\n                    pn = nf.createThrow(expr(false), lineno);\n                    break;\n                }\n            case Token.BREAK:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.BREAK);\n                    // matchJumpLabelName only matches if there is one\n                    Node breakStatement = matchJumpLabelName();\n                    if (breakStatement == null) {\n                        if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                            reportError(\"msg.bad.break\");\n                            return null;\n                        }\n                        breakStatement = (Node) loopAndSwitchSet.peek();\n                    }\n                    pn = nf.createBreak(breakStatement, lineno);\n                    break;\n                }\n            case Token.CONTINUE:\n                {\n                    consumeToken();\n                    int lineno = ts.getLineno();\n                    decompiler.addToken(Token.CONTINUE);\n                    Node loop;\n                    // matchJumpLabelName only matches if there is one\n                    Node label = matchJumpLabelName();\n                    if (label == null) {\n                        if (loopSet == null || loopSet.size() == 0) {\n                            reportError(\"msg.continue.outside\");\n                            return null;\n                        }\n                        loop = (Node) loopSet.peek();\n                    } else {\n                        loop = nf.getLabelLoop(label);\n                        if (loop == null) {\n                            reportError(\"msg.continue.nonloop\");\n                            return null;\n                        }\n                    }\n                    pn = nf.createContinue(loop, lineno);\n                    break;\n                }\n            case Token.WITH:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.WITH);\n                    int lineno = ts.getLineno();\n                    mustMatchToken(Token.LP, \"msg.no.paren.with\");\n                    decompiler.addToken(Token.LP);\n                    Node obj = expr(false);\n                    mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n                    decompiler.addToken(Token.RP);\n                    decompiler.addEOL(Token.LC);\n                    ++nestingOfWith;\n                    Node body;\n                    try {\n                        body = statement();\n                    } finally {\n                        --nestingOfWith;\n                    }\n                    decompiler.addEOL(Token.RC);\n                    pn = nf.createWith(obj, body, lineno);\n                    return pn;\n                }\n            case Token.CONST:\n            case Token.VAR:\n                {\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = variables(false, tt);\n                    break;\n                }\n            case Token.LET:\n                {\n                    consumeToken();\n                    decompiler.addToken(Token.LET);\n                    if (peekToken() == Token.LP) {\n                        return let(true);\n                    } else {\n                        pn = variables(false, tt);\n                        if (peekToken() == Token.SEMI)\n                            break;\n                        return pn;\n                    }\n                }\n            case Token.RETURN:\n            case Token.YIELD:\n                {\n                    pn = returnOrYield(tt, false);\n                    break;\n                }\n            case Token.DEBUGGER:\n                consumeToken();\n                decompiler.addToken(Token.DEBUGGER);\n                pn = nf.createDebugger(ts.getLineno());\n                break;\n            case Token.LC:\n                consumeToken();\n                if (statementLabel != null) {\n                    decompiler.addToken(Token.LC);\n                }\n                Node scope = nf.createScopeNode(Token.BLOCK, ts.getLineno());\n                pushScope(scope);\n                try {\n                    statements(scope);\n                    mustMatchToken(Token.RC, \"msg.no.brace.block\");\n                    if (statementLabel != null) {\n                        decompiler.addEOL(Token.RC);\n                    }\n                    return scope;\n                } finally {\n                    popScope();\n                }\n            case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n            case Token.SEMI:\n                consumeToken();\n                pn = nf.createLeaf(Token.EMPTY);\n                return pn;\n            case Token.FUNCTION:\n                {\n                    consumeToken();\n                    pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n                    return pn;\n                }\n            case Token.DEFAULT:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DEFAULT);\n                int nsLine = ts.getLineno();\n                if (!(matchToken(Token.NAME) && ts.getString().equals(\"xml\"))) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addName(\" xml\");\n                if (!(matchToken(Token.NAME) && ts.getString().equals(\"namespace\"))) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addName(\" namespace\");\n                if (!matchToken(Token.ASSIGN)) {\n                    reportError(\"msg.bad.namespace\");\n                }\n                decompiler.addToken(Token.ASSIGN);\n                Node expr = expr(false);\n                pn = nf.createDefaultNamespace(expr, nsLine);\n                break;\n            case Token.NAME:\n                {\n                    int lineno = ts.getLineno();\n                    String name = ts.getString();\n                    setCheckForLabel();\n                    pn = expr(false);\n                    if (pn.getType() != Token.LABEL) {\n                        pn = nf.createExprStatement(pn, lineno);\n                    } else {\n                        // Parsed the label: push back token should be\n                        // colon that primaryExpr left untouched.\n                        if (peekToken() != Token.COLON)\n                            Kit.codeBug();\n                        consumeToken();\n                        // depend on decompiling lookahead to guess that that\n                        // last name was a label.\n                        decompiler.addName(name);\n                        decompiler.addEOL(Token.COLON);\n                        if (labelSet == null) {\n                            labelSet = new HashMap<String, Node>();\n                        } else if (labelSet.containsKey(name)) {\n                            reportError(\"msg.dup.label\");\n                        }\n                        boolean firstLabel;\n                        if (statementLabel == null) {\n                            firstLabel = true;\n                            statementLabel = pn;\n                        } else {\n                            // Discard multiple label nodes and use only\n                            // the first: it allows to simplify IRFactory\n                            firstLabel = false;\n                        }\n                        labelSet.put(name, statementLabel);\n                        try {\n                            pn = statementHelper(statementLabel);\n                        } finally {\n                            labelSet.remove(name);\n                        }\n                        if (firstLabel) {\n                            pn = nf.createLabeledStatement(statementLabel, pn);\n                        }\n                        return pn;\n                    }\n                    break;\n                }\n            default:\n                {\n                    int lineno = ts.getLineno();\n                    pn = expr(false);\n                    pn = nf.createExprStatement(pn, lineno);\n                    break;\n                }\n        }\n        int ttFlagged = peekFlaggedToken();\n        switch(ttFlagged & CLEAR_TI_MASK) {\n            case Token.SEMI:\n                // Consume ';' as a part of expression\n                consumeToken();\n                break;\n            case Token.ERROR:\n            case Token.EOF:\n            case Token.RC:\n                // Autoinsert ;\n                break;\n            default:\n                if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                    // Report error if no EOL or autoinsert ; otherwise\n                    reportError(\"msg.no.semi.stmt\");\n                }\n                break;\n        }\n        decompiler.addEOL(Token.SEMI);\n        return pn;\n    }\n\n    /**\n     * Returns whether or not the bits in the mask have changed to all set.\n     * @param before bits before change\n     * @param after bits after change\n     * @param mask mask for bits\n     * @return true if all the bits in the mask are set in \"after\" but not\n     *              \"before\"\n     */\n    private static final boolean nowAllSet(int before, int after, int mask) {\n        return ((before & mask) != mask) && ((after & mask) == mask);\n    }\n\n    private Node returnOrYield(int tt, boolean exprContext) throws IOException, ParserException {\n        if (!insideFunction()) {\n            reportError(tt == Token.RETURN ? \"msg.bad.return\" : \"msg.bad.yield\");\n        }\n        consumeToken();\n        decompiler.addToken(tt);\n        int lineno = ts.getLineno();\n        Node e;\n        /* This is ugly, but we don't want to require a semicolon. */\n        switch(peekTokenOrEOL()) {\n            case Token.SEMI:\n            case Token.RC:\n            case Token.EOF:\n            case Token.EOL:\n            case Token.ERROR:\n            case Token.RB:\n            case Token.RP:\n            case Token.YIELD:\n                e = null;\n                break;\n            default:\n                e = expr(false);\n                break;\n        }\n        int before = endFlags;\n        Node ret;\n        if (tt == Token.RETURN) {\n            if (e == null) {\n                endFlags |= Node.END_RETURNS;\n            } else {\n                endFlags |= Node.END_RETURNS_VALUE;\n            }\n            ret = nf.createReturn(e, lineno);\n            // see if we need a strict mode warning\n            if (nowAllSet(before, endFlags, Node.END_RETURNS | Node.END_RETURNS_VALUE)) {\n                addStrictWarning(\"msg.return.inconsistent\", \"\");\n            }\n        } else {\n            endFlags |= Node.END_YIELDS;\n            ret = nf.createYield(e, lineno);\n            if (!exprContext)\n                ret = new Node(Token.EXPR_VOID, ret, lineno);\n        }\n        // see if we are mixing yields and value returns.\n        if (nowAllSet(before, endFlags, Node.END_YIELDS | Node.END_RETURNS_VALUE)) {\n            String name = ((FunctionNode) currentScriptOrFn).getFunctionName();\n            if (name.length() == 0)\n                addError(\"msg.anon.generator.returns\", \"\");\n            else\n                addError(\"msg.generator.returns\", name);\n        }\n        return ret;\n    }\n\n    /**\n     * Parse a 'var' or 'const' statement, or a 'var' init list in a for\n     * statement.\n     * @param inFor true if we are currently in the midst of the init\n     * clause of a for.\n     * @param declType A token value: either VAR, CONST, or LET depending on\n     * context.\n     * @return The parsed statement\n     * @throws IOException\n     * @throws ParserException\n     */\n    private Node variables(boolean inFor, int declType) throws IOException, ParserException {\n        Node result = nf.createVariables(declType, ts.getLineno());\n        boolean first = true;\n        for (; ; ) {\n            Node destructuring = null;\n            String s = null;\n            int tt = peekToken();\n            if (tt == Token.LB || tt == Token.LC) {\n                // Destructuring assignment, e.g., var [a,b] = ...\n                destructuring = primaryExpr();\n            } else {\n                // Simple variable name\n                mustMatchToken(Token.NAME, \"msg.bad.var\");\n                s = ts.getString();\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                decompiler.addName(s);\n                defineSymbol(declType, inFor, s);\n            }\n            Node init = null;\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n                init = assignExpr(inFor);\n            }\n            if (destructuring != null) {\n                if (init == null) {\n                    if (!inFor)\n                        reportError(\"msg.destruct.assign.no.init\");\n                    nf.addChildToBack(result, destructuring);\n                } else {\n                    nf.addChildToBack(result, nf.createDestructuringAssignment(declType, destructuring, init));\n                }\n            } else {\n                Node name = nf.createName(s);\n                if (init != null)\n                    nf.addChildToBack(name, init);\n                nf.addChildToBack(result, name);\n            }\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return result;\n    }\n\n    private Node let(boolean isStatement) throws IOException, ParserException {\n        mustMatchToken(Token.LP, \"msg.no.paren.after.let\");\n        decompiler.addToken(Token.LP);\n        Node result = nf.createScopeNode(Token.LET, ts.getLineno());\n        pushScope(result);\n        try {\n            Node vars = variables(false, Token.LET);\n            nf.addChildToBack(result, vars);\n            mustMatchToken(Token.RP, \"msg.no.paren.let\");\n            decompiler.addToken(Token.RP);\n            if (isStatement && peekToken() == Token.LC) {\n                // let statement\n                consumeToken();\n                decompiler.addEOL(Token.LC);\n                nf.addChildToBack(result, statements(null));\n                mustMatchToken(Token.RC, \"msg.no.curly.let\");\n                decompiler.addToken(Token.RC);\n            } else {\n                // let expression\n                result.setType(Token.LETEXPR);\n                nf.addChildToBack(result, expr(false));\n                if (isStatement) {\n                    // let expression in statement context\n                    result = nf.createExprStatement(result, ts.getLineno());\n                }\n            }\n        } finally {\n            popScope();\n        }\n        return result;\n    }\n\n    void defineSymbol(int declType, boolean ignoreNotInBlock, String name) {\n        Node.Scope definingScope = currentScope.getDefiningScope(name);\n        Node.Scope.Symbol symbol = definingScope != null ? definingScope.getSymbol(name) : null;\n        boolean error = false;\n        if (symbol != null && (symbol.declType == Token.CONST || declType == Token.CONST)) {\n            error = true;\n        } else {\n            switch(declType) {\n                case Token.LET:\n                    if (symbol != null && definingScope == currentScope) {\n                        error = symbol.declType == Token.LET;\n                    }\n                    int currentScopeType = currentScope.getType();\n                    if (!ignoreNotInBlock && ((currentScopeType == Token.LOOP) || (currentScopeType == Token.IF))) {\n                        addError(\"msg.let.decl.not.in.block\");\n                    }\n                    currentScope.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    break;\n                case Token.VAR:\n                case Token.CONST:\n                case Token.FUNCTION:\n                    if (symbol != null) {\n                        if (symbol.declType == Token.VAR)\n                            addStrictWarning(\"msg.var.redecl\", name);\n                        else if (symbol.declType == Token.LP) {\n                            addStrictWarning(\"msg.var.hides.arg\", name);\n                        }\n                    } else {\n                        currentScriptOrFn.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    }\n                    break;\n                case Token.LP:\n                    if (symbol != null) {\n                        // must be duplicate parameter. Second parameter hides the\n                        // first, so go ahead and add the second pararameter\n                        addWarning(\"msg.dup.parms\", name);\n                    }\n                    currentScriptOrFn.putSymbol(name, new Node.Scope.Symbol(declType, name));\n                    break;\n                default:\n                    throw Kit.codeBug();\n            }\n        }\n        if (error) {\n            addError(symbol.declType == Token.CONST ? \"msg.const.redecl\" : symbol.declType == Token.LET ? \"msg.let.redecl\" : symbol.declType == Token.VAR ? \"msg.var.redecl\" : symbol.declType == Token.FUNCTION ? \"msg.fn.redecl\" : \"msg.parm.redecl\", name);\n        }\n    }\n\n    private Node expr(boolean inForInit) throws IOException, ParserException {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            if (compilerEnv.isStrictMode() && !pn.hasSideEffects())\n                addStrictWarning(\"msg.no.side.effects\", \"\");\n            if (peekToken() == Token.YIELD) {\n                reportError(\"msg.yield.parenthesized\");\n            }\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit) throws IOException, ParserException {\n        int tt = peekToken();\n        if (tt == Token.YIELD) {\n            consumeToken();\n            return returnOrYield(tt, true);\n        }\n        Node pn = condExpr(inForInit);\n        tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = orExpr(inForInit);\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            Node ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            Node ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = relExpr(inForInit);\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.EQ:\n                case Token.NE:\n                case Token.SHEQ:\n                case Token.SHNE:\n                    consumeToken();\n                    int decompilerToken = tt;\n                    int parseToken = tt;\n                    if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                        // JavaScript 1.2 uses shallow equality for == and != .\n                        // In addition, convert === and !== for decompiler into\n                        // == and != since the decompiler is supposed to show\n                        // canonical source and in 1.2 ===, !== are allowed\n                        // only as an alias to ==, !=.\n                        switch(tt) {\n                            case Token.EQ:\n                                parseToken = Token.SHEQ;\n                                break;\n                            case Token.NE:\n                                parseToken = Token.SHNE;\n                                break;\n                            case Token.SHEQ:\n                                decompilerToken = Token.EQ;\n                                break;\n                            case Token.SHNE:\n                                decompilerToken = Token.NE;\n                                break;\n                        }\n                    }\n                    decompiler.addToken(decompilerToken);\n                    pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit) throws IOException, ParserException {\n        Node pn = shiftExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.IN:\n                    if (inForInit)\n                        break;\n                // fall through\n                case Token.INSTANCEOF:\n                case Token.LE:\n                case Token.LT:\n                case Token.GE:\n                case Token.GT:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, shiftExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr() throws IOException, ParserException {\n        Node pn = addExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.LSH:\n                case Token.URSH:\n                case Token.RSH:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, addExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr() throws IOException, ParserException {\n        Node pn = mulExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node mulExpr() throws IOException, ParserException {\n        Node pn = unaryExpr();\n        for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.MUL:\n                case Token.DIV:\n                case Token.MOD:\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    pn = nf.createBinary(tt, pn, unaryExpr());\n                    continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node unaryExpr() throws IOException, ParserException {\n        int tt;\n        tt = peekToken();\n        switch(tt) {\n            case Token.VOID:\n            case Token.NOT:\n            case Token.BITNOT:\n            case Token.TYPEOF:\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createUnary(tt, unaryExpr());\n            case Token.ADD:\n                consumeToken();\n                // Convert to special POS token in decompiler and parse tree\n                decompiler.addToken(Token.POS);\n                return nf.createUnary(Token.POS, unaryExpr());\n            case Token.SUB:\n                consumeToken();\n                // Convert to special NEG token in decompiler and parse tree\n                decompiler.addToken(Token.NEG);\n                return nf.createUnary(Token.NEG, unaryExpr());\n            case Token.INC:\n            case Token.DEC:\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, false, memberExpr(true));\n            case Token.DELPROP:\n                consumeToken();\n                decompiler.addToken(Token.DELPROP);\n                return nf.createUnary(Token.DELPROP, unaryExpr());\n            case Token.ERROR:\n                consumeToken();\n                break;\n            // XML stream encountered in expression.\n            case Token.LT:\n                if (compilerEnv.isXmlAvailable()) {\n                    consumeToken();\n                    Node pn = xmlInitializer();\n                    return memberExprTail(true, pn);\n                }\n            // Fall thru to the default handling of RELOP\n            default:\n                Node pn = memberExpr(true);\n                // Don't look across a newline boundary for a postfix incop.\n                tt = peekTokenOrEOL();\n                if (tt == Token.INC || tt == Token.DEC) {\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    return nf.createIncDec(tt, true, pn);\n                }\n                return pn;\n        }\n        // Only reached on error.Try to continue.\n        return nf.createName(\"error\");\n    }\n\n    private Node xmlInitializer() throws IOException {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n        pn = null;\n        Node expr;\n        for (; ; tt = ts.getNextXMLToken()) {\n            switch(tt) {\n                case Token.XML:\n                    xml = ts.getString();\n                    decompiler.addName(xml);\n                    mustMatchToken(Token.LC, \"msg.syntax\");\n                    decompiler.addToken(Token.LC);\n                    expr = (peekToken() == Token.RC) ? nf.createString(\"\") : expr(false);\n                    mustMatchToken(Token.RC, \"msg.syntax\");\n                    decompiler.addToken(Token.RC);\n                    if (pn == null) {\n                        pn = nf.createString(xml);\n                    } else {\n                        pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                    }\n                    if (ts.isXMLAttribute()) {\n                        /* Need to put the result in double quotes */\n                        expr = nf.createUnary(Token.ESCXMLATTR, expr);\n                        Node prepend = nf.createBinary(Token.ADD, nf.createString(\"\\\"\"), expr);\n                        expr = nf.createBinary(Token.ADD, prepend, nf.createString(\"\\\"\"));\n                    } else {\n                        expr = nf.createUnary(Token.ESCXMLTEXT, expr);\n                    }\n                    pn = nf.createBinary(Token.ADD, pn, expr);\n                    break;\n                case Token.XMLEND:\n                    xml = ts.getString();\n                    decompiler.addName(xml);\n                    if (pn == null) {\n                        pn = nf.createString(xml);\n                    } else {\n                        pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                    }\n                    nf.addChildToBack(pnXML, pn);\n                    return pnXML;\n                default:\n                    reportError(\"msg.syntax\");\n                    return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode) throws IOException, ParserException {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                if (peekToken() == Token.YIELD) {\n                    reportError(\"msg.yield.parenthesized\");\n                }\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {\n        int tt;\n        Node pn;\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {\n        tailLoop: for (; ; ) {\n            int tt = peekToken();\n            switch(tt) {\n                case Token.DOT:\n                case Token.DOTDOT:\n                    {\n                        int memberTypeFlags;\n                        String s;\n                        consumeToken();\n                        decompiler.addToken(tt);\n                        memberTypeFlags = 0;\n                        if (tt == Token.DOTDOT) {\n                            mustHaveXML();\n                            memberTypeFlags = Node.DESCENDANTS_FLAG;\n                        }\n                        if (!compilerEnv.isXmlAvailable()) {\n                            mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                            s = ts.getString();\n                            decompiler.addName(s);\n                            pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                            break;\n                        }\n                        tt = nextToken();\n                        switch(tt) {\n                            // needed for generator.throw();\n                            case Token.THROW:\n                                decompiler.addName(\"throw\");\n                                pn = propertyName(pn, \"throw\", memberTypeFlags);\n                                break;\n                            // handles: name, ns::name, ns::*, ns::[expr]\n                            case Token.NAME:\n                                s = ts.getString();\n                                decompiler.addName(s);\n                                pn = propertyName(pn, s, memberTypeFlags);\n                                break;\n                            // handles: *, *::name, *::*, *::[expr]\n                            case Token.MUL:\n                                decompiler.addName(\"*\");\n                                pn = propertyName(pn, \"*\", memberTypeFlags);\n                                break;\n                            // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                            //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                            case Token.XMLATTR:\n                                decompiler.addToken(Token.XMLATTR);\n                                pn = attributeAccess(pn, memberTypeFlags);\n                                break;\n                            default:\n                                reportError(\"msg.no.name.after.dot\");\n                        }\n                    }\n                    break;\n                case Token.DOTQUERY:\n                    consumeToken();\n                    mustHaveXML();\n                    decompiler.addToken(Token.DOTQUERY);\n                    pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                    mustMatchToken(Token.RP, \"msg.no.paren\");\n                    decompiler.addToken(Token.RP);\n                    break;\n                case Token.LB:\n                    consumeToken();\n                    decompiler.addToken(Token.LB);\n                    pn = nf.createElementGet(pn, null, expr(false), 0);\n                    mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                    decompiler.addToken(Token.RB);\n                    break;\n                case Token.LP:\n                    if (!allowCallSyntax) {\n                        break tailLoop;\n                    }\n                    consumeToken();\n                    decompiler.addToken(Token.LP);\n                    pn = nf.createCallOrNew(Token.CALL, pn);\n                    /* Add the arguments to pn, if any are supplied. */\n                    argumentList(pn);\n                    break;\n                default:\n                    break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n        switch(tt) {\n            // handles: @name, @ns::name, @ns::*, @ns::[expr]\n            case Token.NAME:\n                {\n                    String s = ts.getString();\n                    decompiler.addName(s);\n                    pn = propertyName(pn, s, memberTypeFlags);\n                }\n                break;\n            // handles: @*, @*::name, @*::*, @*::[expr]\n            case Token.MUL:\n                decompiler.addName(\"*\");\n                pn = propertyName(pn, \"*\", memberTypeFlags);\n                break;\n            // handles @[expr]\n            case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n            default:\n                reportError(\"msg.no.name.after.xmlAttr\");\n                pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n                break;\n        }\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n            int tt = nextToken();\n            switch(tt) {\n                // handles name::name\n                case Token.NAME:\n                    name = ts.getString();\n                    decompiler.addName(name);\n                    break;\n                // handles name::*\n                case Token.MUL:\n                    decompiler.addName(\"*\");\n                    name = \"*\";\n                    break;\n                // handles name::[expr]\n                case Token.LB:\n                    decompiler.addToken(Token.LB);\n                    pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);\n                    mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                    decompiler.addToken(Token.RB);\n                    return pn;\n                default:\n                    reportError(\"msg.no.name.after.coloncolon\");\n                    name = \"?\";\n            }\n        }\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node arrayComprehension(String arrayName, Node expr) throws IOException, ParserException {\n        if (nextToken() != Token.FOR)\n            // shouldn't be here if next token isn't 'for'\n            throw Kit.codeBug();\n        // space after array literal expr\n        decompiler.addName(\" \");\n        decompiler.addToken(Token.FOR);\n        boolean isForEach = false;\n        if (matchToken(Token.NAME)) {\n            decompiler.addName(ts.getString());\n            if (ts.getString().equals(\"each\")) {\n                isForEach = true;\n            } else {\n                reportError(\"msg.no.paren.for\");\n            }\n        }\n        mustMatchToken(Token.LP, \"msg.no.paren.for\");\n        decompiler.addToken(Token.LP);\n        String name;\n        int tt = peekToken();\n        if (tt == Token.LB || tt == Token.LC) {\n            // handle destructuring assignment\n            name = currentScriptOrFn.getNextTempName();\n            defineSymbol(Token.LP, false, name);\n            expr = nf.createBinary(Token.COMMA, nf.createAssignment(Token.ASSIGN, primaryExpr(), nf.createName(name)), expr);\n        } else if (tt == Token.NAME) {\n            consumeToken();\n            name = ts.getString();\n            decompiler.addName(name);\n        } else {\n            reportError(\"msg.bad.var\");\n            return nf.createNumber(0);\n        }\n        Node init = nf.createName(name);\n        // Define as a let since we want the scope of the variable to\n        // be restricted to the array comprehension\n        defineSymbol(Token.LET, false, name);\n        mustMatchToken(Token.IN, \"msg.in.after.for.name\");\n        decompiler.addToken(Token.IN);\n        Node iterator = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n        decompiler.addToken(Token.RP);\n        Node body;\n        tt = peekToken();\n        if (tt == Token.FOR) {\n            body = arrayComprehension(arrayName, expr);\n        } else {\n            Node call = nf.createCallOrNew(Token.CALL, nf.createPropertyGet(nf.createName(arrayName), null, \"push\", 0));\n            call.addChildToBack(expr);\n            body = new Node(Token.EXPR_VOID, call, ts.getLineno());\n            if (tt == Token.IF) {\n                consumeToken();\n                decompiler.addToken(Token.IF);\n                int lineno = ts.getLineno();\n                Node cond = condition();\n                body = nf.createIf(cond, body, null, lineno);\n            }\n            mustMatchToken(Token.RB, \"msg.no.bracket.arg\");\n            decompiler.addToken(Token.RB);\n        }\n        Node loop = enterLoop(null, true);\n        try {\n            return nf.createForIn(Token.LET, loop, init, iterator, body, isForEach);\n        } finally {\n            exitLoop(false);\n        }\n    }\n\n    private Node primaryExpr() throws IOException, ParserException {\n        Node pn;\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n        switch(tt) {\n            case Token.FUNCTION:\n                return function(FunctionNode.FUNCTION_EXPRESSION);\n            case Token.LB:\n                {\n                    ObjArray elems = new ObjArray();\n                    int skipCount = 0;\n                    int destructuringLen = 0;\n                    decompiler.addToken(Token.LB);\n                    boolean after_lb_or_comma = true;\n                    for (; ; ) {\n                        tt = peekToken();\n                        if (tt == Token.COMMA) {\n                            consumeToken();\n                            decompiler.addToken(Token.COMMA);\n                            if (!after_lb_or_comma) {\n                                after_lb_or_comma = true;\n                            } else {\n                                elems.add(null);\n                                ++skipCount;\n                            }\n                        } else if (tt == Token.RB) {\n                            consumeToken();\n                            decompiler.addToken(Token.RB);\n                            // for ([a,] in obj) is legal, but for ([a] in obj) is\n                            // not since we have both key and value supplied. The\n                            // trick is that [a,] and [a] are equivalent in other\n                            // array literal contexts. So we calculate a special\n                            // length value just for destructuring assignment.\n                            destructuringLen = elems.size() + (after_lb_or_comma ? 1 : 0);\n                            break;\n                        } else if (skipCount == 0 && elems.size() == 1 && tt == Token.FOR) {\n                            Node scopeNode = nf.createScopeNode(Token.ARRAYCOMP, ts.getLineno());\n                            String tempName = currentScriptOrFn.getNextTempName();\n                            pushScope(scopeNode);\n                            try {\n                                defineSymbol(Token.LET, false, tempName);\n                                Node expr = (Node) elems.get(0);\n                                Node block = nf.createBlock(ts.getLineno());\n                                Node init = new Node(Token.EXPR_VOID, nf.createAssignment(Token.ASSIGN, nf.createName(tempName), nf.createCallOrNew(Token.NEW, nf.createName(\"Array\"))), ts.getLineno());\n                                block.addChildToBack(init);\n                                block.addChildToBack(arrayComprehension(tempName, expr));\n                                scopeNode.addChildToBack(block);\n                                scopeNode.addChildToBack(nf.createName(tempName));\n                                return scopeNode;\n                            } finally {\n                                popScope();\n                            }\n                        } else {\n                            if (!after_lb_or_comma) {\n                                reportError(\"msg.no.bracket.arg\");\n                            }\n                            elems.add(assignExpr(false));\n                            after_lb_or_comma = false;\n                        }\n                    }\n                    return nf.createArrayLiteral(elems, skipCount, destructuringLen);\n                }\n            case Token.LC:\n                {\n                    ObjArray elems = new ObjArray();\n                    decompiler.addToken(Token.LC);\n                    if (!matchToken(Token.RC)) {\n                        boolean first = true;\n                        commaloop: do {\n                            Object property;\n                            if (!first)\n                                decompiler.addToken(Token.COMMA);\n                            else\n                                first = false;\n                            tt = peekToken();\n                            switch(tt) {\n                                case Token.NAME:\n                                case Token.STRING:\n                                    consumeToken();\n                                    // map NAMEs to STRINGs in object literal context\n                                    // but tell the decompiler the proper type\n                                    String s = ts.getString();\n                                    if (tt == Token.NAME) {\n                                        if (s.equals(\"get\") && peekToken() == Token.NAME) {\n                                            decompiler.addToken(Token.GET);\n                                            consumeToken();\n                                            s = ts.getString();\n                                            decompiler.addName(s);\n                                            property = ScriptRuntime.getIndexObject(s);\n                                            if (!getterSetterProperty(elems, property, true))\n                                                break commaloop;\n                                            break;\n                                        } else if (s.equals(\"set\") && peekToken() == Token.NAME) {\n                                            decompiler.addToken(Token.SET);\n                                            consumeToken();\n                                            s = ts.getString();\n                                            decompiler.addName(s);\n                                            property = ScriptRuntime.getIndexObject(s);\n                                            if (!getterSetterProperty(elems, property, false))\n                                                break commaloop;\n                                            break;\n                                        }\n                                        decompiler.addName(s);\n                                    } else {\n                                        decompiler.addString(s);\n                                    }\n                                    property = ScriptRuntime.getIndexObject(s);\n                                    plainProperty(elems, property);\n                                    break;\n                                case Token.NUMBER:\n                                    consumeToken();\n                                    double n = ts.getNumber();\n                                    decompiler.addNumber(n);\n                                    property = ScriptRuntime.getIndexObject(n);\n                                    plainProperty(elems, property);\n                                    break;\n                                case Token.RC:\n                                    // trailing comma is OK.\n                                    break commaloop;\n                                default:\n                                    reportError(\"msg.bad.prop\");\n                                    break commaloop;\n                            }\n                        } while (matchToken(Token.COMMA));\n                        mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n                    }\n                    decompiler.addToken(Token.RC);\n                    return nf.createObjectLiteral(elems);\n                }\n            case Token.LET:\n                decompiler.addToken(Token.LET);\n                return let(false);\n            case Token.LP:\n                /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n                decompiler.addToken(Token.LP);\n                pn = expr(false);\n                pn.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                return pn;\n            case Token.XMLATTR:\n                mustHaveXML();\n                decompiler.addToken(Token.XMLATTR);\n                pn = attributeAccess(null, 0);\n                return pn;\n            case Token.NAME:\n                {\n                    String name = ts.getString();\n                    if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                        if (peekToken() == Token.COLON) {\n                            // Do not consume colon, it is used as unwind indicator\n                            // to return to statementHelper.\n                            // XXX Better way?\n                            return nf.createLabel(ts.getLineno());\n                        }\n                    }\n                    decompiler.addName(name);\n                    if (compilerEnv.isXmlAvailable()) {\n                        pn = propertyName(null, name, 0);\n                    } else {\n                        pn = nf.createName(name);\n                    }\n                    return pn;\n                }\n            case Token.NUMBER:\n                {\n                    double n = ts.getNumber();\n                    decompiler.addNumber(n);\n                    return nf.createNumber(n);\n                }\n            case Token.STRING:\n                {\n                    String s = ts.getString();\n                    decompiler.addString(s);\n                    return nf.createString(s);\n                }\n            case Token.DIV:\n            case Token.ASSIGN_DIV:\n                {\n                    // Got / or /= which should be treated as regexp in fact\n                    ts.readRegExp(tt);\n                    String flags = ts.regExpFlags;\n                    ts.regExpFlags = null;\n                    String re = ts.getString();\n                    decompiler.addRegexp(re, flags);\n                    int index = currentScriptOrFn.addRegexp(re, flags);\n                    return nf.createRegExp(index);\n                }\n            case Token.NULL:\n            case Token.THIS:\n            case Token.FALSE:\n            case Token.TRUE:\n                decompiler.addToken(tt);\n                return nf.createLeaf(tt);\n            case Token.RESERVED:\n                reportError(\"msg.reserved.id\");\n                break;\n            case Token.ERROR:\n                /* the scanner or one of its subroutines reported the error. */\n                break;\n            case Token.EOF:\n                reportError(\"msg.unexpected.eof\");\n                break;\n            case Token.CONDCOMMENT:\n                String condComment = ts.getString();\n                decompiler.addJScriptConditionalComment(condComment);\n                return nf.createString(condComment);\n            case Token.KEEPCOMMENT:\n                String keepComment = ts.getString();\n                decompiler.addPreservedComment(keepComment);\n                return nf.createString(keepComment);\n            default:\n                reportError(\"msg.syntax\");\n                break;\n        }\n        // should never reach here\n        return null;\n    }\n\n    private void plainProperty(ObjArray elems, Object property) throws IOException {\n        mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n        // OBJLIT is used as ':' in object literal for\n        // decompilation to solve spacing ambiguity.\n        decompiler.addToken(Token.OBJECTLIT);\n        elems.add(property);\n        elems.add(assignExpr(false));\n    }\n\n    private boolean getterSetterProperty(ObjArray elems, Object property, boolean isGetter) throws IOException {\n        Node f = function(FunctionNode.FUNCTION_EXPRESSION);\n        if (f.getType() != Token.FUNCTION) {\n            reportError(\"msg.bad.prop\");\n            return false;\n        }\n        int fnIndex = f.getExistingIntProp(Node.FUNCTION_PROP);\n        FunctionNode fn = currentScriptOrFn.getFunctionNode(fnIndex);\n        if (fn.getFunctionName().length() != 0) {\n            reportError(\"msg.bad.prop\");\n            return false;\n        }\n        elems.add(property);\n        if (isGetter) {\n            elems.add(nf.createUnary(Token.GET, f));\n        } else {\n            elems.add(nf.createUnary(Token.SET, f));\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/22_byuic/src/main/java/org/mozilla/javascript/ParserTest2.java",
		"test_prompt": "// ParserTest2.java\npackage org.mozilla.javascript;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Parser}.\n* It contains ten unit test cases for the {@link Parser#parse(Reader, String, int)} method.\n*/\nclass ParserTest2 {"
	},
	{
		"original_code": "// Decompiler.java\n/* ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License\n * Version 1.1 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License\n * at http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * See the License for the specific language governing rights and\n * limitations under the License.\n *\n * The Original Code is org/mozilla/javascript/Decompiler.java,\n * a component of the Rhino Library ( http://www.mozilla.org/rhino/ )\n * This file is a modification of the Original Code developed\n * for YUI Compressor.\n *\n * The Initial Developer of the Original Code is Mozilla Foundation\n *\n * Copyright (c) 2009 Mozilla Foundation. All Rights Reserved.\n *\n * Contributor(s):  Yahoo! Inc. 2009\n *\n * ***** END LICENSE BLOCK ***** */\npackage org.mozilla.javascript;\n\n/**\n * The following class save decompilation information about the source.\n * Source information is returned from the parser as a String\n * associated with function nodes and with the toplevel script.  When\n * saved in the constant pool of a class, this string will be UTF-8\n * encoded, and token values will occupy a single byte.\n *\n * Source is saved (mostly) as token numbers.  The tokens saved pretty\n * much correspond to the token stream of a 'canonical' representation\n * of the input program, as directed by the parser.  (There were a few\n * cases where tokens could have been left out where decompiler could\n * easily reconstruct them, but I left them in for clarity).  (I also\n * looked adding source collection to TokenStream instead, where I\n * could have limited the changes to a few lines in getToken... but\n * this wouldn't have saved any space in the resulting source\n * representation, and would have meant that I'd have to duplicate\n * parser logic in the decompiler to disambiguate situations where\n * newlines are important.)  The function decompile expands the\n * tokens back into their string representations, using simple\n * lookahead to correct spacing and indentation.\n *\n * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens\n * are stored inline, as a NUMBER token, a character representing the type, and\n * either 1 or 4 characters representing the bit-encoding of the number.  String\n * types NAME, STRING and OBJECT are currently stored as a token type,\n * followed by a character giving the length of the string (assumed to\n * be less than 2^16), followed by the characters of the string\n * inlined into the source string.  Changing this to some reference to\n * to the string in the compiled class' constant pool would probably\n * save a lot of space... but would require some method of deriving\n * the final constant pool entry from information available at parse\n * time.\n */\npublic class Decompiler {\n\n    /**\n     * Flag to indicate that the decompilation should omit the\n     * function header and trailing brace.\n     */\n    public static final int ONLY_BODY_FLAG = 1 << 0;\n\n    /**\n     * Flag to indicate that the decompilation generates toSource result.\n     */\n    public static final int TO_SOURCE_FLAG = 1 << 1;\n\n    /**\n     * Decompilation property to specify initial ident value.\n     */\n    public static final int INITIAL_INDENT_PROP = 1;\n\n    /**\n     * Decompilation property to specify default identation offset.\n     */\n    public static final int INDENT_GAP_PROP = 2;\n\n    /**\n     * Decompilation property to specify identation offset for case labels.\n     */\n    public static final int CASE_GAP_PROP = 3;\n\n    // Marker to denote the last RC of function so it can be distinguished from\n    // the last RC of object literals in case of function expressions\n    private static final int FUNCTION_END = Token.LAST_TOKEN + 1;\n\n    String getEncodedSource() {\n        return sourceToString(0);\n    }\n\n    int getCurrentOffset() {\n        return sourceTop;\n    }\n\n    int markFunctionStart(int functionType) {\n        int savedOffset = getCurrentOffset();\n        addToken(Token.FUNCTION);\n        append((char) functionType);\n        return savedOffset;\n    }\n\n    int markFunctionEnd(int functionStart) {\n        int offset = getCurrentOffset();\n        append((char) FUNCTION_END);\n        return offset;\n    }\n\n    void addToken(int token) {\n        if (!(0 <= token && token <= Token.LAST_TOKEN))\n            throw new IllegalArgumentException();\n        append((char) token);\n    }\n\n    void addEOL(int token) {\n        if (!(0 <= token && token <= Token.LAST_TOKEN))\n            throw new IllegalArgumentException();\n        append((char) token);\n        append((char) Token.EOL);\n    }\n\n    void addName(String str) {\n        addToken(Token.NAME);\n        appendString(str);\n    }\n\n    void addString(String str) {\n        addToken(Token.STRING);\n        appendString(str);\n    }\n\n    void addRegexp(String regexp, String flags) {\n        addToken(Token.REGEXP);\n        appendString('/' + regexp + '/' + flags);\n    }\n\n    void addJScriptConditionalComment(String str) {\n        addToken(Token.CONDCOMMENT);\n        appendString(str);\n    }\n\n    void addPreservedComment(String str) {\n        addToken(Token.KEEPCOMMENT);\n        appendString(str);\n    }\n\n    void addNumber(double n) {\n        addToken(Token.NUMBER);\n        /* encode the number in the source stream.\n         * Save as NUMBER type (char | char char char char)\n         * where type is\n         * 'D' - double, 'S' - short, 'J' - long.\n\n         * We need to retain float vs. integer type info to keep the\n         * behavior of liveconnect type-guessing the same after\n         * decompilation.  (Liveconnect tries to present 1.0 to Java\n         * as a float/double)\n         * OPT: This is no longer true. We could compress the format.\n\n         * This may not be the most space-efficient encoding;\n         * the chars created below may take up to 3 bytes in\n         * constant pool UTF-8 encoding, so a Double could take\n         * up to 12 bytes.\n         */\n        long lbits = (long) n;\n        if (lbits != n) {\n            // if it's floating point, save as a Double bit pattern.\n            // (12/15/97 our scanner only returns Double for f.p.)\n            lbits = Double.doubleToLongBits(n);\n            append('D');\n            append((char) (lbits >> 48));\n            append((char) (lbits >> 32));\n            append((char) (lbits >> 16));\n            append((char) lbits);\n        } else {\n            // we can ignore negative values, bc they're already prefixed\n            // by NEG\n            if (lbits < 0)\n                Kit.codeBug();\n            // will it fit in a char?\n            // this gives a short encoding for integer values up to 2^16.\n            if (lbits <= Character.MAX_VALUE) {\n                append('S');\n                append((char) lbits);\n            } else {\n                // Integral, but won't fit in a char. Store as a long.\n                append('J');\n                append((char) (lbits >> 48));\n                append((char) (lbits >> 32));\n                append((char) (lbits >> 16));\n                append((char) lbits);\n            }\n        }\n    }\n\n    private void appendString(String str) {\n        int L = str.length();\n        int lengthEncodingSize = 1;\n        if (L >= 0x8000) {\n            lengthEncodingSize = 2;\n        }\n        int nextTop = sourceTop + lengthEncodingSize + L;\n        if (nextTop > sourceBuffer.length) {\n            increaseSourceCapacity(nextTop);\n        }\n        if (L >= 0x8000) {\n            // Use 2 chars to encode strings exceeding 32K, were the highest\n            // bit in the first char indicates presence of the next byte\n            sourceBuffer[sourceTop] = (char) (0x8000 | (L >>> 16));\n            ++sourceTop;\n        }\n        sourceBuffer[sourceTop] = (char) L;\n        ++sourceTop;\n        str.getChars(0, L, sourceBuffer, sourceTop);\n        sourceTop = nextTop;\n    }\n\n    private void append(char c) {\n        if (sourceTop == sourceBuffer.length) {\n            increaseSourceCapacity(sourceTop + 1);\n        }\n        sourceBuffer[sourceTop] = c;\n        ++sourceTop;\n    }\n\n    private void increaseSourceCapacity(int minimalCapacity) {\n        // Call this only when capacity increase is must\n        if (minimalCapacity <= sourceBuffer.length)\n            Kit.codeBug();\n        int newCapacity = sourceBuffer.length * 2;\n        if (newCapacity < minimalCapacity) {\n            newCapacity = minimalCapacity;\n        }\n        char[] tmp = new char[newCapacity];\n        System.arraycopy(sourceBuffer, 0, tmp, 0, sourceTop);\n        sourceBuffer = tmp;\n    }\n\n    private String sourceToString(int offset) {\n        if (offset < 0 || sourceTop < offset)\n            Kit.codeBug();\n        return new String(sourceBuffer, offset, sourceTop - offset);\n    }\n\n    /**\n     * Decompile the source information associated with this js\n     * function/script back into a string.  For the most part, this\n     * just means translating tokens back to their string\n     * representations; there's a little bit of lookahead logic to\n     * decide the proper spacing/indentation.  Most of the work in\n     * mapping the original source to the prettyprinted decompiled\n     * version is done by the parser.\n     *\n     * @param source encoded source tree presentation\n     *\n     * @param flags flags to select output format\n     *\n     * @param properties indentation properties\n     */\n    public static String decompile(String source, int flags, UintMap properties) {\n        int length = source.length();\n        if (length == 0) {\n            return \"\";\n        }\n        int indent = properties.getInt(INITIAL_INDENT_PROP, 0);\n        if (indent < 0)\n            throw new IllegalArgumentException();\n        int indentGap = properties.getInt(INDENT_GAP_PROP, 4);\n        if (indentGap < 0)\n            throw new IllegalArgumentException();\n        int caseGap = properties.getInt(CASE_GAP_PROP, 2);\n        if (caseGap < 0)\n            throw new IllegalArgumentException();\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n        // Spew tokens in source, for debugging.\n        // as TYPE number char\n        if (printSource) {\n            System.err.println(\"length:\" + length);\n            for (int i = 0; i < length; ++i) {\n                // Note that tokenToName will fail unless Context.printTrees\n                // is true.\n                String tokenname = null;\n                if (Token.printNames) {\n                    tokenname = Token.name(source.charAt(i));\n                }\n                if (tokenname == null) {\n                    tokenname = \"---\";\n                }\n                String pad = tokenname.length() > 7 ? \"\\t\" : \"\\t\\t\";\n                System.err.println(tokenname + pad + (int) source.charAt(i) + \"\\t'\" + ScriptRuntime.escapeString(source.substring(i, i + 1)) + \"'\");\n            }\n            System.err.println();\n        }\n        int braceNesting = 0;\n        boolean afterFirstEOL = false;\n        int i = 0;\n        int topFunctionType;\n        if (source.charAt(i) == Token.SCRIPT) {\n            ++i;\n            topFunctionType = -1;\n        } else {\n            topFunctionType = source.charAt(i + 1);\n        }\n        if (!toSource) {\n            // add an initial newline to exactly match js.\n            result.append('\\n');\n            for (int j = 0; j < indent; j++) result.append(' ');\n        } else {\n            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {\n                result.append('(');\n            }\n        }\n        while (i < length) {\n            switch(source.charAt(i)) {\n                case Token.GET:\n                case Token.SET:\n                    result.append(source.charAt(i) == Token.GET ? \"get \" : \"set \");\n                    ++i;\n                    i = printSourceString(source, i + 1, false, result);\n                    // Now increment one more to get past the FUNCTION token\n                    ++i;\n                    break;\n                case Token.NAME:\n                case // re-wrapped in '/'s in parser...\n                Token.REGEXP:\n                    i = printSourceString(source, i + 1, false, result);\n                    continue;\n                case Token.STRING:\n                    i = printSourceString(source, i + 1, true, result);\n                    continue;\n                case Token.NUMBER:\n                    i = printSourceNumber(source, i + 1, result);\n                    continue;\n                case Token.TRUE:\n                    result.append(\"true\");\n                    break;\n                case Token.FALSE:\n                    result.append(\"false\");\n                    break;\n                case Token.NULL:\n                    result.append(\"null\");\n                    break;\n                case Token.THIS:\n                    result.append(\"this\");\n                    break;\n                case Token.FUNCTION:\n                    // skip function type\n                    ++i;\n                    result.append(\"function \");\n                    break;\n                case FUNCTION_END:\n                    // Do nothing\n                    break;\n                case Token.COMMA:\n                    result.append(\", \");\n                    break;\n                case Token.LC:\n                    ++braceNesting;\n                    if (Token.EOL == getNext(source, length, i))\n                        indent += indentGap;\n                    result.append('{');\n                    break;\n                case Token.RC:\n                    {\n                        --braceNesting;\n                        /* don't print the closing RC if it closes the\n                 * toplevel function and we're called from\n                 * decompileFunctionBody.\n                 */\n                        if (justFunctionBody && braceNesting == 0)\n                            break;\n                        result.append('}');\n                        switch(getNext(source, length, i)) {\n                            case Token.EOL:\n                            case FUNCTION_END:\n                                indent -= indentGap;\n                                break;\n                            case Token.WHILE:\n                            case Token.ELSE:\n                                indent -= indentGap;\n                                result.append(' ');\n                                break;\n                        }\n                        break;\n                    }\n                case Token.LP:\n                    result.append('(');\n                    break;\n                case Token.RP:\n                    result.append(')');\n                    if (Token.LC == getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.LB:\n                    result.append('[');\n                    break;\n                case Token.RB:\n                    result.append(']');\n                    break;\n                case Token.EOL:\n                    {\n                        if (toSource)\n                            break;\n                        boolean newLine = true;\n                        if (!afterFirstEOL) {\n                            afterFirstEOL = true;\n                            if (justFunctionBody) {\n                                /* throw away just added 'function name(...) {'\n                         * and restore the original indent\n                         */\n                                result.setLength(0);\n                                indent -= indentGap;\n                                newLine = false;\n                            }\n                        }\n                        if (newLine) {\n                            result.append('\\n');\n                        }\n                        /* add indent if any tokens remain,\n                 * less setback if next token is\n                 * a label, case or default.\n                 */\n                        if (i + 1 < length) {\n                            int less = 0;\n                            int nextToken = source.charAt(i + 1);\n                            if (nextToken == Token.CASE || nextToken == Token.DEFAULT) {\n                                less = indentGap - caseGap;\n                            } else if (nextToken == Token.RC) {\n                                less = indentGap;\n                            } else /* elaborate check against label... skip past a\n                     * following inlined NAME and look for a COLON.\n                     */\n                            if (nextToken == Token.NAME) {\n                                int afterName = getSourceStringEnd(source, i + 2);\n                                if (source.charAt(afterName) == Token.COLON)\n                                    less = indentGap;\n                            }\n                            for (; less < indent; less++) result.append(' ');\n                        }\n                        break;\n                    }\n                case Token.DOT:\n                    result.append('.');\n                    break;\n                case Token.NEW:\n                    result.append(\"new \");\n                    break;\n                case Token.DELPROP:\n                    result.append(\"delete \");\n                    break;\n                case Token.IF:\n                    result.append(\"if \");\n                    break;\n                case Token.ELSE:\n                    result.append(\"else \");\n                    break;\n                case Token.FOR:\n                    result.append(\"for \");\n                    break;\n                case Token.IN:\n                    result.append(\" in \");\n                    break;\n                case Token.WITH:\n                    result.append(\"with \");\n                    break;\n                case Token.WHILE:\n                    result.append(\"while \");\n                    break;\n                case Token.DO:\n                    result.append(\"do \");\n                    break;\n                case Token.TRY:\n                    result.append(\"try \");\n                    break;\n                case Token.CATCH:\n                    result.append(\"catch \");\n                    break;\n                case Token.FINALLY:\n                    result.append(\"finally \");\n                    break;\n                case Token.THROW:\n                    result.append(\"throw \");\n                    break;\n                case Token.SWITCH:\n                    result.append(\"switch \");\n                    break;\n                case Token.BREAK:\n                    result.append(\"break\");\n                    if (Token.NAME == getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.CONTINUE:\n                    result.append(\"continue\");\n                    if (Token.NAME == getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.CASE:\n                    result.append(\"case \");\n                    break;\n                case Token.DEFAULT:\n                    result.append(\"default\");\n                    break;\n                case Token.RETURN:\n                    result.append(\"return\");\n                    if (Token.SEMI != getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.VAR:\n                    result.append(\"var \");\n                    break;\n                case Token.LET:\n                    result.append(\"let \");\n                    break;\n                case Token.SEMI:\n                    result.append(';');\n                    if (Token.EOL != getNext(source, length, i)) {\n                        // separators in FOR\n                        result.append(' ');\n                    }\n                    break;\n                case Token.ASSIGN:\n                    result.append(\" = \");\n                    break;\n                case Token.ASSIGN_ADD:\n                    result.append(\" += \");\n                    break;\n                case Token.ASSIGN_SUB:\n                    result.append(\" -= \");\n                    break;\n                case Token.ASSIGN_MUL:\n                    result.append(\" *= \");\n                    break;\n                case Token.ASSIGN_DIV:\n                    result.append(\" /= \");\n                    break;\n                case Token.ASSIGN_MOD:\n                    result.append(\" %= \");\n                    break;\n                case Token.ASSIGN_BITOR:\n                    result.append(\" |= \");\n                    break;\n                case Token.ASSIGN_BITXOR:\n                    result.append(\" ^= \");\n                    break;\n                case Token.ASSIGN_BITAND:\n                    result.append(\" &= \");\n                    break;\n                case Token.ASSIGN_LSH:\n                    result.append(\" <<= \");\n                    break;\n                case Token.ASSIGN_RSH:\n                    result.append(\" >>= \");\n                    break;\n                case Token.ASSIGN_URSH:\n                    result.append(\" >>>= \");\n                    break;\n                case Token.HOOK:\n                    result.append(\" ? \");\n                    break;\n                case Token.OBJECTLIT:\n                    // pun OBJECTLIT to mean colon in objlit property\n                    // initialization.\n                    // This needs to be distinct from COLON in the general case\n                    // to distinguish from the colon in a ternary... which needs\n                    // different spacing.\n                    result.append(':');\n                    break;\n                case Token.COLON:\n                    if (Token.EOL == getNext(source, length, i))\n                        // it's the end of a label\n                        result.append(':');\n                    else\n                        // it's the middle part of a ternary\n                        result.append(\" : \");\n                    break;\n                case Token.OR:\n                    result.append(\" || \");\n                    break;\n                case Token.AND:\n                    result.append(\" && \");\n                    break;\n                case Token.BITOR:\n                    result.append(\" | \");\n                    break;\n                case Token.BITXOR:\n                    result.append(\" ^ \");\n                    break;\n                case Token.BITAND:\n                    result.append(\" & \");\n                    break;\n                case Token.SHEQ:\n                    result.append(\" === \");\n                    break;\n                case Token.SHNE:\n                    result.append(\" !== \");\n                    break;\n                case Token.EQ:\n                    result.append(\" == \");\n                    break;\n                case Token.NE:\n                    result.append(\" != \");\n                    break;\n                case Token.LE:\n                    result.append(\" <= \");\n                    break;\n                case Token.LT:\n                    result.append(\" < \");\n                    break;\n                case Token.GE:\n                    result.append(\" >= \");\n                    break;\n                case Token.GT:\n                    result.append(\" > \");\n                    break;\n                case Token.INSTANCEOF:\n                    result.append(\" instanceof \");\n                    break;\n                case Token.LSH:\n                    result.append(\" << \");\n                    break;\n                case Token.RSH:\n                    result.append(\" >> \");\n                    break;\n                case Token.URSH:\n                    result.append(\" >>> \");\n                    break;\n                case Token.TYPEOF:\n                    result.append(\"typeof \");\n                    break;\n                case Token.VOID:\n                    result.append(\"void \");\n                    break;\n                case Token.CONST:\n                    result.append(\"const \");\n                    break;\n                case Token.YIELD:\n                    result.append(\"yield \");\n                    break;\n                case Token.NOT:\n                    result.append('!');\n                    break;\n                case Token.BITNOT:\n                    result.append('~');\n                    break;\n                case Token.POS:\n                    result.append('+');\n                    break;\n                case Token.NEG:\n                    result.append('-');\n                    break;\n                case Token.INC:\n                    result.append(\"++\");\n                    break;\n                case Token.DEC:\n                    result.append(\"--\");\n                    break;\n                case Token.ADD:\n                    result.append(\" + \");\n                    break;\n                case Token.SUB:\n                    result.append(\" - \");\n                    break;\n                case Token.MUL:\n                    result.append(\" * \");\n                    break;\n                case Token.DIV:\n                    result.append(\" / \");\n                    break;\n                case Token.MOD:\n                    result.append(\" % \");\n                    break;\n                case Token.COLONCOLON:\n                    result.append(\"::\");\n                    break;\n                case Token.DOTDOT:\n                    result.append(\"..\");\n                    break;\n                case Token.DOTQUERY:\n                    result.append(\".(\");\n                    break;\n                case Token.XMLATTR:\n                    result.append('@');\n                    break;\n                default:\n                    // If we don't know how to decompile it, raise an exception.\n                    throw new RuntimeException(\"Token: \" + Token.name(source.charAt(i)));\n            }\n            ++i;\n        }\n        if (!toSource) {\n            // add that trailing newline if it's an outermost function.\n            if (!justFunctionBody)\n                result.append('\\n');\n        } else {\n            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {\n                result.append(')');\n            }\n        }\n        return result.toString();\n    }\n\n    private static int getNext(String source, int length, int i) {\n        return (i + 1 < length) ? source.charAt(i + 1) : Token.EOF;\n    }\n\n    private static int getSourceStringEnd(String source, int offset) {\n        return printSourceString(source, offset, false, null);\n    }\n\n    private static int printSourceString(String source, int offset, boolean asQuotedString, StringBuffer sb) {\n        int length = source.charAt(offset);\n        ++offset;\n        if ((0x8000 & length) != 0) {\n            length = ((0x7FFF & length) << 16) | source.charAt(offset);\n            ++offset;\n        }\n        if (sb != null) {\n            String str = source.substring(offset, offset + length);\n            if (!asQuotedString) {\n                sb.append(str);\n            } else {\n                sb.append('\"');\n                sb.append(ScriptRuntime.escapeString(str));\n                sb.append('\"');\n            }\n        }\n        return offset + length;\n    }\n\n    private static int printSourceNumber(String source, int offset, StringBuffer sb) {\n        double number = 0.0;\n        char type = source.charAt(offset);\n        ++offset;\n        if (type == 'S') {\n            if (sb != null) {\n                int ival = source.charAt(offset);\n                number = ival;\n            }\n            ++offset;\n        } else if (type == 'J' || type == 'D') {\n            if (sb != null) {\n                long lbits;\n                lbits = (long) source.charAt(offset) << 48;\n                lbits |= (long) source.charAt(offset + 1) << 32;\n                lbits |= (long) source.charAt(offset + 2) << 16;\n                lbits |= source.charAt(offset + 3);\n                if (type == 'J') {\n                    number = lbits;\n                } else {\n                    number = Double.longBitsToDouble(lbits);\n                }\n            }\n            offset += 4;\n        } else {\n            // Bad source\n            throw new RuntimeException();\n        }\n        if (sb != null) {\n            sb.append(ScriptRuntime.numberToString(number, 10));\n        }\n        return offset;\n    }\n\n    private char[] sourceBuffer = new char[128];\n\n    // Per script/function source buffer top: parent source does not include a\n    // nested functions source and uses function index as a reference instead.\n    private int sourceTop;\n\n    // whether to do a debug print of the source information, when decompiling.\n    private static final boolean printSource = false;\n}\n",
		"id": "EvoSuiteBenchmark/22_byuic/src/main/java/org/mozilla/javascript/DecompilerTest.java",
		"test_prompt": "// DecompilerTest.java\npackage org.mozilla.javascript;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Decompiler}.\n* It contains ten unit test cases for the {@link Decompiler#decompile(String, int, UintMap)} method.\n*/\nclass DecompilerTest {"
	},
	{
		"original_code": "// Token.java\n/* ***** BEGIN LICENSE BLOCK *****\n*\n* Version: MPL 1.1\n*\n* The contents of this file are subject to the Mozilla Public License\n* Version 1.1 (the \"License\"); you may not use this file except in\n* compliance with the License. You may obtain a copy of the License\n* at http://www.mozilla.org/MPL/\n*\n* Software distributed under the License is distributed on an \"AS IS\"\n* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n* See the License for the specific language governing rights and\n* limitations under the License.\n*\n* The Original Code is org/mozilla/javascript/Token.java,\n* a component of the Rhino Library ( http://www.mozilla.org/rhino/ )\n* This file is a modification of the Original Code developed\n* for YUI Compressor.\n*\n* The Initial Developer of the Original Code is Mozilla Foundation\n*\n* Copyright (c) 2009 Mozilla Foundation. All Rights Reserved.\n*\n* Contributor(s): Yahoo! Inc. 2009\n*\n* ***** END LICENSE BLOCK ***** */\npackage org.mozilla.javascript;\n\n/**\n * This class implements the JavaScript scanner.\n *\n * It is based on the C source files jsscan.c and jsscan.h\n * in the jsref package.\n *\n * @see org.mozilla.javascript.Parser\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\npublic class Token {\n\n    // debug flags\n    public static final boolean printTrees = false;\n\n    static final boolean printICode = false;\n\n    static final boolean printNames = printTrees || printICode;\n\n    /**\n     * Token types.  These values correspond to JSTokenType values in\n     * jsscan.c.\n     */\n    public final static int // start enum\n    // well-known as the only code < EOF\n    ERROR = -1, // end of file token - (not EOF_CHAR)\n    EOF = 0, // end of line\n    EOL = 1, // Interpreter reuses the following as bytecodes\n    FIRST_BYTECODE_TOKEN = 2, ENTERWITH = 2, LEAVEWITH = 3, RETURN = 4, GOTO = 5, IFEQ = 6, IFNE = 7, SETNAME = 8, BITOR = 9, BITXOR = 10, BITAND = 11, EQ = 12, NE = 13, LT = 14, LE = 15, GT = 16, GE = 17, LSH = 18, RSH = 19, URSH = 20, ADD = 21, SUB = 22, MUL = 23, DIV = 24, MOD = 25, NOT = 26, BITNOT = 27, POS = 28, NEG = 29, NEW = 30, DELPROP = 31, TYPEOF = 32, GETPROP = 33, GETPROPNOWARN = 34, SETPROP = 35, GETELEM = 36, SETELEM = 37, CALL = 38, NAME = 39, NUMBER = 40, STRING = 41, NULL = 42, THIS = 43, FALSE = 44, TRUE = 45, // shallow equality (===)\n    SHEQ = 46, // shallow inequality (!==)\n    SHNE = 47, REGEXP = 48, BINDNAME = 49, THROW = 50, // rethrow caught exception: catch (e if ) use it\n    RETHROW = 51, IN = 52, INSTANCEOF = 53, LOCAL_LOAD = 54, GETVAR = 55, SETVAR = 56, CATCH_SCOPE = 57, ENUM_INIT_KEYS = 58, ENUM_INIT_VALUES = 59, ENUM_INIT_ARRAY = 60, ENUM_NEXT = 61, ENUM_ID = 62, THISFN = 63, // to return previously stored return result\n    RETURN_RESULT = 64, // array literal\n    ARRAYLIT = 65, // object literal\n    OBJECTLIT = 66, // *reference\n    GET_REF = 67, // *reference    = something\n    SET_REF = 68, // delete reference\n    DEL_REF = 69, // f(args)    = something or f(args)++\n    REF_CALL = 70, // reference for special properties like __proto\n    REF_SPECIAL = 71, // JS 1.7 yield pseudo keyword\n    YIELD = 72, // For XML support:\n    // default xml namespace =\n    DEFAULTNAMESPACE = 73, ESCXMLATTR = 74, ESCXMLTEXT = 75, // Reference for x.@y, x..y etc.\n    REF_MEMBER = 76, // Reference for x.ns::y, x..ns::y etc.\n    REF_NS_MEMBER = 77, // Reference for @y, @[y] etc.\n    REF_NAME = 78, // Reference for ns::y, @ns::y@[y] etc.\n    REF_NS_NAME = 79;\n\n    // End of interpreter bytecodes\n    public final static int LAST_BYTECODE_TOKEN = REF_NS_NAME, TRY = 80, // semicolon\n    SEMI = 81, // left and right brackets\n    LB = 82, RB = 83, // left and right curlies (braces)\n    LC = 84, RC = 85, // left and right parentheses\n    LP = 86, RP = 87, // comma operator\n    COMMA = 88, // simple assignment  (=)\n    ASSIGN = 89, // |=\n    ASSIGN_BITOR = 90, // ^=\n    ASSIGN_BITXOR = 91, // |=\n    ASSIGN_BITAND = 92, // <<=\n    ASSIGN_LSH = 93, // >>=\n    ASSIGN_RSH = 94, // >>>=\n    ASSIGN_URSH = 95, // +=\n    ASSIGN_ADD = 96, // -=\n    ASSIGN_SUB = 97, // *=\n    ASSIGN_MUL = 98, // /=\n    ASSIGN_DIV = 99, // %=\n    ASSIGN_MOD = 100;\n\n    public final static int FIRST_ASSIGN = ASSIGN, LAST_ASSIGN = ASSIGN_MOD, // conditional (?:)\n    HOOK = 101, COLON = 102, // logical or (||)\n    OR = 103, // logical and (&&)\n    AND = 104, // increment/decrement (++ --)\n    INC = 105, DEC = 106, // member operator (.)\n    DOT = 107, // function keyword\n    FUNCTION = 108, // export keyword\n    EXPORT = 109, // import keyword\n    IMPORT = 110, // if keyword\n    IF = 111, // else keyword\n    ELSE = 112, // switch keyword\n    SWITCH = 113, // case keyword\n    CASE = 114, // default keyword\n    DEFAULT = 115, // while keyword\n    WHILE = 116, // do keyword\n    DO = 117, // for keyword\n    FOR = 118, // break keyword\n    BREAK = 119, // continue keyword\n    CONTINUE = 120, // var keyword\n    VAR = 121, // with keyword\n    WITH = 122, // catch keyword\n    CATCH = 123, // finally keyword\n    FINALLY = 124, // void keyword\n    VOID = 125, // reserved keywords\n    RESERVED = 126, EMPTY = 127, /* types used for the parse tree - these never get returned\n         * by the scanner.\n         */\n    // statement block\n    BLOCK = 128, // label\n    LABEL = 129, TARGET = 130, LOOP = 131, // expression statement in functions\n    EXPR_VOID = 132, // expression statement in scripts\n    EXPR_RESULT = 133, JSR = 134, // top-level node for entire script\n    SCRIPT = 135, // for typeof(simple-name)\n    TYPEOFNAME = 136, USE_STACK = 137, // x.y op= something\n    SETPROP_OP = 138, // x[y] op= something\n    SETELEM_OP = 139, LOCAL_BLOCK = 140, // *reference op= something\n    SET_REF_OP = 141, // For XML support:\n    // member operator (..)\n    DOTDOT = 142, // namespace::name\n    COLONCOLON = 143, // XML type\n    XML = 144, // .() -- e.g., x.emps.emp.(name == \"terry\")\n    DOTQUERY = 145, // @\n    XMLATTR = 146, XMLEND = 147, // Optimizer-only-tokens\n    TO_OBJECT = 148, TO_DOUBLE = 149, // JS 1.5 get pseudo keyword\n    GET = 150, // JS 1.5 set pseudo keyword\n    SET = 151, // JS 1.7 let pseudo keyword\n    LET = 152, CONST = 153, SETCONST = 154, SETCONSTVAR = 155, // array comprehension\n    ARRAYCOMP = 156, LETEXPR = 157, WITHEXPR = 158, DEBUGGER = 159, // JScript conditional comment\n    CONDCOMMENT = 160, // /*! ... */ comment\n    KEEPCOMMENT = 161, LAST_TOKEN = 162;\n\n    public static String name(int token) {\n        if (!printNames) {\n            return String.valueOf(token);\n        }\n        switch(token) {\n            case ERROR:\n                return \"ERROR\";\n            case EOF:\n                return \"EOF\";\n            case EOL:\n                return \"EOL\";\n            case ENTERWITH:\n                return \"ENTERWITH\";\n            case LEAVEWITH:\n                return \"LEAVEWITH\";\n            case RETURN:\n                return \"RETURN\";\n            case GOTO:\n                return \"GOTO\";\n            case IFEQ:\n                return \"IFEQ\";\n            case IFNE:\n                return \"IFNE\";\n            case SETNAME:\n                return \"SETNAME\";\n            case BITOR:\n                return \"BITOR\";\n            case BITXOR:\n                return \"BITXOR\";\n            case BITAND:\n                return \"BITAND\";\n            case EQ:\n                return \"EQ\";\n            case NE:\n                return \"NE\";\n            case LT:\n                return \"LT\";\n            case LE:\n                return \"LE\";\n            case GT:\n                return \"GT\";\n            case GE:\n                return \"GE\";\n            case LSH:\n                return \"LSH\";\n            case RSH:\n                return \"RSH\";\n            case URSH:\n                return \"URSH\";\n            case ADD:\n                return \"ADD\";\n            case SUB:\n                return \"SUB\";\n            case MUL:\n                return \"MUL\";\n            case DIV:\n                return \"DIV\";\n            case MOD:\n                return \"MOD\";\n            case NOT:\n                return \"NOT\";\n            case BITNOT:\n                return \"BITNOT\";\n            case POS:\n                return \"POS\";\n            case NEG:\n                return \"NEG\";\n            case NEW:\n                return \"NEW\";\n            case DELPROP:\n                return \"DELPROP\";\n            case TYPEOF:\n                return \"TYPEOF\";\n            case GETPROP:\n                return \"GETPROP\";\n            case GETPROPNOWARN:\n                return \"GETPROPNOWARN\";\n            case SETPROP:\n                return \"SETPROP\";\n            case GETELEM:\n                return \"GETELEM\";\n            case SETELEM:\n                return \"SETELEM\";\n            case CALL:\n                return \"CALL\";\n            case NAME:\n                return \"NAME\";\n            case NUMBER:\n                return \"NUMBER\";\n            case STRING:\n                return \"STRING\";\n            case NULL:\n                return \"NULL\";\n            case THIS:\n                return \"THIS\";\n            case FALSE:\n                return \"FALSE\";\n            case TRUE:\n                return \"TRUE\";\n            case SHEQ:\n                return \"SHEQ\";\n            case SHNE:\n                return \"SHNE\";\n            case REGEXP:\n                return \"OBJECT\";\n            case BINDNAME:\n                return \"BINDNAME\";\n            case THROW:\n                return \"THROW\";\n            case RETHROW:\n                return \"RETHROW\";\n            case IN:\n                return \"IN\";\n            case INSTANCEOF:\n                return \"INSTANCEOF\";\n            case LOCAL_LOAD:\n                return \"LOCAL_LOAD\";\n            case GETVAR:\n                return \"GETVAR\";\n            case SETVAR:\n                return \"SETVAR\";\n            case CATCH_SCOPE:\n                return \"CATCH_SCOPE\";\n            case ENUM_INIT_KEYS:\n                return \"ENUM_INIT_KEYS\";\n            case ENUM_INIT_VALUES:\n                return \"ENUM_INIT_VALUES\";\n            case ENUM_INIT_ARRAY:\n                return \"ENUM_INIT_ARRAY\";\n            case ENUM_NEXT:\n                return \"ENUM_NEXT\";\n            case ENUM_ID:\n                return \"ENUM_ID\";\n            case THISFN:\n                return \"THISFN\";\n            case RETURN_RESULT:\n                return \"RETURN_RESULT\";\n            case ARRAYLIT:\n                return \"ARRAYLIT\";\n            case OBJECTLIT:\n                return \"OBJECTLIT\";\n            case GET_REF:\n                return \"GET_REF\";\n            case SET_REF:\n                return \"SET_REF\";\n            case DEL_REF:\n                return \"DEL_REF\";\n            case REF_CALL:\n                return \"REF_CALL\";\n            case REF_SPECIAL:\n                return \"REF_SPECIAL\";\n            case DEFAULTNAMESPACE:\n                return \"DEFAULTNAMESPACE\";\n            case ESCXMLTEXT:\n                return \"ESCXMLTEXT\";\n            case ESCXMLATTR:\n                return \"ESCXMLATTR\";\n            case REF_MEMBER:\n                return \"REF_MEMBER\";\n            case REF_NS_MEMBER:\n                return \"REF_NS_MEMBER\";\n            case REF_NAME:\n                return \"REF_NAME\";\n            case REF_NS_NAME:\n                return \"REF_NS_NAME\";\n            case TRY:\n                return \"TRY\";\n            case SEMI:\n                return \"SEMI\";\n            case LB:\n                return \"LB\";\n            case RB:\n                return \"RB\";\n            case LC:\n                return \"LC\";\n            case RC:\n                return \"RC\";\n            case LP:\n                return \"LP\";\n            case RP:\n                return \"RP\";\n            case COMMA:\n                return \"COMMA\";\n            case ASSIGN:\n                return \"ASSIGN\";\n            case ASSIGN_BITOR:\n                return \"ASSIGN_BITOR\";\n            case ASSIGN_BITXOR:\n                return \"ASSIGN_BITXOR\";\n            case ASSIGN_BITAND:\n                return \"ASSIGN_BITAND\";\n            case ASSIGN_LSH:\n                return \"ASSIGN_LSH\";\n            case ASSIGN_RSH:\n                return \"ASSIGN_RSH\";\n            case ASSIGN_URSH:\n                return \"ASSIGN_URSH\";\n            case ASSIGN_ADD:\n                return \"ASSIGN_ADD\";\n            case ASSIGN_SUB:\n                return \"ASSIGN_SUB\";\n            case ASSIGN_MUL:\n                return \"ASSIGN_MUL\";\n            case ASSIGN_DIV:\n                return \"ASSIGN_DIV\";\n            case ASSIGN_MOD:\n                return \"ASSIGN_MOD\";\n            case HOOK:\n                return \"HOOK\";\n            case COLON:\n                return \"COLON\";\n            case OR:\n                return \"OR\";\n            case AND:\n                return \"AND\";\n            case INC:\n                return \"INC\";\n            case DEC:\n                return \"DEC\";\n            case DOT:\n                return \"DOT\";\n            case FUNCTION:\n                return \"FUNCTION\";\n            case EXPORT:\n                return \"EXPORT\";\n            case IMPORT:\n                return \"IMPORT\";\n            case IF:\n                return \"IF\";\n            case ELSE:\n                return \"ELSE\";\n            case SWITCH:\n                return \"SWITCH\";\n            case CASE:\n                return \"CASE\";\n            case DEFAULT:\n                return \"DEFAULT\";\n            case WHILE:\n                return \"WHILE\";\n            case DO:\n                return \"DO\";\n            case FOR:\n                return \"FOR\";\n            case BREAK:\n                return \"BREAK\";\n            case CONTINUE:\n                return \"CONTINUE\";\n            case VAR:\n                return \"VAR\";\n            case WITH:\n                return \"WITH\";\n            case CATCH:\n                return \"CATCH\";\n            case FINALLY:\n                return \"FINALLY\";\n            case VOID:\n                return \"VOID\";\n            case RESERVED:\n                return \"RESERVED\";\n            case EMPTY:\n                return \"EMPTY\";\n            case BLOCK:\n                return \"BLOCK\";\n            case LABEL:\n                return \"LABEL\";\n            case TARGET:\n                return \"TARGET\";\n            case LOOP:\n                return \"LOOP\";\n            case EXPR_VOID:\n                return \"EXPR_VOID\";\n            case EXPR_RESULT:\n                return \"EXPR_RESULT\";\n            case JSR:\n                return \"JSR\";\n            case SCRIPT:\n                return \"SCRIPT\";\n            case TYPEOFNAME:\n                return \"TYPEOFNAME\";\n            case USE_STACK:\n                return \"USE_STACK\";\n            case SETPROP_OP:\n                return \"SETPROP_OP\";\n            case SETELEM_OP:\n                return \"SETELEM_OP\";\n            case LOCAL_BLOCK:\n                return \"LOCAL_BLOCK\";\n            case SET_REF_OP:\n                return \"SET_REF_OP\";\n            case DOTDOT:\n                return \"DOTDOT\";\n            case COLONCOLON:\n                return \"COLONCOLON\";\n            case XML:\n                return \"XML\";\n            case DOTQUERY:\n                return \"DOTQUERY\";\n            case XMLATTR:\n                return \"XMLATTR\";\n            case XMLEND:\n                return \"XMLEND\";\n            case TO_OBJECT:\n                return \"TO_OBJECT\";\n            case TO_DOUBLE:\n                return \"TO_DOUBLE\";\n            case GET:\n                return \"GET\";\n            case SET:\n                return \"SET\";\n            case LET:\n                return \"LET\";\n            case YIELD:\n                return \"YIELD\";\n            case CONST:\n                return \"CONST\";\n            case SETCONST:\n                return \"SETCONST\";\n            case ARRAYCOMP:\n                return \"ARRAYCOMP\";\n            case WITHEXPR:\n                return \"WITHEXPR\";\n            case LETEXPR:\n                return \"LETEXPR\";\n            case DEBUGGER:\n                return \"DEBUGGER\";\n        }\n        // Token without name\n        throw new IllegalStateException(String.valueOf(token));\n    }\n}\n",
		"id": "EvoSuiteBenchmark/22_byuic/src/main/java/org/mozilla/javascript/TokenTest.java",
		"test_prompt": "// TokenTest.java\npackage org.mozilla.javascript;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#name(int)} method.\n*/\nclass TokenTest {"
	},
	{
		"original_code": "// JarClassLoader.java\n/*\n * YUI Compressor\n * http://developer.yahoo.com/yui/compressor/\n * Author: Julien Lecomte -  http://www.julienlecomte.net/\n * Copyright (c) 2011 Yahoo! Inc.  All rights reserved.\n * The copyrights embodied in the content of this file are licensed\n * by Yahoo! Inc. under the BSD (revised) open source license.\n */\npackage com.yahoo.platform.yui.compressor;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Enumeration;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\n\npublic class JarClassLoader extends ClassLoader {\n\n    private static String jarPath;\n\n    public Class loadClass(String name) throws ClassNotFoundException {\n        // First check if the class is already loaded\n        Class c = findLoadedClass(name);\n        if (c == null) {\n            c = findClass(name);\n        }\n        if (c == null) {\n            c = ClassLoader.getSystemClassLoader().loadClass(name);\n        }\n        return c;\n    }\n\n    private static String getJarPath() {\n        if (jarPath != null) {\n            return jarPath;\n        }\n        String classname = JarClassLoader.class.getName().replace('.', '/') + \".class\";\n        String classpath = System.getProperty(\"java.class.path\");\n        String[] classpaths = classpath.split(System.getProperty(\"path.separator\"));\n        for (int i = 0; i < classpaths.length; i++) {\n            String path = classpaths[i];\n            JarFile jarFile = null;\n            JarEntry jarEntry = null;\n            try {\n                jarFile = new JarFile(path);\n                jarEntry = findJarEntry(jarFile, classname);\n            } catch (IOException ioe) {\n                /* ignore */\n            } finally {\n                if (jarFile != null) {\n                    try {\n                        jarFile.close();\n                    } catch (IOException ioe) {\n                        /* ignore */\n                    }\n                }\n            }\n            if (jarEntry != null) {\n                jarPath = path;\n                break;\n            }\n        }\n        return jarPath;\n    }\n\n    private static JarEntry findJarEntry(JarFile jarFile, String entryName) {\n        Enumeration entries = jarFile.entries();\n        while (entries.hasMoreElements()) {\n            JarEntry entry = (JarEntry) entries.nextElement();\n            if (entry.getName().equals(entryName)) {\n                return entry;\n            }\n        }\n        return null;\n    }\n\n    protected Class findClass(String name) {\n        Class c = null;\n        String jarPath = getJarPath();\n        if (jarPath != null) {\n            JarFile jarFile = null;\n            try {\n                jarFile = new JarFile(jarPath);\n                c = loadClassData(jarFile, name);\n            } catch (IOException ioe) {\n                /* ignore */\n            } finally {\n                if (jarFile != null) {\n                    try {\n                        jarFile.close();\n                    } catch (IOException ioe) {\n                        /* ignore */\n                    }\n                }\n            }\n        }\n        return c;\n    }\n\n    private Class loadClassData(JarFile jarFile, String className) {\n        String entryName = className.replace('.', '/') + \".class\";\n        JarEntry jarEntry = findJarEntry(jarFile, entryName);\n        if (jarEntry == null) {\n            return null;\n        }\n        // Create the necessary package if needed...\n        int index = className.lastIndexOf('.');\n        if (index >= 0) {\n            String packageName = className.substring(0, index);\n            if (getPackage(packageName) == null) {\n                definePackage(packageName, \"\", \"\", \"\", \"\", \"\", \"\", null);\n            }\n        }\n        // Read the Jar File entry and define the class...\n        Class c = null;\n        try {\n            InputStream is = jarFile.getInputStream(jarEntry);\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            copy(is, os);\n            byte[] bytes = os.toByteArray();\n            c = defineClass(className, bytes, 0, bytes.length);\n        } catch (IOException ioe) {\n            /* ignore */\n        }\n        return c;\n    }\n\n    private void copy(InputStream in, OutputStream out) throws IOException {\n        byte[] buf = new byte[1024];\n        while (true) {\n            int len = in.read(buf);\n            if (len < 0)\n                break;\n            out.write(buf, 0, len);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/22_byuic/src/main/java/com/yahoo/platform/yui/compressor/JarClassLoaderTest.java",
		"test_prompt": "// JarClassLoaderTest.java\npackage com.yahoo.platform.yui.compressor;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Enumeration;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JarClassLoader}.\n* It contains ten unit test cases for the {@link JarClassLoader#loadClass(String)} method.\n*/\nclass JarClassLoaderTest {"
	}
]