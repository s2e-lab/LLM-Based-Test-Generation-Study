[
	{
		"original_code": "// JCLO.java\npackage edu.mscd.cs.jclo;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Modifier;\n\n/**\n * This class is used to parse command-line arguments based on a the\n * variables with an object.  Each variable in the class specifies a\n * command-line argument that can be accepted; the name of the variable\n * becomes the name of the command-line argument.  As Java does not allow\n * dashes '-' in variables, use two underscores '__' if you want a dash in\n * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),\n * start the variable name with a single underscore.  JCLO uses reflection\n * to determine the type of each variable in the passed object and sets the\n * values in the object passed to it via parsing the command line.  If you\n * include a String array named \"additional\", all non-dashed arguments will\n * be placed in it.\n *\n * @author\t\tSteve Beaty (beatys@mscd.edu) @version\t$Id:\n * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $\n */\npublic class JCLO {\n\n    private Field[] fields;\n\n    private Object object;\n\n    private boolean doubleDashes;\n\n    private boolean hasEquals;\n\n    private String prefix = \"\";\n\n    private String[][] aliases;\n\n    /**\n     * \tA constructor that takes the Object that contains the variables\n     * \tacceptable on a command line.  Call parse (String) to do the actual\n     * \tparsing.\n     *\n     * \t@param\tobject\twhere the variables/arguments are\n     */\n    public JCLO(Object object) {\n        this((String) null, object, null);\n    }\n\n    public JCLO(Object object, String[][] aliases) {\n        this((String) null, object, aliases);\n    }\n\n    public JCLO(String prefix, Object object) {\n        this(prefix, object, null);\n    }\n\n    /**\n     * \tA constructor that takes an Object, a prefix, and a boolean that\n     * \tspecifies whether to accept single or double dashes; call parse\n     * \t(String) to do the actual parsing.\n     *\n     * \t@param\tobject\twhere the variables/arguments are\n     * \t@param\tprefix\tthe String CLO's start with, if any\n     */\n    public JCLO(String prefix, Object object, String[][] aliases) {\n        this.object = object;\n        this.prefix = prefix;\n        this.aliases = aliases;\n        fields = object.getClass().getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n    }\n\n    /**\n     * \tJust a simple method to put the try/catch in one place.\n     *\n     * \t@param\tf\tthe Field to get the value of\n     * \t@return\t\tthe Object with the value\n     */\n    private Object getObject(Field f) {\n        try {\n            return (f.get(object));\n        } catch (java.lang.IllegalAccessException iae) {\n            iae.printStackTrace();\n            System.exit(1);\n        }\n        return (null);\n    }\n\n    private Field getField(String key) {\n        Field f = null;\n        if (prefix != null)\n            key = prefix + key;\n        for (int i = 0; i < fields.length; i++) {\n            String name = fields[i].getName();\n            if (name.equals(key))\n                return (fields[i]);\n        }\n        return (null);\n    }\n\n    /**\n     * \tGet the current value of the variable in the object\n     *\n     * \t@param\tkey\tthe variable name\n     * \t@return\t\tan Object with the value\n     */\n    public Object getValue(String key) {\n        Field f = getField(key);\n        if (f == null) {\n            System.out.println(\"Field not found: \" + key);\n            return (null);\n        }\n        return (getObject(f));\n    }\n\n    /**\n     * \tJust a simple method to put the try/catch in one place.\n     *\n     * \t@param\tf\tthe Field to set the value of\n     * \t@param\to\tthe Object with the value\n     */\n    private void setObject(Field f, Object o) {\n        try {\n            f.set(object, o);\n        } catch (java.lang.IllegalAccessException iae) {\n            iae.printStackTrace();\n        }\n    }\n\n    private String getArrayType(Class type) {\n        return (type.getComponentType().toString().replaceFirst(\"class.*\\\\.\", \"\"));\n    }\n\n    /**\n     * \tAn external representation of the object\n     *\n     * \t@return\t\ta formatted version of this object\n     */\n    public String toString() {\n        String r = \"\";\n        boolean first = true;\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            String key = field.getName();\n            Class type = field.getType();\n            Object object = getObject(field);\n            if (!first)\n                r += \"\\n\";\n            first = false;\n            if (type.isArray()) {\n                r += getArrayType(type) + \"[]\" + \": \" + key + \" = \";\n                r += java.util.Arrays.toString((Object[]) object);\n            } else {\n                r += type.toString().replaceFirst(\"class java.lang.\", \"\") + \": \" + key + \" = \" + object;\n            }\n        }\n        return (r);\n    }\n\n    private String getUsageType(Class type) {\n        if (type.getName().equals(\"boolean\")) {\n            return (doubleDashes ? \"[=boolean]\" : \"\");\n        } else if (type.isArray()) {\n            return ((doubleDashes ? \"=\" : \" \") + getArrayType(type) + \"...\");\n        } else {\n            return ((doubleDashes ? \"=\" : \" \") + type.getName().replaceFirst(\"java.lang.\", \"\"));\n        }\n    }\n\n    /**\n     *  Create and usage message for the acceptable command line variables.\n     *\n     * \t@return\t\ta String that specifies acceptable options\n     */\n    public String usage() {\n        boolean additional = false;\n        String[] a = new String[fields.length];\n        int count = 0;\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            String key = field.getName();\n            Class type = field.getType();\n            if (key.equals(\"additional\"))\n                continue;\n            if (prefix != null) {\n                if (!key.startsWith(prefix))\n                    continue;\n                else\n                    key = key.replaceFirst(\"^\" + prefix, \"\");\n            }\n            if (Modifier.isFinal(field.getModifiers()))\n                continue;\n            key = key.replaceFirst(\"^_([0-9])\", \"$1\");\n            key = key.replaceAll(\"__\", \"-\");\n            key = key.replaceAll(\"_\\\\$\", \".\");\n            a[count++] = (doubleDashes ? \"--\" : \"-\") + key + getUsageType(type) + \"\\n\";\n        }\n        String r = \"\";\n        java.util.Arrays.sort(a, 0, count);\n        for (int i = 0; i < a.length; i++) if (a[i] != null)\n            r += a[i];\n        return (r);\n    }\n\n    private void parseAdditional(String[] args, int i) {\n        int number = args.length - i;\n        String[] add = new String[number];\n        for (int j = 0; j < number; j++, i++) {\n            add[j] = args[i];\n        }\n        Field f = getField(\"additional\");\n        if (f != null) {\n            setObject(f, add);\n        } else {\n            System.err.println(\"No varible 'additional' found\");\n        }\n    }\n\n    /**\n     * \tAdd to object o to the end of the array contained in field and\n     * \treturn the resulting array.\n     *\n     * \t@param\tfield\tthe field in the object\n     * \t@param\to\tthe new object to be placed at the end\n     * \t@return\t\ta formatted version of this object\n     */\n    private Object addToArray(Field field, Object o) {\n        Object ret;\n        Object orig = getObject(field);\n        Class componentType = field.getType().getComponentType();\n        if (// the array is empty\n        orig == null) {\n            ret = Array.newInstance(componentType, 1);\n            Array.set(ret, 0, o);\n        } else {\n            int length = Array.getLength(orig);\n            ret = Array.newInstance(componentType, length + 1);\n            int j;\n            for (j = 0; j < length; j++) {\n                Array.set(ret, j, Array.get(orig, j));\n            }\n            Array.set(ret, j, o);\n        }\n        return (ret);\n    }\n\n    private String getKey(String arg) {\n        if (hasEquals)\n            arg = arg.replaceFirst(\"=.*\", \"\");\n        if (doubleDashes)\n            arg = arg.substring(2);\n        else\n            arg = arg.substring(1);\n        // variables can't start with a number and can't have a dash\n        arg = arg.replaceAll(\"^([0-9])\", \"_$1\");\n        arg = arg.replaceAll(\"-\", \"__\");\n        arg = arg.replaceAll(\"\\\\.\", \"_\\\\$\");\n        if (aliases != null) {\n            for (int i = 0; i < aliases.length; i++) {\n                if (aliases[i][0].equals(arg))\n                    arg = aliases[i][1];\n            }\n        }\n        return (arg);\n    }\n\n    private String getBooleanValue(String arg) {\n        if (hasEquals) {\n            arg = arg.replaceFirst(\"[^=]*=\", \"\");\n            if (arg.equalsIgnoreCase(\"true\") || arg.equalsIgnoreCase(\"yes\"))\n                return (\"true\");\n            else\n                return (\"false\");\n        } else {\n            return (\"true\");\n        }\n    }\n\n    /**\n     * \tMake an Object of the correct type for the field, using a String\n     * \tversion of the value to create it.\n     *\n     * \t@param\ttype\ta String representing the base (or String) type\n     * \t@param\tval\tthe value\n     * \t@return\t\tan Object of the correct type and value\n     */\n    private Object makeObject(String type, String val) {\n        if (type.equals(\"boolean\")) {\n            return (new Boolean(val));\n        }\n        if (type.equals(\"byte\")) {\n            return (new Byte(val));\n        }\n        if (type.equals(\"short\")) {\n            return (new Short(val));\n        }\n        if (type.equals(\"int\")) {\n            return (new Integer(val));\n        }\n        if (type.equals(\"float\")) {\n            return (new Float(val));\n        }\n        if (type.equals(\"double\")) {\n            return (new Double(val));\n        }\n        if (type.equals(\"long\")) {\n            return (new Long(val));\n        }\n        if (type.equals(\"java.lang.String\")) {\n            return (val);\n        }\n        if (type.equals(\"char\")) {\n            return (new Character(val.charAt(0)));\n        }\n        return (null);\n    }\n\n    private String getEqualsValue(String arg) {\n        if (arg.indexOf(\"=\") == -1) {\n            throw (new IllegalArgumentException(\"'\" + arg + \"' requires '=VALUE'\"));\n        } else {\n            return (arg.replaceFirst(\"[^=]*=\", \"\"));\n        }\n    }\n\n    /**\n     * \tParse a command line.\n     *\n     * \t@param\targs\tthe arguments to be parsed\n     */\n    public void parse(String[] args) {\n        for (int i = 0; i < args.length; i++) {\n            if (!args[i].startsWith(\"-\")) {\n                parseAdditional(args, i);\n                return;\n            }\n            doubleDashes = args[i].startsWith(\"--\");\n            hasEquals = args[i].indexOf(\"=\") != -1;\n            String key = getKey(args[i]);\n            Field field = getField(key);\n            if (field == null) {\n                throw (new IllegalArgumentException(\"No such option: \\\"\" + key + \"\\\"\"));\n            }\n            Class type = field.getType();\n            String name = type.getName();\n            if (type.isArray())\n                name = type.getComponentType().getName();\n            String value = null;\n            if (name.equals(\"boolean\"))\n                value = getBooleanValue(args[i]);\n            else if (doubleDashes || hasEquals)\n                value = getEqualsValue(args[i]);\n            else\n                value = args[++i];\n            Object o = makeObject(name, value);\n            if (o == null)\n                continue;\n            if (type.isArray())\n                o = addToArray(field, o);\n            setObject(field, o);\n        }\n    }\n\n    /**\n     * Get a boolean value from the object after parsing.\n     */\n    public boolean getBoolean(String key) {\n        return (((Boolean) getValue(key)).booleanValue());\n    }\n\n    /**\n     * Get a byte value from the object after parsing.\n     */\n    public byte getByte(String key) {\n        return (((Byte) getValue(key)).byteValue());\n    }\n\n    /**\n     * Get a character value from the object after parsing.\n     */\n    public char getChar(String key) {\n        return (((Character) getValue(key)).charValue());\n    }\n\n    /**\n     * Get a short value from the object after parsing.\n     */\n    public short getShort(String key) {\n        return (((Short) getValue(key)).shortValue());\n    }\n\n    /**\n     * Get an integer value from the object after parsing.\n     */\n    public int getInt(String key) {\n        return (((Integer) getValue(key)).intValue());\n    }\n\n    /**\n     * Get a float value from the object after parsing.\n     */\n    public float getFloat(String key) {\n        return (((Float) getValue(key)).floatValue());\n    }\n\n    /**\n     * Get a double value from the object after parsing.\n     */\n    public double getDouble(String key) {\n        return (((Double) getValue(key)).doubleValue());\n    }\n\n    /**\n     * Get a long value from the object after parsing.\n     */\n    public long getLong(String key) {\n        return (((Long) getValue(key)).longValue());\n    }\n\n    /**\n     * Get a String from the object after parsing.\n     */\n    public String getString(String key) {\n        return ((String) getValue(key));\n    }\n\n    /**\n     * Get an array of bytes from the object after parsing.\n     */\n    public byte[] getBytes(String key) {\n        return ((byte[]) getValue(key));\n    }\n\n    /**\n     * Get an array of characaters from the object after parsing.\n     */\n    public char[] getChars(String key) {\n        return ((char[]) getValue(key));\n    }\n\n    /**\n     * Get an array of shorts from the object after parsing.\n     */\n    public short[] getShorts(String key) {\n        return ((short[]) getValue(key));\n    }\n\n    /**\n     * Get an array of integers from the object after parsing.\n     */\n    public int[] getInts(String key) {\n        return ((int[]) getValue(key));\n    }\n\n    /**\n     * Get an array of floats from the object after parsing.\n     */\n    public float[] getFloats(String key) {\n        return ((float[]) getValue(key));\n    }\n\n    /**\n     * Get an array of doubles from the object after parsing.\n     */\n    public double[] getDoubles(String key) {\n        return ((double[]) getValue(key));\n    }\n\n    /**\n     * Get an array of longs from the object after parsing.\n     */\n    public long[] getLongs(String key) {\n        return ((long[]) getValue(key));\n    }\n\n    /**\n     * Get an array of Strings from the object after parsing.\n     */\n    public String[] getStrings(String key) {\n        return ((String[]) getValue(key));\n    }\n\n    public static void main(String[] args) {\n        // cheesy, i know...\n        if (args.length == 1 && args[0].equalsIgnoreCase(\"--version\")) {\n            System.out.println(\"1.3.4\");\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLOTest.java",
		"test_prompt": "// JCLOTest.java\npackage edu.mscd.cs.jclo;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Modifier;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JCLO}.\n* It contains ten unit test cases for the {@link JCLO#usage()} method.\n*/\nclass JCLOTest {"
	}
]