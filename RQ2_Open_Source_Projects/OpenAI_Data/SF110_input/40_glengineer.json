[
	{
		"original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for horizontal layouting.\r\n */\r\npublic class HorizontalBlock extends Block {\r\n\r\n    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public HorizontalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public Block subblock(int x1, int y1, int x2, int y2) {\r\n        return new HorizontalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock cloneWith(CharPosition1 p1) {\r\n        return new HorizontalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        HorizontalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components, gaps , or horizontal lines\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component, gap, or horizontal line)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstSequentialSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of an entity.\r\n     * @return\tthe position of the entity found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain entities.\r\n     */\r\n    private CharPosition firstEntity() {\r\n        int y = firstEntityBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstEntityBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstEntityBelow(int x, int y) {\r\n        for (; y < y2; y++) if (entityAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a horizontal line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '|';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !entityAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has horizontal lines,\r\n     * this method divides the block by the maximal horizontal lines only.\r\n     * <p>\r\n     * If there are no horizontal lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<HWordPosition> hLines = getIntersectingHLines();\r\n        if (hLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(hLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all horizontal lines intersecting this block.\r\n     */\r\n    private Set<HWordPosition> getIntersectingHLines() {\r\n        Set<HWordPosition> source = scheme.getHLinesPositions();\r\n        Set<HWordPosition> result = new HashSet<HWordPosition>();\r\n        for (HWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long horizontal lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {\r\n        removeSmallHLinesFrom(hLines);\r\n        List<Integer> separators = sortedYsOf(hLines);\r\n        return extractParallelSubblocksSeparatedBy(separators);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of horizontal lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (HWordPosition line : hLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        HWordPosition line;\r\n        Iterator<HWordPosition> i = hLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the specified horizontal lines' vertical coordinates.\r\n     */\r\n    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {\r\n        LinkedList<Integer> linesY = new LinkedList<Integer>();\r\n        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));\r\n        Collections.sort(linesY);\r\n        return linesY;\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {\r\n        List<Block> blocksList = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //upper bound of a subblock\r\n        int upperY = y1;\r\n        for (int lowerY : ySeparators) {\r\n            if (lowerY > upperY) {\r\n                //there is a (non-trivial?) block between two lines.\r\n                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    blocksList.add(subBlock);\r\n            }\r\n            upperY = lowerY + 1;\r\n        }\r\n        //below the last line:\r\n        if (upperY < y2) {\r\n            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                blocksList.add(subBlock);\r\n        }\r\n        return blocksList;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without horizontal lines\r\n     * into a set of parallel subblocks, optimizes these subblocks\r\n     * and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block block;\r\n        for (int y = y1; y < y2; y++) {\r\n            block = subblock(x1, y, x2, y + 1);\r\n            block.optimize();\r\n            if (!block.isTrivial())\r\n                result.add(block);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlockTest0.java",
		"test_prompt": "// HorizontalBlockTest0.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#subblock(int, int, int, int)} method.\n*/\nclass HorizontalBlockTest0 {"
	},
	{
		"original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for horizontal layouting.\r\n */\r\npublic class HorizontalBlock extends Block {\r\n\r\n    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public HorizontalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public Block subblock(int x1, int y1, int x2, int y2) {\r\n        return new HorizontalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock cloneWith(CharPosition1 p1) {\r\n        return new HorizontalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        HorizontalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components, gaps , or horizontal lines\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component, gap, or horizontal line)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstSequentialSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of an entity.\r\n     * @return\tthe position of the entity found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain entities.\r\n     */\r\n    private CharPosition firstEntity() {\r\n        int y = firstEntityBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstEntityBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstEntityBelow(int x, int y) {\r\n        for (; y < y2; y++) if (entityAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a horizontal line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '|';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !entityAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has horizontal lines,\r\n     * this method divides the block by the maximal horizontal lines only.\r\n     * <p>\r\n     * If there are no horizontal lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<HWordPosition> hLines = getIntersectingHLines();\r\n        if (hLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(hLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all horizontal lines intersecting this block.\r\n     */\r\n    private Set<HWordPosition> getIntersectingHLines() {\r\n        Set<HWordPosition> source = scheme.getHLinesPositions();\r\n        Set<HWordPosition> result = new HashSet<HWordPosition>();\r\n        for (HWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long horizontal lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {\r\n        removeSmallHLinesFrom(hLines);\r\n        List<Integer> separators = sortedYsOf(hLines);\r\n        return extractParallelSubblocksSeparatedBy(separators);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of horizontal lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (HWordPosition line : hLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        HWordPosition line;\r\n        Iterator<HWordPosition> i = hLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the specified horizontal lines' vertical coordinates.\r\n     */\r\n    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {\r\n        LinkedList<Integer> linesY = new LinkedList<Integer>();\r\n        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));\r\n        Collections.sort(linesY);\r\n        return linesY;\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {\r\n        List<Block> blocksList = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //upper bound of a subblock\r\n        int upperY = y1;\r\n        for (int lowerY : ySeparators) {\r\n            if (lowerY > upperY) {\r\n                //there is a (non-trivial?) block between two lines.\r\n                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    blocksList.add(subBlock);\r\n            }\r\n            upperY = lowerY + 1;\r\n        }\r\n        //below the last line:\r\n        if (upperY < y2) {\r\n            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                blocksList.add(subBlock);\r\n        }\r\n        return blocksList;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without horizontal lines\r\n     * into a set of parallel subblocks, optimizes these subblocks\r\n     * and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block block;\r\n        for (int y = y1; y < y2; y++) {\r\n            block = subblock(x1, y, x2, y + 1);\r\n            block.optimize();\r\n            if (!block.isTrivial())\r\n                result.add(block);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlockTest1.java",
		"test_prompt": "// HorizontalBlockTest1.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#cloneWith(CharPosition1)} method.\n*/\nclass HorizontalBlockTest1 {"
	},
	{
		"original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for horizontal layouting.\r\n */\r\npublic class HorizontalBlock extends Block {\r\n\r\n    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public HorizontalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public Block subblock(int x1, int y1, int x2, int y2) {\r\n        return new HorizontalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock cloneWith(CharPosition1 p1) {\r\n        return new HorizontalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        HorizontalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components, gaps , or horizontal lines\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component, gap, or horizontal line)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstSequentialSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of an entity.\r\n     * @return\tthe position of the entity found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain entities.\r\n     */\r\n    private CharPosition firstEntity() {\r\n        int y = firstEntityBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstEntityBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstEntityBelow(int x, int y) {\r\n        for (; y < y2; y++) if (entityAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a horizontal line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '|';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !entityAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has horizontal lines,\r\n     * this method divides the block by the maximal horizontal lines only.\r\n     * <p>\r\n     * If there are no horizontal lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<HWordPosition> hLines = getIntersectingHLines();\r\n        if (hLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(hLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all horizontal lines intersecting this block.\r\n     */\r\n    private Set<HWordPosition> getIntersectingHLines() {\r\n        Set<HWordPosition> source = scheme.getHLinesPositions();\r\n        Set<HWordPosition> result = new HashSet<HWordPosition>();\r\n        for (HWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long horizontal lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {\r\n        removeSmallHLinesFrom(hLines);\r\n        List<Integer> separators = sortedYsOf(hLines);\r\n        return extractParallelSubblocksSeparatedBy(separators);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of horizontal lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (HWordPosition line : hLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        HWordPosition line;\r\n        Iterator<HWordPosition> i = hLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the specified horizontal lines' vertical coordinates.\r\n     */\r\n    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {\r\n        LinkedList<Integer> linesY = new LinkedList<Integer>();\r\n        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));\r\n        Collections.sort(linesY);\r\n        return linesY;\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {\r\n        List<Block> blocksList = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //upper bound of a subblock\r\n        int upperY = y1;\r\n        for (int lowerY : ySeparators) {\r\n            if (lowerY > upperY) {\r\n                //there is a (non-trivial?) block between two lines.\r\n                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    blocksList.add(subBlock);\r\n            }\r\n            upperY = lowerY + 1;\r\n        }\r\n        //below the last line:\r\n        if (upperY < y2) {\r\n            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                blocksList.add(subBlock);\r\n        }\r\n        return blocksList;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without horizontal lines\r\n     * into a set of parallel subblocks, optimizes these subblocks\r\n     * and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block block;\r\n        for (int y = y1; y < y2; y++) {\r\n            block = subblock(x1, y, x2, y + 1);\r\n            block.optimize();\r\n            if (!block.isTrivial())\r\n                result.add(block);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlockTest2.java",
		"test_prompt": "// HorizontalBlockTest2.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.\n*/\nclass HorizontalBlockTest2 {"
	},
	{
		"original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for horizontal layouting.\r\n */\r\npublic class HorizontalBlock extends Block {\r\n\r\n    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public HorizontalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public Block subblock(int x1, int y1, int x2, int y2) {\r\n        return new HorizontalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock cloneWith(CharPosition1 p1) {\r\n        return new HorizontalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        HorizontalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components, gaps , or horizontal lines\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component, gap, or horizontal line)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstSequentialSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of an entity.\r\n     * @return\tthe position of the entity found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain entities.\r\n     */\r\n    private CharPosition firstEntity() {\r\n        int y = firstEntityBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstEntityBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstEntityBelow(int x, int y) {\r\n        for (; y < y2; y++) if (entityAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a horizontal line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '|';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !entityAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has horizontal lines,\r\n     * this method divides the block by the maximal horizontal lines only.\r\n     * <p>\r\n     * If there are no horizontal lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<HWordPosition> hLines = getIntersectingHLines();\r\n        if (hLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(hLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all horizontal lines intersecting this block.\r\n     */\r\n    private Set<HWordPosition> getIntersectingHLines() {\r\n        Set<HWordPosition> source = scheme.getHLinesPositions();\r\n        Set<HWordPosition> result = new HashSet<HWordPosition>();\r\n        for (HWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long horizontal lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {\r\n        removeSmallHLinesFrom(hLines);\r\n        List<Integer> separators = sortedYsOf(hLines);\r\n        return extractParallelSubblocksSeparatedBy(separators);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of horizontal lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (HWordPosition line : hLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        HWordPosition line;\r\n        Iterator<HWordPosition> i = hLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the specified horizontal lines' vertical coordinates.\r\n     */\r\n    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {\r\n        LinkedList<Integer> linesY = new LinkedList<Integer>();\r\n        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));\r\n        Collections.sort(linesY);\r\n        return linesY;\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {\r\n        List<Block> blocksList = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //upper bound of a subblock\r\n        int upperY = y1;\r\n        for (int lowerY : ySeparators) {\r\n            if (lowerY > upperY) {\r\n                //there is a (non-trivial?) block between two lines.\r\n                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    blocksList.add(subBlock);\r\n            }\r\n            upperY = lowerY + 1;\r\n        }\r\n        //below the last line:\r\n        if (upperY < y2) {\r\n            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                blocksList.add(subBlock);\r\n        }\r\n        return blocksList;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without horizontal lines\r\n     * into a set of parallel subblocks, optimizes these subblocks\r\n     * and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block block;\r\n        for (int y = y1; y < y2; y++) {\r\n            block = subblock(x1, y, x2, y + 1);\r\n            block.optimize();\r\n            if (!block.isTrivial())\r\n                result.add(block);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlockTest3.java",
		"test_prompt": "// HorizontalBlockTest3.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.\n*/\nclass HorizontalBlockTest3 {"
	},
	{
		"original_code": "// VerticalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for vertical layouting.\r\n */\r\npublic class VerticalBlock extends Block {\r\n\r\n    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public VerticalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {\r\n        return new VerticalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock cloneWith(CharPosition1 p1) {\r\n        return new VerticalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        VerticalBlock firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive horizontal line\r\n     * does not contain elements of vertical lines\r\n     * starting above the line.\r\n     * <p>\r\n     * The algorithm finds the upper entity\r\n     * (an element of a component, gap, or vertical line)\r\n     * using simple search along the scheme,\r\n     * and retains it as the top of the required block.\r\n     * Then, starting from the height of that point,\r\n     * it sequentially finds vertical lines\r\n     * end below but begin not below\r\n     * and moves to lower end of such lines.\r\n     * The lower end of the last such vertical line defines\r\n     * the bottom of the required block.\r\n     */\r\n    private VerticalBlock extractFirstSequentialSubblock() {\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        CharPosition blockStart = getBlockStart();\r\n        int y2 = getUpperSubblockEnd(blockStart, vLines);\r\n        return subblock(this.x1, blockStart.y, this.x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all vertical lines intersecting this block.\r\n     */\r\n    private Set<VWordPosition> getIntersectingVLines() {\r\n        Set<VWordPosition> source = scheme.getVLinesPositions();\r\n        Set<VWordPosition> result = new HashSet<VWordPosition>();\r\n        for (VWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the upper entity (an element of a word or vertical line)\r\n     * of this block.\r\n     * Returns its position on the scheme.\r\n     * @throws\tIllegalArgumentException if this block happens to be empty.\r\n     */\r\n    private CharPosition getBlockStart() {\r\n        int x = x1;\r\n        int y = y1;\r\n        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))\r\n            return new CharPosition(x, y);\r\n        throw new IllegalArgumentException(\"Can not extract elements from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a vertical line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '-';\r\n    }\r\n\r\n    /**\r\n     * Finds the last line of the subblock\r\n     * containing the specified position {@code blockStart}.\r\n     * Returns the coordinate {@code y2} of such block.\r\n     */\r\n    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {\r\n        int nextY = blockStart.y;\r\n        int currentY;\r\n        do {\r\n            currentY = nextY;\r\n            nextY = y2OfAVLineCovering(currentY, vLines);\r\n        } while (nextY > currentY && nextY < y2 - 1);\r\n        return Math.min(y2, nextY + 1);\r\n    }\r\n\r\n    /**\r\n     * Finds a vertical line which vertical range covers\r\n     * the specified value {@code y}\r\n     * and which lower point is lower than {@code y}.\r\n     * Returns the position of the last element of such line (inclusive)\r\n     * or {@code y} if such line does not exist.\r\n     */\r\n    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {\r\n        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)\r\n            return line.y2 - 1;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has vertical lines,\r\n     * this method divides the block by the maximal vertical lines only.\r\n     * <p>\r\n     * If there are no vertical lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        if (vLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(vLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long vertical lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {\r\n        removeSmallVLinesFrom(vLines);\r\n        return extractParallelSubblocksSeparatedBy(vLines);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of vertical lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (VWordPosition line : vLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        VWordPosition line;\r\n        Iterator<VWordPosition> i = vLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //the left bound of a subblock\r\n        int leftX = x1;\r\n        //the exclusive right bound of a subblock\r\n        int rightX;\r\n        //(may exist; widens the separator)\r\n        HWordPosition gapAtSeparator = null;\r\n        for (VWordPosition rightSeparator : sortedVLines(separators)) {\r\n            rightX = rightSeparator.x;\r\n            //if the separator has a gap, the latter must be skipped:\r\n            gapAtSeparator = scheme.gapAtLine(rightSeparator);\r\n            if (gapAtSeparator != null)\r\n                rightX = gapAtSeparator.x1;\r\n            //adding the subblock between leftX and rightX:\r\n            if (rightX > leftX + 1) {\r\n                subBlock = subblock(leftX, y1, rightX, y2);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    result.add(subBlock);\r\n            }\r\n            //iterating leftX:\r\n            if (gapAtSeparator == null)\r\n                leftX = rightX + 1;\r\n            else\r\n                leftX = gapAtSeparator.x2;\r\n        }\r\n        //on the right of the last line:\r\n        if (leftX < x2) {\r\n            subBlock = subblock(leftX, y1, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                result.add(subBlock);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n\t * Returns a list of the specified vertical lines\r\n\t * sorted according to the horizontal coordinates.\r\n\t */\r\n    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {\r\n        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);\r\n        Collections.sort(list);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without vertical lines\r\n     * into a set of (optimized) parallel subblocks.\r\n     * Returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstParallelSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components or gaps\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component or gap)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstParallelSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of a word character.\r\n     * @return\tthe position of the word character found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain word characters.\r\n     */\r\n    private CharPosition firstWordChar() {\r\n        int y = firstWordCharBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstWordCharBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstWordCharBelow(int x, int y) {\r\n        for (; y < y2; y++) if (wordCharAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character.\r\n     * <p>\r\n     * Overrides the less optimal method {@code CharTable.wordCharAt()}.\r\n     * Since all symbols on the scheme are definitely correct\r\n     * (which has been verified in its constructor),\r\n     * there is no need to use slower method.\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        return c != ' ' && c != '-' && c != '|' && c != '+';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !wordCharAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlockTest0.java",
		"test_prompt": "// VerticalBlockTest0.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#subblock(int, int, int, int)} method.\n*/\nclass VerticalBlockTest0 {"
	},
	{
		"original_code": "// VerticalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for vertical layouting.\r\n */\r\npublic class VerticalBlock extends Block {\r\n\r\n    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public VerticalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {\r\n        return new VerticalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock cloneWith(CharPosition1 p1) {\r\n        return new VerticalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        VerticalBlock firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive horizontal line\r\n     * does not contain elements of vertical lines\r\n     * starting above the line.\r\n     * <p>\r\n     * The algorithm finds the upper entity\r\n     * (an element of a component, gap, or vertical line)\r\n     * using simple search along the scheme,\r\n     * and retains it as the top of the required block.\r\n     * Then, starting from the height of that point,\r\n     * it sequentially finds vertical lines\r\n     * end below but begin not below\r\n     * and moves to lower end of such lines.\r\n     * The lower end of the last such vertical line defines\r\n     * the bottom of the required block.\r\n     */\r\n    private VerticalBlock extractFirstSequentialSubblock() {\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        CharPosition blockStart = getBlockStart();\r\n        int y2 = getUpperSubblockEnd(blockStart, vLines);\r\n        return subblock(this.x1, blockStart.y, this.x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all vertical lines intersecting this block.\r\n     */\r\n    private Set<VWordPosition> getIntersectingVLines() {\r\n        Set<VWordPosition> source = scheme.getVLinesPositions();\r\n        Set<VWordPosition> result = new HashSet<VWordPosition>();\r\n        for (VWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the upper entity (an element of a word or vertical line)\r\n     * of this block.\r\n     * Returns its position on the scheme.\r\n     * @throws\tIllegalArgumentException if this block happens to be empty.\r\n     */\r\n    private CharPosition getBlockStart() {\r\n        int x = x1;\r\n        int y = y1;\r\n        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))\r\n            return new CharPosition(x, y);\r\n        throw new IllegalArgumentException(\"Can not extract elements from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a vertical line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '-';\r\n    }\r\n\r\n    /**\r\n     * Finds the last line of the subblock\r\n     * containing the specified position {@code blockStart}.\r\n     * Returns the coordinate {@code y2} of such block.\r\n     */\r\n    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {\r\n        int nextY = blockStart.y;\r\n        int currentY;\r\n        do {\r\n            currentY = nextY;\r\n            nextY = y2OfAVLineCovering(currentY, vLines);\r\n        } while (nextY > currentY && nextY < y2 - 1);\r\n        return Math.min(y2, nextY + 1);\r\n    }\r\n\r\n    /**\r\n     * Finds a vertical line which vertical range covers\r\n     * the specified value {@code y}\r\n     * and which lower point is lower than {@code y}.\r\n     * Returns the position of the last element of such line (inclusive)\r\n     * or {@code y} if such line does not exist.\r\n     */\r\n    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {\r\n        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)\r\n            return line.y2 - 1;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has vertical lines,\r\n     * this method divides the block by the maximal vertical lines only.\r\n     * <p>\r\n     * If there are no vertical lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        if (vLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(vLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long vertical lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {\r\n        removeSmallVLinesFrom(vLines);\r\n        return extractParallelSubblocksSeparatedBy(vLines);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of vertical lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (VWordPosition line : vLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        VWordPosition line;\r\n        Iterator<VWordPosition> i = vLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //the left bound of a subblock\r\n        int leftX = x1;\r\n        //the exclusive right bound of a subblock\r\n        int rightX;\r\n        //(may exist; widens the separator)\r\n        HWordPosition gapAtSeparator = null;\r\n        for (VWordPosition rightSeparator : sortedVLines(separators)) {\r\n            rightX = rightSeparator.x;\r\n            //if the separator has a gap, the latter must be skipped:\r\n            gapAtSeparator = scheme.gapAtLine(rightSeparator);\r\n            if (gapAtSeparator != null)\r\n                rightX = gapAtSeparator.x1;\r\n            //adding the subblock between leftX and rightX:\r\n            if (rightX > leftX + 1) {\r\n                subBlock = subblock(leftX, y1, rightX, y2);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    result.add(subBlock);\r\n            }\r\n            //iterating leftX:\r\n            if (gapAtSeparator == null)\r\n                leftX = rightX + 1;\r\n            else\r\n                leftX = gapAtSeparator.x2;\r\n        }\r\n        //on the right of the last line:\r\n        if (leftX < x2) {\r\n            subBlock = subblock(leftX, y1, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                result.add(subBlock);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n\t * Returns a list of the specified vertical lines\r\n\t * sorted according to the horizontal coordinates.\r\n\t */\r\n    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {\r\n        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);\r\n        Collections.sort(list);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without vertical lines\r\n     * into a set of (optimized) parallel subblocks.\r\n     * Returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstParallelSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components or gaps\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component or gap)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstParallelSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of a word character.\r\n     * @return\tthe position of the word character found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain word characters.\r\n     */\r\n    private CharPosition firstWordChar() {\r\n        int y = firstWordCharBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstWordCharBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstWordCharBelow(int x, int y) {\r\n        for (; y < y2; y++) if (wordCharAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character.\r\n     * <p>\r\n     * Overrides the less optimal method {@code CharTable.wordCharAt()}.\r\n     * Since all symbols on the scheme are definitely correct\r\n     * (which has been verified in its constructor),\r\n     * there is no need to use slower method.\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        return c != ' ' && c != '-' && c != '|' && c != '+';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !wordCharAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlockTest1.java",
		"test_prompt": "// VerticalBlockTest1.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#cloneWith(CharPosition1)} method.\n*/\nclass VerticalBlockTest1 {"
	},
	{
		"original_code": "// VerticalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for vertical layouting.\r\n */\r\npublic class VerticalBlock extends Block {\r\n\r\n    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public VerticalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {\r\n        return new VerticalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock cloneWith(CharPosition1 p1) {\r\n        return new VerticalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        VerticalBlock firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive horizontal line\r\n     * does not contain elements of vertical lines\r\n     * starting above the line.\r\n     * <p>\r\n     * The algorithm finds the upper entity\r\n     * (an element of a component, gap, or vertical line)\r\n     * using simple search along the scheme,\r\n     * and retains it as the top of the required block.\r\n     * Then, starting from the height of that point,\r\n     * it sequentially finds vertical lines\r\n     * end below but begin not below\r\n     * and moves to lower end of such lines.\r\n     * The lower end of the last such vertical line defines\r\n     * the bottom of the required block.\r\n     */\r\n    private VerticalBlock extractFirstSequentialSubblock() {\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        CharPosition blockStart = getBlockStart();\r\n        int y2 = getUpperSubblockEnd(blockStart, vLines);\r\n        return subblock(this.x1, blockStart.y, this.x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all vertical lines intersecting this block.\r\n     */\r\n    private Set<VWordPosition> getIntersectingVLines() {\r\n        Set<VWordPosition> source = scheme.getVLinesPositions();\r\n        Set<VWordPosition> result = new HashSet<VWordPosition>();\r\n        for (VWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the upper entity (an element of a word or vertical line)\r\n     * of this block.\r\n     * Returns its position on the scheme.\r\n     * @throws\tIllegalArgumentException if this block happens to be empty.\r\n     */\r\n    private CharPosition getBlockStart() {\r\n        int x = x1;\r\n        int y = y1;\r\n        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))\r\n            return new CharPosition(x, y);\r\n        throw new IllegalArgumentException(\"Can not extract elements from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a vertical line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '-';\r\n    }\r\n\r\n    /**\r\n     * Finds the last line of the subblock\r\n     * containing the specified position {@code blockStart}.\r\n     * Returns the coordinate {@code y2} of such block.\r\n     */\r\n    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {\r\n        int nextY = blockStart.y;\r\n        int currentY;\r\n        do {\r\n            currentY = nextY;\r\n            nextY = y2OfAVLineCovering(currentY, vLines);\r\n        } while (nextY > currentY && nextY < y2 - 1);\r\n        return Math.min(y2, nextY + 1);\r\n    }\r\n\r\n    /**\r\n     * Finds a vertical line which vertical range covers\r\n     * the specified value {@code y}\r\n     * and which lower point is lower than {@code y}.\r\n     * Returns the position of the last element of such line (inclusive)\r\n     * or {@code y} if such line does not exist.\r\n     */\r\n    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {\r\n        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)\r\n            return line.y2 - 1;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has vertical lines,\r\n     * this method divides the block by the maximal vertical lines only.\r\n     * <p>\r\n     * If there are no vertical lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        if (vLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(vLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long vertical lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {\r\n        removeSmallVLinesFrom(vLines);\r\n        return extractParallelSubblocksSeparatedBy(vLines);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of vertical lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (VWordPosition line : vLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        VWordPosition line;\r\n        Iterator<VWordPosition> i = vLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //the left bound of a subblock\r\n        int leftX = x1;\r\n        //the exclusive right bound of a subblock\r\n        int rightX;\r\n        //(may exist; widens the separator)\r\n        HWordPosition gapAtSeparator = null;\r\n        for (VWordPosition rightSeparator : sortedVLines(separators)) {\r\n            rightX = rightSeparator.x;\r\n            //if the separator has a gap, the latter must be skipped:\r\n            gapAtSeparator = scheme.gapAtLine(rightSeparator);\r\n            if (gapAtSeparator != null)\r\n                rightX = gapAtSeparator.x1;\r\n            //adding the subblock between leftX and rightX:\r\n            if (rightX > leftX + 1) {\r\n                subBlock = subblock(leftX, y1, rightX, y2);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    result.add(subBlock);\r\n            }\r\n            //iterating leftX:\r\n            if (gapAtSeparator == null)\r\n                leftX = rightX + 1;\r\n            else\r\n                leftX = gapAtSeparator.x2;\r\n        }\r\n        //on the right of the last line:\r\n        if (leftX < x2) {\r\n            subBlock = subblock(leftX, y1, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                result.add(subBlock);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n\t * Returns a list of the specified vertical lines\r\n\t * sorted according to the horizontal coordinates.\r\n\t */\r\n    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {\r\n        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);\r\n        Collections.sort(list);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without vertical lines\r\n     * into a set of (optimized) parallel subblocks.\r\n     * Returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstParallelSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components or gaps\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component or gap)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstParallelSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of a word character.\r\n     * @return\tthe position of the word character found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain word characters.\r\n     */\r\n    private CharPosition firstWordChar() {\r\n        int y = firstWordCharBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstWordCharBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstWordCharBelow(int x, int y) {\r\n        for (; y < y2; y++) if (wordCharAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character.\r\n     * <p>\r\n     * Overrides the less optimal method {@code CharTable.wordCharAt()}.\r\n     * Since all symbols on the scheme are definitely correct\r\n     * (which has been verified in its constructor),\r\n     * there is no need to use slower method.\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        return c != ' ' && c != '-' && c != '|' && c != '+';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !wordCharAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlockTest2.java",
		"test_prompt": "// VerticalBlockTest2.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.\n*/\nclass VerticalBlockTest2 {"
	},
	{
		"original_code": "// VerticalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for vertical layouting.\r\n */\r\npublic class VerticalBlock extends Block {\r\n\r\n    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public VerticalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {\r\n        return new VerticalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock cloneWith(CharPosition1 p1) {\r\n        return new VerticalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        VerticalBlock firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive horizontal line\r\n     * does not contain elements of vertical lines\r\n     * starting above the line.\r\n     * <p>\r\n     * The algorithm finds the upper entity\r\n     * (an element of a component, gap, or vertical line)\r\n     * using simple search along the scheme,\r\n     * and retains it as the top of the required block.\r\n     * Then, starting from the height of that point,\r\n     * it sequentially finds vertical lines\r\n     * end below but begin not below\r\n     * and moves to lower end of such lines.\r\n     * The lower end of the last such vertical line defines\r\n     * the bottom of the required block.\r\n     */\r\n    private VerticalBlock extractFirstSequentialSubblock() {\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        CharPosition blockStart = getBlockStart();\r\n        int y2 = getUpperSubblockEnd(blockStart, vLines);\r\n        return subblock(this.x1, blockStart.y, this.x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all vertical lines intersecting this block.\r\n     */\r\n    private Set<VWordPosition> getIntersectingVLines() {\r\n        Set<VWordPosition> source = scheme.getVLinesPositions();\r\n        Set<VWordPosition> result = new HashSet<VWordPosition>();\r\n        for (VWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the upper entity (an element of a word or vertical line)\r\n     * of this block.\r\n     * Returns its position on the scheme.\r\n     * @throws\tIllegalArgumentException if this block happens to be empty.\r\n     */\r\n    private CharPosition getBlockStart() {\r\n        int x = x1;\r\n        int y = y1;\r\n        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))\r\n            return new CharPosition(x, y);\r\n        throw new IllegalArgumentException(\"Can not extract elements from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a vertical line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '-';\r\n    }\r\n\r\n    /**\r\n     * Finds the last line of the subblock\r\n     * containing the specified position {@code blockStart}.\r\n     * Returns the coordinate {@code y2} of such block.\r\n     */\r\n    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {\r\n        int nextY = blockStart.y;\r\n        int currentY;\r\n        do {\r\n            currentY = nextY;\r\n            nextY = y2OfAVLineCovering(currentY, vLines);\r\n        } while (nextY > currentY && nextY < y2 - 1);\r\n        return Math.min(y2, nextY + 1);\r\n    }\r\n\r\n    /**\r\n     * Finds a vertical line which vertical range covers\r\n     * the specified value {@code y}\r\n     * and which lower point is lower than {@code y}.\r\n     * Returns the position of the last element of such line (inclusive)\r\n     * or {@code y} if such line does not exist.\r\n     */\r\n    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {\r\n        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)\r\n            return line.y2 - 1;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has vertical lines,\r\n     * this method divides the block by the maximal vertical lines only.\r\n     * <p>\r\n     * If there are no vertical lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        if (vLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(vLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long vertical lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {\r\n        removeSmallVLinesFrom(vLines);\r\n        return extractParallelSubblocksSeparatedBy(vLines);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of vertical lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (VWordPosition line : vLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        VWordPosition line;\r\n        Iterator<VWordPosition> i = vLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //the left bound of a subblock\r\n        int leftX = x1;\r\n        //the exclusive right bound of a subblock\r\n        int rightX;\r\n        //(may exist; widens the separator)\r\n        HWordPosition gapAtSeparator = null;\r\n        for (VWordPosition rightSeparator : sortedVLines(separators)) {\r\n            rightX = rightSeparator.x;\r\n            //if the separator has a gap, the latter must be skipped:\r\n            gapAtSeparator = scheme.gapAtLine(rightSeparator);\r\n            if (gapAtSeparator != null)\r\n                rightX = gapAtSeparator.x1;\r\n            //adding the subblock between leftX and rightX:\r\n            if (rightX > leftX + 1) {\r\n                subBlock = subblock(leftX, y1, rightX, y2);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    result.add(subBlock);\r\n            }\r\n            //iterating leftX:\r\n            if (gapAtSeparator == null)\r\n                leftX = rightX + 1;\r\n            else\r\n                leftX = gapAtSeparator.x2;\r\n        }\r\n        //on the right of the last line:\r\n        if (leftX < x2) {\r\n            subBlock = subblock(leftX, y1, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                result.add(subBlock);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n\t * Returns a list of the specified vertical lines\r\n\t * sorted according to the horizontal coordinates.\r\n\t */\r\n    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {\r\n        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);\r\n        Collections.sort(list);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without vertical lines\r\n     * into a set of (optimized) parallel subblocks.\r\n     * Returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstParallelSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components or gaps\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component or gap)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstParallelSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of a word character.\r\n     * @return\tthe position of the word character found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain word characters.\r\n     */\r\n    private CharPosition firstWordChar() {\r\n        int y = firstWordCharBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstWordCharBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstWordCharBelow(int x, int y) {\r\n        for (; y < y2; y++) if (wordCharAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character.\r\n     * <p>\r\n     * Overrides the less optimal method {@code CharTable.wordCharAt()}.\r\n     * Since all symbols on the scheme are definitely correct\r\n     * (which has been verified in its constructor),\r\n     * there is no need to use slower method.\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        return c != ' ' && c != '-' && c != '|' && c != '+';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !wordCharAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlockTest3.java",
		"test_prompt": "// VerticalBlockTest3.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.\n*/\nclass VerticalBlockTest3 {"
	},
	{
		"original_code": "// VerticalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for vertical layouting.\r\n */\r\npublic class VerticalBlock extends Block {\r\n\r\n    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public VerticalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {\r\n        return new VerticalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock cloneWith(CharPosition1 p1) {\r\n        return new VerticalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List<Block> extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        List<Block> result = new LinkedList<Block>();\r\n        VerticalBlock firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstSequentialSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive horizontal line\r\n     * does not contain elements of vertical lines\r\n     * starting above the line.\r\n     * <p>\r\n     * The algorithm finds the upper entity\r\n     * (an element of a component, gap, or vertical line)\r\n     * using simple search along the scheme,\r\n     * and retains it as the top of the required block.\r\n     * Then, starting from the height of that point,\r\n     * it sequentially finds vertical lines\r\n     * end below but begin not below\r\n     * and moves to lower end of such lines.\r\n     * The lower end of the last such vertical line defines\r\n     * the bottom of the required block.\r\n     */\r\n    private VerticalBlock extractFirstSequentialSubblock() {\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        CharPosition blockStart = getBlockStart();\r\n        int y2 = getUpperSubblockEnd(blockStart, vLines);\r\n        return subblock(this.x1, blockStart.y, this.x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all vertical lines intersecting this block.\r\n     */\r\n    private Set<VWordPosition> getIntersectingVLines() {\r\n        Set<VWordPosition> source = scheme.getVLinesPositions();\r\n        Set<VWordPosition> result = new HashSet<VWordPosition>();\r\n        for (VWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the upper entity (an element of a word or vertical line)\r\n     * of this block.\r\n     * Returns its position on the scheme.\r\n     * @throws\tIllegalArgumentException if this block happens to be empty.\r\n     */\r\n    private CharPosition getBlockStart() {\r\n        int x = x1;\r\n        int y = y1;\r\n        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))\r\n            return new CharPosition(x, y);\r\n        throw new IllegalArgumentException(\"Can not extract elements from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a vertical line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c != ' ' && c != '-';\r\n    }\r\n\r\n    /**\r\n     * Finds the last line of the subblock\r\n     * containing the specified position {@code blockStart}.\r\n     * Returns the coordinate {@code y2} of such block.\r\n     */\r\n    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {\r\n        int nextY = blockStart.y;\r\n        int currentY;\r\n        do {\r\n            currentY = nextY;\r\n            nextY = y2OfAVLineCovering(currentY, vLines);\r\n        } while (nextY > currentY && nextY < y2 - 1);\r\n        return Math.min(y2, nextY + 1);\r\n    }\r\n\r\n    /**\r\n     * Finds a vertical line which vertical range covers\r\n     * the specified value {@code y}\r\n     * and which lower point is lower than {@code y}.\r\n     * Returns the position of the last element of such line (inclusive)\r\n     * or {@code y} if such line does not exist.\r\n     */\r\n    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {\r\n        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)\r\n            return line.y2 - 1;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * <p>\r\n     * If the block has vertical lines,\r\n     * this method divides the block by the maximal vertical lines only.\r\n     * <p>\r\n     * If there are no vertical lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List<Block> extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList<Block>();\r\n        Set<VWordPosition> vLines = getIntersectingVLines();\r\n        if (vLines.size() > 0)\r\n            return extractParallelSubblocksSeparatedByLines(vLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long vertical lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {\r\n        removeSmallVLinesFrom(vLines);\r\n        return extractParallelSubblocksSeparatedBy(vLines);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of vertical lines\r\n     * and then removes from it all other elements.\r\n     * <p>\r\n     * Note that, more formally, this method considers the lengths\r\n     * of <i>intersections</i> of the lines with this block.\r\n     */\r\n    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {\r\n        //determine the maximum length:\r\n        int maxLength = 0;\r\n        int length;\r\n        for (VWordPosition line : vLines) {\r\n            length = line.getLengthInsideOf(this);\r\n            maxLength = Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        VWordPosition line;\r\n        Iterator<VWordPosition> i = vLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line = i.next();\r\n            if (line.getLengthInsideOf(this) < maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block subBlock;\r\n        //the left bound of a subblock\r\n        int leftX = x1;\r\n        //the exclusive right bound of a subblock\r\n        int rightX;\r\n        //(may exist; widens the separator)\r\n        HWordPosition gapAtSeparator = null;\r\n        for (VWordPosition rightSeparator : sortedVLines(separators)) {\r\n            rightX = rightSeparator.x;\r\n            //if the separator has a gap, the latter must be skipped:\r\n            gapAtSeparator = scheme.gapAtLine(rightSeparator);\r\n            if (gapAtSeparator != null)\r\n                rightX = gapAtSeparator.x1;\r\n            //adding the subblock between leftX and rightX:\r\n            if (rightX > leftX + 1) {\r\n                subBlock = subblock(leftX, y1, rightX, y2);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    result.add(subBlock);\r\n            }\r\n            //iterating leftX:\r\n            if (gapAtSeparator == null)\r\n                leftX = rightX + 1;\r\n            else\r\n                leftX = gapAtSeparator.x2;\r\n        }\r\n        //on the right of the last line:\r\n        if (leftX < x2) {\r\n            subBlock = subblock(leftX, y1, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                result.add(subBlock);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n\t * Returns a list of the specified vertical lines\r\n\t * sorted according to the horizontal coordinates.\r\n\t */\r\n    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {\r\n        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);\r\n        Collections.sort(list);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without vertical lines\r\n     * into a set of (optimized) parallel subblocks.\r\n     * Returns them as a linked list.\r\n     */\r\n    protected List<Block> extractParallelSubblocksWithoutLines() {\r\n        List<Block> result = new LinkedList<Block>();\r\n        Block firstBlock;\r\n        VerticalBlock theRest = this;\r\n        do {\r\n            firstBlock = theRest.extractFirstParallelSubblock();\r\n            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * <p>\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components or gaps\r\n     * starting on the left from the line.\r\n     * <p>\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component or gap)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstParallelSubblock() {\r\n        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());\r\n        HWordPosition lastWord = firstWord;\r\n        HWordPosition nextWord = firstWord;\r\n        for (; nextWord != null; ) {\r\n            lastWord = nextWord;\r\n            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX = firstWord.x1;\r\n        int endX = lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX = Math.max(startX, x1);\r\n        endX = Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of a word character.\r\n     * @return\tthe position of the word character found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain word characters.\r\n     */\r\n    private CharPosition firstWordChar() {\r\n        int y = firstWordCharBelow(x1, y1);\r\n        if (y != y2)\r\n            return new CharPosition(x1, y);\r\n        int x = x1 + 1;\r\n        for (; x < x2; x++) {\r\n            y = firstWordCharBelow(x, y1);\r\n            if (y != y2)\r\n                break;\r\n        }\r\n        if (x != x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstWordCharBelow(int x, int y) {\r\n        for (; y < y2; y++) if (wordCharAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character.\r\n     * <p>\r\n     * Overrides the less optimal method {@code CharTable.wordCharAt()}.\r\n     * Since all symbols on the scheme are definitely correct\r\n     * (which has been verified in its constructor),\r\n     * there is no need to use slower method.\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        char c = charAt(x, y);\r\n        return c != ' ' && c != '-' && c != '|' && c != '+';\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x = currentWord.x2 - 1;\r\n        int y = y1;\r\n        int yToSkip = currentWord.y;\r\n        HWordPosition result;\r\n        for (; y < y2; y++) {\r\n            if (y == yToSkip || !wordCharAt(x, y))\r\n                continue;\r\n            result = scheme.anyHElementAt(x, y);\r\n            if (result == null)\r\n                continue;\r\n            if (result.x2 > currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlockTest4.java",
		"test_prompt": "// VerticalBlockTest4.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#wordCharAt(int, int)} method.\n*/\nclass VerticalBlockTest4 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest0.java",
		"test_prompt": "// CharTableTest0.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#permitsX(int)} method.\n*/\nclass CharTableTest0 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest1.java",
		"test_prompt": "// CharTableTest1.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#permitsY(int)} method.\n*/\nclass CharTableTest1 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest2.java",
		"test_prompt": "// CharTableTest2.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#contains(int, int)} method.\n*/\nclass CharTableTest2 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest3.java",
		"test_prompt": "// CharTableTest3.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#contains(CharPosition)} method.\n*/\nclass CharTableTest3 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest4.java",
		"test_prompt": "// CharTableTest4.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#isTrivial()} method.\n*/\nclass CharTableTest4 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest5.java",
		"test_prompt": "// CharTableTest5.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#charAt(CharPosition)} method.\n*/\nclass CharTableTest5 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest6.java",
		"test_prompt": "// CharTableTest6.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#isLetter(char)} method.\n*/\nclass CharTableTest6 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest7.java",
		"test_prompt": "// CharTableTest7.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#letterAt(int, int)} method.\n*/\nclass CharTableTest7 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest8.java",
		"test_prompt": "// CharTableTest8.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#isWordChar(char)} method.\n*/\nclass CharTableTest8 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest9.java",
		"test_prompt": "// CharTableTest9.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#wordCharAt(int, int)} method.\n*/\nclass CharTableTest9 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest10.java",
		"test_prompt": "// CharTableTest10.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#isSplitter(char)} method.\n*/\nclass CharTableTest10 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest11.java",
		"test_prompt": "// CharTableTest11.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#splitterAt(int, int)} method.\n*/\nclass CharTableTest11 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest12.java",
		"test_prompt": "// CharTableTest12.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#textAt(WordPosition)} method.\n*/\nclass CharTableTest12 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest13.java",
		"test_prompt": "// CharTableTest13.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#textAt(HWordPosition)} method.\n*/\nclass CharTableTest13 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest14.java",
		"test_prompt": "// CharTableTest14.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#textAt(VWordPosition)} method.\n*/\nclass CharTableTest14 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest15.java",
		"test_prompt": "// CharTableTest15.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#firstWord_Horizontally()} method.\n*/\nclass CharTableTest15 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest16.java",
		"test_prompt": "// CharTableTest16.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#firstWordAfter_Horizontally(HWordPosition)} method.\n*/\nclass CharTableTest16 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest17.java",
		"test_prompt": "// CharTableTest17.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#lastWord_Horizontally()} method.\n*/\nclass CharTableTest17 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest18.java",
		"test_prompt": "// CharTableTest18.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#firstWord_Vertically()} method.\n*/\nclass CharTableTest18 {"
	},
	{
		"original_code": "// CharTable.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\n\r\n/**\r\n * An abstract class for the {@code Scheme} and {@code Block} classes.\r\n * Encapsulates various operations dealing with table boundaries,\r\n * operations classifying the type of text under specified positions,\r\n * and operations searching for text of specified type.\r\n * <p>\r\n * The basic text possessing operations are leaved abstract.\r\n */\r\npublic abstract class CharTable {\r\n\r\n    /**\r\n     * The string declares the set of characters\r\n     * which are allowed in the names of components.\r\n     */\r\n    public static final String LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890\";\r\n\r\n    /**\r\n     * The string of elements for drawing horizontal and vertical lines.\r\n     */\r\n    public static final String SPLITTERS = \"-|+\";\r\n\r\n    /**\r\n     * This table left boundary coordinate (inclusive).\r\n     */\r\n    public int x1;\r\n\r\n    /**\r\n     * This table top boundary coordinate (inclusive).\r\n     */\r\n    public int y1;\r\n\r\n    /**\r\n     * This table right boundary coordinate (exclusive).\r\n     */\r\n    public int x2;\r\n\r\n    /**\r\n     * This table bottom boundary coordinate (exclusive).\r\n     */\r\n    public int y2;\r\n\r\n    public CharPosition1 getPos1() {\r\n        return new CharPosition1(x1, y1);\r\n    }\r\n\r\n    public CharPosition2 getPos2() {\r\n        return new CharPosition2(x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper x-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsX(int x) {\r\n        if (x1 <= x && x < x2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified value\r\n     * is a proper y-coordinate for an element of this char table.\r\n     */\r\n    public boolean permitsY(int y) {\r\n        if (y1 <= y && y < y2)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(int x, int y) {\r\n        return permitsX(x) && permitsY(y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character position\r\n     * lies inside of this char table.\r\n     */\r\n    public boolean contains(CharPosition pos) {\r\n        return permitsX(pos.x) && permitsY(pos.y);\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return (x1 >= x2) || (y1 >= y2);\r\n    }\r\n\r\n    /**\r\n     *    , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     * @return\t   .\r\n     */\r\n    public abstract char charAt(int x, int y);\r\n\r\n    /**\r\n     *    ,   {@code p}.\r\n     */\r\n    public char charAt(CharPosition p) {\r\n        return charAt(p.x, p.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified character can be a part of a word\r\n     * (say, is a letter).\r\n     *\r\n     * @param c\tcharacter\r\n     */\r\n    public static boolean isLetter(char c) {\r\n        return LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    public boolean letterAt(int x, int y) {\r\n        return isLetter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the specified symbol is a word character,\r\n     * i.e. is a letter or a dot.\r\n     *\r\n     * @param c\tsymbol\r\n     */\r\n    public static boolean isWordChar(char c) {\r\n        return c == '.' || LETTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the symbol at the specified position {@code (x,y)}\r\n     * is a word character, i.e. is a letter or a dot.\r\n     *\r\n     * @param x\tx-coordinate\r\n     * @param y\ty-coordinate\r\n     * @return\t{@code true} if the symbol under position {@code (x,y)}\r\n     * \t\t\tis a word character\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        return isWordChar(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * ,       .\r\n     * @param c\t.\r\n     */\r\n    public static boolean isSplitter(char c) {\r\n        return SPLITTERS.indexOf(c) > -1;\r\n    }\r\n\r\n    /**\r\n     * ,    ,   \r\n     * {@code (x,y)},   .\r\n     */\r\n    public boolean splitterAt(int x, int y) {\r\n        return isSplitter(charAt(x, y));\r\n    }\r\n\r\n    /**\r\n     * Returns the text on the table\r\n     * specified by the given horizontal word position coordinates.\r\n     *\r\n     * @param x1\tthe number of the first symbol\r\n     * \t\t\t\tof the required word on the table.\r\n     * @param x2\tthe number of the last symbol\r\n     * \t\t\t\tof the required word on the table + 1.\r\n     * @param y\t\tthe number of the line with the required word.\r\n     *\r\n     * @return\t\tthe text lying at the specified horizontal word position.\r\n     */\r\n    public abstract String textAt(int x1, int x2, int y);\r\n\r\n    /**\r\n     * Returns the text lying at the specified word position on the table.\r\n     *\r\n     * @param wp\tthe position of the word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(WordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Null word position.\");\r\n        return wp.textAt(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * horizontal word position on the table.\r\n     *\r\n     * @param hwp\tthe position of the horizontal word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(HWordPosition hwp) {\r\n        return textAt(hwp.x1, hwp.x2, hwp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text lying at the specified\r\n     * vertical word position on the table.\r\n     *\r\n     * @param vwp\tthe position of the vertical word to be returned.\r\n     *\r\n     * @return\t\tthe text lying at the specified word position.\r\n     */\r\n    public String textAt(VWordPosition vwp) {\r\n        StringBuilder result = new StringBuilder(\"(vertical) \");\r\n        for (int y = vwp.y1; y < vwp.y2; y++) result.append(charAt(vwp.x, y));\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Optimizes the boundaries by moving them close to the contained\r\n     * components and gaps.\r\n     * <p>\r\n     * If the optimized table remains non-trivial, it definitely contains\r\n     * some components or gaps.\r\n     */\r\n    public void optimize() {\r\n        optimizeX1();\r\n        optimizeX2();\r\n        optimizeY1();\r\n        optimizeY2();\r\n    }\r\n\r\n    private void optimizeX1() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x1); ) x1++;\r\n    }\r\n\r\n    private void optimizeX2() {\r\n        for (; x1 < x2 && columnContainsNoWordChars(x2 - 1); ) x2--;\r\n    }\r\n\r\n    private void optimizeY1() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y1); ) y1++;\r\n    }\r\n\r\n    private void optimizeY2() {\r\n        for (; y1 < y2 && rowContainsNoWordChars(y2 - 1); ) y2--;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the column under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean columnContainsNoWordChars(int x) {\r\n        for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Verifies that the row under the specified number\r\n     * does not contain word characters.\r\n     */\r\n    private boolean rowContainsNoWordChars(int y) {\r\n        for (int x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     */\r\n    public HWordPosition firstWord_Horizontally() {\r\n        return firstWordAfter_Horizontally(getPos1());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {\r\n        return firstWordAfter_Horizontally(wp.getEnd());\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private HWordPosition firstWordAfter_Horizontally(CharPosition p) {\r\n        CharPosition wordStart = firstWordCharAfter_Horizontally(p);\r\n        if (//word characters not found.\r\n        wordStart == null)\r\n            return null;\r\n        //wordStart is the character found.\r\n        return new HWordPosition(wordStart, firstNonWordCharOnTheRightOf(wordStart));\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is rightwards-downwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Horizontally(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the horizontal line end:\r\n        for (x = p.x; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other horizontal lines:\r\n        for (y++; y < y2; y++) for (x = x1; x < x2; x++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the first symbol which lies on the right\r\n     * from the specified position {@code p} and is not a word character.\r\n     *\r\n     * If not found, returns {@code x2}.\r\n     */\r\n    private int firstNonWordCharOnTheRightOf(CharPosition p) {\r\n        int x = p.x + 1;\r\n        int y = p.y;\r\n        for (; x < x2 && wordCharAt(x, y); x++) ;\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is leftwards-upwards (say, horizontal).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition lastWord_Horizontally() {\r\n        CharPosition wordEnd = lastWordChar_Horizontally();\r\n        if (wordEnd == null)\r\n            return null;\r\n        return new HWordPosition(lastWordCharOnTheLeftOf(wordEnd), wordEnd);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first letter + 1\r\n     * when the search direction is leftwards-upwards (say, horizontal)\r\n     * or null if not found.\r\n     */\r\n    private CharPosition lastWordChar_Horizontally() {\r\n        int x = x2 - 1;\r\n        int y = y2 - 1;\r\n        for (; y >= y1; y--) for (x = x2 - 1; x >= x1; x--) if (wordCharAt(x, y))\r\n            return new CharPosition(x + 1, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the x-coordinate of the last word character\r\n     * of a continuous sequence of word characters\r\n     * starting at the specified position {@code p} and going leftwards.\r\n     */\r\n    private int lastWordCharOnTheLeftOf(CharPosition p) {\r\n        int x = p.x - 1;\r\n        int y = p.y;\r\n        for (; x >= x1 && wordCharAt(x, y); x--) ;\r\n        return x + 1;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word in this char table;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     */\r\n    public HWordPosition firstWord_Vertically() {\r\n        CharPosition nextWordCharPos = firstWordCharVertically();\r\n        if (nextWordCharPos != null)\r\n            return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n        else\r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character;\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharVertically() {\r\n        for (int x = x1; x < x2; x++) for (int y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns (position of) the first horizontal word after the\r\n     * specified word {@code wp}; the direction of searching\r\n     * is downwards-rightwards (say, vertical).\r\n     * If not found, returns null.\r\n     *\r\n     * @throws IllegalArgumentException if the specified word position is null.\r\n     */\r\n    public HWordPosition firstWordAfter_Vertically(HWordPosition wp) {\r\n        if (wp == null)\r\n            throw new IllegalArgumentException(\"Can not search for the word following the null word.\");\r\n        CharPosition nextWordCharPos = firstWordCharAfter_Vertically(wp.getStart());\r\n        while (nextWordCharPos != null && this.contains(nextWordCharPos)) {\r\n            if (//this is a new word\r\n            !wp.contains(nextWordCharPos))\r\n                return new HWordPosition(nextWordCharPos, firstNonWordCharOnTheRightOf(nextWordCharPos));\r\n            nextWordCharPos = firstWordCharAfter_Vertically(nextWordCharPos);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first word character after the\r\n     * specified position {@code p} (inclusive);\r\n     * the direction of searching is downwards-rightwards (say, vertical).\r\n     *\r\n     * If not found, returns null.\r\n     */\r\n    private CharPosition firstWordCharAfter_Vertically(CharPosition p) {\r\n        int x = p.x;\r\n        int y = p.y;\r\n        //search to the vertical line end:\r\n        for (y++; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        //since not found, search in other vertical lines:\r\n        for (x++; x < x2; x++) for (y = y1; y < y2; y++) if (wordCharAt(x, y))\r\n            return new CharPosition(x, y);\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/CharTableTest19.java",
		"test_prompt": "// CharTableTest19.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharTable}.\n* It contains ten unit test cases for the {@link CharTable#firstWordAfter_Vertically(HWordPosition)} method.\n*/\nclass CharTableTest19 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest0.java",
		"test_prompt": "// SchemeTest0.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#containsComponentName(String)} method.\n*/\nclass SchemeTest0 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest1.java",
		"test_prompt": "// SchemeTest1.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#containsGapName(String)} method.\n*/\nclass SchemeTest1 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest2.java",
		"test_prompt": "// SchemeTest2.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#charAt(int, int)} method.\n*/\nclass SchemeTest2 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest3.java",
		"test_prompt": "// SchemeTest3.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#textAt(int, int, int)} method.\n*/\nclass SchemeTest3 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest4.java",
		"test_prompt": "// SchemeTest4.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#anyHElementAt(int, int)} method.\n*/\nclass SchemeTest4 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest5.java",
		"test_prompt": "// SchemeTest5.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#anyHElementAt(CharPosition)} method.\n*/\nclass SchemeTest5 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest6.java",
		"test_prompt": "// SchemeTest6.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#gapAt(int, int)} method.\n*/\nclass SchemeTest6 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest7.java",
		"test_prompt": "// SchemeTest7.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#gapAt(CharPosition)} method.\n*/\nclass SchemeTest7 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest8.java",
		"test_prompt": "// SchemeTest8.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#verticalLineAt(int, int)} method.\n*/\nclass SchemeTest8 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest9.java",
		"test_prompt": "// SchemeTest9.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#verticalLineAt(CharPosition)} method.\n*/\nclass SchemeTest9 {"
	},
	{
		"original_code": "// Scheme.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\n/**\n * Represents the layout scheme which is specified by the end user\n * as a sequence of strings.\n */\npublic class Scheme extends CharTable {\n\n    protected final String[] lines;\n\n    /**\n     * Encapsulates the sets of positions of all components, lines and gaps\n     * present on the scheme.\n     */\n    private static class Positions {\n\n        HashSet<HWordPosition> components = new HashSet<HWordPosition>();\n\n        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();\n\n        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();\n\n        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();\n    }\n\n    private Positions positions;\n\n    /**\n     * Encapsulates the sets of names of all components and of all gaps\n     * present on the scheme.\n     */\n    private static class Names {\n\n        HashSet<String> components = new HashSet<String>();\n\n        HashSet<String> gaps = new HashSet<String>();\n    }\n\n    private Names names;\n\n    /**\n     * Maps components and gaps positions to the corresponding names.\n     */\n    private HashMap<HWordPosition, String> positionsToNames;\n\n    /**\n     * Maps the y-coordinates on the scheme\n     * to sets of horizontal words having these coordinates.\n     * This map is used in the horizontal words and lines search methods.\n     */\n    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;\n\n    /**\n     * Maps the x-coordinates on the scheme\n     * to sets of vertical words having these coordinates.\n     * This map is used in the vertical line search method.\n     */\n    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;\n\n    /**\n     * Represents the correspondence between the lines on the scheme\n     * and the gaps which belong to those lines (intersect them).\n     * Both lines and gaps are represented by their positions on the scheme.\n     * <p>\n     * Note that each line may contain (may be intersected by) only one gap.\n     */\n    private Map<WordPosition, HWordPosition> gapsAtLines;\n\n    public Scheme(String... strings) {\n        lines = strings;\n        calculateAndCheckSize();\n        recognizeContent();\n        extractNamesFromPositions();\n        organizeFastElementsSearch();\n        recognizeGapsAtLines();\n    }\n\n    protected void calculateAndCheckSize() {\n        if (lines.length == 0)\n            throw new IllegalArgumentException(\"The scheme has no lines.\");\n        x1 = 0;\n        y1 = 0;\n        y2 = lines.length;\n        x2 = lines[0].length();\n        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)\n            throw new IllegalArgumentException(\"The strings are not of equal length.\");\n    }\n\n    /**\n     * Finds each element present on the scheme,\n     * identifies it with certain type,\n     * and places the element to the corresponding set\n     * in the field {@code positions}.\n     *\n     * @throws \tIllegalArgumentException if the scheme contains improper symbols.\n     * \t\t\t<p>\n     * \t\t\tNote that after successful scheme initialization\n     * \t\t\tthere is no need to determine its characters types using\n     * \t\t\tcomparation with {@code CharTable.LETTERS}. One can just\n     * \t\t\tuse comparation with dots, lines, and spaces instead.\n     */\n    protected void recognizeContent() {\n        positions = new Positions();\n        /* Find sequentially the upper-left corner\n\t\t * of each element on the scheme,\n\t\t * find another end of the element,\n\t\t * identify the element,\n\t\t * register it.\n\t\t */\n        //A non-trivial order of visiting cells of the scheme is possible.\n        boolean[][] visited = new boolean[x2][y2];\n        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {\n            if (visited[x][y] || charAt(x, y) == ' ')\n                continue;\n            visited[x][y] = true;\n            trackElementStartingAt(x, y, visited);\n        }\n    }\n\n    /**\n     * Recognizes the element containing the specified position\n     * (if such element exists).\n     */\n    private void trackElementStartingAt(int x, int y, boolean[][] visited) {\n        char c = charAt(x, y);\n        if (c == '-')\n            positions.hLines.add(trackHLineStartingAt(x, y, visited));\n        else if (c == '|')\n            positions.vLines.add(trackVLineStartingAt(x, y, visited));\n        else if (isLetter(c))\n            positions.components.add(trackComponentStartingAt(x, y, visited));\n        else if (c == '.')\n            positions.gaps.add(trackGapStartingAt(x, y, visited));\n        else if (c == '+') {\n            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');\n            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');\n            if (startsHline)\n                positions.hLines.add(trackHLineStartingAt(x, y, visited));\n            if (startsVline)\n                positions.vLines.add(trackVLineStartingAt(x, y, visited));\n            else if (!startsHline)\n                throw new IllegalArgumentException(\"Unrecognizable construction found in the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n        } else\n            throwWrongSymbolException(x, y, c);\n    }\n\n    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {\n        //retain x and move x to the end of the line:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '-' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '|' || c == '.' || isLetter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {\n        int startY = y;\n        //just in case check for pluses above:\n        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;\n        //retain y as startY and move y to the end of the line:\n        char c;\n        for (y = startY + 1; y < y2; y++) {\n            c = charAt(x, y);\n            if (//the line continues\n            c == '|' || c == '+')\n                visited[x][y] = true;\n            else if (//line end\n            c == ' ' || c == '-' || c == '.' || isLetter(c))\n                return new VWordPosition(x, startY, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new VWordPosition(x, startY, y);\n    }\n\n    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the component:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the component continues\n            isLetter(c))\n                visited[x][y] = true;\n            else if (//component finished\n            c == ' ' || isSplitter(c))\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {\n        //retain x as startX and move x to the end of the gap:\n        int startX = x;\n        char c;\n        for (x = startX + 1; x < x2; x++) {\n            c = charAt(x, y);\n            if (//the gap continues\n            isWordChar(c))\n                visited[x][y] = true;\n            else if (//gap finished\n            c == '-' || c == '+' || c == ' ')\n                return new HWordPosition(startX, x, y);\n            else\n                throwWrongSymbolException(x, y, c);\n        }\n        return new HWordPosition(startX, x, y);\n    }\n\n    private char firstNonPlusOnTheRightFrom(int x, int y) {\n        char c;\n        for (; x < x2; x++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private char firstNonPlusDownFrom(int x, int y) {\n        char c;\n        for (; y < y2; y++) {\n            c = charAt(x, y);\n            if (c != '+')\n                return c;\n        }\n        return ' ';\n    }\n\n    private void throwWrongSymbolException(int x, int y, char c) {\n        throw new IllegalArgumentException(\"A wrong symbol \\'\" + c + \"\\' was found on the scheme\" + \" under position (\" + x + \",\" + y + \")\");\n    }\n\n    /**\n     * Initializes the sets {@code names.components} and {@code names.gaps}\n     * and the mapping {@code positionsToNames}\n     * using the positions of all these elements on the scheme,\n     * which are considered to be initialized earlier.\n     */\n    protected void extractNamesFromPositions() {\n        names = new Names();\n        positionsToNames = new HashMap<HWordPosition, String>();\n        String name;\n        for (HWordPosition wp : positions.components) {\n            name = textAt(wp);\n            registerComponentName(name);\n            positionsToNames.put(wp, name);\n        }\n        for (HWordPosition wp : positions.gaps) {\n            name = textAt(wp);\n            registerGapName(name);\n            positionsToNames.put(wp, name);\n        }\n    }\n\n    private void registerComponentName(String name) {\n        if (!names.components.add(name))\n            throw new IllegalArgumentException(\"cannot register the component name \\\"\" + name + \"\\\"\");\n    }\n\n    private void registerGapName(String name) {\n        names.gaps.add(name);\n    }\n\n    /**\n     * Initializes the variables\n     * {@code hWordsAtLines} and {@code vWordsAtLines}\n     * which are used in the searching methods\n     * {@code horizontalElementAt()} and {@code verticalLineAt()}.\n     */\n    protected void organizeFastElementsSearch() {\n        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);\n        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());\n        distributeHWordsByLines(positions.components);\n        distributeHWordsByLines(positions.gaps);\n        distributeHWordsByLines(positions.hLines);\n        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();\n        distributeVWordsByLines(positions.vLines);\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code hWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeHWordsByLines(Set<HWordPosition> from) {\n        for (HWordPosition wp : from) {\n            hWordsAtYs.get(new Integer(wp.y)).add(wp);\n        }\n    }\n\n    /**\n     * Puts the references at each word position in the specified\n     * set {@code from} into the corresponding values of the map\n     * {@code vWordsAtLines}.\n     *\n     * @param from\tthe set of positions to be distributed.\n     */\n    private void distributeVWordsByLines(Set<VWordPosition> from) {\n        Integer key;\n        for (VWordPosition wp : from) {\n            key = new Integer(wp.x);\n            if (!vWordsAtXs.containsKey(key))\n                vWordsAtXs.put(key, new HashSet<VWordPosition>());\n            vWordsAtXs.get(key).add(wp);\n        }\n    }\n\n    /**\n     * Investigates, which gaps must be considered as belonging to lines;\n     * then modifies the corresponding lines' positions.\n     * <p>\n     * This method initializes the field {@code gapsAtLines}\n     * and influences the fields\n     * {@code positions.hLines}, {@code positions.vLines}\n     * {@code hWordsAtYs}, and {@code vWordsAtXs}.\n     */\n    protected void recognizeGapsAtLines() {\n        gapsAtLines = new HashMap<WordPosition, HWordPosition>();\n        recognizeHorizontalGapsAtLines();\n        recognizeVerticalGapsAtLines();\n    }\n\n    protected void recognizeHorizontalGapsAtLines() {\n        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();\n        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<HWordPosition> i = positions.hLines.iterator();\n        HWordPosition hLine;\n        while (i.hasNext()) {\n            hLine = i.next();\n            if (//already visited.\n            hLinesToRemove.contains(hLine))\n                continue;\n            int newX1 = hLine.x1;\n            HWordPosition leftGap = gapOnTheLeftFrom(hLine);\n            if (leftGap != null) {\n                newX1 = leftGap.x1;\n                gapAtLine = leftGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);\n                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {\n                    newX1 = leftLine.x1;\n                    //the line will be changed.\n                    hLinesToRemove.add(leftLine);\n                    if (gapOnTheLeftFrom(leftLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            int newX2 = hLine.x2;\n            HWordPosition rightGap = gapOnTheRightFrom(hLine);\n            if (rightGap != null) {\n                if (//this is not the first gap.\n                leftGap != null)\n                    throwMultipleGapsAtYException(hLine.y);\n                newX2 = rightGap.x2;\n                gapAtLine = rightGap;\n                //the current line will be changed.\n                hLinesToRemove.add(hLine);\n                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);\n                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {\n                    newX2 = rightLine.x2;\n                    //the line will be changed.\n                    hLinesToRemove.add(rightLine);\n                    if (gapOnTheRightFrom(rightLine) != null)\n                        throwMultipleGapsAtYException(hLine.y);\n                }\n            }\n            if (newX1 != hLine.x1 || newX2 != hLine.x2) {\n                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);\n                hLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        for (HWordPosition line : hLinesToRemove) {\n            positions.hLines.remove(line);\n            hWordsAtYs.get(line.y).remove(line);\n        }\n        for (HWordPosition line : hLinesToAdd) {\n            positions.hLines.add(line);\n            hWordsAtYs.get(line.y).add(line);\n        }\n    }\n\n    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return gapAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {\n        CharPosition leftPos = hLine.getStart();\n        return anyHElementAt(leftPos.x - 1, leftPos.y);\n    }\n\n    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {\n        return gapAt(hLine.getEnd());\n    }\n\n    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {\n        CharPosition rightPos = hLine.getEnd();\n        return anyHElementAt(rightPos.x, rightPos.y);\n    }\n\n    private void throwMultipleGapsAtYException(int y) {\n        throw new IllegalArgumentException(\"Multiple gaps on a horisontal line\" + \" at y=\" + y + \" found.\");\n    }\n\n    protected void recognizeVerticalGapsAtLines() {\n        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();\n        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();\n        HWordPosition gapAtLine = null;\n        //Searching:\n        Iterator<VWordPosition> i = positions.vLines.iterator();\n        VWordPosition vLine;\n        while (i.hasNext()) {\n            vLine = i.next();\n            if (//already visited.\n            vLinesToRemove.contains(vLine))\n                continue;\n            int newY1 = vLine.y1;\n            HWordPosition topGap = gapAbove(vLine);\n            if (topGap != null) {\n                newY1 = topGap.y;\n                gapAtLine = topGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition topLine = vLineAbove(vLine);\n                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {\n                    newY1 = topLine.y1;\n                    //the line will be changed.\n                    vLinesToRemove.add(topLine);\n                    if (gapAbove(topLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            int newY2 = vLine.y2;\n            HWordPosition bottomGap = gapBelow(vLine);\n            if (bottomGap != null) {\n                if (//this is not the first gap.\n                topGap != null)\n                    throwMultipleGapsAtXException(vLine.x);\n                newY2 = bottomGap.y + 1;\n                gapAtLine = bottomGap;\n                //the current line will be changed.\n                vLinesToRemove.add(vLine);\n                VWordPosition bottomLine = vLineBelow(vLine);\n                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {\n                    newY2 = bottomLine.y2;\n                    //the line will be changed.\n                    vLinesToRemove.add(bottomLine);\n                    if (gapBelow(bottomLine) != null)\n                        throwMultipleGapsAtXException(vLine.x);\n                }\n            }\n            if (newY1 != vLine.y1 || newY2 != vLine.y2) {\n                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);\n                vLinesToAdd.add(newLine);\n                gapsAtLines.put(newLine, gapAtLine);\n            }\n        }\n        //Applying the changes:\n        //removing:\n        for (VWordPosition line : vLinesToRemove) {\n            positions.vLines.remove(line);\n            vWordsAtXs.get(line.x).remove(line);\n        }\n        //adding:\n        for (VWordPosition line : vLinesToAdd) {\n            positions.vLines.add(line);\n            vWordsAtXs.get(line.x).add(line);\n        }\n    }\n\n    private HWordPosition gapAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return gapAt(topPos.x, topPos.y - 1);\n    }\n\n    /* \n\t * Returns the vertical line lying above the specified line\n\t * and the gap lying above it.\n\t */\n    private VWordPosition vLineAbove(VWordPosition vLine) {\n        CharPosition topPos = vLine.getStart();\n        return verticalLineAt(topPos.x, topPos.y - 2);\n    }\n\n    private HWordPosition gapBelow(VWordPosition vLine) {\n        return gapAt(vLine.getEnd());\n    }\n\n    /* \n\t * Returns the vertical line lying below the specified line\n\t * and the gap lying below it.\n\t */\n    private VWordPosition vLineBelow(VWordPosition vLine) {\n        CharPosition bottomPos = vLine.getEnd();\n        return verticalLineAt(bottomPos.x, bottomPos.y + 1);\n    }\n\n    private void throwMultipleGapsAtXException(int x) {\n        throw new IllegalArgumentException(\"Multiple gaps on a vertical line\" + \" at x=\" + x + \" found.\");\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified component name.\n     */\n    public boolean containsComponentName(String name) {\n        return names.components.contains(name);\n    }\n\n    /**\n     * Verifies whether the scheme contains the specified gap denotation.\n     */\n    public boolean containsGapName(String name) {\n        return names.gaps.contains(name);\n    }\n\n    /**\n     * Returns the symbol lying on the scheme under the specified position.\n     */\n    public char charAt(int x, int y) {\n        try {\n            return lines[y].charAt(x);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position out of table\");\n        }\n    }\n\n    /**\n     * Returns the text lying on the scheme\n     * specified by the given word position coordinates.\n     */\n    public String textAt(int x1, int x2, int y) {\n        try {\n            return lines[y].substring(x1, x2);\n        } catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of horizontal lines on the scheme.\n     */\n    public Set<HWordPosition> getHLinesPositions() {\n        return Collections.unmodifiableSet(positions.hLines);\n    }\n\n    /**\n     * Returns an unmodifiable set of all positions\n     * of vertical lines on the scheme.\n     */\n    public Set<VWordPosition> getVLinesPositions() {\n        return Collections.unmodifiableSet(positions.vLines);\n    }\n\n    /**\n     * Finds and returns (the position of) a horizontal element\n     * which contains the specified point.\n     * If such element does not exist, returns null.\n     * <p>\n     * Note that some points may lie at horizontal lines\n     * and at gaps belonging to that lines simultaneously.\n     * In such cases the method returns any of the two elements.\n     */\n    public HWordPosition anyHElementAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition anyHElementAt(CharPosition pos) {\n        return anyHElementAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the gap\n     * containing the specified point\n     * or null if such gap does not exist on the scheme.\n     */\n    public HWordPosition gapAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '|')\n            return null;\n        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));\n        if (h != null)\n            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))\n                return hwp;\n        return null;\n    }\n\n    public HWordPosition gapAt(CharPosition pos) {\n        return gapAt(pos.x, pos.y);\n    }\n\n    /**\n     * Finds and returns (the position of) the vertical line\n     * which contains the specified point\n     * or null if such line does not exist.\n     */\n    public VWordPosition verticalLineAt(int x, int y) {\n        if (!contains(x, y))\n            return null;\n        char c = charAt(x, y);\n        if (c == ' ' || c == '-')\n            return null;\n        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));\n        if (v != null)\n            for (VWordPosition vwp : v) if (vwp.contains(x, y))\n                return vwp;\n        return null;\n    }\n\n    public VWordPosition verticalLineAt(CharPosition pos) {\n        return verticalLineAt(pos.x, pos.y);\n    }\n\n    /**\n     * Returns the gap belonging to the specified horizontal or vertical line\n     * or null if such gap does not exist.\n     */\n    public HWordPosition gapAtLine(WordPosition line) {\n        if (gapsAtLines == null)\n            return null;\n        return gapsAtLines.get(line);\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);\n        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\\n');\n        return result.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/SchemeTest10.java",
		"test_prompt": "// SchemeTest10.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Scheme}.\n* It contains ten unit test cases for the {@link Scheme#gapAtLine(WordPosition)} method.\n*/\nclass SchemeTest10 {"
	},
	{
		"original_code": "// Block.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * Represents a rectangular area on a scheme.\r\n * This is an abstract class for its two concrete descendants,\r\n * {@code HorizontalBlock} and {@code VerticalBlock},\r\n * which are used for dealing with\r\n * the horizontal and the vertical layouts, respectively.\r\n */\r\npublic abstract class Block extends CharTable {\r\n\r\n    /**\r\n     *  ,    {@code Block}.\r\n     */\r\n    protected Scheme scheme;\r\n\r\n    /**\r\n     *        \r\n     *   .\r\n     */\r\n    public Block(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        if (x1 < 0 || y1 < 0 || x1 > x2 || y1 > y2 || x2 > scheme.x2 || y2 > scheme.y2)\r\n            throw new IllegalArgumentException(\"improper block definition\" + \": \" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \".\");\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    public Block(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        this(scheme, p1.x, p1.y, p2.x, p2.y);\r\n    }\r\n\r\n    /**\r\n     *    ,      .\r\n     */\r\n    public Block(Scheme scheme) {\r\n        x1 = 0;\r\n        y1 = 0;\r\n        x2 = scheme.x2;\r\n        y2 = scheme.y2;\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    /**\r\n     *    ,   .\r\n     * @param x1\t{@code x}-   .\r\n     * @param y1\t{@code y}-   .\r\n     * @param x2\t{@code x}-   .\r\n     * @param y2\t{@code y}-   .\r\n     * @return\t\t .\r\n     */\r\n    public abstract Block subblock(int x1, int y1, int x2, int y2);\r\n\r\n    /**\r\n     *   , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     *\r\n     * @return\t   .\r\n     */\r\n    public char charAt(int x, int y) {\r\n        try {\r\n            return scheme.lines[y].charAt(x);\r\n        } catch (RuntimeException re) {\r\n            throw new IllegalArgumentException(\"char position \" + new CharPosition(x, y) + \" out of block.\\n\" + this);\r\n        }\r\n    }\r\n\r\n    public String textAt(int x1, int x2, int y) {\r\n        try {\r\n            return scheme.lines[y].substring(x1, x2);\r\n        } catch (RuntimeException re) {\r\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the block contains only one element\r\n     * (a component or a gap).\r\n     *\r\n     * @return\t{@code true} if only one or {@code false} if more than one.\r\n     * \t\t\tIf there are no elements or the block is trivial,\r\n     * \t\t\tan exception is thrown.\r\n     */\r\n    public boolean containsOnlyOneWord() {\r\n        if (isTrivial())\r\n            throw new IllegalArgumentException(\"cannot search in a trivial block\");\r\n        HWordPosition firstWord = firstWord_Horizontally();\r\n        if (//  .\r\n        firstWord.y == y2)\r\n            throw new IllegalArgumentException(\"cannot verify unicity of an word in an empty block\");\r\n        WordPosition lastWord = lastWord_Horizontally();\r\n        return firstWord.equals(lastWord);\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     */\r\n    public abstract List<Block> extractSequentialSubblocks();\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     */\r\n    public abstract List<Block> extractParallelSubblocks();\r\n\r\n    public String toString() {\r\n        String result = \"Block(\" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \"):\\n\";\r\n        //      :\r\n        int frameWidth = x2 - x1 + 4;\r\n        char[] line = new char[frameWidth];\r\n        java.util.Arrays.fill(line, '#');\r\n        String lineString = \" \" + new String(line);\r\n        result = result.concat(lineString + \"\\n\");\r\n        for (int y = y1; y < y2; y++) result = result.concat(\" # \" + scheme.textAt(x1, x2, y) + \" #\\n\");\r\n        result = result.concat(lineString);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the upper line of this block.\r\n     * <p>\r\n     * This method is used when the block represents a position\r\n     * of a horizontal word on a scheme.\r\n     */\r\n    public String getUpperLine() {\r\n        return textAt(x1, x2, y1);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/BlockTest0.java",
		"test_prompt": "// BlockTest0.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Block}.\n* It contains ten unit test cases for the {@link Block#charAt(int, int)} method.\n*/\nclass BlockTest0 {"
	},
	{
		"original_code": "// Block.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * Represents a rectangular area on a scheme.\r\n * This is an abstract class for its two concrete descendants,\r\n * {@code HorizontalBlock} and {@code VerticalBlock},\r\n * which are used for dealing with\r\n * the horizontal and the vertical layouts, respectively.\r\n */\r\npublic abstract class Block extends CharTable {\r\n\r\n    /**\r\n     *  ,    {@code Block}.\r\n     */\r\n    protected Scheme scheme;\r\n\r\n    /**\r\n     *        \r\n     *   .\r\n     */\r\n    public Block(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        if (x1 < 0 || y1 < 0 || x1 > x2 || y1 > y2 || x2 > scheme.x2 || y2 > scheme.y2)\r\n            throw new IllegalArgumentException(\"improper block definition\" + \": \" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \".\");\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    public Block(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        this(scheme, p1.x, p1.y, p2.x, p2.y);\r\n    }\r\n\r\n    /**\r\n     *    ,      .\r\n     */\r\n    public Block(Scheme scheme) {\r\n        x1 = 0;\r\n        y1 = 0;\r\n        x2 = scheme.x2;\r\n        y2 = scheme.y2;\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    /**\r\n     *    ,   .\r\n     * @param x1\t{@code x}-   .\r\n     * @param y1\t{@code y}-   .\r\n     * @param x2\t{@code x}-   .\r\n     * @param y2\t{@code y}-   .\r\n     * @return\t\t .\r\n     */\r\n    public abstract Block subblock(int x1, int y1, int x2, int y2);\r\n\r\n    /**\r\n     *   , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     *\r\n     * @return\t   .\r\n     */\r\n    public char charAt(int x, int y) {\r\n        try {\r\n            return scheme.lines[y].charAt(x);\r\n        } catch (RuntimeException re) {\r\n            throw new IllegalArgumentException(\"char position \" + new CharPosition(x, y) + \" out of block.\\n\" + this);\r\n        }\r\n    }\r\n\r\n    public String textAt(int x1, int x2, int y) {\r\n        try {\r\n            return scheme.lines[y].substring(x1, x2);\r\n        } catch (RuntimeException re) {\r\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the block contains only one element\r\n     * (a component or a gap).\r\n     *\r\n     * @return\t{@code true} if only one or {@code false} if more than one.\r\n     * \t\t\tIf there are no elements or the block is trivial,\r\n     * \t\t\tan exception is thrown.\r\n     */\r\n    public boolean containsOnlyOneWord() {\r\n        if (isTrivial())\r\n            throw new IllegalArgumentException(\"cannot search in a trivial block\");\r\n        HWordPosition firstWord = firstWord_Horizontally();\r\n        if (//  .\r\n        firstWord.y == y2)\r\n            throw new IllegalArgumentException(\"cannot verify unicity of an word in an empty block\");\r\n        WordPosition lastWord = lastWord_Horizontally();\r\n        return firstWord.equals(lastWord);\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     */\r\n    public abstract List<Block> extractSequentialSubblocks();\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     */\r\n    public abstract List<Block> extractParallelSubblocks();\r\n\r\n    public String toString() {\r\n        String result = \"Block(\" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \"):\\n\";\r\n        //      :\r\n        int frameWidth = x2 - x1 + 4;\r\n        char[] line = new char[frameWidth];\r\n        java.util.Arrays.fill(line, '#');\r\n        String lineString = \" \" + new String(line);\r\n        result = result.concat(lineString + \"\\n\");\r\n        for (int y = y1; y < y2; y++) result = result.concat(\" # \" + scheme.textAt(x1, x2, y) + \" #\\n\");\r\n        result = result.concat(lineString);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the upper line of this block.\r\n     * <p>\r\n     * This method is used when the block represents a position\r\n     * of a horizontal word on a scheme.\r\n     */\r\n    public String getUpperLine() {\r\n        return textAt(x1, x2, y1);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/BlockTest1.java",
		"test_prompt": "// BlockTest1.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Block}.\n* It contains ten unit test cases for the {@link Block#textAt(int, int, int)} method.\n*/\nclass BlockTest1 {"
	},
	{
		"original_code": "// Block.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * Represents a rectangular area on a scheme.\r\n * This is an abstract class for its two concrete descendants,\r\n * {@code HorizontalBlock} and {@code VerticalBlock},\r\n * which are used for dealing with\r\n * the horizontal and the vertical layouts, respectively.\r\n */\r\npublic abstract class Block extends CharTable {\r\n\r\n    /**\r\n     *  ,    {@code Block}.\r\n     */\r\n    protected Scheme scheme;\r\n\r\n    /**\r\n     *        \r\n     *   .\r\n     */\r\n    public Block(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        if (x1 < 0 || y1 < 0 || x1 > x2 || y1 > y2 || x2 > scheme.x2 || y2 > scheme.y2)\r\n            throw new IllegalArgumentException(\"improper block definition\" + \": \" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \".\");\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    public Block(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        this(scheme, p1.x, p1.y, p2.x, p2.y);\r\n    }\r\n\r\n    /**\r\n     *    ,      .\r\n     */\r\n    public Block(Scheme scheme) {\r\n        x1 = 0;\r\n        y1 = 0;\r\n        x2 = scheme.x2;\r\n        y2 = scheme.y2;\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    /**\r\n     *    ,   .\r\n     * @param x1\t{@code x}-   .\r\n     * @param y1\t{@code y}-   .\r\n     * @param x2\t{@code x}-   .\r\n     * @param y2\t{@code y}-   .\r\n     * @return\t\t .\r\n     */\r\n    public abstract Block subblock(int x1, int y1, int x2, int y2);\r\n\r\n    /**\r\n     *   , \r\n     *   {@code x}  {@code y}.\r\n     *\r\n     * @param x\t  .\r\n     * @param y\t  .\r\n     *\r\n     * @return\t   .\r\n     */\r\n    public char charAt(int x, int y) {\r\n        try {\r\n            return scheme.lines[y].charAt(x);\r\n        } catch (RuntimeException re) {\r\n            throw new IllegalArgumentException(\"char position \" + new CharPosition(x, y) + \" out of block.\\n\" + this);\r\n        }\r\n    }\r\n\r\n    public String textAt(int x1, int x2, int y) {\r\n        try {\r\n            return scheme.lines[y].substring(x1, x2);\r\n        } catch (RuntimeException re) {\r\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the block contains only one element\r\n     * (a component or a gap).\r\n     *\r\n     * @return\t{@code true} if only one or {@code false} if more than one.\r\n     * \t\t\tIf there are no elements or the block is trivial,\r\n     * \t\t\tan exception is thrown.\r\n     */\r\n    public boolean containsOnlyOneWord() {\r\n        if (isTrivial())\r\n            throw new IllegalArgumentException(\"cannot search in a trivial block\");\r\n        HWordPosition firstWord = firstWord_Horizontally();\r\n        if (//  .\r\n        firstWord.y == y2)\r\n            throw new IllegalArgumentException(\"cannot verify unicity of an word in an empty block\");\r\n        WordPosition lastWord = lastWord_Horizontally();\r\n        return firstWord.equals(lastWord);\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     */\r\n    public abstract List<Block> extractSequentialSubblocks();\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     */\r\n    public abstract List<Block> extractParallelSubblocks();\r\n\r\n    public String toString() {\r\n        String result = \"Block(\" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \"):\\n\";\r\n        //      :\r\n        int frameWidth = x2 - x1 + 4;\r\n        char[] line = new char[frameWidth];\r\n        java.util.Arrays.fill(line, '#');\r\n        String lineString = \" \" + new String(line);\r\n        result = result.concat(lineString + \"\\n\");\r\n        for (int y = y1; y < y2; y++) result = result.concat(\" # \" + scheme.textAt(x1, x2, y) + \" #\\n\");\r\n        result = result.concat(lineString);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the upper line of this block.\r\n     * <p>\r\n     * This method is used when the block represents a position\r\n     * of a horizontal word on a scheme.\r\n     */\r\n    public String getUpperLine() {\r\n        return textAt(x1, x2, y1);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/BlockTest2.java",
		"test_prompt": "// BlockTest2.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Block}.\n* It contains ten unit test cases for the {@link Block#containsOnlyOneWord()} method.\n*/\nclass BlockTest2 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest0.java",
		"test_prompt": "// PreferredGapAgentTest0.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#isComponent(String)} method.\n*/\nclass PreferredGapAgentTest0 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest1.java",
		"test_prompt": "// PreferredGapAgentTest1.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#isGroup(String, String)} method.\n*/\nclass PreferredGapAgentTest1 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest2.java",
		"test_prompt": "// PreferredGapAgentTest2.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#isGap()} method.\n*/\nclass PreferredGapAgentTest2 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest3.java",
		"test_prompt": "// PreferredGapAgentTest3.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#equals(Agent)} method.\n*/\nclass PreferredGapAgentTest3 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest4.java",
		"test_prompt": "// PreferredGapAgentTest4.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#findDependingComponentByName(String)} method.\n*/\nclass PreferredGapAgentTest4 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest5.java",
		"test_prompt": "// PreferredGapAgentTest5.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#findDependingGroupByNames(String, String)} method.\n*/\nclass PreferredGapAgentTest5 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest6.java",
		"test_prompt": "// PreferredGapAgentTest6.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#findDependingParallelGroupByNames(String, String)} method.\n*/\nclass PreferredGapAgentTest6 {"
	},
	{
		"original_code": "// PreferredGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\n\r\npublic class PreferredGapAgent extends Agent {\r\n\r\n    public PreferredGapAgent(ComponentPlacement type) {\r\n        settings = new PreferredGapSettings(type);\r\n    }\r\n\r\n    public PreferredGapAgent(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public PreferredGapSettings getSettings() {\r\n        return (PreferredGapSettings) settings;\r\n    }\r\n\r\n    public void setSettings(ComponentPlacement type, int pref, int max) {\r\n        settings = new PreferredGapSettings(type, pref, max);\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *     .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        if (!(targetGroup instanceof SequentialGroup))\r\n            throw new IllegalArgumentException(\"cannot add preferred gaps into non-sequential groups\");\r\n        PreferredGapSettings settings = getSettings();\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        ((SequentialGroup) targetGroup).addPreferredGap(settings.type, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public String toString() {\r\n        return getSettings().type + \" gap\";\r\n        //\t\t\t\t+ \", \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/PreferredGapAgentTest7.java",
		"test_prompt": "// PreferredGapAgentTest7.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PreferredGapAgent}.\n* It contains ten unit test cases for the {@link PreferredGapAgent#findDependingSequentialGroupByNames(String, String)} method.\n*/\nclass PreferredGapAgentTest7 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest0.java",
		"test_prompt": "// GroupAgentTest0.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#isComponent(String)} method.\n*/\nclass GroupAgentTest0 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest1.java",
		"test_prompt": "// GroupAgentTest1.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#isGroup(String, String)} method.\n*/\nclass GroupAgentTest1 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest2.java",
		"test_prompt": "// GroupAgentTest2.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#isGap()} method.\n*/\nclass GroupAgentTest2 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest3.java",
		"test_prompt": "// GroupAgentTest3.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#equals(Agent)} method.\n*/\nclass GroupAgentTest3 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest4.java",
		"test_prompt": "// GroupAgentTest4.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#findDependingComponentByName(String)} method.\n*/\nclass GroupAgentTest4 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest5.java",
		"test_prompt": "// GroupAgentTest5.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#findDependingGroupByNames(String, String)} method.\n*/\nclass GroupAgentTest5 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest6.java",
		"test_prompt": "// GroupAgentTest6.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#findDependingParallelGroupByNames(String, String)} method.\n*/\nclass GroupAgentTest6 {"
	},
	{
		"original_code": "// GroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\r\nimport glengineer.agents.settings.Settings;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a group.\r\n */\r\npublic abstract class GroupAgent extends Agent {\r\n\r\n    protected LinkedList<Agent> childrenAgents = new LinkedList<Agent>();\r\n\r\n    public GroupAgent() {\r\n        settings = new Settings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getFirstName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        if (childrenAgents.isEmpty())\r\n            return null;\r\n        String result;\r\n        Iterator<Agent> i = childrenAgents.descendingIterator();\r\n        while (i.hasNext()) {\r\n            result = i.next().getLastName();\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return getFirstName().equals(firstName) && getLastName().equals(lastName);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isGroup(getFirstName(), getLastName());\r\n    }\r\n\r\n    public void addAgent(Agent agent) {\r\n        if (agent == null)\r\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\r\n        childrenAgents.add(agent);\r\n    }\r\n\r\n    public List<Agent> getChildren() {\r\n        return Collections.unmodifiableList(childrenAgents);\r\n    }\r\n\r\n    public int getNumberOfChildren() {\r\n        return childrenAgents.size();\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the component with the specified name.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public ComponentAgent getComponent(String name) {\r\n        for (Agent child : childrenAgents) if (child.isComponent(name))\r\n            return (ComponentAgent) child;\r\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds and returns the child of this group\r\n     * which is the group with the specified first and last names.\r\n     *\r\n     * @throws\tIllegalArgumentException if not found.\r\n     */\r\n    public GroupAgent getGroup(String firstName, String lastName) {\r\n        for (Agent child : childrenAgents) if (child.isGroup(firstName, lastName))\r\n            return (GroupAgent) child;\r\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified first and last names\r\n     * among this agent and all agents of lower level (if this is a group).\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        ComponentAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingComponentByName(componentName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches for the group agent with the specified name\r\n     * among all agents of lower level.\r\n     *\r\n     * @return\tthe agent found or null if not found.\r\n     */\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName))\r\n            return this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof ParallelGroupAgent)\r\n            return (ParallelGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (ParallelGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        if (isGroup(firstName, lastName) && this instanceof SequentialGroupAgent)\r\n            return (SequentialGroupAgent) this;\r\n        GroupAgent result = null;\r\n        for (Agent child : childrenAgents) {\r\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\r\n            if (result != null)\r\n                return (SequentialGroupAgent) result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gaps must affect sequential groups only.\r\n     * This method does all the job related to removing gaps from\r\n     * parallel groups in this group.\r\n     * In particular, it finds parallel groups which consist of gaps only\r\n     * and replaces these parallel groups by gaps of corresponding types.\r\n     * <p>\r\n     * More precisely:\r\n     * <ol>\r\n     * <li> Passes the invocation of this method to all subgroups.\r\n     * <li> Removes all gaps from every deeper parallel group\r\n     * containing not only gaps.\r\n     * <li> Replaces every deeper parallel group containing only gaps\r\n     * by the gap of that type.\r\n     * If such parallel group contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> Replaces every continuous sequence of gaps\r\n     * by a gap of that type.\r\n     * If such sequence contains gaps of different type,\r\n     * throws a runtime exception.\r\n     * <li> After all, if some subgroups have begun\r\n     * to consist of single elements,\r\n     * this method replaces them by those elements.\r\n     * </ol>\r\n     *\r\n     * <p> Note that this method\r\n     * is called from the constructor of the {@code GroupLayoutEngineer},\r\n     * and hence the gaps added into the hierarchy manually\r\n     * will not be removed by this method.\r\n     */\r\n    public void removeGapsFromParallelGroups() {\r\n        passTheCallToSubgroups();\r\n        removeGapsFromParallelSubgroupsWithOtherContent();\r\n        replaceParallelSubgroupsWithGapsByTheirSingleGaps();\r\n        replaceContinuousSequencesOfGapsBySingleGaps();\r\n        replaceGroupsWithSingleElementsByThatElements();\r\n    }\r\n\r\n    private void passTheCallToSubgroups() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).removeGapsFromParallelGroups();\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * Removes gaps from parallel subgroups containing not only gaps.\r\n\t */\r\n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        while (i.hasNext()) {\r\n            child = i.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                if (!parallel.containsGapsOnly())\r\n                    parallel.removeAllGaps();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        ParallelGroupAgent parallel;\r\n        Agent gap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof ParallelGroupAgent) {\r\n                parallel = (ParallelGroupAgent) child;\r\n                gap = parallel.getGapsType();\r\n                if (//gaps found!\r\n                gap != null)\r\n                    //replace the group by its single gap.\r\n                    li.set(gap);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        Agent currentGap;\r\n        Agent nextGap;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (!child.isGap())\r\n                continue;\r\n            //begins a sequence of gaps.\r\n            currentGap = child;\r\n            //remove elements of the sequence one by one:\r\n            while (li.hasNext()) {\r\n                nextGap = li.next();\r\n                if (!nextGap.isGap())\r\n                    //the sequence of gaps is finished.\r\n                    break;\r\n                if (nextGap.equals(currentGap))\r\n                    li.remove();\r\n                else\r\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types\" + \" was found in a group.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void replaceGroupsWithSingleElementsByThatElements() {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        GroupAgent nextSubgroup;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent) {\r\n                nextSubgroup = (GroupAgent) child;\r\n                if (nextSubgroup.getNumberOfChildren() == 1)\r\n                    li.set(nextSubgroup.getChildren().get(0));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all temporary gaps in this group and in all lower groups\r\n     * by the corresponding gaps.\r\n     * The correspondence is defined by the specified parameter {@code map}.\r\n     * <p>\r\n     * This method is (typically) called by the engineer object\r\n     * at the beginning of its {@code engineer()} method\r\n     * because at that point all user denotations for the gaps on the scheme\r\n     * are already associated with concrete gaps types by the user.\r\n     */\r\n    public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map) {\r\n        ListIterator<Agent> li = childrenAgents.listIterator();\r\n        Agent child;\r\n        while (li.hasNext()) {\r\n            child = li.next();\r\n            if (child instanceof GroupAgent)\r\n                ((GroupAgent) child).replaceTemporaryGapsByRealGaps(map);\r\n            if (child instanceof TemporaryGapAgent)\r\n                li.set(map.gap((TemporaryGapAgent) child));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *      ,\r\n     *        \r\n     *   {@code ComponentAdder},   \r\n     *   -   {@code GroupCreator}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param parentGroup\t\t,  \r\n     * \t\t\t\t\t\t\t \r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addGroupToGroup(groupContent(creatorAndAdder), settings, parentGroup);\r\n    }\r\n\r\n    /**\r\n     *   ,    .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public abstract Group groupContent(GroupCreatorAndElementAdder creatorAndAdder);\r\n\r\n    /**\r\n     * Returns a class implementing the interface\r\n     * {@code FunctionsOnGroup} (more precisely, its extensions)\r\n     * which allows the end user to possess access\r\n     * to the settings of elements of this group.\r\n     */\r\n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\r\n\r\n    /**\r\n     * This is a base class for two classes\r\n     * which provide the end user by methods\r\n     * of controlling settings of elements of groups\r\n     * and methods of inserting gaps beside elements of groups.\r\n     * <p>\r\n     * For this purpose, this class declares the fields\r\n     * {@code parentGroupAgent} and {@code elementAgent}\r\n     * which specify the group and its element.\r\n     * These fields are then used in methods of this class' extensions.\r\n     * <p>\r\n     * This class also implements methods of inserting non-preferred gaps\r\n     * beside the element {@code parentGroupAgent}\r\n     * of the group {@code elementAgent}.\r\n     *\r\n     * @see\r\n     * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation\r\n     * @see\r\n     * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation\r\n     */\r\n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement {\r\n\r\n        /**\r\n         * A parent group containing some element\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected GroupAgent parentGroupAgent;\r\n\r\n        /**\r\n         * An element in the parent group\r\n         * which settings with respect to the parent group will be changed.\r\n         */\r\n        protected Agent elementAgent;\r\n\r\n        public FunctionsOnGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            this.parentGroupAgent = parent;\r\n            this.elementAgent = element;\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int size) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} before its {@code elementAgent}.\r\n         */\r\n        public void addPrecedingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a rigid gap of the specified size\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int size) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(size), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * Adds a gap of the specified sizes\r\n         * to the {@code parentGroupAgent} after its {@code elementAgent}.\r\n         */\r\n        public void addFollowingGap(int min, int pref, int max) {\r\n            parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list before that element.\r\n     */\r\n    public void addGapBefore(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of this group's children\r\n     * and inserts the specified gap into that list after that element.\r\n     */\r\n    public void addGapAfter(GapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GroupAgentTest7.java",
		"test_prompt": "// GroupAgentTest7.java\npackage glengineer.agents;\n\nimport glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnGroupAndElement;\nimport glengineer.agents.settings.Settings;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupAgent}.\n* It contains ten unit test cases for the {@link GroupAgent#findDependingSequentialGroupByNames(String, String)} method.\n*/\nclass GroupAgentTest7 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest0.java",
		"test_prompt": "// TemporaryGapAgentTest0.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#isComponent(String)} method.\n*/\nclass TemporaryGapAgentTest0 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest1.java",
		"test_prompt": "// TemporaryGapAgentTest1.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#isGroup(String, String)} method.\n*/\nclass TemporaryGapAgentTest1 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest2.java",
		"test_prompt": "// TemporaryGapAgentTest2.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#isGap()} method.\n*/\nclass TemporaryGapAgentTest2 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest3.java",
		"test_prompt": "// TemporaryGapAgentTest3.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#equals(Agent)} method.\n*/\nclass TemporaryGapAgentTest3 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest4.java",
		"test_prompt": "// TemporaryGapAgentTest4.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#findDependingComponentByName(String)} method.\n*/\nclass TemporaryGapAgentTest4 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest5.java",
		"test_prompt": "// TemporaryGapAgentTest5.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#findDependingGroupByNames(String, String)} method.\n*/\nclass TemporaryGapAgentTest5 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest6.java",
		"test_prompt": "// TemporaryGapAgentTest6.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#findDependingParallelGroupByNames(String, String)} method.\n*/\nclass TemporaryGapAgentTest6 {"
	},
	{
		"original_code": "// TemporaryGapAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * Temporary gap agents replace real gap agents\r\n * which names are present on the scheme but are not yet\r\n * associated by the user with concrete types of gaps\r\n * (at the moment of building the hierarchy of agents).\r\n * <p>\r\n * The class {@code TemporaryGapAgent} just encapsulates\r\n * the name of a gap on the scheme\r\n * and implements the method {@code equals()} of comparison\r\n * with other temporary gaps by their names.\r\n * The other abstract methods of the base class {@code Agent}\r\n * are implemented in a trivial manner.\r\n */\r\npublic class TemporaryGapAgent extends Agent {\r\n\r\n    private String gapDenotation;\r\n\r\n    public TemporaryGapAgent(String gapDenotation) {\r\n        this.gapDenotation = gapDenotation;\r\n    }\r\n\r\n    public String getDenotation() {\r\n        return gapDenotation;\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent instanceof TemporaryGapAgent && ((TemporaryGapAgent) agent).gapDenotation.equals(this.gapDenotation);\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public void addContentToGroup(Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        throw new IllegalArgumentException(\"An attempt to add content of a temporary gap.\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"temporary gap \\\"\" + gapDenotation + \"\\\"\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TemporaryGapAgentTest7.java",
		"test_prompt": "// TemporaryGapAgentTest7.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TemporaryGapAgent}.\n* It contains ten unit test cases for the {@link TemporaryGapAgent#findDependingSequentialGroupByNames(String, String)} method.\n*/\nclass TemporaryGapAgentTest7 {"
	},
	{
		"original_code": "// ContainerGapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.*;\r\nimport javax.swing.GroupLayout.*;\r\n\r\n/**\r\n *  \"\",   .\r\n * <p>\r\n *      ,   \r\n *      {@code Agent},\r\n *       ,\r\n *         {@code Agent}.\r\n */\r\npublic class ContainerGapAgent {\r\n\r\n    public ContainerGapSettings settings;\r\n\r\n    public ContainerGapAgent() {\r\n        settings = new ContainerGapSettings();\r\n    }\r\n\r\n    public ContainerGapAgent(int pref, int max) {\r\n        settings = new ContainerGapSettings(pref, max);\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *    \r\n     *       .\r\n     */\r\n    public void addOneselfToGroup(SequentialGroup targetGroup) {\r\n        SpecialGapSizes sizes = settings.sizes;\r\n        if (sizes != null)\r\n            targetGroup.addContainerGap(sizes.pref, sizes.max);\r\n        else\r\n            targetGroup.addContainerGap();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ContainerGapAgentTest.java",
		"test_prompt": "// ContainerGapAgentTest.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport javax.swing.GroupLayout.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ContainerGapAgent}.\n* It contains ten unit test cases for the {@link ContainerGapAgent#isGap()} method.\n*/\nclass ContainerGapAgentTest {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest0.java",
		"test_prompt": "// GapAgentTest0.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#isComponent(String)} method.\n*/\nclass GapAgentTest0 {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest1.java",
		"test_prompt": "// GapAgentTest1.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#isGroup(String, String)} method.\n*/\nclass GapAgentTest1 {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest2.java",
		"test_prompt": "// GapAgentTest2.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#isGap()} method.\n*/\nclass GapAgentTest2 {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest3.java",
		"test_prompt": "// GapAgentTest3.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#equals(Agent)} method.\n*/\nclass GapAgentTest3 {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest4.java",
		"test_prompt": "// GapAgentTest4.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#findDependingComponentByName(String)} method.\n*/\nclass GapAgentTest4 {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest5.java",
		"test_prompt": "// GapAgentTest5.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#findDependingGroupByNames(String, String)} method.\n*/\nclass GapAgentTest5 {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest6.java",
		"test_prompt": "// GapAgentTest6.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#findDependingParallelGroupByNames(String, String)} method.\n*/\nclass GapAgentTest6 {"
	},
	{
		"original_code": "// GapAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.settings.GapSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * ,  .\r\n */\r\npublic class GapAgent extends Agent {\r\n\r\n    public GapAgent() {\r\n        settings = new GapSettings();\r\n    }\r\n\r\n    public GapAgent(Sizes sizes) {\r\n        settings = new GapSettings(sizes);\r\n    }\r\n\r\n    public GapAgent(int size) {\r\n        settings = new GapSettings(size);\r\n    }\r\n\r\n    public GapAgent(int min, int pref, int max) {\r\n        settings = new GapSettings(min, pref, max);\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return null;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return true;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return false;\r\n    }\r\n\r\n    public GapSettings getSettings() {\r\n        return (GapSettings) settings;\r\n    }\r\n\r\n    public ComponentAgent findDependingComponentByName(String name) {\r\n        return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String first, String last) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *    .\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        Sizes sizes = getSettings().sizes;\r\n        targetGroup.addGap(sizes.min, sizes.pref, sizes.max);\r\n    }\r\n\r\n    public void setSizes(int min, int pref, int max) {\r\n        getSettings().sizes = new Sizes(min, pref, max);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"gap \" + getSettings().sizes;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/GapAgentTest7.java",
		"test_prompt": "// GapAgentTest7.java\npackage glengineer.agents;\n\nimport glengineer.agents.settings.GapSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GapAgent}.\n* It contains ten unit test cases for the {@link GapAgent#findDependingSequentialGroupByNames(String, String)} method.\n*/\nclass GapAgentTest7 {"
	},
	{
		"original_code": "// ParallelGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\r\nimport glengineer.agents.settings.ParallelGroupSettings;\r\nimport java.util.Iterator;\r\nimport javax.swing.GroupLayout.Alignment;\r\nimport javax.swing.GroupLayout.ParallelGroup;\r\n\r\n/**\r\n * ,   .\r\n */\r\npublic class ParallelGroupAgent extends GroupAgent {\r\n\r\n    public ParallelGroupAgent() {\r\n        settings = new ParallelGroupSettings();\r\n    }\r\n\r\n    public ParallelGroupSettings getSettings() {\r\n        return (ParallelGroupSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether all of the elements of this parallel group agent\r\n     * are gaps.\r\n     */\r\n    public boolean containsGapsOnly() {\r\n        for (Agent child : childrenAgents) if (!child.isGap())\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes all gaps from this parallel group.\r\n     */\r\n    public void removeAllGaps() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) if (i.next().isGap())\r\n            i.remove();\r\n    }\r\n\r\n    /**\r\n     * Returns the gap of the type contained in this parallel group\r\n     * or null if this group has no gaps.\r\n     * If the gaps possess different types, throws a runtime exception.\r\n     * <p>\r\n     * After calling this method this parallel group,\r\n     * which typically consists of gaps only,\r\n     * can be replaced by the gap returned by this method.\r\n     */\r\n    public Agent getGapsType() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent firstGapFound = null;\r\n        Agent next;\r\n        while (i.hasNext()) {\r\n            next = i.next();\r\n            if (!next.isGap())\r\n                continue;\r\n            if (firstGapFound == null)\r\n                firstGapFound = next;\r\n            else //the first gap has been already found.\r\n            if (next != firstGapFound)\r\n                throw new IllegalArgumentException(\"A parallel group consists of gaps only \" + \"but the gaps have different types.\");\r\n        }\r\n        return firstGapFound;\r\n    }\r\n\r\n    /**\r\n     *       \r\n     *   .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {\r\n        return new FunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {\r\n\r\n        /**\r\n         *      .\r\n         *\r\n         * @param alignment\t \r\n         */\r\n        public void setContentAlignment(Alignment alignment) {\r\n            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;\r\n        }\r\n\r\n        /**\r\n         * Determines the {@code resize} behavior of the {@code ParallelGroup}.\r\n         *\r\n         * @param resizable\t{@code true} if the group is resizable;\r\n         * \t\t\t\t\tif the group is not resizable\r\n         * \t\t\t\t\tthe preferred size is used for\r\n         * \t\t\t\t\tthe minimum and maximum size of the group.\r\n         */\r\n        public void setResizable(boolean resizable) {\r\n            ParallelGroupAgent.this.getSettings().resizable = resizable;\r\n        }\r\n\r\n        /**\r\n         *   \" \"  \r\n         *    .\r\n         * <p>\r\n         *   {@code FunctionsOnParallelGroupAndElement}\r\n         *      .\r\n         *\r\n         * @param componentName\t  \r\n         * @return\t\t\t\t\r\n         * \t\t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t\t  \r\n         */\r\n        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));\r\n        }\r\n\r\n        /**\r\n         *   \" \"  \r\n         *        .\r\n         * <p>\r\n         *   {@code FunctionsOnParallelGroupAndElement}\r\n         *      .\r\n         *\r\n         * @param firstName\t    \r\n         * @param lastName\t    \r\n         * @return\t\t\t\r\n         * \t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t  \r\n         */\r\n        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));\r\n        }\r\n    }\r\n\r\n    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {\r\n\r\n        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            super(parent, element);\r\n        }\r\n\r\n        /**\r\n         * Assigns the specified alignment of the element {@code elementAgent}\r\n         * in the parallel group {@code parentAgent}.\r\n         */\r\n        public void setAlignmentWithinParent(Alignment alignment) {\r\n            elementAgent.settings.alignmentWithRespectToParent = alignment;\r\n        }\r\n    }\r\n\r\n    public String toString() {\r\n        return \"parallel group <\" + getFirstName() + \",\" + getLastName() + \">\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgentTest0.java",
		"test_prompt": "// ParallelGroupAgentTest0.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParallelGroupAgent}.\n* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.\n*/\nclass ParallelGroupAgentTest0 {"
	},
	{
		"original_code": "// ParallelGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\r\nimport glengineer.agents.settings.ParallelGroupSettings;\r\nimport java.util.Iterator;\r\nimport javax.swing.GroupLayout.Alignment;\r\nimport javax.swing.GroupLayout.ParallelGroup;\r\n\r\n/**\r\n * ,   .\r\n */\r\npublic class ParallelGroupAgent extends GroupAgent {\r\n\r\n    public ParallelGroupAgent() {\r\n        settings = new ParallelGroupSettings();\r\n    }\r\n\r\n    public ParallelGroupSettings getSettings() {\r\n        return (ParallelGroupSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether all of the elements of this parallel group agent\r\n     * are gaps.\r\n     */\r\n    public boolean containsGapsOnly() {\r\n        for (Agent child : childrenAgents) if (!child.isGap())\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes all gaps from this parallel group.\r\n     */\r\n    public void removeAllGaps() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        while (i.hasNext()) if (i.next().isGap())\r\n            i.remove();\r\n    }\r\n\r\n    /**\r\n     * Returns the gap of the type contained in this parallel group\r\n     * or null if this group has no gaps.\r\n     * If the gaps possess different types, throws a runtime exception.\r\n     * <p>\r\n     * After calling this method this parallel group,\r\n     * which typically consists of gaps only,\r\n     * can be replaced by the gap returned by this method.\r\n     */\r\n    public Agent getGapsType() {\r\n        Iterator<Agent> i = childrenAgents.iterator();\r\n        Agent firstGapFound = null;\r\n        Agent next;\r\n        while (i.hasNext()) {\r\n            next = i.next();\r\n            if (!next.isGap())\r\n                continue;\r\n            if (firstGapFound == null)\r\n                firstGapFound = next;\r\n            else //the first gap has been already found.\r\n            if (next != firstGapFound)\r\n                throw new IllegalArgumentException(\"A parallel group consists of gaps only \" + \"but the gaps have different types.\");\r\n        }\r\n        return firstGapFound;\r\n    }\r\n\r\n    /**\r\n     *       \r\n     *   .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {\r\n        return new FunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {\r\n\r\n        /**\r\n         *      .\r\n         *\r\n         * @param alignment\t \r\n         */\r\n        public void setContentAlignment(Alignment alignment) {\r\n            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;\r\n        }\r\n\r\n        /**\r\n         * Determines the {@code resize} behavior of the {@code ParallelGroup}.\r\n         *\r\n         * @param resizable\t{@code true} if the group is resizable;\r\n         * \t\t\t\t\tif the group is not resizable\r\n         * \t\t\t\t\tthe preferred size is used for\r\n         * \t\t\t\t\tthe minimum and maximum size of the group.\r\n         */\r\n        public void setResizable(boolean resizable) {\r\n            ParallelGroupAgent.this.getSettings().resizable = resizable;\r\n        }\r\n\r\n        /**\r\n         *   \" \"  \r\n         *    .\r\n         * <p>\r\n         *   {@code FunctionsOnParallelGroupAndElement}\r\n         *      .\r\n         *\r\n         * @param componentName\t  \r\n         * @return\t\t\t\t\r\n         * \t\t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t\t  \r\n         */\r\n        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));\r\n        }\r\n\r\n        /**\r\n         *   \" \"  \r\n         *        .\r\n         * <p>\r\n         *   {@code FunctionsOnParallelGroupAndElement}\r\n         *      .\r\n         *\r\n         * @param firstName\t    \r\n         * @param lastName\t    \r\n         * @return\t\t\t\r\n         * \t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t  \r\n         */\r\n        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));\r\n        }\r\n    }\r\n\r\n    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {\r\n\r\n        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            super(parent, element);\r\n        }\r\n\r\n        /**\r\n         * Assigns the specified alignment of the element {@code elementAgent}\r\n         * in the parallel group {@code parentAgent}.\r\n         */\r\n        public void setAlignmentWithinParent(Alignment alignment) {\r\n            elementAgent.settings.alignmentWithRespectToParent = alignment;\r\n        }\r\n    }\r\n\r\n    public String toString() {\r\n        return \"parallel group <\" + getFirstName() + \",\" + getLastName() + \">\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgentTest1.java",
		"test_prompt": "// ParallelGroupAgentTest1.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParallelGroupAgent}.\n* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass ParallelGroupAgentTest1 {"
	},
	{
		"original_code": "// SequentialGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport java.util.ListIterator;\r\nimport glengineer.agents.setters.*;\r\nimport javax.swing.GroupLayout;\r\nimport javax.swing.LayoutStyle;\r\nimport javax.swing.GroupLayout.*;\r\n\r\n/**\r\n * ,   .\r\n */\r\npublic class SequentialGroupAgent extends GroupAgent {\r\n\r\n    /**\r\n     *       \r\n     *   .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        SequentialGroup result = creatorAndAdder.createSequentialGroup();\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnSequentialGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {\r\n        return new FunctionsOnSequentialGroupImplemenation();\r\n    }\r\n\r\n    protected class FunctionsOnSequentialGroupImplemenation implements FunctionsOnSequentialGroup {\r\n\r\n        public FunctionsOnSequentialGroupAndElement getComponent(String name) {\r\n            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getComponent(name));\r\n        }\r\n\r\n        public FunctionsOnSequentialGroupAndElement getGroup(String firstName, String lastName) {\r\n            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getGroup(firstName, lastName));\r\n        }\r\n    }\r\n\r\n    private static class FunctionsOnSequentialGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnSequentialGroupAndElement {\r\n\r\n        public FunctionsOnSequentialGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            super(parent, element);\r\n        }\r\n\r\n        private SequentialGroupAgent getParentGroupAgent() {\r\n            return (SequentialGroupAgent) parentGroupAgent;\r\n        }\r\n\r\n        /**\r\n         *     \r\n         *  \"\" .\r\n         */\r\n        public void addPrecedingRelatedGap() {\r\n            addPrecedingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         *     \r\n         *  \"\" .\r\n         */\r\n        public void addPrecedingUnrelatedGap() {\r\n            addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         *     \r\n         *  \"\" .\r\n         */\r\n        public void addFollowingRelatedGap() {\r\n            addFollowingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         *     \r\n         *  \"\" .\r\n         */\r\n        public void addFollowingUnrelatedGap() {\r\n            addFollowingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         *       \r\n         *  \"\"      \r\n         *     .\r\n         */\r\n        public void addPrecedingRelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         *       \r\n         *  \"\"      \r\n         *     .\r\n         */\r\n        public void addPrecedingUnrelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         *       \r\n         *  \"\"      \r\n         *     .\r\n         */\r\n        public void addFollowingRelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         *       \r\n         *  \"\"      \r\n         *     .\r\n         */\r\n        public void addFollowingUnrelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of\r\n     * this sequential group's children and inserts\r\n     * the specified preferred gap into that list before that element.\r\n     */\r\n    public void addPreferredGapBefore(PreferredGapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of\r\n     * this sequential group's children and inserts\r\n     * the specified preferred gap into that list after that element.\r\n     */\r\n    public void addPreferredGapAfter(PreferredGapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator<Agent> iter = childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"sequential group <\" + getFirstName() + \",\" + getLastName() + \">\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgentTest.java",
		"test_prompt": "// SequentialGroupAgentTest.java\npackage glengineer.agents;\n\nimport java.util.ListIterator;\nimport glengineer.agents.setters.*;\nimport javax.swing.GroupLayout;\nimport javax.swing.LayoutStyle;\nimport javax.swing.GroupLayout.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SequentialGroupAgent}.\n* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass SequentialGroupAgentTest {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest0.java",
		"test_prompt": "// ComponentAgentTest0.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#isComponent(String)} method.\n*/\nclass ComponentAgentTest0 {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest1.java",
		"test_prompt": "// ComponentAgentTest1.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#isGroup(String, String)} method.\n*/\nclass ComponentAgentTest1 {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest2.java",
		"test_prompt": "// ComponentAgentTest2.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#isGap()} method.\n*/\nclass ComponentAgentTest2 {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest3.java",
		"test_prompt": "// ComponentAgentTest3.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#equals(Agent)} method.\n*/\nclass ComponentAgentTest3 {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest4.java",
		"test_prompt": "// ComponentAgentTest4.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#findDependingComponentByName(String)} method.\n*/\nclass ComponentAgentTest4 {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest5.java",
		"test_prompt": "// ComponentAgentTest5.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#findDependingGroupByNames(String, String)} method.\n*/\nclass ComponentAgentTest5 {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest6.java",
		"test_prompt": "// ComponentAgentTest6.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#findDependingParallelGroupByNames(String, String)} method.\n*/\nclass ComponentAgentTest6 {"
	},
	{
		"original_code": "// ComponentAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnComponent;\r\nimport glengineer.agents.settings.ComponentSettings;\r\nimport glengineer.agents.settings.Sizes;\r\nimport javax.swing.GroupLayout.Group;\r\n\r\n/**\r\n * The agent representing a component.\r\n */\r\npublic class ComponentAgent extends Agent {\r\n\r\n    private String componentName;\r\n\r\n    public ComponentAgent(String componentName) {\r\n        this.componentName = componentName;\r\n        settings = new ComponentSettings();\r\n    }\r\n\r\n    public String getFirstName() {\r\n        return componentName;\r\n    }\r\n\r\n    public String getLastName() {\r\n        return componentName;\r\n    }\r\n\r\n    public boolean isComponent(String componentName) {\r\n        return this.componentName.equals(componentName);\r\n    }\r\n\r\n    public boolean isGroup(String firstName, String lastName) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isGap() {\r\n        return false;\r\n    }\r\n\r\n    public boolean equals(Agent agent) {\r\n        return agent.isComponent(componentName);\r\n    }\r\n\r\n    private ComponentSettings getSettings() {\r\n        return (ComponentSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Returns this component agent if its name equals the specified one\r\n     * or null if it is not the case.\r\n     */\r\n    public ComponentAgent findDependingComponentByName(String componentName) {\r\n        if (isComponent(componentName))\r\n            return this;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *     , \r\n     *     .\r\n     *        \r\n     *    {@code ComponentAdder}.\r\n     * <p>\r\n     *  -.\r\n     *\r\n     * @param targetGroup\t\t,   \r\n     * \t\t\t\t\t\t\t\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     */\r\n    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {\r\n        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());\r\n    }\r\n\r\n    /**\r\n     * Returns a class implementing the interface {@code FunctionsOnComponent}\r\n     * which allows the user to control the sizes of this component.\r\n     */\r\n    public FunctionsOnComponent getFunctionsOnComponentImplementation() {\r\n        return new FunctionsOnComponent() {\r\n\r\n            public void setSize(int size) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(size);\r\n            }\r\n\r\n            public void setSize(int min, int pref, int max) {\r\n                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);\r\n            }\r\n        };\r\n    }\r\n\r\n    public String toString() {\r\n        return \"component \" + componentName;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgentTest7.java",
		"test_prompt": "// ComponentAgentTest7.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnComponent;\nimport glengineer.agents.settings.ComponentSettings;\nimport glengineer.agents.settings.Sizes;\nimport javax.swing.GroupLayout.Group;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComponentAgent}.\n* It contains ten unit test cases for the {@link ComponentAgent#findDependingSequentialGroupByNames(String, String)} method.\n*/\nclass ComponentAgentTest7 {"
	},
	{
		"original_code": "// TopSequentialGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.SequentialGroup;\r\nimport glengineer.agents.setters.*;\r\n\r\n/**\r\n * ,     .\r\n * <p>\r\n *   {@code FunctionsOnTopSequentialGroup}\r\n *    \r\n *         .\r\n */\r\npublic class TopSequentialGroupAgent extends SequentialGroupAgent {\r\n\r\n    /**\r\n     * ,      .\r\n     */\r\n    private ContainerGapAgent precedingContainerGap;\r\n\r\n    /**\r\n     * ,      .\r\n     */\r\n    private ContainerGapAgent followingContainerGap;\r\n\r\n    /**\r\n     *       ,\r\n     * ,  ,       ,\r\n     *    .\r\n     * <p>\r\n     *   {@code TopSequentialGroupAgent.groupContent()},\r\n     *     .\r\n     *\r\n     * @param creatorAndAdder\t   \r\n     * \t\t\t\t\t\t\t    \r\n     * @return\t\t\t\t\t,   \r\n     * \t\t\t\t\t\t\t.\r\n     */\r\n    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        SequentialGroup result = creatorAndAdder.createSequentialGroup();\r\n        if (precedingContainerGap != null)\r\n            precedingContainerGap.addOneselfToGroup(result);\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        if (followingContainerGap != null)\r\n            followingContainerGap.addOneselfToGroup(result);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnTopSequentialGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {\r\n        return getFunctionsOnTopSequentialGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnTopSequentialGroup getFunctionsOnTopSequentialGroupImplemenation() {\r\n        return new FunctionsOnTopSequentialGroupImplemenation();\r\n    }\r\n\r\n    private class FunctionsOnTopSequentialGroupImplemenation extends SequentialGroupAgent.FunctionsOnSequentialGroupImplemenation implements FunctionsOnTopSequentialGroup {\r\n\r\n        /**\r\n         *   \r\n         *      .\r\n         */\r\n        public void addPrecedingContainerGap() {\r\n            precedingContainerGap = new ContainerGapAgent();\r\n        }\r\n\r\n        /**\r\n         *       \r\n         *      .\r\n         */\r\n        public void addPrecedingContainerGap(int pref, int max) {\r\n            precedingContainerGap = new ContainerGapAgent(pref, max);\r\n        }\r\n\r\n        /**\r\n         *   \r\n         *      .\r\n         */\r\n        public void addFollowingContainerGap() {\r\n            followingContainerGap = new ContainerGapAgent();\r\n        }\r\n\r\n        /**\r\n         *       \r\n         *      .\r\n         */\r\n        public void addFollowingContainerGap(int pref, int max) {\r\n            followingContainerGap = new ContainerGapAgent(pref, max);\r\n        }\r\n\r\n        public void addBothContainerGaps() {\r\n            addPrecedingContainerGap();\r\n            addFollowingContainerGap();\r\n        }\r\n\r\n        public void addBothContainerGaps(int pref, int max) {\r\n            addPrecedingContainerGap(pref, max);\r\n            addFollowingContainerGap(pref, max);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgentTest.java",
		"test_prompt": "// TopSequentialGroupAgentTest.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.SequentialGroup;\nimport glengineer.agents.setters.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TopSequentialGroupAgent}.\n* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass TopSequentialGroupAgentTest {"
	},
	{
		"original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable<VWordPosition> {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 > y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x = x;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp = (VWordPosition) wp;\r\n        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 >= y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x == this.x && y1 <= y && y < y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx = vLine.x;\r\n        if (x < xx)\r\n            return -1;\r\n        else if (x == xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPositionTest0.java",
		"test_prompt": "// VWordPositionTest0.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#equals(WordPosition)} method.\n*/\nclass VWordPositionTest0 {"
	},
	{
		"original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable<VWordPosition> {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 > y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x = x;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp = (VWordPosition) wp;\r\n        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 >= y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x == this.x && y1 <= y && y < y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx = vLine.x;\r\n        if (x < xx)\r\n            return -1;\r\n        else if (x == xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPositionTest1.java",
		"test_prompt": "// VWordPositionTest1.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#isTrivial()} method.\n*/\nclass VWordPositionTest1 {"
	},
	{
		"original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable<VWordPosition> {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 > y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x = x;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp = (VWordPosition) wp;\r\n        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 >= y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x == this.x && y1 <= y && y < y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx = vLine.x;\r\n        if (x < xx)\r\n            return -1;\r\n        else if (x == xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPositionTest2.java",
		"test_prompt": "// VWordPositionTest2.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#contains(int, int)} method.\n*/\nclass VWordPositionTest2 {"
	},
	{
		"original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable<VWordPosition> {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 > y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x = x;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp = (VWordPosition) wp;\r\n        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 >= y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x == this.x && y1 <= y && y < y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx = vLine.x;\r\n        if (x < xx)\r\n            return -1;\r\n        else if (x == xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPositionTest3.java",
		"test_prompt": "// VWordPositionTest3.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#liesIn(CharTable)} method.\n*/\nclass VWordPositionTest3 {"
	},
	{
		"original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable<VWordPosition> {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 > y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x = x;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp = (VWordPosition) wp;\r\n        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 >= y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x == this.x && y1 <= y && y < y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx = vLine.x;\r\n        if (x < xx)\r\n            return -1;\r\n        else if (x == xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPositionTest4.java",
		"test_prompt": "// VWordPositionTest4.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#intersects(CharTable)} method.\n*/\nclass VWordPositionTest4 {"
	},
	{
		"original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable<VWordPosition> {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 > y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x = x;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp = (VWordPosition) wp;\r\n        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 >= y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x == this.x && y1 <= y && y < y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx = vLine.x;\r\n        if (x < xx)\r\n            return -1;\r\n        else if (x == xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPositionTest5.java",
		"test_prompt": "// VWordPositionTest5.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#compareTo(VWordPosition)} method.\n*/\nclass VWordPositionTest5 {"
	},
	{
		"original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable<VWordPosition> {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 > y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x = x;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp = (VWordPosition) wp;\r\n        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 >= y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x == this.x && y1 <= y && y < y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx = vLine.x;\r\n        if (x < xx)\r\n            return -1;\r\n        else if (x == xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPositionTest6.java",
		"test_prompt": "// VWordPositionTest6.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.\n*/\nclass VWordPositionTest6 {"
	},
	{
		"original_code": "// CharPosition.java\npackage glengineer.positions;\r\n\r\n/**\r\n * ,   \r\n *       .\r\n */\r\npublic class CharPosition {\r\n\r\n    public final int x, y;\r\n\r\n    public CharPosition(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public boolean equals(CharPosition p) {\r\n        return x == p.x && y == p.y;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"(\" + x + \",\" + y + \")\";\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/CharPositionTest.java",
		"test_prompt": "// CharPositionTest.java\npackage glengineer.positions;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CharPosition}.\n* It contains ten unit test cases for the {@link CharPosition#equals(CharPosition)} method.\n*/\nclass CharPositionTest {"
	},
	{
		"original_code": "// WordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * An abstract class for horizontal and vertical words positions.\r\n */\r\npublic abstract class WordPosition {\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public abstract CharPosition1 getStart();\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public abstract CharPosition2 getEnd();\r\n\r\n    public abstract boolean equals(WordPosition wp);\r\n\r\n    public abstract boolean isTrivial();\r\n\r\n    public abstract boolean contains(int x, int y);\r\n\r\n    public boolean contains(CharPosition pos) {\r\n        return contains(pos.x, pos.y);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position lies\r\n     * inside of the specified char table.\r\n     */\r\n    public abstract boolean liesIn(CharTable ct);\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public abstract boolean intersects(CharTable ct);\r\n\r\n    /**\r\n     * Returns the length (width or height)\r\n     * of the intersection of this line with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public abstract int getLengthInsideOf(Block block);\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public abstract String textAt(CharTable ct);\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/WordPositionTest.java",
		"test_prompt": "// WordPositionTest.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WordPosition}.\n* It contains ten unit test cases for the {@link WordPosition#contains(CharPosition)} method.\n*/\nclass WordPositionTest {"
	},
	{
		"original_code": "// HWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying horizontally on the scheme.\r\n */\r\npublic class HWordPosition extends WordPosition {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word start.\r\n     */\r\n    public final int x1;\r\n\r\n    /**\r\n     * The horizontal coordinate of the word end + 1.\r\n     */\r\n    public final int x2;\r\n\r\n    /**\r\n     * The vertical coordinate of the word.\r\n     */\r\n    public final int y;\r\n\r\n    public HWordPosition(int x1, int x2, int y) {\r\n        if (x1 > x2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x1 = x1;\r\n        this.x2 = x2;\r\n        this.y = y;\r\n    }\r\n\r\n    public HWordPosition(CharPosition start, int x2) {\r\n        this(start.x, x2, start.y);\r\n    }\r\n\r\n    public HWordPosition(int x1, CharPosition end) {\r\n        this(x1, end.x, end.y);\r\n    }\r\n\r\n    /**\r\n     * The word position is initialized\r\n     * representing the upper line of the specified block.\r\n     */\r\n    public HWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public HWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.x, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x1, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x2, y);\r\n    }\r\n\r\n    public int getWidth() {\r\n        return x2 - x1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof HWordPosition))\r\n            return false;\r\n        HWordPosition hwp = (HWordPosition) wp;\r\n        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return x1 >= x2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return y == this.y && x1 <= x && x < x2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);\r\n        return Math.max(width, 0);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"horizontal(\" + x1 + \",\" + x2 + \";\" + y + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPositionTest0.java",
		"test_prompt": "// HWordPositionTest0.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#equals(WordPosition)} method.\n*/\nclass HWordPositionTest0 {"
	},
	{
		"original_code": "// HWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying horizontally on the scheme.\r\n */\r\npublic class HWordPosition extends WordPosition {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word start.\r\n     */\r\n    public final int x1;\r\n\r\n    /**\r\n     * The horizontal coordinate of the word end + 1.\r\n     */\r\n    public final int x2;\r\n\r\n    /**\r\n     * The vertical coordinate of the word.\r\n     */\r\n    public final int y;\r\n\r\n    public HWordPosition(int x1, int x2, int y) {\r\n        if (x1 > x2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x1 = x1;\r\n        this.x2 = x2;\r\n        this.y = y;\r\n    }\r\n\r\n    public HWordPosition(CharPosition start, int x2) {\r\n        this(start.x, x2, start.y);\r\n    }\r\n\r\n    public HWordPosition(int x1, CharPosition end) {\r\n        this(x1, end.x, end.y);\r\n    }\r\n\r\n    /**\r\n     * The word position is initialized\r\n     * representing the upper line of the specified block.\r\n     */\r\n    public HWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public HWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.x, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x1, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x2, y);\r\n    }\r\n\r\n    public int getWidth() {\r\n        return x2 - x1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof HWordPosition))\r\n            return false;\r\n        HWordPosition hwp = (HWordPosition) wp;\r\n        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return x1 >= x2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return y == this.y && x1 <= x && x < x2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);\r\n        return Math.max(width, 0);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"horizontal(\" + x1 + \",\" + x2 + \";\" + y + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPositionTest1.java",
		"test_prompt": "// HWordPositionTest1.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#isTrivial()} method.\n*/\nclass HWordPositionTest1 {"
	},
	{
		"original_code": "// HWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying horizontally on the scheme.\r\n */\r\npublic class HWordPosition extends WordPosition {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word start.\r\n     */\r\n    public final int x1;\r\n\r\n    /**\r\n     * The horizontal coordinate of the word end + 1.\r\n     */\r\n    public final int x2;\r\n\r\n    /**\r\n     * The vertical coordinate of the word.\r\n     */\r\n    public final int y;\r\n\r\n    public HWordPosition(int x1, int x2, int y) {\r\n        if (x1 > x2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x1 = x1;\r\n        this.x2 = x2;\r\n        this.y = y;\r\n    }\r\n\r\n    public HWordPosition(CharPosition start, int x2) {\r\n        this(start.x, x2, start.y);\r\n    }\r\n\r\n    public HWordPosition(int x1, CharPosition end) {\r\n        this(x1, end.x, end.y);\r\n    }\r\n\r\n    /**\r\n     * The word position is initialized\r\n     * representing the upper line of the specified block.\r\n     */\r\n    public HWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public HWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.x, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x1, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x2, y);\r\n    }\r\n\r\n    public int getWidth() {\r\n        return x2 - x1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof HWordPosition))\r\n            return false;\r\n        HWordPosition hwp = (HWordPosition) wp;\r\n        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return x1 >= x2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return y == this.y && x1 <= x && x < x2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);\r\n        return Math.max(width, 0);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"horizontal(\" + x1 + \",\" + x2 + \";\" + y + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPositionTest2.java",
		"test_prompt": "// HWordPositionTest2.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#contains(int, int)} method.\n*/\nclass HWordPositionTest2 {"
	},
	{
		"original_code": "// HWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying horizontally on the scheme.\r\n */\r\npublic class HWordPosition extends WordPosition {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word start.\r\n     */\r\n    public final int x1;\r\n\r\n    /**\r\n     * The horizontal coordinate of the word end + 1.\r\n     */\r\n    public final int x2;\r\n\r\n    /**\r\n     * The vertical coordinate of the word.\r\n     */\r\n    public final int y;\r\n\r\n    public HWordPosition(int x1, int x2, int y) {\r\n        if (x1 > x2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x1 = x1;\r\n        this.x2 = x2;\r\n        this.y = y;\r\n    }\r\n\r\n    public HWordPosition(CharPosition start, int x2) {\r\n        this(start.x, x2, start.y);\r\n    }\r\n\r\n    public HWordPosition(int x1, CharPosition end) {\r\n        this(x1, end.x, end.y);\r\n    }\r\n\r\n    /**\r\n     * The word position is initialized\r\n     * representing the upper line of the specified block.\r\n     */\r\n    public HWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public HWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.x, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x1, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x2, y);\r\n    }\r\n\r\n    public int getWidth() {\r\n        return x2 - x1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof HWordPosition))\r\n            return false;\r\n        HWordPosition hwp = (HWordPosition) wp;\r\n        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return x1 >= x2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return y == this.y && x1 <= x && x < x2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);\r\n        return Math.max(width, 0);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"horizontal(\" + x1 + \",\" + x2 + \";\" + y + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPositionTest3.java",
		"test_prompt": "// HWordPositionTest3.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#liesIn(CharTable)} method.\n*/\nclass HWordPositionTest3 {"
	},
	{
		"original_code": "// HWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying horizontally on the scheme.\r\n */\r\npublic class HWordPosition extends WordPosition {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word start.\r\n     */\r\n    public final int x1;\r\n\r\n    /**\r\n     * The horizontal coordinate of the word end + 1.\r\n     */\r\n    public final int x2;\r\n\r\n    /**\r\n     * The vertical coordinate of the word.\r\n     */\r\n    public final int y;\r\n\r\n    public HWordPosition(int x1, int x2, int y) {\r\n        if (x1 > x2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x1 = x1;\r\n        this.x2 = x2;\r\n        this.y = y;\r\n    }\r\n\r\n    public HWordPosition(CharPosition start, int x2) {\r\n        this(start.x, x2, start.y);\r\n    }\r\n\r\n    public HWordPosition(int x1, CharPosition end) {\r\n        this(x1, end.x, end.y);\r\n    }\r\n\r\n    /**\r\n     * The word position is initialized\r\n     * representing the upper line of the specified block.\r\n     */\r\n    public HWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public HWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.x, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x1, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x2, y);\r\n    }\r\n\r\n    public int getWidth() {\r\n        return x2 - x1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof HWordPosition))\r\n            return false;\r\n        HWordPosition hwp = (HWordPosition) wp;\r\n        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return x1 >= x2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return y == this.y && x1 <= x && x < x2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);\r\n        return Math.max(width, 0);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"horizontal(\" + x1 + \",\" + x2 + \";\" + y + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPositionTest4.java",
		"test_prompt": "// HWordPositionTest4.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#intersects(CharTable)} method.\n*/\nclass HWordPositionTest4 {"
	},
	{
		"original_code": "// HWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying horizontally on the scheme.\r\n */\r\npublic class HWordPosition extends WordPosition {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word start.\r\n     */\r\n    public final int x1;\r\n\r\n    /**\r\n     * The horizontal coordinate of the word end + 1.\r\n     */\r\n    public final int x2;\r\n\r\n    /**\r\n     * The vertical coordinate of the word.\r\n     */\r\n    public final int y;\r\n\r\n    public HWordPosition(int x1, int x2, int y) {\r\n        if (x1 > x2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x1 = x1;\r\n        this.x2 = x2;\r\n        this.y = y;\r\n    }\r\n\r\n    public HWordPosition(CharPosition start, int x2) {\r\n        this(start.x, x2, start.y);\r\n    }\r\n\r\n    public HWordPosition(int x1, CharPosition end) {\r\n        this(x1, end.x, end.y);\r\n    }\r\n\r\n    /**\r\n     * The word position is initialized\r\n     * representing the upper line of the specified block.\r\n     */\r\n    public HWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public HWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.x, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x1, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x2, y);\r\n    }\r\n\r\n    public int getWidth() {\r\n        return x2 - x1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof HWordPosition))\r\n            return false;\r\n        HWordPosition hwp = (HWordPosition) wp;\r\n        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return x1 >= x2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return y == this.y && x1 <= x && x < x2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the intersection of this line\r\n     * with the specified block\r\n     * or <code>0</code> if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);\r\n        return Math.max(width, 0);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"horizontal(\" + x1 + \",\" + x2 + \";\" + y + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPositionTest5.java",
		"test_prompt": "// HWordPositionTest5.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.\n*/\nclass HWordPositionTest5 {"
	}
]