[
	{
		"original_code": "// JVCGenerator.java\npackage com.pmdesigns.jvc.tools;\n\nimport java.io.*;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * Generate the a working web application (the view and controller part) based\n * on a set view templates.\n */\npublic class JVCGenerator {\n\n    // break into this comment into two lines so that this file doesnt get deleted by 'realclean'\n    public static final String MACHINE_GENERATED_1 = \"/* This is a machine generated file.\";\n\n    public static final String MACHINE_GENERATED_2 = \" DO NOT EDIT. */\";\n\n    public static final String GENERATOR_METHOD_NAME = \"genPage\";\n\n    public static final String TEMPLATE_SUFFIX = \".jhtml\";\n\n    private File docRoot;\n\n    private File srcRoot;\n\n    private File srcDir;\n\n    private String pkgPrefix;\n\n    private boolean force;\n\n    private boolean debug;\n\n    private Map<String, Class> generators;\n\n    private static final String[] genNames = { \"Application\", \"BaseController\", \"BaseGenerator\", \"Helpers\", \"LocalBaseController\", \"PageController\", \"PageGenerator\" };\n\n    public static void usage() {\n        System.err.println(\"args   : <template root dir> <src root dir> [<package prefix>] [-force] [-debug]\");\n        System.err.println(\"example: ./templates ./src com.pmdesigns -debug\");\n    }\n\n    public static void main(String[] args) {\n        if (args.length < 2 || args.length > 5) {\n            System.err.println(\"Wrong number of args\");\n            usage();\n            return;\n        }\n        JVCGenerator generator = new JVCGenerator();\n        generator.docRoot = new File(args[0]);\n        generator.srcRoot = new File(args[1]);\n        generator.pkgPrefix = \"\";\n        generator.force = false;\n        generator.debug = false;\n        if (args.length > 2) {\n            for (int i = args.length; i-- > 2; ) {\n                if (\"-debug\".equals(args[i])) {\n                    generator.debug = true;\n                } else if (\"-force\".equals(args[i])) {\n                    generator.force = true;\n                } else {\n                    generator.pkgPrefix = args[i];\n                }\n            }\n        }\n        try {\n            generator.generate();\n        } catch (InvocationTargetException e) {\n            // unwrap invocation target exception if possible\n            Throwable t = e.getTargetException();\n            if (t == null)\n                t = e;\n            System.err.println(\"Invocation error: \" + t.getMessage());\n            if (generator.debug) {\n                t.printStackTrace();\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            if (generator.debug) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void generate() throws Exception {\n        if (!docRoot.isDirectory()) {\n            throw new FileNotFoundException(\"Template root directory '\" + docRoot + \"' doesn't exist.\");\n        }\n        // get bootstrap generator classes\n        generators = new HashMap<String, Class>();\n        for (String name : genNames) {\n            String className = \"com.pmdesigns.jvc.tools.bootstrap.\" + name + \"Generator\";\n            generators.put(name, Class.forName(className));\n        }\n        // always ends with '/'\n        String relPath = File.separator;\n        srcDir = new File(srcRoot, pkgPrefix.replace('.', File.separatorChar));\n        // create view generators and controllers corresponding to the view templates\n        walkDir(docRoot, relPath);\n        // create an Application class, if necessary.\n        File f = new File(srcDir, \"Application.java\");\n        if (!f.exists()) {\n            makeClass(\"Application\", relPath, \"Application\", \"\", null, null, f);\n        }\n        // create BaseGenerator class, if necessary\n        f = new File(srcDir, \"generators/BaseGenerator.java\");\n        if (force || !f.exists()) {\n            makeClass(\"BaseGenerator\", relPath + \"generators/\", \"BaseGenerator\", \"Generators\", null, null, f);\n        }\n        // create BaseController class, if necessary\n        f = new File(srcDir, \"controllers/BaseController.java\");\n        if (!f.exists()) {\n            makeClass(\"BaseController\", relPath + \"controllers/\", \"BaseController\", \"Controllers\", null, null, f);\n        }\n        // create a Helpers class, if necessary.\n        // (putting in utils directory so that things work without a package prefix, hmm)\n        f = new File(srcDir, \"utils/Helpers.java\");\n        if (!f.exists()) {\n            makeClass(\"Helpers\", relPath, \"Helpers\", \"Utils\", null, null, f);\n        }\n    }\n\n    private void walkDir(File templateDir, String relPath) throws Exception {\n        makeGeneratorsAndControllers(templateDir, relPath);\n        for (File f : templateDir.listFiles()) {\n            if (f.isDirectory()) {\n                String name = f.getName();\n                walkDir(new File(templateDir, name), relPath + name + File.separatorChar);\n            }\n        }\n    }\n\n    private void makeGeneratorsAndControllers(File templateDir, String relPath) throws Exception {\n        TreeSet<String> imports = new TreeSet<String>();\n        boolean atRoot = (relPath.length() == 1);\n        String DirName = (atRoot ? \"\" : capitalize(templateDir.getName()));\n        boolean hasTemplates = false;\n        File outFile;\n        for (File f : templateDir.listFiles()) {\n            if (!isTemplate(f))\n                continue;\n            hasTemplates = true;\n            // parse template and convert to page generator\n            String name = f.getName();\n            name = name.substring(0, name.length() - TEMPLATE_SUFFIX.length());\n            String Name = capitalize(name);\n            outFile = new File(new File(srcDir, \"generators\" + relPath), Name + \"Generator.java\");\n            // check if the generator is out of date\n            if (!force && outFile.exists() && outFile.lastModified() >= f.lastModified()) {\n                continue;\n            }\n            // parse the view template\n            imports.clear();\n            JVCParser parser = new JVCParser(f.getAbsolutePath(), imports, debug);\n            String body = parser.parse();\n            // and finally make the generator\n            makeClass(\"PageGenerator\", relPath, Name, DirName, imports, body, outFile);\n            // create an empty controller for this page (unless one already exists)\n            outFile = new File(new File(srcDir, \"controllers\" + relPath), Name + \"Controller.java\");\n            if (outFile.exists()) {\n                System.out.println(\"Controller exists, NOT overwriting:\\n    \" + outFile);\n            } else {\n                makeClass(\"PageController\", relPath, Name, DirName, null, null, outFile);\n            }\n        }\n        // don't create 'local' base controller unless there are templates in this directory\n        // and we're not at the root (the 'global' base controller goes there)\n        if (hasTemplates && !atRoot) {\n            outFile = new File(new File(srcDir, \"controllers\" + relPath), \"Base\" + DirName + \"Controller.java\");\n            if (outFile.exists()) {\n                System.out.println(\"Controller exists, NOT overwriting:\\n    \" + outFile);\n            } else {\n                makeClass(\"LocalBaseController\", relPath, DirName, DirName, null, null, outFile);\n            }\n        }\n    }\n\n    private void makeClass(String generatorName, String relPath, String name, String dirName, Set<String> imports, String body, File outFile) throws Exception {\n        // build the parameter map, templates expect the following keys:\n        // map.get(\"machine.generated\")\n        // map.get(\"package.prefix\")\n        // map.get(\"package.prefix.dot\")\n        // map.get(\"dot.relative.package\")\n        // map.get(\"page.name\")\n        // map.get(\"dir.name\")\n        // map.get(\"imports\")\n        // map.get(\"page.body\")\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"machine.generated\", MACHINE_GENERATED_1 + MACHINE_GENERATED_2);\n        if (pkgPrefix.length() > 0) {\n            map.put(\"package.prefix\", pkgPrefix);\n            map.put(\"package.prefix.dot\", pkgPrefix + \".\");\n        } else {\n            map.put(\"package.prefix\", \"\");\n            map.put(\"package.prefix.dot\", \"\");\n        }\n        if (relPath.length() > 1) {\n            String relPkg = relPath.substring(0, relPath.length() - 1).replace(File.separatorChar, '.');\n            map.put(\"dot.relative.package\", relPkg);\n        } else {\n            map.put(\"dot.relative.package\", \"\");\n        }\n        map.put(\"page.name\", name);\n        map.put(\"dir.name\", dirName);\n        map.put(\"page.body\", body);\n        if (imports != null) {\n            StringBuilder sb = new StringBuilder();\n            for (String imp : imports) {\n                sb.append(\"import \").append(imp).append(\";\\n\");\n            }\n            map.put(\"imports\", sb.toString());\n        } else {\n            map.put(\"imports\", \"\");\n        }\n        // generate the file, finally!\n        Class generator = generators.get(generatorName);\n        Class[] args = { Class.forName(\"java.util.Map\") };\n        Method meth = generator.getMethod(GENERATOR_METHOD_NAME, args);\n        String s = (String) meth.invoke(null, map);\n        // write to output file\n        File parent = outFile.getParentFile();\n        if (!parent.exists())\n            parent.mkdirs();\n        PrintWriter pw = new PrintWriter(outFile);\n        pw.println(s);\n        pw.close();\n        System.out.println(\"wrote: \" + outFile);\n    }\n\n    private static boolean isTemplate(File f) {\n        if (f.isDirectory())\n            return false;\n        String name = f.getName();\n        return name.endsWith(TEMPLATE_SUFFIX) && name.charAt(0) != '_';\n    }\n\n    public static String capitalize(String s) {\n        if (s == null || s.length() == 0)\n            return s;\n        return Character.toUpperCase(s.charAt(0)) + s.substring(1);\n    }\n\n    private static String appendPkg(String prefix, String pkg) {\n        return (prefix == null || prefix.length() == 0) ? pkg : prefix + \".\" + pkg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/JVCGeneratorTest.java",
		"test_prompt": "// JVCGeneratorTest.java\npackage com.pmdesigns.jvc.tools;\n\nimport java.io.*;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCGenerator}.\n* It contains ten unit test cases for the {@link JVCGenerator#capitalize(String)} method.\n*/\nclass JVCGeneratorTest {"
	},
	{
		"original_code": "// JVCBootstrapGenerator.java\npackage com.pmdesigns.jvc.tools;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class is for bootstrapping the real JVCGenerator.\n * It generated the source files for the generators used by the JVCGenerator.\n */\npublic class JVCBootstrapGenerator {\n\n    public static final String GENERATOR_METHOD_NAME = \"genPage\";\n\n    public static final String TEMPLATE_SUFFIX = \".java.tpl\";\n\n    public static void usage() {\n        System.err.println(\"args   : <template dir> <src root dir> [-force] [-debug]\");\n    }\n\n    public static void main(String[] args) {\n        if (args.length < 2 || args.length > 4) {\n            System.err.println(\"Wrong number of args\");\n            usage();\n            return;\n        }\n        File tplDir = new File(args[0]);\n        File srcRoot = new File(args[1]);\n        boolean force = false;\n        boolean debug = false;\n        if (args.length > 2) {\n            for (int i = args.length; i-- > 2; ) {\n                if (\"-debug\".equals(args[i])) {\n                    debug = true;\n                } else if (\"-force\".equals(args[i])) {\n                    force = true;\n                }\n            }\n        }\n        System.out.println(\"JVCBootstrapGenerator\");\n        System.out.println(\"    template dir:   \" + tplDir);\n        System.out.println(\"         src dir:   \" + srcRoot);\n        System.out.println(\"           force:   \" + force);\n        System.out.println(\"           debug:   \" + debug);\n        try {\n            generate(tplDir, srcRoot, force, debug);\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            if (debug) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void generate(File tplDir, File srcRoot, boolean force, boolean debug) throws FileNotFoundException, ParseException {\n        if (!tplDir.isDirectory()) {\n            throw new FileNotFoundException(\"Template root directory '\" + tplDir + \"' doesn't exist.\");\n        }\n        String pkgPrefix = \"com.pmdesigns.jvc.tools.bootstrap\";\n        File outDir = new File(srcRoot, pkgPrefix.replace('.', File.separatorChar));\n        if (!outDir.exists())\n            outDir.mkdirs();\n        TreeSet<String> imports = new TreeSet<String>();\n        for (File f : tplDir.listFiles()) {\n            String Name = getGeneratorName(f);\n            if (Name == null)\n                continue;\n            // parse template and convert to bootstrap generator\n            File outFile = new File(outDir, Name + \"Generator.java\");\n            // check if the generator is out of date\n            if (!force && outFile.exists() && outFile.lastModified() >= f.lastModified()) {\n                continue;\n            }\n            // parse the view template\n            imports.clear();\n            imports.add(\"java.util.*\");\n            JVCParser parser = new JVCParser(f.getAbsolutePath(), imports, debug);\n            String body = parser.parse();\n            // write the page generator\n            PrintWriter pw = new PrintWriter(outFile);\n            pw.println(JVCGenerator.MACHINE_GENERATED_1 + JVCGenerator.MACHINE_GENERATED_2);\n            pw.println(\"package \" + pkgPrefix + \";\");\n            pw.println(\"\");\n            for (String pkg : imports) {\n                pw.println(\"import \" + pkg + \";\");\n            }\n            pw.println(\"\");\n            pw.println(\"public class \" + Name + \"Generator {\");\n            pw.println(\"\");\n            pw.println(\"public static String \" + GENERATOR_METHOD_NAME + \"(Map<String,String> map) {\");\n            pw.println(\"StringBuilder _sb = new StringBuilder();\");\n            pw.println(body);\n            pw.println(\"return _sb.toString();\");\n            pw.println(\"}\");\n            pw.println(\"private static String _nf(String x) { return (x == null) ? \\\"\\\" : x; }\");\n            pw.println(\"}\");\n            pw.close();\n            System.out.println(\"wrote: \" + outFile);\n        }\n    }\n\n    static String getGeneratorName(File f) {\n        if (f.isDirectory())\n            return null;\n        String name = f.getName();\n        if (!name.endsWith(TEMPLATE_SUFFIX))\n            return null;\n        // remove '.java.tpl'\n        name = name.substring(0, name.length() - TEMPLATE_SUFFIX.length());\n        return capitalize(name);\n    }\n\n    public static String capitalize(String s) {\n        if (s == null || s.length() == 0)\n            return s;\n        return Character.toUpperCase(s.charAt(0)) + s.substring(1);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/JVCBootstrapGeneratorTest.java",
		"test_prompt": "// JVCBootstrapGeneratorTest.java\npackage com.pmdesigns.jvc.tools;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCBootstrapGenerator}.\n* It contains ten unit test cases for the {@link JVCBootstrapGenerator#capitalize(String)} method.\n*/\nclass JVCBootstrapGeneratorTest {"
	},
	{
		"original_code": "// HtmlEncoder.java\npackage com.pmdesigns.jvc.tools;\n\n/**\n * A simple HTML encoder\n */\npublic class HtmlEncoder {\n\n    public static String encode(String s) {\n        int len = s.length();\n        // first check if there are any characters that need to be escaped\n        boolean found = false;\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (\"\\\"&<>\".indexOf(c) != -1 || (0xffff & c) >= 160) {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n            return s;\n        StringBuilder sb = new StringBuilder(len);\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (c == '\"') {\n                sb.append(\"&quot;\");\n            } else if (c == '&') {\n                sb.append(\"&amp;\");\n            } else if (c == '<') {\n                sb.append(\"&lt;\");\n            } else if (c == '>') {\n                sb.append(\"&gt;\");\n            } else {\n                int ci = 0xffff & c;\n                if (ci < 160) {\n                    // nothing special only 7 Bit\n                    sb.append(c);\n                } else {\n                    // Not 7 Bit use the unicode system\n                    sb.append(\"&#\").append(Integer.toString(ci)).append(';');\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/HtmlEncoderTest.java",
		"test_prompt": "// HtmlEncoderTest.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlEncoder}.\n* It contains ten unit test cases for the {@link HtmlEncoder#encode(String)} method.\n*/\nclass HtmlEncoderTest {"
	},
	{
		"original_code": "// SimpleCharStream.java\n/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (without unicode processing).\n */\npublic class SimpleCharStream {\n\n    /**\n     * Whether parser is static.\n     */\n    public static final boolean staticFlag = false;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    /**\n     * Position in buffer.\n     */\n    public int bufpos = -1;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int inBuf = 0;\n\n    protected int tabSize = 8;\n\n    protected void setTabSize(int i) {\n        tabSize = i;\n    }\n\n    protected int getTabSize(int i) {\n        return tabSize;\n    }\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos -= tokenBegin);\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        bufsize += 2048;\n        available = bufsize;\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        if (maxNextCharInd == available) {\n            if (available == bufsize) {\n                if (tokenBegin > 2048) {\n                    bufpos = maxNextCharInd = 0;\n                    available = tokenBegin;\n                } else if (tokenBegin < 0)\n                    bufpos = maxNextCharInd = 0;\n                else\n                    ExpandBuff(false);\n            } else if (available > tokenBegin)\n                available = bufsize;\n            else if ((tokenBegin - available) < 2048)\n                ExpandBuff(true);\n            else\n                available = tokenBegin;\n        }\n        int i;\n        try {\n            if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            --bufpos;\n            backup(0);\n            if (tokenBegin == -1)\n                tokenBegin = bufpos;\n            throw e;\n        }\n    }\n\n    /**\n     * Start.\n     */\n    public char BeginToken() throws java.io.IOException {\n        tokenBegin = -1;\n        char c = readChar();\n        tokenBegin = bufpos;\n        return c;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (tabSize - (column % tabSize));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    /**\n     * Read a character.\n     */\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        if (++bufpos >= maxNextCharInd)\n            FillBuff();\n        char c = buffer[bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token end column number.\n     */\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * Get token end line number.\n     */\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token beginning column number.\n     */\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    /**\n     * Get token beginning line number.\n     */\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    /**\n     * Backup a number of characters.\n     */\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        bufpos = -1;\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Get token literal value.\n     */\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    /**\n     * Get the suffix.\n     */\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    /**\n     * Reset buffer when finished.\n     */\n    public void Done() {\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n/* JavaCC - OriginalChecksum=d9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStreamTest0.java",
		"test_prompt": "// SimpleCharStreamTest0.java\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCharStream}.\n* It contains ten unit test cases for the {@link SimpleCharStream#BeginToken()} method.\n*/\nclass SimpleCharStreamTest0 {"
	},
	{
		"original_code": "// SimpleCharStream.java\n/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (without unicode processing).\n */\npublic class SimpleCharStream {\n\n    /**\n     * Whether parser is static.\n     */\n    public static final boolean staticFlag = false;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    /**\n     * Position in buffer.\n     */\n    public int bufpos = -1;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int inBuf = 0;\n\n    protected int tabSize = 8;\n\n    protected void setTabSize(int i) {\n        tabSize = i;\n    }\n\n    protected int getTabSize(int i) {\n        return tabSize;\n    }\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos -= tokenBegin);\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        bufsize += 2048;\n        available = bufsize;\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        if (maxNextCharInd == available) {\n            if (available == bufsize) {\n                if (tokenBegin > 2048) {\n                    bufpos = maxNextCharInd = 0;\n                    available = tokenBegin;\n                } else if (tokenBegin < 0)\n                    bufpos = maxNextCharInd = 0;\n                else\n                    ExpandBuff(false);\n            } else if (available > tokenBegin)\n                available = bufsize;\n            else if ((tokenBegin - available) < 2048)\n                ExpandBuff(true);\n            else\n                available = tokenBegin;\n        }\n        int i;\n        try {\n            if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            --bufpos;\n            backup(0);\n            if (tokenBegin == -1)\n                tokenBegin = bufpos;\n            throw e;\n        }\n    }\n\n    /**\n     * Start.\n     */\n    public char BeginToken() throws java.io.IOException {\n        tokenBegin = -1;\n        char c = readChar();\n        tokenBegin = bufpos;\n        return c;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (tabSize - (column % tabSize));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    /**\n     * Read a character.\n     */\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        if (++bufpos >= maxNextCharInd)\n            FillBuff();\n        char c = buffer[bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token end column number.\n     */\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * Get token end line number.\n     */\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token beginning column number.\n     */\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    /**\n     * Get token beginning line number.\n     */\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    /**\n     * Backup a number of characters.\n     */\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        bufpos = -1;\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Get token literal value.\n     */\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    /**\n     * Get the suffix.\n     */\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    /**\n     * Reset buffer when finished.\n     */\n    public void Done() {\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n/* JavaCC - OriginalChecksum=d9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStreamTest1.java",
		"test_prompt": "// SimpleCharStreamTest1.java\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCharStream}.\n* It contains ten unit test cases for the {@link SimpleCharStream#readChar()} method.\n*/\nclass SimpleCharStreamTest1 {"
	},
	{
		"original_code": "// SimpleCharStream.java\n/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (without unicode processing).\n */\npublic class SimpleCharStream {\n\n    /**\n     * Whether parser is static.\n     */\n    public static final boolean staticFlag = false;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    /**\n     * Position in buffer.\n     */\n    public int bufpos = -1;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int inBuf = 0;\n\n    protected int tabSize = 8;\n\n    protected void setTabSize(int i) {\n        tabSize = i;\n    }\n\n    protected int getTabSize(int i) {\n        return tabSize;\n    }\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos -= tokenBegin);\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        bufsize += 2048;\n        available = bufsize;\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        if (maxNextCharInd == available) {\n            if (available == bufsize) {\n                if (tokenBegin > 2048) {\n                    bufpos = maxNextCharInd = 0;\n                    available = tokenBegin;\n                } else if (tokenBegin < 0)\n                    bufpos = maxNextCharInd = 0;\n                else\n                    ExpandBuff(false);\n            } else if (available > tokenBegin)\n                available = bufsize;\n            else if ((tokenBegin - available) < 2048)\n                ExpandBuff(true);\n            else\n                available = tokenBegin;\n        }\n        int i;\n        try {\n            if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            --bufpos;\n            backup(0);\n            if (tokenBegin == -1)\n                tokenBegin = bufpos;\n            throw e;\n        }\n    }\n\n    /**\n     * Start.\n     */\n    public char BeginToken() throws java.io.IOException {\n        tokenBegin = -1;\n        char c = readChar();\n        tokenBegin = bufpos;\n        return c;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (tabSize - (column % tabSize));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    /**\n     * Read a character.\n     */\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        if (++bufpos >= maxNextCharInd)\n            FillBuff();\n        char c = buffer[bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token end column number.\n     */\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * Get token end line number.\n     */\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token beginning column number.\n     */\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    /**\n     * Get token beginning line number.\n     */\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    /**\n     * Backup a number of characters.\n     */\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        bufpos = -1;\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Get token literal value.\n     */\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    /**\n     * Get the suffix.\n     */\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    /**\n     * Reset buffer when finished.\n     */\n    public void Done() {\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n/* JavaCC - OriginalChecksum=d9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStreamTest2.java",
		"test_prompt": "// SimpleCharStreamTest2.java\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCharStream}.\n* It contains ten unit test cases for the {@link SimpleCharStream#GetImage()} method.\n*/\nclass SimpleCharStreamTest2 {"
	},
	{
		"original_code": "// SimpleCharStream.java\n/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (without unicode processing).\n */\npublic class SimpleCharStream {\n\n    /**\n     * Whether parser is static.\n     */\n    public static final boolean staticFlag = false;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    /**\n     * Position in buffer.\n     */\n    public int bufpos = -1;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int inBuf = 0;\n\n    protected int tabSize = 8;\n\n    protected void setTabSize(int i) {\n        tabSize = i;\n    }\n\n    protected int getTabSize(int i) {\n        return tabSize;\n    }\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                maxNextCharInd = (bufpos -= tokenBegin);\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        bufsize += 2048;\n        available = bufsize;\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        if (maxNextCharInd == available) {\n            if (available == bufsize) {\n                if (tokenBegin > 2048) {\n                    bufpos = maxNextCharInd = 0;\n                    available = tokenBegin;\n                } else if (tokenBegin < 0)\n                    bufpos = maxNextCharInd = 0;\n                else\n                    ExpandBuff(false);\n            } else if (available > tokenBegin)\n                available = bufsize;\n            else if ((tokenBegin - available) < 2048)\n                ExpandBuff(true);\n            else\n                available = tokenBegin;\n        }\n        int i;\n        try {\n            if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            --bufpos;\n            backup(0);\n            if (tokenBegin == -1)\n                tokenBegin = bufpos;\n            throw e;\n        }\n    }\n\n    /**\n     * Start.\n     */\n    public char BeginToken() throws java.io.IOException {\n        tokenBegin = -1;\n        char c = readChar();\n        tokenBegin = bufpos;\n        return c;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (tabSize - (column % tabSize));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    /**\n     * Read a character.\n     */\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        if (++bufpos >= maxNextCharInd)\n            FillBuff();\n        char c = buffer[bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token end column number.\n     */\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * Get token end line number.\n     */\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token beginning column number.\n     */\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    /**\n     * Get token beginning line number.\n     */\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    /**\n     * Backup a number of characters.\n     */\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        bufpos = -1;\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Get token literal value.\n     */\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    /**\n     * Get the suffix.\n     */\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    /**\n     * Reset buffer when finished.\n     */\n    public void Done() {\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n/* JavaCC - OriginalChecksum=d9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStreamTest3.java",
		"test_prompt": "// SimpleCharStreamTest3.java\n/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCharStream}.\n* It contains ten unit test cases for the {@link SimpleCharStream#GetSuffix(int)} method.\n*/\nclass SimpleCharStreamTest3 {"
	},
	{
		"original_code": "// Token.java\n/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */\n/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * Describes the input token stream.\n */\npublic class Token implements java.io.Serializable {\n\n    /**\n     * The version identifier for this Serializable class.\n     * Increment only if the <i>serialized</i> form of the\n     * class changes.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * An integer that describes the kind of this token.  This numbering\n     * system is determined by JavaCCParser, and a table of these numbers is\n     * stored in the file ...Constants.java.\n     */\n    public int kind;\n\n    /**\n     * The line number of the first character of this Token.\n     */\n    public int beginLine;\n\n    /**\n     * The column number of the first character of this Token.\n     */\n    public int beginColumn;\n\n    /**\n     * The line number of the last character of this Token.\n     */\n    public int endLine;\n\n    /**\n     * The column number of the last character of this Token.\n     */\n    public int endColumn;\n\n    /**\n     * The string image of the token.\n     */\n    public String image;\n\n    /**\n     * A reference to the next regular (non-special) token from the input\n     * stream.  If this is the last token from the input stream, or if the\n     * token manager has not read tokens beyond this one, this field is\n     * set to null.  This is true only if this token is also a regular\n     * token.  Otherwise, see below for a description of the contents of\n     * this field.\n     */\n    public Token next;\n\n    /**\n     * This field is used to access special tokens that occur prior to this\n     * token, but after the immediately preceding regular (non-special) token.\n     * If there are no such special tokens, this field is set to null.\n     * When there are more than one such special token, this field refers\n     * to the last of these special tokens, which in turn refers to the next\n     * previous special token through its specialToken field, and so on\n     * until the first special token (whose specialToken field is null).\n     * The next fields of special tokens refer to other special tokens that\n     * immediately follow it (without an intervening regular token).  If there\n     * is no such token, this field is null.\n     */\n    public Token specialToken;\n\n    /**\n     * An optional attribute value of the Token.\n     * Tokens which are not used as syntactic sugar will often contain\n     * meaningful values that will be used later on by the compiler or\n     * interpreter. This attribute value is often different from the image.\n     * Any subclass of Token that actually wants to return a non-null value can\n     * override this method as appropriate.\n     */\n    public Object getValue() {\n        return null;\n    }\n\n    /**\n     * No-argument constructor\n     */\n    public Token() {\n    }\n\n    /**\n     * Constructs a new token for the specified Image.\n     */\n    public Token(int kind) {\n        this(kind, null);\n    }\n\n    /**\n     * Constructs a new token for the specified Image and Kind.\n     */\n    public Token(int kind, String image) {\n        this.kind = kind;\n        this.image = image;\n    }\n\n    /**\n     * Returns the image.\n     */\n    public String toString() {\n        return image;\n    }\n\n    /**\n     * Returns a new Token object, by default. However, if you want, you\n     * can create and return subclass objects based on the value of ofKind.\n     * Simply add the cases to the switch for all those special cases.\n     * For example, if you have a subclass of Token called IDToken that\n     * you want to create if ofKind is ID, simply add something like :\n     *\n     *    case MyParserConstants.ID : return new IDToken(ofKind, image);\n     *\n     * to the following switch statement. Then you can cast matchedToken\n     * variable to the appropriate type and use sit in your lexical actions.\n     */\n    public static Token newToken(int ofKind, String image) {\n        switch(ofKind) {\n            default:\n                return new Token(ofKind, image);\n        }\n    }\n\n    public static Token newToken(int ofKind) {\n        return newToken(ofKind, null);\n    }\n}\n/* JavaCC - OriginalChecksum=c62ea26356a10231e81682606bfd4f6c (do not edit this line) */\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/TokenTest0.java",
		"test_prompt": "// TokenTest0.java\n/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#newToken(int, String)} method.\n*/\nclass TokenTest0 {"
	},
	{
		"original_code": "// Token.java\n/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */\n/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * Describes the input token stream.\n */\npublic class Token implements java.io.Serializable {\n\n    /**\n     * The version identifier for this Serializable class.\n     * Increment only if the <i>serialized</i> form of the\n     * class changes.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * An integer that describes the kind of this token.  This numbering\n     * system is determined by JavaCCParser, and a table of these numbers is\n     * stored in the file ...Constants.java.\n     */\n    public int kind;\n\n    /**\n     * The line number of the first character of this Token.\n     */\n    public int beginLine;\n\n    /**\n     * The column number of the first character of this Token.\n     */\n    public int beginColumn;\n\n    /**\n     * The line number of the last character of this Token.\n     */\n    public int endLine;\n\n    /**\n     * The column number of the last character of this Token.\n     */\n    public int endColumn;\n\n    /**\n     * The string image of the token.\n     */\n    public String image;\n\n    /**\n     * A reference to the next regular (non-special) token from the input\n     * stream.  If this is the last token from the input stream, or if the\n     * token manager has not read tokens beyond this one, this field is\n     * set to null.  This is true only if this token is also a regular\n     * token.  Otherwise, see below for a description of the contents of\n     * this field.\n     */\n    public Token next;\n\n    /**\n     * This field is used to access special tokens that occur prior to this\n     * token, but after the immediately preceding regular (non-special) token.\n     * If there are no such special tokens, this field is set to null.\n     * When there are more than one such special token, this field refers\n     * to the last of these special tokens, which in turn refers to the next\n     * previous special token through its specialToken field, and so on\n     * until the first special token (whose specialToken field is null).\n     * The next fields of special tokens refer to other special tokens that\n     * immediately follow it (without an intervening regular token).  If there\n     * is no such token, this field is null.\n     */\n    public Token specialToken;\n\n    /**\n     * An optional attribute value of the Token.\n     * Tokens which are not used as syntactic sugar will often contain\n     * meaningful values that will be used later on by the compiler or\n     * interpreter. This attribute value is often different from the image.\n     * Any subclass of Token that actually wants to return a non-null value can\n     * override this method as appropriate.\n     */\n    public Object getValue() {\n        return null;\n    }\n\n    /**\n     * No-argument constructor\n     */\n    public Token() {\n    }\n\n    /**\n     * Constructs a new token for the specified Image.\n     */\n    public Token(int kind) {\n        this(kind, null);\n    }\n\n    /**\n     * Constructs a new token for the specified Image and Kind.\n     */\n    public Token(int kind, String image) {\n        this.kind = kind;\n        this.image = image;\n    }\n\n    /**\n     * Returns the image.\n     */\n    public String toString() {\n        return image;\n    }\n\n    /**\n     * Returns a new Token object, by default. However, if you want, you\n     * can create and return subclass objects based on the value of ofKind.\n     * Simply add the cases to the switch for all those special cases.\n     * For example, if you have a subclass of Token called IDToken that\n     * you want to create if ofKind is ID, simply add something like :\n     *\n     *    case MyParserConstants.ID : return new IDToken(ofKind, image);\n     *\n     * to the following switch statement. Then you can cast matchedToken\n     * variable to the appropriate type and use sit in your lexical actions.\n     */\n    public static Token newToken(int ofKind, String image) {\n        switch(ofKind) {\n            default:\n                return new Token(ofKind, image);\n        }\n    }\n\n    public static Token newToken(int ofKind) {\n        return newToken(ofKind, null);\n    }\n}\n/* JavaCC - OriginalChecksum=c62ea26356a10231e81682606bfd4f6c (do not edit this line) */\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/TokenTest1.java",
		"test_prompt": "// TokenTest1.java\n/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#newToken(int)} method.\n*/\nclass TokenTest1 {"
	},
	{
		"original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * <p>\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * <p>\r\n * This is \"Open Source\" software and released under the <a href=\"http://www.gnu.org/licenses/lgpl.html\">GNU/LGPL</a> license.<br>\r\n * It is provided \"as is\" without warranty of any kind.<br>\r\n * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>\r\n * Home page: <a href=\"http://www.source-code.biz\">www.source-code.biz</a><br>\r\n *\r\n * <p>\r\n * Version history:<br>\r\n * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>\r\n * 2006-11-21 chdh:<br>\r\n *  &nbsp; Method encode(String) renamed to encodeString(String).<br>\r\n *  &nbsp; Method decode(String) renamed to decodeString(String).<br>\r\n *  &nbsp; New method encode(byte[],int) added.<br>\r\n *  &nbsp; New method decode(String) added.<br>\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 = new char[64];\r\n\r\n    static {\r\n        int i = 0;\r\n        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;\r\n        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;\r\n        for (char c = '0'; c <= '9'; c++) map1[i++] = c;\r\n        map1[i++] = '+';\r\n        map1[i++] = '/';\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 = new byte[128];\r\n\r\n    static {\r\n        for (int i = 0; i < map2.length; i++) map2[i] = -1;\r\n        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in <code>in</code>.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen = (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen = ((iLen + 2) / 3) * 4;\r\n        char[] out = new char[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++] & 0xff;\r\n            int i1 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int i2 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int o0 = i0 >>> 2;\r\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n            int o3 = i2 & 0x3F;\r\n            out[op++] = map1[o0];\r\n            out[op++] = map1[o1];\r\n            out[op] = op < oDataLen ? map1[o2] : '=';\r\n            op++;\r\n            out[op] = op < oDataLen ? map1[o3] : '=';\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen = in.length;\r\n        if (iLen % 4 != 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen > 0 && in[iLen - 1] == '=') iLen--;\r\n        int oLen = (iLen * 3) / 4;\r\n        byte[] out = new byte[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++];\r\n            int i1 = in[ip++];\r\n            int i2 = ip < iLen ? in[ip++] : 'A';\r\n            int i3 = ip < iLen ? in[ip++] : 'A';\r\n            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 = map2[i0];\r\n            int b1 = map2[i1];\r\n            int b2 = map2[i2];\r\n            int b3 = map2[i3];\r\n            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 = (b0 << 2) | (b1 >>> 4);\r\n            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n            int o2 = ((b2 & 3) << 6) | b3;\r\n            out[op++] = (byte) o0;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o1;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64CoderTest0.java",
		"test_prompt": "// Base64CoderTest0.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#encodeString(String)} method.\n*/\nclass Base64CoderTest0 {"
	},
	{
		"original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * <p>\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * <p>\r\n * This is \"Open Source\" software and released under the <a href=\"http://www.gnu.org/licenses/lgpl.html\">GNU/LGPL</a> license.<br>\r\n * It is provided \"as is\" without warranty of any kind.<br>\r\n * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>\r\n * Home page: <a href=\"http://www.source-code.biz\">www.source-code.biz</a><br>\r\n *\r\n * <p>\r\n * Version history:<br>\r\n * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>\r\n * 2006-11-21 chdh:<br>\r\n *  &nbsp; Method encode(String) renamed to encodeString(String).<br>\r\n *  &nbsp; Method decode(String) renamed to decodeString(String).<br>\r\n *  &nbsp; New method encode(byte[],int) added.<br>\r\n *  &nbsp; New method decode(String) added.<br>\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 = new char[64];\r\n\r\n    static {\r\n        int i = 0;\r\n        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;\r\n        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;\r\n        for (char c = '0'; c <= '9'; c++) map1[i++] = c;\r\n        map1[i++] = '+';\r\n        map1[i++] = '/';\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 = new byte[128];\r\n\r\n    static {\r\n        for (int i = 0; i < map2.length; i++) map2[i] = -1;\r\n        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in <code>in</code>.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen = (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen = ((iLen + 2) / 3) * 4;\r\n        char[] out = new char[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++] & 0xff;\r\n            int i1 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int i2 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int o0 = i0 >>> 2;\r\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n            int o3 = i2 & 0x3F;\r\n            out[op++] = map1[o0];\r\n            out[op++] = map1[o1];\r\n            out[op] = op < oDataLen ? map1[o2] : '=';\r\n            op++;\r\n            out[op] = op < oDataLen ? map1[o3] : '=';\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen = in.length;\r\n        if (iLen % 4 != 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen > 0 && in[iLen - 1] == '=') iLen--;\r\n        int oLen = (iLen * 3) / 4;\r\n        byte[] out = new byte[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++];\r\n            int i1 = in[ip++];\r\n            int i2 = ip < iLen ? in[ip++] : 'A';\r\n            int i3 = ip < iLen ? in[ip++] : 'A';\r\n            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 = map2[i0];\r\n            int b1 = map2[i1];\r\n            int b2 = map2[i2];\r\n            int b3 = map2[i3];\r\n            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 = (b0 << 2) | (b1 >>> 4);\r\n            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n            int o2 = ((b2 & 3) << 6) | b3;\r\n            out[op++] = (byte) o0;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o1;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64CoderTest1.java",
		"test_prompt": "// Base64CoderTest1.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#encode(byte[])} method.\n*/\nclass Base64CoderTest1 {"
	},
	{
		"original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * <p>\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * <p>\r\n * This is \"Open Source\" software and released under the <a href=\"http://www.gnu.org/licenses/lgpl.html\">GNU/LGPL</a> license.<br>\r\n * It is provided \"as is\" without warranty of any kind.<br>\r\n * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>\r\n * Home page: <a href=\"http://www.source-code.biz\">www.source-code.biz</a><br>\r\n *\r\n * <p>\r\n * Version history:<br>\r\n * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>\r\n * 2006-11-21 chdh:<br>\r\n *  &nbsp; Method encode(String) renamed to encodeString(String).<br>\r\n *  &nbsp; Method decode(String) renamed to decodeString(String).<br>\r\n *  &nbsp; New method encode(byte[],int) added.<br>\r\n *  &nbsp; New method decode(String) added.<br>\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 = new char[64];\r\n\r\n    static {\r\n        int i = 0;\r\n        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;\r\n        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;\r\n        for (char c = '0'; c <= '9'; c++) map1[i++] = c;\r\n        map1[i++] = '+';\r\n        map1[i++] = '/';\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 = new byte[128];\r\n\r\n    static {\r\n        for (int i = 0; i < map2.length; i++) map2[i] = -1;\r\n        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in <code>in</code>.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen = (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen = ((iLen + 2) / 3) * 4;\r\n        char[] out = new char[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++] & 0xff;\r\n            int i1 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int i2 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int o0 = i0 >>> 2;\r\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n            int o3 = i2 & 0x3F;\r\n            out[op++] = map1[o0];\r\n            out[op++] = map1[o1];\r\n            out[op] = op < oDataLen ? map1[o2] : '=';\r\n            op++;\r\n            out[op] = op < oDataLen ? map1[o3] : '=';\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen = in.length;\r\n        if (iLen % 4 != 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen > 0 && in[iLen - 1] == '=') iLen--;\r\n        int oLen = (iLen * 3) / 4;\r\n        byte[] out = new byte[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++];\r\n            int i1 = in[ip++];\r\n            int i2 = ip < iLen ? in[ip++] : 'A';\r\n            int i3 = ip < iLen ? in[ip++] : 'A';\r\n            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 = map2[i0];\r\n            int b1 = map2[i1];\r\n            int b2 = map2[i2];\r\n            int b3 = map2[i3];\r\n            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 = (b0 << 2) | (b1 >>> 4);\r\n            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n            int o2 = ((b2 & 3) << 6) | b3;\r\n            out[op++] = (byte) o0;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o1;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64CoderTest2.java",
		"test_prompt": "// Base64CoderTest2.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#encode(byte[], int)} method.\n*/\nclass Base64CoderTest2 {"
	},
	{
		"original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * <p>\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * <p>\r\n * This is \"Open Source\" software and released under the <a href=\"http://www.gnu.org/licenses/lgpl.html\">GNU/LGPL</a> license.<br>\r\n * It is provided \"as is\" without warranty of any kind.<br>\r\n * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>\r\n * Home page: <a href=\"http://www.source-code.biz\">www.source-code.biz</a><br>\r\n *\r\n * <p>\r\n * Version history:<br>\r\n * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>\r\n * 2006-11-21 chdh:<br>\r\n *  &nbsp; Method encode(String) renamed to encodeString(String).<br>\r\n *  &nbsp; Method decode(String) renamed to decodeString(String).<br>\r\n *  &nbsp; New method encode(byte[],int) added.<br>\r\n *  &nbsp; New method decode(String) added.<br>\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 = new char[64];\r\n\r\n    static {\r\n        int i = 0;\r\n        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;\r\n        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;\r\n        for (char c = '0'; c <= '9'; c++) map1[i++] = c;\r\n        map1[i++] = '+';\r\n        map1[i++] = '/';\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 = new byte[128];\r\n\r\n    static {\r\n        for (int i = 0; i < map2.length; i++) map2[i] = -1;\r\n        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in <code>in</code>.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen = (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen = ((iLen + 2) / 3) * 4;\r\n        char[] out = new char[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++] & 0xff;\r\n            int i1 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int i2 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int o0 = i0 >>> 2;\r\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n            int o3 = i2 & 0x3F;\r\n            out[op++] = map1[o0];\r\n            out[op++] = map1[o1];\r\n            out[op] = op < oDataLen ? map1[o2] : '=';\r\n            op++;\r\n            out[op] = op < oDataLen ? map1[o3] : '=';\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen = in.length;\r\n        if (iLen % 4 != 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen > 0 && in[iLen - 1] == '=') iLen--;\r\n        int oLen = (iLen * 3) / 4;\r\n        byte[] out = new byte[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++];\r\n            int i1 = in[ip++];\r\n            int i2 = ip < iLen ? in[ip++] : 'A';\r\n            int i3 = ip < iLen ? in[ip++] : 'A';\r\n            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 = map2[i0];\r\n            int b1 = map2[i1];\r\n            int b2 = map2[i2];\r\n            int b3 = map2[i3];\r\n            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 = (b0 << 2) | (b1 >>> 4);\r\n            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n            int o2 = ((b2 & 3) << 6) | b3;\r\n            out[op++] = (byte) o0;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o1;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64CoderTest3.java",
		"test_prompt": "// Base64CoderTest3.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#decodeString(String)} method.\n*/\nclass Base64CoderTest3 {"
	},
	{
		"original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * <p>\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * <p>\r\n * This is \"Open Source\" software and released under the <a href=\"http://www.gnu.org/licenses/lgpl.html\">GNU/LGPL</a> license.<br>\r\n * It is provided \"as is\" without warranty of any kind.<br>\r\n * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>\r\n * Home page: <a href=\"http://www.source-code.biz\">www.source-code.biz</a><br>\r\n *\r\n * <p>\r\n * Version history:<br>\r\n * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>\r\n * 2006-11-21 chdh:<br>\r\n *  &nbsp; Method encode(String) renamed to encodeString(String).<br>\r\n *  &nbsp; Method decode(String) renamed to decodeString(String).<br>\r\n *  &nbsp; New method encode(byte[],int) added.<br>\r\n *  &nbsp; New method decode(String) added.<br>\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 = new char[64];\r\n\r\n    static {\r\n        int i = 0;\r\n        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;\r\n        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;\r\n        for (char c = '0'; c <= '9'; c++) map1[i++] = c;\r\n        map1[i++] = '+';\r\n        map1[i++] = '/';\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 = new byte[128];\r\n\r\n    static {\r\n        for (int i = 0; i < map2.length; i++) map2[i] = -1;\r\n        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in <code>in</code>.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen = (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen = ((iLen + 2) / 3) * 4;\r\n        char[] out = new char[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++] & 0xff;\r\n            int i1 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int i2 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int o0 = i0 >>> 2;\r\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n            int o3 = i2 & 0x3F;\r\n            out[op++] = map1[o0];\r\n            out[op++] = map1[o1];\r\n            out[op] = op < oDataLen ? map1[o2] : '=';\r\n            op++;\r\n            out[op] = op < oDataLen ? map1[o3] : '=';\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen = in.length;\r\n        if (iLen % 4 != 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen > 0 && in[iLen - 1] == '=') iLen--;\r\n        int oLen = (iLen * 3) / 4;\r\n        byte[] out = new byte[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++];\r\n            int i1 = in[ip++];\r\n            int i2 = ip < iLen ? in[ip++] : 'A';\r\n            int i3 = ip < iLen ? in[ip++] : 'A';\r\n            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 = map2[i0];\r\n            int b1 = map2[i1];\r\n            int b2 = map2[i2];\r\n            int b3 = map2[i3];\r\n            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 = (b0 << 2) | (b1 >>> 4);\r\n            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n            int o2 = ((b2 & 3) << 6) | b3;\r\n            out[op++] = (byte) o0;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o1;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64CoderTest4.java",
		"test_prompt": "// Base64CoderTest4.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#decode(String)} method.\n*/\nclass Base64CoderTest4 {"
	},
	{
		"original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * <p>\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * <p>\r\n * This is \"Open Source\" software and released under the <a href=\"http://www.gnu.org/licenses/lgpl.html\">GNU/LGPL</a> license.<br>\r\n * It is provided \"as is\" without warranty of any kind.<br>\r\n * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>\r\n * Home page: <a href=\"http://www.source-code.biz\">www.source-code.biz</a><br>\r\n *\r\n * <p>\r\n * Version history:<br>\r\n * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>\r\n * 2006-11-21 chdh:<br>\r\n *  &nbsp; Method encode(String) renamed to encodeString(String).<br>\r\n *  &nbsp; Method decode(String) renamed to decodeString(String).<br>\r\n *  &nbsp; New method encode(byte[],int) added.<br>\r\n *  &nbsp; New method decode(String) added.<br>\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 = new char[64];\r\n\r\n    static {\r\n        int i = 0;\r\n        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;\r\n        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;\r\n        for (char c = '0'; c <= '9'; c++) map1[i++] = c;\r\n        map1[i++] = '+';\r\n        map1[i++] = '/';\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 = new byte[128];\r\n\r\n    static {\r\n        for (int i = 0; i < map2.length; i++) map2[i] = -1;\r\n        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in <code>in</code>.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen = (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen = ((iLen + 2) / 3) * 4;\r\n        char[] out = new char[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++] & 0xff;\r\n            int i1 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int i2 = ip < iLen ? in[ip++] & 0xff : 0;\r\n            int o0 = i0 >>> 2;\r\n            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n            int o3 = i2 & 0x3F;\r\n            out[op++] = map1[o0];\r\n            out[op++] = map1[o1];\r\n            out[op] = op < oDataLen ? map1[o2] : '=';\r\n            op++;\r\n            out[op] = op < oDataLen ? map1[o3] : '=';\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen = in.length;\r\n        if (iLen % 4 != 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen > 0 && in[iLen - 1] == '=') iLen--;\r\n        int oLen = (iLen * 3) / 4;\r\n        byte[] out = new byte[oLen];\r\n        int ip = 0;\r\n        int op = 0;\r\n        while (ip < iLen) {\r\n            int i0 = in[ip++];\r\n            int i1 = in[ip++];\r\n            int i2 = ip < iLen ? in[ip++] : 'A';\r\n            int i3 = ip < iLen ? in[ip++] : 'A';\r\n            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 = map2[i0];\r\n            int b1 = map2[i1];\r\n            int b2 = map2[i2];\r\n            int b3 = map2[i3];\r\n            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 = (b0 << 2) | (b1 >>> 4);\r\n            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n            int o2 = ((b2 & 3) << 6) | b3;\r\n            out[op++] = (byte) o0;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o1;\r\n            if (op < oLen)\r\n                out[op++] = (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64CoderTest5.java",
		"test_prompt": "// Base64CoderTest5.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#decode(char[])} method.\n*/\nclass Base64CoderTest5 {"
	},
	{
		"original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * <p>\n * It also provides access to the 'flash' which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * <p>\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE = \"BINARY_VALUE\";\n\n    /**\n     * The 'flash' map for holding temporary key/value strings.\n     */\n    public final Map<String, String> flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map<String, String> cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {\n        this.request = request;\n        this.response = response;\n        this.servlet = servlet;\n        this.controller = controller;\n        this.action = action;\n        this.flash = flash;\n        hasMultipartContent = ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                InputStream stream = item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val = Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName = item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data = readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o = request.getAttribute(name);\n            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form '<name>[<key>]' and return then in a map where the\n     * keys are the <key> strings and the values are the\n     * corresponding parameter values.\n     * <pre>\n     * For example, if there are parameters:\n     *   'foo[bar1]' = 'baz1'\n     *   'foo[bar2]' = 'baz2'\n     * then getParamMap('foo') will returned the map:\n     *   map['bar1'] = 'baz1'\n     *   map['bar2'] = 'baz2'\n     * </pre>\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form 'name[<key>]'\n     * where the <key> strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map<String, String> getParamMap(String name) {\n        Map<String, String> m = new HashMap<String, String>();\n        String prefix = name + \"[\";\n        int n = prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key = e.nextElement();\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map<String, String[]> pm = request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List<String> list = new ArrayList<String>();\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map<String, String[]> m = request.getParameterMap();\n            String[] a = new String[m.size()];\n            int i = 0;\n            for (String key : m.keySet()) {\n                a[i++] = key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() == null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) == null)\n            return new String[0];\n        ArrayList<String> a = new ArrayList<String>();\n        Enumeration<String> e = request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name == null)\n            return null;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return new String[0];\n        String[] a = new String[cookies.length];\n        int i = 0;\n        for (Cookie c : cookies) {\n            a[i++] = c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        return \"<a href='\" + path + \"' \" + options + \">\" + anchor + \"</a>\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap == null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap == null) {\n            cacheMap = new HashMap<String, String>();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys = getParamNames();\n        for (String key : keys) {\n            sb.append(key).append('=').append(getParam(key)).append(sep);\n        }\n        if (keys.length > 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContextTest0.java",
		"test_prompt": "// JVCRequestContextTest0.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#isSecure()} method.\n*/\nclass JVCRequestContextTest0 {"
	},
	{
		"original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * <p>\n * It also provides access to the 'flash' which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * <p>\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE = \"BINARY_VALUE\";\n\n    /**\n     * The 'flash' map for holding temporary key/value strings.\n     */\n    public final Map<String, String> flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map<String, String> cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {\n        this.request = request;\n        this.response = response;\n        this.servlet = servlet;\n        this.controller = controller;\n        this.action = action;\n        this.flash = flash;\n        hasMultipartContent = ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                InputStream stream = item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val = Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName = item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data = readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o = request.getAttribute(name);\n            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form '<name>[<key>]' and return then in a map where the\n     * keys are the <key> strings and the values are the\n     * corresponding parameter values.\n     * <pre>\n     * For example, if there are parameters:\n     *   'foo[bar1]' = 'baz1'\n     *   'foo[bar2]' = 'baz2'\n     * then getParamMap('foo') will returned the map:\n     *   map['bar1'] = 'baz1'\n     *   map['bar2'] = 'baz2'\n     * </pre>\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form 'name[<key>]'\n     * where the <key> strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map<String, String> getParamMap(String name) {\n        Map<String, String> m = new HashMap<String, String>();\n        String prefix = name + \"[\";\n        int n = prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key = e.nextElement();\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map<String, String[]> pm = request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List<String> list = new ArrayList<String>();\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map<String, String[]> m = request.getParameterMap();\n            String[] a = new String[m.size()];\n            int i = 0;\n            for (String key : m.keySet()) {\n                a[i++] = key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() == null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) == null)\n            return new String[0];\n        ArrayList<String> a = new ArrayList<String>();\n        Enumeration<String> e = request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name == null)\n            return null;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return new String[0];\n        String[] a = new String[cookies.length];\n        int i = 0;\n        for (Cookie c : cookies) {\n            a[i++] = c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        return \"<a href='\" + path + \"' \" + options + \">\" + anchor + \"</a>\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap == null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap == null) {\n            cacheMap = new HashMap<String, String>();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys = getParamNames();\n        for (String key : keys) {\n            sb.append(key).append('=').append(getParam(key)).append(sep);\n        }\n        if (keys.length > 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContextTest1.java",
		"test_prompt": "// JVCRequestContextTest1.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#absPath(String)} method.\n*/\nclass JVCRequestContextTest1 {"
	},
	{
		"original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * <p>\n * It also provides access to the 'flash' which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * <p>\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE = \"BINARY_VALUE\";\n\n    /**\n     * The 'flash' map for holding temporary key/value strings.\n     */\n    public final Map<String, String> flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map<String, String> cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {\n        this.request = request;\n        this.response = response;\n        this.servlet = servlet;\n        this.controller = controller;\n        this.action = action;\n        this.flash = flash;\n        hasMultipartContent = ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                InputStream stream = item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val = Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName = item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data = readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o = request.getAttribute(name);\n            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form '<name>[<key>]' and return then in a map where the\n     * keys are the <key> strings and the values are the\n     * corresponding parameter values.\n     * <pre>\n     * For example, if there are parameters:\n     *   'foo[bar1]' = 'baz1'\n     *   'foo[bar2]' = 'baz2'\n     * then getParamMap('foo') will returned the map:\n     *   map['bar1'] = 'baz1'\n     *   map['bar2'] = 'baz2'\n     * </pre>\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form 'name[<key>]'\n     * where the <key> strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map<String, String> getParamMap(String name) {\n        Map<String, String> m = new HashMap<String, String>();\n        String prefix = name + \"[\";\n        int n = prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key = e.nextElement();\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map<String, String[]> pm = request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List<String> list = new ArrayList<String>();\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map<String, String[]> m = request.getParameterMap();\n            String[] a = new String[m.size()];\n            int i = 0;\n            for (String key : m.keySet()) {\n                a[i++] = key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() == null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) == null)\n            return new String[0];\n        ArrayList<String> a = new ArrayList<String>();\n        Enumeration<String> e = request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name == null)\n            return null;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return new String[0];\n        String[] a = new String[cookies.length];\n        int i = 0;\n        for (Cookie c : cookies) {\n            a[i++] = c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        return \"<a href='\" + path + \"' \" + options + \">\" + anchor + \"</a>\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap == null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap == null) {\n            cacheMap = new HashMap<String, String>();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys = getParamNames();\n        for (String key : keys) {\n            sb.append(key).append('=').append(getParam(key)).append(sep);\n        }\n        if (keys.length > 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContextTest2.java",
		"test_prompt": "// JVCRequestContextTest2.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#makeLink(String, String)} method.\n*/\nclass JVCRequestContextTest2 {"
	},
	{
		"original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * <p>\n * It also provides access to the 'flash' which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * <p>\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE = \"BINARY_VALUE\";\n\n    /**\n     * The 'flash' map for holding temporary key/value strings.\n     */\n    public final Map<String, String> flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map<String, String> cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {\n        this.request = request;\n        this.response = response;\n        this.servlet = servlet;\n        this.controller = controller;\n        this.action = action;\n        this.flash = flash;\n        hasMultipartContent = ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                InputStream stream = item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val = Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName = item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data = readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o = request.getAttribute(name);\n            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form '<name>[<key>]' and return then in a map where the\n     * keys are the <key> strings and the values are the\n     * corresponding parameter values.\n     * <pre>\n     * For example, if there are parameters:\n     *   'foo[bar1]' = 'baz1'\n     *   'foo[bar2]' = 'baz2'\n     * then getParamMap('foo') will returned the map:\n     *   map['bar1'] = 'baz1'\n     *   map['bar2'] = 'baz2'\n     * </pre>\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form 'name[<key>]'\n     * where the <key> strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map<String, String> getParamMap(String name) {\n        Map<String, String> m = new HashMap<String, String>();\n        String prefix = name + \"[\";\n        int n = prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key = e.nextElement();\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map<String, String[]> pm = request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List<String> list = new ArrayList<String>();\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map<String, String[]> m = request.getParameterMap();\n            String[] a = new String[m.size()];\n            int i = 0;\n            for (String key : m.keySet()) {\n                a[i++] = key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() == null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) == null)\n            return new String[0];\n        ArrayList<String> a = new ArrayList<String>();\n        Enumeration<String> e = request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name == null)\n            return null;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return new String[0];\n        String[] a = new String[cookies.length];\n        int i = 0;\n        for (Cookie c : cookies) {\n            a[i++] = c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        return \"<a href='\" + path + \"' \" + options + \">\" + anchor + \"</a>\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap == null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap == null) {\n            cacheMap = new HashMap<String, String>();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys = getParamNames();\n        for (String key : keys) {\n            sb.append(key).append('=').append(getParam(key)).append(sep);\n        }\n        if (keys.length > 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContextTest3.java",
		"test_prompt": "// JVCRequestContextTest3.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#makeLink(String, String, String)} method.\n*/\nclass JVCRequestContextTest3 {"
	},
	{
		"original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * <p>\n * It also provides access to the 'flash' which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * <p>\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE = \"BINARY_VALUE\";\n\n    /**\n     * The 'flash' map for holding temporary key/value strings.\n     */\n    public final Map<String, String> flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map<String, String> cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {\n        this.request = request;\n        this.response = response;\n        this.servlet = servlet;\n        this.controller = controller;\n        this.action = action;\n        this.flash = flash;\n        hasMultipartContent = ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                InputStream stream = item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val = Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName = item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data = readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o = request.getAttribute(name);\n            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form '<name>[<key>]' and return then in a map where the\n     * keys are the <key> strings and the values are the\n     * corresponding parameter values.\n     * <pre>\n     * For example, if there are parameters:\n     *   'foo[bar1]' = 'baz1'\n     *   'foo[bar2]' = 'baz2'\n     * then getParamMap('foo') will returned the map:\n     *   map['bar1'] = 'baz1'\n     *   map['bar2'] = 'baz2'\n     * </pre>\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form 'name[<key>]'\n     * where the <key> strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map<String, String> getParamMap(String name) {\n        Map<String, String> m = new HashMap<String, String>();\n        String prefix = name + \"[\";\n        int n = prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key = e.nextElement();\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map<String, String[]> pm = request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List<String> list = new ArrayList<String>();\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map<String, String[]> m = request.getParameterMap();\n            String[] a = new String[m.size()];\n            int i = 0;\n            for (String key : m.keySet()) {\n                a[i++] = key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() == null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) == null)\n            return new String[0];\n        ArrayList<String> a = new ArrayList<String>();\n        Enumeration<String> e = request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name == null)\n            return null;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return new String[0];\n        String[] a = new String[cookies.length];\n        int i = 0;\n        for (Cookie c : cookies) {\n            a[i++] = c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        return \"<a href='\" + path + \"' \" + options + \">\" + anchor + \"</a>\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap == null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap == null) {\n            cacheMap = new HashMap<String, String>();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys = getParamNames();\n        for (String key : keys) {\n            sb.append(key).append('=').append(getParam(key)).append(sep);\n        }\n        if (keys.length > 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContextTest4.java",
		"test_prompt": "// JVCRequestContextTest4.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#isPost()} method.\n*/\nclass JVCRequestContextTest4 {"
	},
	{
		"original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * <p>\n * It also provides access to the 'flash' which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * <p>\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE = \"BINARY_VALUE\";\n\n    /**\n     * The 'flash' map for holding temporary key/value strings.\n     */\n    public final Map<String, String> flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map<String, String> cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {\n        this.request = request;\n        this.response = response;\n        this.servlet = servlet;\n        this.controller = controller;\n        this.action = action;\n        this.flash = flash;\n        hasMultipartContent = ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                InputStream stream = item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val = Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName = item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data = readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o = request.getAttribute(name);\n            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form '<name>[<key>]' and return then in a map where the\n     * keys are the <key> strings and the values are the\n     * corresponding parameter values.\n     * <pre>\n     * For example, if there are parameters:\n     *   'foo[bar1]' = 'baz1'\n     *   'foo[bar2]' = 'baz2'\n     * then getParamMap('foo') will returned the map:\n     *   map['bar1'] = 'baz1'\n     *   map['bar2'] = 'baz2'\n     * </pre>\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form 'name[<key>]'\n     * where the <key> strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map<String, String> getParamMap(String name) {\n        Map<String, String> m = new HashMap<String, String>();\n        String prefix = name + \"[\";\n        int n = prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key = e.nextElement();\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map<String, String[]> pm = request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List<String> list = new ArrayList<String>();\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map<String, String[]> m = request.getParameterMap();\n            String[] a = new String[m.size()];\n            int i = 0;\n            for (String key : m.keySet()) {\n                a[i++] = key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() == null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) == null)\n            return new String[0];\n        ArrayList<String> a = new ArrayList<String>();\n        Enumeration<String> e = request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name == null)\n            return null;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return new String[0];\n        String[] a = new String[cookies.length];\n        int i = 0;\n        for (Cookie c : cookies) {\n            a[i++] = c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        return \"<a href='\" + path + \"' \" + options + \">\" + anchor + \"</a>\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap == null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap == null) {\n            cacheMap = new HashMap<String, String>();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys = getParamNames();\n        for (String key : keys) {\n            sb.append(key).append('=').append(getParam(key)).append(sep);\n        }\n        if (keys.length > 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContextTest5.java",
		"test_prompt": "// JVCRequestContextTest5.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#isGet()} method.\n*/\nclass JVCRequestContextTest5 {"
	},
	{
		"original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * <p>\n * It also provides access to the 'flash' which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * <p>\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE = \"BINARY_VALUE\";\n\n    /**\n     * The 'flash' map for holding temporary key/value strings.\n     */\n    public final Map<String, String> flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map<String, String> cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {\n        this.request = request;\n        this.response = response;\n        this.servlet = servlet;\n        this.controller = controller;\n        this.action = action;\n        this.flash = flash;\n        hasMultipartContent = ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload = new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                InputStream stream = item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val = Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName = item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data = readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * <ul>\n     * <li>context path</li>\n     * <li>servlet path</li>\n     * <li>query string</li>\n     * </ul>\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o = request.getAttribute(name);\n            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form '<name>[<key>]' and return then in a map where the\n     * keys are the <key> strings and the values are the\n     * corresponding parameter values.\n     * <pre>\n     * For example, if there are parameters:\n     *   'foo[bar1]' = 'baz1'\n     *   'foo[bar2]' = 'baz2'\n     * then getParamMap('foo') will returned the map:\n     *   map['bar1'] = 'baz1'\n     *   map['bar2'] = 'baz2'\n     * </pre>\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form 'name[<key>]'\n     * where the <key> strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map<String, String> getParamMap(String name) {\n        Map<String, String> m = new HashMap<String, String>();\n        String prefix = name + \"[\";\n        int n = prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key = e.nextElement();\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map<String, String[]> pm = request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) && key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List<String> list = new ArrayList<String>();\n            Enumeration<String> e = request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map<String, String[]> m = request.getParameterMap();\n            String[] a = new String[m.size()];\n            int i = 0;\n            for (String key : m.keySet()) {\n                a[i++] = key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() == null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) == null)\n            return new String[0];\n        ArrayList<String> a = new ArrayList<String>();\n        Enumeration<String> e = request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() == null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name == null)\n            return null;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null)\n            return new String[0];\n        String[] a = new String[cookies.length];\n        int i = 0;\n        for (Cookie c : cookies) {\n            a[i++] = c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a '/' character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path = absPath(path);\n        return \"<a href='\" + path + \"' \" + options + \">\" + anchor + \"</a>\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap == null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap == null) {\n            cacheMap = new HashMap<String, String>();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys = getParamNames();\n        for (String key : keys) {\n            sb.append(key).append('=').append(getParam(key)).append(sep);\n        }\n        if (keys.length > 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContextTest6.java",
		"test_prompt": "// JVCRequestContextTest6.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getCachedBlock(String)} method.\n*/\nclass JVCRequestContextTest6 {"
	},
	{
		"original_code": "// JVCDispatcher.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\nimport com.pmdesigns.jvc.tools.Base64Coder;\nimport com.pmdesigns.jvc.tools.JVCGenerator;\n\n/**\n * JVC request dispatching servlet\n *\n * @author mike dooley\n */\npublic class JVCDispatcher extends HttpServlet {\n\n    private Map<String, Class> generatorClasses;\n\n    private String pkgPrefix;\n\n    public static final String PKG_PREFIX_KEY = \"pkg_prefix\";\n\n    private static Class requestContextClass;\n\n    private static Class classNotFound;\n\n    private Destroyable application;\n\n    private static final boolean TRACE = false;\n\n    private static ThreadLocal<JVCRequestContext> ctxHolder = new ThreadLocal<JVCRequestContext>() {\n\n        protected synchronized JVCRequestContext initialValue() {\n            return null;\n        }\n    };\n\n    /**\n     * Return the thread local request context\n     * @return the JVCRequestContext associated with the current thread or null\n     */\n    public static JVCRequestContext getRC() {\n        return ctxHolder.get();\n    }\n\n    /**\n     * Get the package prefix (from config) so we know the fully qualified\n     * name of page generators and controllers.  Also create and instance\n     * of the Application object.\n     */\n    public void init() {\n        pkgPrefix = getInitParameter(PKG_PREFIX_KEY);\n        generatorClasses = new HashMap<String, Class>();\n        if (classNotFound == null) {\n            // just a rock, any Class will do\n            classNotFound = getClass();\n        }\n        // create an instance of the Application class\n        String className = appendPkg(pkgPrefix, \"Application\");\n        try {\n            Class appClass = Class.forName(className);\n            Class[] args = { Class.forName(\"javax.servlet.GenericServlet\") };\n            Constructor<Destroyable> appConstructor = appClass.getConstructor(args);\n            this.application = appConstructor.newInstance(this);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getTargetException();\n            Log.error(\"Failed to create Application instance: \", ((t != null) ? t : e));\n        } catch (IllegalArgumentException e) {\n            Log.error(\"Illegal Application constructor args\", e);\n        } catch (NoSuchMethodException e) {\n            Log.error(\"Constructor not found for: \" + className, e);\n        } catch (Exception e) {\n            Log.error(\"Error while creating Application\", e);\n        }\n    }\n\n    /**\n     * Notify the Application that its shutdown time.\n     */\n    public void destroy() {\n        if (application != null) {\n            application.destroy();\n            application = null;\n        }\n    }\n\n    /**\n     * Handle a GET request. Called by servlet container.\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        handleRequest(request, response);\n    }\n\n    /**\n     * Handle a POST request. Called by servlet container.\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        handleRequest(request, response);\n    }\n\n    /**\n     * Private implementation to handle a GET or POST request by invoking the appropriate\n     * PageGenerator and Controller objects, or by serving static content.\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    private void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        long t0, t1;\n        if (TRACE)\n            t0 = System.currentTimeMillis();\n        // i18n\n        response.setCharacterEncoding(\"UTF8\");\n        request.setCharacterEncoding(\"UTF8\");\n        // request path for a dynamic page is expected to be of the form: / [<controller> / ] [<action>]\n        String reqPath = request.getServletPath();\n        // strip leading '/'\n        if (reqPath.length() < 1) {\n            // should never happen\n            Log.error(\"Empty path!\");\n            response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());\n        } else if (reqPath.charAt(0) == '/') {\n            reqPath = reqPath.substring(1, reqPath.length());\n        }\n        // try to extract the controller and action from the request path\n        String controller;\n        String action;\n        int idx = reqPath.lastIndexOf('/');\n        if (idx == -1) {\n            controller = \"\";\n            action = reqPath;\n        } else {\n            controller = reqPath.substring(0, idx);\n            action = reqPath.substring(idx + 1);\n        }\n        // only look for a generator if there isn't a '.' in the action\n        if (action.indexOf('.') == -1) {\n            if (action.length() == 0) {\n                // automatically supply this action\n                action = \"index\";\n            }\n            String pkg = appendPkg(pkgPrefix, \"generators\");\n            if (controller.length() > 0) {\n                pkg += \".\" + controller.replace('/', '.');\n            }\n            String methodName = JVCGenerator.GENERATOR_METHOD_NAME;\n            String className = pkg + \".\" + JVCGenerator.capitalize(action) + \"Generator\";\n            //Log.info(\"looking for generator '\"+reqPath+\"', class: \"+className+\", meth: \"+methodName);\n            // lookup the generator class\n            Class genClass = generatorClasses.get(className);\n            if (genClass == null) {\n                try {\n                    genClass = Class.forName(className);\n                } catch (ClassNotFoundException e) {\n                    genClass = classNotFound;\n                    //Log.info(\"Generator class not found: \"+className);\n                }\n                generatorClasses.put(className, genClass);\n            }\n            if (genClass != classNotFound) {\n                // this is a dynamic page request. invoke page generator\n                JVCRequestContext rc = null;\n                try {\n                    if (requestContextClass == null) {\n                        requestContextClass = Class.forName(\"com.pmdesigns.jvc.JVCRequestContext\");\n                    }\n                    Class[] args = { requestContextClass };\n                    Method meth = genClass.getMethod(methodName, args);\n                    // look for 'flash cookie'\n                    Map<String, String> flash = getFlash(request, response);\n                    // render the page\n                    rc = new JVCRequestContext(request, response, this, flash, controller, action);\n                    // put the context in thread local\n                    ctxHolder.set(rc);\n                    String s = (String) meth.invoke(null, rc);\n                    // write response\n                    response.getWriter().print(s);\n                    response.flushBuffer();\n                } catch (InvocationTargetException e) {\n                    // our non-standard-response exceptions get wrapped in invocation-target exceptions\n                    Throwable t = e.getTargetException();\n                    if (t instanceof NonStandardResponseException) {\n                        // send appropriate response (usually a redirect)\n                        NonStandardResponseException resp = (NonStandardResponseException) t;\n                        //Log.info(\"non standard response: \"+resp);\n                        if (resp.httpCode == HttpURLConnection.HTTP_MOVED_TEMP) {\n                            // add 'flash cookie' if necessary\n                            if (rc != null && !rc.flash.isEmpty()) {\n                                Cookie c = makeFlashCookie(rc.flash);\n                                c.setPath(request.getContextPath());\n                                response.addCookie(c);\n                            }\n                            response.sendRedirect(resp.arg);\n                        } else {\n                            response.sendError(resp.httpCode, resp.arg);\n                        }\n                    } else if (t instanceof BinaryResponseException) {\n                        // send binary response\n                        BinaryResponseException bre = (BinaryResponseException) t;\n                        OutputStream out = new BufferedOutputStream(response.getOutputStream());\n                        copy(bre.in, out);\n                        response.flushBuffer();\n                    } else {\n                        // send a server error response\n                        String err = ((t != null) ? t.toString() : e.toString());\n                        Log.error(\"Invocation error: \", ((t != null) ? t : e));\n                        response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR, err);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // send a not-found response\n                    Log.error(\"Method not found: \" + className + \".\" + methodName);\n                    response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());\n                } catch (Throwable e) {\n                    Log.error(\"Unhandled exception while processing \" + request.getRequestURI(), e);\n                    // send server-error response\n                    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR, request.getRequestURI());\n                } finally {\n                    // remove context from the thread local\n                    ctxHolder.set(null);\n                    if (TRACE)\n                        Log.info(\"TIMING_1 '\" + reqPath + \"' = \" + (System.currentTimeMillis() - t0));\n                }\n                // done with dynamic page request\n                return;\n            }\n        }\n        // look for static file\n        if (action.length() == 0) {\n            // supply default static file\n            reqPath += \"index.html\";\n        }\n        //Log.info(\"looking for resource '\"+reqPath+\"'\");\n        try {\n            InputStream in = getServletContext().getResourceAsStream(reqPath);\n            if (in != null) {\n                OutputStream out = new BufferedOutputStream(response.getOutputStream());\n                copy(in, out);\n                response.flushBuffer();\n                if (TRACE)\n                    Log.info(\"TIMING_2 '\" + reqPath + \"' = \" + (System.currentTimeMillis() - t0));\n                return;\n            }\n        } catch (IOException e) {\n            Log.error(\"Error sending '\" + reqPath + \"'\", e);\n        }\n        response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());\n        if (TRACE)\n            Log.info(\"TIMING_3 '\" + reqPath + \"' = \" + (System.currentTimeMillis() - t0));\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private void copy(InputStream in, OutputStream out) throws IOException {\n        byte[] buf = new byte[4096];\n        int read;\n        while ((read = in.read(buf)) > -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n    }\n\n    /**\n     * Append a package string to a prefix if the prefix isn't empty\n     */\n    private static String appendPkg(String prefix, String pkg) {\n        return (prefix == null || prefix.length() == 0) ? pkg : prefix + \".\" + pkg;\n    }\n\n    private static final String FLASH_COOKIE = \"jvc_flash\";\n\n    /**\n     * Look for a 'flash cookie' in the request.  If found deserialize it, clear the cookie\n     * and return it, otherwise just return an empty Map.\n     * @see #makeFlashCookie\n     * @see #serializeMap\n     * @see #deserializeMap\n     */\n    private static Map<String, String> getFlash(HttpServletRequest request, HttpServletResponse response) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie c : cookies) {\n                if (FLASH_COOKIE.equals(c.getName())) {\n                    // extract the flash from the cookie\n                    Map<String, String> map = deserializeMap(c.getValue());\n                    // clear the flash cookie\n                    c = new Cookie(FLASH_COOKIE, \"\");\n                    c.setPath(request.getContextPath());\n                    c.setMaxAge(0);\n                    response.addCookie(c);\n                    return map;\n                }\n            }\n        }\n        return new HashMap<String, String>();\n    }\n\n    /**\n     * Serialize the indicated map and return it in a 'flash cookie'\n     * @see #getFlash\n     * @see #serializeMap\n     * @see #deserializeMap\n     */\n    private static Cookie makeFlashCookie(Map<String, String> map) {\n        return new Cookie(FLASH_COOKIE, serializeMap(map));\n    }\n\n    /**\n     * Return a string representation of the map.\n     * This method encodes the map by writing its keys and values\n     * separated by the 0 character (the end of the list is indicated\n     * by an empty key) and then base64 encoding this string.\n     * @see #getFlash\n     * @see #makeFlashCookie\n     * @see #deserializeMap\n     */\n    private static String serializeMap(Map<String, String> map) {\n        StringBuilder sb = new StringBuilder();\n        for (String key : map.keySet()) {\n            String val = map.get(key);\n            if (val != null) {\n                sb.append(key).append((char) 0).append(val).append((char) 0);\n            }\n        }\n        sb.append((char) 0);\n        return Base64Coder.encodeString(sb.toString());\n    }\n\n    /**\n     * Return the map representation of the indicated string (see serializeMap())\n     * @see #getFlash\n     * @see #makeFlashCookie\n     * @see #serializeMap\n     */\n    private static Map<String, String> deserializeMap(String s) {\n        s = Base64Coder.decodeString(s);\n        Map<String, String> map = new HashMap<String, String>();\n        int idx = 0;\n        int idx2;\n        while ((idx2 = s.indexOf((char) 0, idx)) != -1) {\n            if (idx == idx2) {\n                // end of list is marked by empty key\n                break;\n            }\n            String key = s.substring(idx, idx2);\n            idx = idx2 + 1;\n            idx2 = s.indexOf((char) 0, idx);\n            if (idx2 == -1) {\n                Log.error(\"Invalid serialized map.\");\n                // throw exception ?\n                break;\n            }\n            String val = s.substring(idx, idx2);\n            map.put(key, val);\n            idx = idx2 + 1;\n        }\n        return map;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCDispatcherTest.java",
		"test_prompt": "// JVCDispatcherTest.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\nimport com.pmdesigns.jvc.tools.Base64Coder;\nimport com.pmdesigns.jvc.tools.JVCGenerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCDispatcher}.\n* It contains ten unit test cases for the {@link JVCDispatcher#getRC()} method.\n*/\nclass JVCDispatcherTest {"
	}
]