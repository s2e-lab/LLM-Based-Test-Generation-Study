[
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest0.java",
		"test_prompt": "// UsersBDTest0.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#loadGroupsAndUsers()} method.\n*/\nclass UsersBDTest0 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest1.java",
		"test_prompt": "// UsersBDTest1.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#loadRooms()} method.\n*/\nclass UsersBDTest1 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest2.java",
		"test_prompt": "// UsersBDTest2.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#createUser(User)} method.\n*/\nclass UsersBDTest2 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest3.java",
		"test_prompt": "// UsersBDTest3.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#createGroup(Group)} method.\n*/\nclass UsersBDTest3 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest4.java",
		"test_prompt": "// UsersBDTest4.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#createRoom(Room)} method.\n*/\nclass UsersBDTest4 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest5.java",
		"test_prompt": "// UsersBDTest5.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#delUser(User)} method.\n*/\nclass UsersBDTest5 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest6.java",
		"test_prompt": "// UsersBDTest6.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#delGroup(Group)} method.\n*/\nclass UsersBDTest6 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest7.java",
		"test_prompt": "// UsersBDTest7.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#delRoom(Room)} method.\n*/\nclass UsersBDTest7 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest8.java",
		"test_prompt": "// UsersBDTest8.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#updateUser(User)} method.\n*/\nclass UsersBDTest8 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest9.java",
		"test_prompt": "// UsersBDTest9.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#updateGroup(Group)} method.\n*/\nclass UsersBDTest9 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest10.java",
		"test_prompt": "// UsersBDTest10.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#updateRoom(Room)} method.\n*/\nclass UsersBDTest10 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest11.java",
		"test_prompt": "// UsersBDTest11.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#updatePassword(int, String, String)} method.\n*/\nclass UsersBDTest11 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest12.java",
		"test_prompt": "// UsersBDTest12.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#resetUserPass(User)} method.\n*/\nclass UsersBDTest12 {"
	},
	{
		"original_code": "// UsersBD.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\n\n/**\n * @author ooransa\n */\npublic class UsersBD implements IBO {\n\n    public static final String FILE_TYPE = \"1\";\n\n    public static final String DB_TYPE = \"2\";\n\n    private IBO businessObject;\n\n    public UsersBD(String type, String path, ModernChatServer modernServer) throws Exception {\n        if (type == null || type.equals(FILE_TYPE)) {\n            businessObject = new FileBO(path, modernServer);\n        } else if (type.equals(DB_TYPE)) {\n            throw new UnsupportedOperationException(\"Not supported yet.\");\n        }\n    }\n\n    public Vector<Group> loadGroupsAndUsers() {\n        return businessObject.loadGroupsAndUsers();\n    }\n\n    public Vector<Room> loadRooms() {\n        return businessObject.loadRooms();\n    }\n\n    public Hashtable<Integer, String> getPasswords() {\n        return businessObject.getPasswords();\n    }\n\n    public User createUser(User user) {\n        return businessObject.createUser(user);\n    }\n\n    public Group createGroup(Group group) {\n        return businessObject.createGroup(group);\n    }\n\n    public Room createRoom(Room room) {\n        return businessObject.createRoom(room);\n    }\n\n    public User delUser(User user) {\n        return businessObject.delUser(user);\n    }\n\n    public Group delGroup(Group group) {\n        return businessObject.delGroup(group);\n    }\n\n    public Room delRoom(Room room) {\n        return businessObject.delRoom(room);\n    }\n\n    public User updateUser(User user) {\n        return businessObject.updateUser(user);\n    }\n\n    public Group updateGroup(Group group) {\n        return businessObject.updateGroup(group);\n    }\n\n    public Room updateRoom(Room room) {\n        return businessObject.updateRoom(room);\n    }\n\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\n        return businessObject.updatePassword(userId, oldPass, newPass);\n    }\n\n    public User getAdminUser() {\n        return businessObject.getAdminUser();\n    }\n\n    public User resetUserPass(User user) {\n        return businessObject.resetUserPass(user);\n    }\n\n    public User updateUserGroup(User user) {\n        return businessObject.updateUserGroup(user);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bd/UsersBDTest13.java",
		"test_prompt": "// UsersBDTest13.java\npackage osa.ora.server.bd;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.bo.FileBO;\nimport osa.ora.server.bo.IBO;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UsersBD}.\n* It contains ten unit test cases for the {@link UsersBD#updateUserGroup(User)} method.\n*/\nclass UsersBDTest13 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest0.java",
		"test_prompt": "// ModernChatServerTest0.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServerTest0 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest1.java",
		"test_prompt": "// ModernChatServerTest1.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServerTest1 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest2.java",
		"test_prompt": "// ModernChatServerTest2.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServerTest2 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest3.java",
		"test_prompt": "// ModernChatServerTest3.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServerTest3 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest4.java",
		"test_prompt": "// ModernChatServerTest4.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServerTest4 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest5.java",
		"test_prompt": "// ModernChatServerTest5.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#loadGroupsAndUsers(String)} method.\n*/\nclass ModernChatServerTest5 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest6.java",
		"test_prompt": "// ModernChatServerTest6.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendTextMessage(TextMessage)} method.\n*/\nclass ModernChatServerTest6 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest7.java",
		"test_prompt": "// ModernChatServerTest7.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServerTest7 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest8.java",
		"test_prompt": "// ModernChatServerTest8.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServerTest8 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest9.java",
		"test_prompt": "// ModernChatServerTest9.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServerTest9 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest10.java",
		"test_prompt": "// ModernChatServerTest10.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServerTest10 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest11.java",
		"test_prompt": "// ModernChatServerTest11.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServerTest11 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest12.java",
		"test_prompt": "// ModernChatServerTest12.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#createUser(User, String)} method.\n*/\nclass ModernChatServerTest12 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest13.java",
		"test_prompt": "// ModernChatServerTest13.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#createGroup(Group, String)} method.\n*/\nclass ModernChatServerTest13 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest14.java",
		"test_prompt": "// ModernChatServerTest14.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#createRoom(Room, String)} method.\n*/\nclass ModernChatServerTest14 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest15.java",
		"test_prompt": "// ModernChatServerTest15.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#delUser(User, String)} method.\n*/\nclass ModernChatServerTest15 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest16.java",
		"test_prompt": "// ModernChatServerTest16.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#delGroup(Group, String)} method.\n*/\nclass ModernChatServerTest16 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest17.java",
		"test_prompt": "// ModernChatServerTest17.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#delRoom(Room, String)} method.\n*/\nclass ModernChatServerTest17 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest18.java",
		"test_prompt": "// ModernChatServerTest18.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#updateUser(User, String)} method.\n*/\nclass ModernChatServerTest18 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest19.java",
		"test_prompt": "// ModernChatServerTest19.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#updateGroup(Group, String)} method.\n*/\nclass ModernChatServerTest19 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest20.java",
		"test_prompt": "// ModernChatServerTest20.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#updateRoom(Room, String)} method.\n*/\nclass ModernChatServerTest20 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest21.java",
		"test_prompt": "// ModernChatServerTest21.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#kickOffUsers(String, String)} method.\n*/\nclass ModernChatServerTest21 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest22.java",
		"test_prompt": "// ModernChatServerTest22.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#loadRooms(String)} method.\n*/\nclass ModernChatServerTest22 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest23.java",
		"test_prompt": "// ModernChatServerTest23.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServerTest23 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest24.java",
		"test_prompt": "// ModernChatServerTest24.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#resetUserPass(User, String)} method.\n*/\nclass ModernChatServerTest24 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest25.java",
		"test_prompt": "// ModernChatServerTest25.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#updateUserGroup(User, String)} method.\n*/\nclass ModernChatServerTest25 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest26.java",
		"test_prompt": "// ModernChatServerTest26.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#returnOnlineIPs(String)} method.\n*/\nclass ModernChatServerTest26 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest27.java",
		"test_prompt": "// ModernChatServerTest27.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#kickOffUser(int, String)} method.\n*/\nclass ModernChatServerTest27 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest28.java",
		"test_prompt": "// ModernChatServerTest28.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendGlobalTextAnn(String, String)} method.\n*/\nclass ModernChatServerTest28 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest29.java",
		"test_prompt": "// ModernChatServerTest29.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendGlobalSecureTextAnn(String, String)} method.\n*/\nclass ModernChatServerTest29 {"
	},
	{
		"original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServerTest30.java",
		"test_prompt": "// ModernChatServerTest30.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#refreshContactList(String)} method.\n*/\nclass ModernChatServerTest30 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest0.java",
		"test_prompt": "// AdminAppTest0.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#loadGroups()} method.\n*/\nclass AdminAppTest0 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest1.java",
		"test_prompt": "// AdminAppTest1.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#changePassword(String, String)} method.\n*/\nclass AdminAppTest1 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest2.java",
		"test_prompt": "// AdminAppTest2.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#createUser(User)} method.\n*/\nclass AdminAppTest2 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest3.java",
		"test_prompt": "// AdminAppTest3.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#createGroup(Group)} method.\n*/\nclass AdminAppTest3 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest4.java",
		"test_prompt": "// AdminAppTest4.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#createRoom(Room)} method.\n*/\nclass AdminAppTest4 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest5.java",
		"test_prompt": "// AdminAppTest5.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#delUser(User)} method.\n*/\nclass AdminAppTest5 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest6.java",
		"test_prompt": "// AdminAppTest6.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#delGroup(Group)} method.\n*/\nclass AdminAppTest6 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest7.java",
		"test_prompt": "// AdminAppTest7.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#delRoom(Room)} method.\n*/\nclass AdminAppTest7 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest8.java",
		"test_prompt": "// AdminAppTest8.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#updateUser(User)} method.\n*/\nclass AdminAppTest8 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest9.java",
		"test_prompt": "// AdminAppTest9.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#updateUserGroup(User)} method.\n*/\nclass AdminAppTest9 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest10.java",
		"test_prompt": "// AdminAppTest10.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#updateGroup(Group)} method.\n*/\nclass AdminAppTest10 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest11.java",
		"test_prompt": "// AdminAppTest11.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#updateRoom(Room)} method.\n*/\nclass AdminAppTest11 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest12.java",
		"test_prompt": "// AdminAppTest12.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#ping()} method.\n*/\nclass AdminAppTest12 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest13.java",
		"test_prompt": "// AdminAppTest13.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#resetUserPass(User)} method.\n*/\nclass AdminAppTest13 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest14.java",
		"test_prompt": "// AdminAppTest14.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#sendGlobalTextAnn(String)} method.\n*/\nclass AdminAppTest14 {"
	},
	{
		"original_code": "// AdminApp.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\n\n/**\n * @author ooransa\n */\npublic class AdminApp {\n\n    private ServerAdminInterface serverAdminInterface;\n\n    private Vector<Group> groups;\n\n    private Vector<Room> rooms;\n\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\n\n    private User user;\n\n    private JFrame chatAdminFrame;\n\n    private JDialog loginDialog;\n\n    private static String path = \"\";\n\n    private AdminSettingBean adminSettingBean;\n\n    private ControlPanel controlPanel;\n\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\n\n    private Hashtable<Integer, String> connectedClientsIPs;\n\n    private int securityMode;\n\n    private String rootNode;\n\n    private String authToken;\n\n    private String securityToke;\n\n    private StringEncrypter stringEnc;\n\n    /**\n     * main method for admin\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            AdminApp adminApp = new AdminApp();\n        } catch (RemoteException ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error in Running!\");\n        }\n    }\n\n    public AdminApp() throws RemoteException {\n        connectedClientsIPs = new Hashtable<Integer, String>(0);\n        groups = new Vector<Group>(0);\n        rooms = new Vector<Room>(0);\n        try {\n            path = AdminApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        }\n        path = path.substring(0, path.lastIndexOf('/') + 1);\n        adminSettingBean = new AdminSettingBean(path);\n        try {\n            if (lookString instanceof String) {\n                LiquidLookAndFeel.setLiquidDecorations(true);\n                UIManager.setLookAndFeel((String) lookString);\n            }\n        } catch (Exception e1) {\n            e1.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\n        }\n        chatAdminFrame = new JFrame();\n        chatAdminFrame.setTitle(\"Free Instant Messenger - Admin Interface\");\n        chatAdminFrame.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        chatAdminFrame.setSize(580, 455);\n        Dimension frameSize = chatAdminFrame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        chatAdminFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        chatAdminFrame.setResizable(false);\n        chatAdminFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        loginDialog = new JDialog(getChatAdminFrame(), \"Login\", true);\n        AdminLoginPanel loginPanel = new AdminLoginPanel(this);\n        loginDialog.setSize(300, 150);\n        //loginDialog.setUndecorated(true);\n        loginDialog.setLocationRelativeTo(chatAdminFrame);\n        loginDialog.setAlwaysOnTop(true);\n        loginDialog.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        loginDialog.setResizable(false);\n        loginDialog.getContentPane().add(loginPanel);\n        loginDialog.setVisible(true);\n    }\n\n    public void initServer() throws Exception {\n        //lookup for the server\n        Registry reg = null;\n        reg = LocateRegistry.getRegistry(adminSettingBean.getServerURL(), Integer.parseInt(adminSettingBean.getServerPort()));\n        System.out.println(\"trying to connect to the FIM server .....\");\n        try {\n            serverAdminInterface = (ServerAdminInterface) reg.lookup(\"ModernChatServer\");\n            System.out.println(\"connected to the FIM server .....\");\n        } catch (RemoteException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Can't find this FIM Server!\");\n        } catch (NotBoundException ex) {\n            //ex.printStackTrace();\n            throw new Exception(\"Server invalid IP/Port or FIM Server not running!\");\n        }\n    }\n\n    public void login(String userEmail, String password) throws Exception {\n        if (serverAdminInterface == null) {\n            initServer();\n        }\n        stringEnc = StringEncrypter.getInstance(password);\n        LoginBean loginBean = serverAdminInterface.signInAsAdmin(StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password));\n        if (loginBean == null) {\n            throw new Exception(\"Invalid User Email or Password!\");\n        } else {\n            authToken = loginBean.getAuthToken();\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\n            stringEnc = StringEncrypter.getInstance(securityToke);\n            user = loginBean.getUser();\n            loginDialog.setVisible(false);\n            controlPanel = new ControlPanel(this);\n            getChatAdminFrame().getContentPane().add(controlPanel);\n            getChatAdminFrame().setVisible(true);\n            try {\n                securityMode = serverAdminInterface.getSecurityMode(authToken);\n                rootNode = serverAdminInterface.getRootNode(authToken);\n                setGroups(loadGroups());\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Groups From FIM Server!\");\n            }\n            try {\n                setRooms(serverAdminInterface.loadRooms(authToken));\n            } catch (RemoteException ex) {\n                ex.printStackTrace();\n                throw new Exception(\"Error During Getting All Rooms From FIM Server!\");\n            }\n        }\n    }\n\n    public Vector<Group> loadGroups() throws RemoteException {\n        groups = serverAdminInterface.loadGroupsAndUsers(authToken);\n        return groups;\n    }\n\n    public String changePassword(String oldPass, String newPass) {\n        ResultBean result = null;\n        try {\n            result = serverAdminInterface.changeAdminPassword(StringEncoder64.encodeStringUTF8(user.getEmail()), stringEnc.encrypt(oldPass), stringEnc.encrypt(newPass));\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"Error: \" + ex.getMessage();\n        }\n        if (result.isSuccess()) {\n            return \"New Password Applied Successfully!\";\n        } else {\n            if (result.getAction() == IConstant.ERROR) {\n                //set user status in the tab and list as offline !\n                return \"Error: \" + result.getMessage();\n            } else {\n                return \"Failed to Change Password!\";\n            }\n        }\n    }\n\n    /**\n     * @return the errorIcon\n     */\n    public ImageIcon getErrorIcon() {\n        return errorIcon;\n    }\n\n    /**\n     * @return the loginDialog\n     */\n    public JDialog getLoginDialog() {\n        return loginDialog;\n    }\n\n    /**\n     * @return the chatAdminFrame\n     */\n    public JFrame getChatAdminFrame() {\n        return chatAdminFrame;\n    }\n\n    /**\n     * @return the groups\n     */\n    public Vector<Group> getGroups() {\n        return groups;\n    }\n\n    /**\n     * @param groups the groups to set\n     */\n    public void setGroups(Vector<Group> groups) {\n        this.groups = groups;\n    }\n\n    /**\n     * @return the rooms\n     */\n    public Vector<Room> getRooms() {\n        return rooms;\n    }\n\n    /**\n     * @param rooms the rooms to set\n     */\n    public void setRooms(Vector<Room> rooms) {\n        this.rooms = rooms;\n    }\n\n    public User createUser(User user) throws RemoteException {\n        return serverAdminInterface.createUser(user, authToken);\n    }\n\n    public Group createGroup(Group group) throws RemoteException {\n        return serverAdminInterface.createGroup(group, authToken);\n    }\n\n    public Room createRoom(Room room) throws RemoteException {\n        return serverAdminInterface.createRoom(room, authToken);\n    }\n\n    public User delUser(User user) throws RemoteException {\n        return serverAdminInterface.delUser(user, authToken);\n    }\n\n    public Group delGroup(Group group) throws RemoteException {\n        return serverAdminInterface.delGroup(group, authToken);\n    }\n\n    public Room delRoom(Room room) throws RemoteException {\n        return serverAdminInterface.delRoom(room, authToken);\n    }\n\n    public User updateUser(User user) throws RemoteException {\n        return serverAdminInterface.updateUser(user, authToken);\n    }\n\n    public User updateUserGroup(User user) throws RemoteException {\n        return serverAdminInterface.updateUserGroup(user, authToken);\n    }\n\n    public Group updateGroup(Group group) throws RemoteException {\n        return serverAdminInterface.updateGroup(group, authToken);\n    }\n\n    public Room updateRoom(Room room) throws RemoteException {\n        return serverAdminInterface.updateRoom(room, authToken);\n    }\n\n    public boolean setNewDefaultPassword(String newPass) throws RemoteException {\n        return serverAdminInterface.setNewDefaultPassword(stringEnc.encrypt(newPass), authToken);\n    }\n\n    public void shutdown(String justification) throws RemoteException {\n        serverAdminInterface.ping();\n        try {\n            serverAdminInterface.shutdownServer(justification, authToken);\n        } catch (Throwable t) {\n            //nothing to done\n        }\n    }\n\n    public void kickOffUsers(String justification) throws RemoteException {\n        serverAdminInterface.kickOffUsers(justification, authToken);\n    }\n\n    public void kickOffUser(int userId) throws RemoteException {\n        serverAdminInterface.kickOffUser(userId, authToken);\n    }\n\n    public boolean ping() throws Exception {\n        try {\n            return serverAdminInterface.ping();\n        } catch (Exception ex) {\n            try {\n                initServer();\n                return serverAdminInterface.ping();\n            } catch (Exception ex1) {\n                throw ex1;\n            }\n        }\n    }\n\n    public User resetUserPass(User user) throws RemoteException {\n        return serverAdminInterface.resetUserPass(user, authToken);\n    }\n\n    public boolean setLogLevel(int level) throws RemoteException {\n        return serverAdminInterface.setLogLevel(level, true, authToken);\n    }\n\n    /**\n     * @return the connectedClientsIPs\n     */\n    public Hashtable<Integer, String> getConnectedClientsIPs() {\n        return connectedClientsIPs;\n    }\n\n    public void returnOnlineIPs() throws RemoteException {\n        connectedClientsIPs = serverAdminInterface.returnOnlineIPs(authToken);\n    }\n\n    public int setSecurityLevel(int level) throws RemoteException {\n        securityMode = level;\n        return serverAdminInterface.setSecurityMode(level, authToken);\n    }\n\n    public int getLogLevel() throws RemoteException {\n        return serverAdminInterface.getLogLevel(authToken);\n    }\n\n    public int getSecurityLevel() throws RemoteException {\n        return serverAdminInterface.getSecurityMode(authToken);\n    }\n\n    public boolean sendGlobalTextAnn(String msg) throws RemoteException {\n        if (securityMode == 0) {\n            return serverAdminInterface.sendGlobalTextAnn(msg, authToken);\n        } else {\n            msg = stringEnc.encrypt(msg);\n            return serverAdminInterface.sendGlobalSecureTextAnn(msg, authToken);\n        }\n    }\n\n    public boolean setNewRootNode(String rootNode) throws RemoteException {\n        this.rootNode = rootNode;\n        return serverAdminInterface.setRootNode(rootNode, authToken);\n    }\n\n    public boolean refreshContactList() throws RemoteException {\n        return serverAdminInterface.refreshContactList(authToken);\n    }\n\n    /**\n     * @return the rootNode\n     */\n    public String getRootNode() {\n        return rootNode;\n    }\n\n    /**\n     * @return the adminSettingBean\n     */\n    public AdminSettingBean getAdminSettingBean() {\n        return adminSettingBean;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/admin/AdminAppTest15.java",
		"test_prompt": "// AdminAppTest15.java\npackage osa.ora.server.admin;\n\nimport osa.ora.server.*;\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.net.URISyntaxException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.UIManager;\nimport osa.ora.server.admin.ui.AdminLoginPanel;\nimport osa.ora.server.admin.ui.ControlPanel;\nimport osa.ora.server.beans.AdminSettingBean;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdminApp}.\n* It contains ten unit test cases for the {@link AdminApp#refreshContactList()} method.\n*/\nclass AdminAppTest15 {"
	},
	{
		"original_code": "// FileEncrypter.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class FileEncrypter {\n\n    private static FileEncrypter fileEncrypter = null;\n\n    private Cipher enCipther;\n\n    private Cipher deCipther;\n\n    /**\n     * Singleton\n     */\n    public static FileEncrypter getInstance() {\n        if (fileEncrypter == null)\n            fileEncrypter = new FileEncrypter(\"FIM\".getBytes());\n        return fileEncrypter;\n    }\n\n    public static FileEncrypter getInstanceInit(byte[] strkey) {\n        fileEncrypter = new FileEncrypter(strkey);\n        return fileEncrypter;\n    }\n\n    /**\n     * private Constructor used to create this object.  Responsible for setting\n     * and initializing this object's encrypter and decrypter Chipher instances\n     * given a Pass Phrase and algorithm.\n     * @param strkey Pass the key used to initialize both the encrypter and\n     *                   decrypter instances.\n     */\n    private FileEncrypter(byte[] strkey) {\n        byte[] ivr = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\n        try {\n            SecretKeySpec key = new SecretKeySpec(strkey, \"Blowfish\");\n            enCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            deCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            IvParameterSpec oIV = new IvParameterSpec(ivr);\n            enCipther.init(Cipher.ENCRYPT_MODE, key, oIV);\n            deCipther.init(Cipher.DECRYPT_MODE, key, oIV);\n        } catch (Exception e) {\n            System.out.println(\"EXCEPTION:\" + e.getMessage());\n        }\n    }\n\n    /**\n     * to encrypt a box of byte array\n     * @param to_encrypt\n     * @return byte[]\n     */\n    private byte[] encryptBlowfish(byte[] to_encrypt) {\n        try {\n            //to_encrypt=StringEncoder64.encode(to_encrypt).getBytes(\"UTF8\");\n            return enCipther.doFinal(to_encrypt);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to decrypt a box of byte array\n     * @param to_decrypt\n     * @return byte[]\n     */\n    private byte[] decryptBlowfish(byte[] to_decrypt) {\n        try {\n            to_decrypt = deCipther.doFinal(to_decrypt);\n            //to_decrypt=StringEncoder64.decode(new String(to_decrypt,\"UTF8\"));\n            return to_decrypt;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to encrypt file using temp file and return the data into byte[]\n     * and delete the temp file\n     * @param file\n     * @param file2\n     * @return byte[] of encrypted file\n     */\n    public byte[] fileEncrypt(File file, File file2) {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            fis = new FileInputStream(file);\n            int lenght = fis.available();\n            //System.out.println(\"Length=\"+lenght);\n            String len = \"\" + lenght;\n            while (len.length() < 8) {\n                len = \"0\" + len;\n            }\n            fos.write(len.getBytes());\n            byte[] data = null;\n            for (int i = 0; i < lenght; i = i + 8) {\n                data = new byte[8];\n                fis.read(data);\n                data = StringEncoder64.encode(data).getBytes(\"UTF8\");\n                byte[] enc = encryptBlowfish(new String(data).getBytes(\"UTF8\"));\n                //System.out.println(\"Length=\"+enc.length);\n                fos.write(enc);\n            }\n            fos.close();\n            fis.close();\n            fis = new FileInputStream(file2);\n            int n = fis.available();\n            data = new byte[n];\n            fis.read(data);\n            fis.close();\n            file2.delete();\n            return data;\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return null;\n        } finally {\n            try {\n                if (fis != null)\n                    fis.close();\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * to decrypt array of bytes and create an output file\n     * @param inputData\n     * @param file2 the decrypted file.\n     */\n    public void fileDecrypt(byte[] inputData, File file2) {\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            byte[] data = new byte[8];\n            System.arraycopy(inputData, 0, data, 0, 8);\n            int lenght = Integer.parseInt(new String(data));\n            //System.out.println(\"Original size=\"+lenght);\n            int partitions = lenght / 8;\n            //System.out.println(\"partitions=\"+partitions);\n            int last = lenght % 8;\n            //System.out.println(\"last size=\"+last);\n            int current = 0;\n            for (int i = 0; i < partitions; i++) {\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + i * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                fos.write(dec);\n                //System.out.println(\"Current=\"+current);\n                current++;\n            }\n            if (last != 0) {\n                //System.out.println(\"in last\");\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + partitions * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                byte[] temp = new byte[last];\n                System.arraycopy(dec, 0, temp, 0, last);\n                //System.out.println(\"last=\"+temp);\n                fos.write(temp);\n            }\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return;\n        } finally {\n            try {\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * main test method\n     * @param args\n     */\n    public static void main(String[] args) {\n        FileEncrypter stringEnc = FileEncrypter.getInstanceInit(\"Modern Chat\".getBytes());\n        try {\n            byte[] data = stringEnc.fileEncrypt(new File(\"/osama2.zip\"), new File(\"/osama3.zip\"));\n            stringEnc.fileDecrypt(data, new File(\"/osama4.zip\"));\n        } catch (Exception ex) {\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypterTest0.java",
		"test_prompt": "// FileEncrypterTest0.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEncrypter}.\n* It contains ten unit test cases for the {@link FileEncrypter#getInstance()} method.\n*/\nclass FileEncrypterTest0 {"
	},
	{
		"original_code": "// FileEncrypter.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class FileEncrypter {\n\n    private static FileEncrypter fileEncrypter = null;\n\n    private Cipher enCipther;\n\n    private Cipher deCipther;\n\n    /**\n     * Singleton\n     */\n    public static FileEncrypter getInstance() {\n        if (fileEncrypter == null)\n            fileEncrypter = new FileEncrypter(\"FIM\".getBytes());\n        return fileEncrypter;\n    }\n\n    public static FileEncrypter getInstanceInit(byte[] strkey) {\n        fileEncrypter = new FileEncrypter(strkey);\n        return fileEncrypter;\n    }\n\n    /**\n     * private Constructor used to create this object.  Responsible for setting\n     * and initializing this object's encrypter and decrypter Chipher instances\n     * given a Pass Phrase and algorithm.\n     * @param strkey Pass the key used to initialize both the encrypter and\n     *                   decrypter instances.\n     */\n    private FileEncrypter(byte[] strkey) {\n        byte[] ivr = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\n        try {\n            SecretKeySpec key = new SecretKeySpec(strkey, \"Blowfish\");\n            enCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            deCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            IvParameterSpec oIV = new IvParameterSpec(ivr);\n            enCipther.init(Cipher.ENCRYPT_MODE, key, oIV);\n            deCipther.init(Cipher.DECRYPT_MODE, key, oIV);\n        } catch (Exception e) {\n            System.out.println(\"EXCEPTION:\" + e.getMessage());\n        }\n    }\n\n    /**\n     * to encrypt a box of byte array\n     * @param to_encrypt\n     * @return byte[]\n     */\n    private byte[] encryptBlowfish(byte[] to_encrypt) {\n        try {\n            //to_encrypt=StringEncoder64.encode(to_encrypt).getBytes(\"UTF8\");\n            return enCipther.doFinal(to_encrypt);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to decrypt a box of byte array\n     * @param to_decrypt\n     * @return byte[]\n     */\n    private byte[] decryptBlowfish(byte[] to_decrypt) {\n        try {\n            to_decrypt = deCipther.doFinal(to_decrypt);\n            //to_decrypt=StringEncoder64.decode(new String(to_decrypt,\"UTF8\"));\n            return to_decrypt;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to encrypt file using temp file and return the data into byte[]\n     * and delete the temp file\n     * @param file\n     * @param file2\n     * @return byte[] of encrypted file\n     */\n    public byte[] fileEncrypt(File file, File file2) {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            fis = new FileInputStream(file);\n            int lenght = fis.available();\n            //System.out.println(\"Length=\"+lenght);\n            String len = \"\" + lenght;\n            while (len.length() < 8) {\n                len = \"0\" + len;\n            }\n            fos.write(len.getBytes());\n            byte[] data = null;\n            for (int i = 0; i < lenght; i = i + 8) {\n                data = new byte[8];\n                fis.read(data);\n                data = StringEncoder64.encode(data).getBytes(\"UTF8\");\n                byte[] enc = encryptBlowfish(new String(data).getBytes(\"UTF8\"));\n                //System.out.println(\"Length=\"+enc.length);\n                fos.write(enc);\n            }\n            fos.close();\n            fis.close();\n            fis = new FileInputStream(file2);\n            int n = fis.available();\n            data = new byte[n];\n            fis.read(data);\n            fis.close();\n            file2.delete();\n            return data;\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return null;\n        } finally {\n            try {\n                if (fis != null)\n                    fis.close();\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * to decrypt array of bytes and create an output file\n     * @param inputData\n     * @param file2 the decrypted file.\n     */\n    public void fileDecrypt(byte[] inputData, File file2) {\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            byte[] data = new byte[8];\n            System.arraycopy(inputData, 0, data, 0, 8);\n            int lenght = Integer.parseInt(new String(data));\n            //System.out.println(\"Original size=\"+lenght);\n            int partitions = lenght / 8;\n            //System.out.println(\"partitions=\"+partitions);\n            int last = lenght % 8;\n            //System.out.println(\"last size=\"+last);\n            int current = 0;\n            for (int i = 0; i < partitions; i++) {\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + i * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                fos.write(dec);\n                //System.out.println(\"Current=\"+current);\n                current++;\n            }\n            if (last != 0) {\n                //System.out.println(\"in last\");\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + partitions * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                byte[] temp = new byte[last];\n                System.arraycopy(dec, 0, temp, 0, last);\n                //System.out.println(\"last=\"+temp);\n                fos.write(temp);\n            }\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return;\n        } finally {\n            try {\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * main test method\n     * @param args\n     */\n    public static void main(String[] args) {\n        FileEncrypter stringEnc = FileEncrypter.getInstanceInit(\"Modern Chat\".getBytes());\n        try {\n            byte[] data = stringEnc.fileEncrypt(new File(\"/osama2.zip\"), new File(\"/osama3.zip\"));\n            stringEnc.fileDecrypt(data, new File(\"/osama4.zip\"));\n        } catch (Exception ex) {\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypterTest1.java",
		"test_prompt": "// FileEncrypterTest1.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEncrypter}.\n* It contains ten unit test cases for the {@link FileEncrypter#getInstanceInit(byte[])} method.\n*/\nclass FileEncrypterTest1 {"
	},
	{
		"original_code": "// FileEncrypter.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class FileEncrypter {\n\n    private static FileEncrypter fileEncrypter = null;\n\n    private Cipher enCipther;\n\n    private Cipher deCipther;\n\n    /**\n     * Singleton\n     */\n    public static FileEncrypter getInstance() {\n        if (fileEncrypter == null)\n            fileEncrypter = new FileEncrypter(\"FIM\".getBytes());\n        return fileEncrypter;\n    }\n\n    public static FileEncrypter getInstanceInit(byte[] strkey) {\n        fileEncrypter = new FileEncrypter(strkey);\n        return fileEncrypter;\n    }\n\n    /**\n     * private Constructor used to create this object.  Responsible for setting\n     * and initializing this object's encrypter and decrypter Chipher instances\n     * given a Pass Phrase and algorithm.\n     * @param strkey Pass the key used to initialize both the encrypter and\n     *                   decrypter instances.\n     */\n    private FileEncrypter(byte[] strkey) {\n        byte[] ivr = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\n        try {\n            SecretKeySpec key = new SecretKeySpec(strkey, \"Blowfish\");\n            enCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            deCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            IvParameterSpec oIV = new IvParameterSpec(ivr);\n            enCipther.init(Cipher.ENCRYPT_MODE, key, oIV);\n            deCipther.init(Cipher.DECRYPT_MODE, key, oIV);\n        } catch (Exception e) {\n            System.out.println(\"EXCEPTION:\" + e.getMessage());\n        }\n    }\n\n    /**\n     * to encrypt a box of byte array\n     * @param to_encrypt\n     * @return byte[]\n     */\n    private byte[] encryptBlowfish(byte[] to_encrypt) {\n        try {\n            //to_encrypt=StringEncoder64.encode(to_encrypt).getBytes(\"UTF8\");\n            return enCipther.doFinal(to_encrypt);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to decrypt a box of byte array\n     * @param to_decrypt\n     * @return byte[]\n     */\n    private byte[] decryptBlowfish(byte[] to_decrypt) {\n        try {\n            to_decrypt = deCipther.doFinal(to_decrypt);\n            //to_decrypt=StringEncoder64.decode(new String(to_decrypt,\"UTF8\"));\n            return to_decrypt;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to encrypt file using temp file and return the data into byte[]\n     * and delete the temp file\n     * @param file\n     * @param file2\n     * @return byte[] of encrypted file\n     */\n    public byte[] fileEncrypt(File file, File file2) {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            fis = new FileInputStream(file);\n            int lenght = fis.available();\n            //System.out.println(\"Length=\"+lenght);\n            String len = \"\" + lenght;\n            while (len.length() < 8) {\n                len = \"0\" + len;\n            }\n            fos.write(len.getBytes());\n            byte[] data = null;\n            for (int i = 0; i < lenght; i = i + 8) {\n                data = new byte[8];\n                fis.read(data);\n                data = StringEncoder64.encode(data).getBytes(\"UTF8\");\n                byte[] enc = encryptBlowfish(new String(data).getBytes(\"UTF8\"));\n                //System.out.println(\"Length=\"+enc.length);\n                fos.write(enc);\n            }\n            fos.close();\n            fis.close();\n            fis = new FileInputStream(file2);\n            int n = fis.available();\n            data = new byte[n];\n            fis.read(data);\n            fis.close();\n            file2.delete();\n            return data;\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return null;\n        } finally {\n            try {\n                if (fis != null)\n                    fis.close();\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * to decrypt array of bytes and create an output file\n     * @param inputData\n     * @param file2 the decrypted file.\n     */\n    public void fileDecrypt(byte[] inputData, File file2) {\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            byte[] data = new byte[8];\n            System.arraycopy(inputData, 0, data, 0, 8);\n            int lenght = Integer.parseInt(new String(data));\n            //System.out.println(\"Original size=\"+lenght);\n            int partitions = lenght / 8;\n            //System.out.println(\"partitions=\"+partitions);\n            int last = lenght % 8;\n            //System.out.println(\"last size=\"+last);\n            int current = 0;\n            for (int i = 0; i < partitions; i++) {\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + i * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                fos.write(dec);\n                //System.out.println(\"Current=\"+current);\n                current++;\n            }\n            if (last != 0) {\n                //System.out.println(\"in last\");\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + partitions * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                byte[] temp = new byte[last];\n                System.arraycopy(dec, 0, temp, 0, last);\n                //System.out.println(\"last=\"+temp);\n                fos.write(temp);\n            }\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return;\n        } finally {\n            try {\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * main test method\n     * @param args\n     */\n    public static void main(String[] args) {\n        FileEncrypter stringEnc = FileEncrypter.getInstanceInit(\"Modern Chat\".getBytes());\n        try {\n            byte[] data = stringEnc.fileEncrypt(new File(\"/osama2.zip\"), new File(\"/osama3.zip\"));\n            stringEnc.fileDecrypt(data, new File(\"/osama4.zip\"));\n        } catch (Exception ex) {\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypterTest2.java",
		"test_prompt": "// FileEncrypterTest2.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEncrypter}.\n* It contains ten unit test cases for the {@link FileEncrypter#fileEncrypt(File, File)} method.\n*/\nclass FileEncrypterTest2 {"
	},
	{
		"original_code": "// StringEncrypter.java\npackage osa.ora.server.utils;\r\n\r\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.SecretKey;\r\nimport java.security.spec.KeySpec;\r\nimport java.security.spec.AlgorithmParameterSpec;\r\nimport javax.crypto.spec.PBEKeySpec;\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.PBEParameterSpec;\r\n\r\npublic class StringEncrypter {\r\n\r\n    public char[] keyUsed = \"FIM\".toCharArray();\r\n\r\n    Cipher ecipher;\r\n\r\n    Cipher dcipher;\r\n\r\n    //private static StringEncrypter stringEncrypter = null;\r\n    /**\r\n     * Singleton\r\n     */\r\n    public static StringEncrypter getInstance(String initKey) {\r\n        return new StringEncrypter(initKey);\r\n    }\r\n\r\n    /**\r\n     * private Constructor used to create this object.  Responsible for setting\r\n     * and initializing this object's encrypter and decrypter Chipher instances\r\n     * given a Pass Phrase and algorithm.\r\n     * @param passPhrase Pass Phrase used to initialize both the encrypter and\r\n     *                   decrypter instances.\r\n     */\r\n    private StringEncrypter(String initKey) {\r\n        keyUsed = initKey.toCharArray();\r\n        // 8-bytes Salt\r\n        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\r\n        // Iteration count\r\n        int iterationCount = 19;\r\n        try {\r\n            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);\r\n            SecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\r\n            ecipher = Cipher.getInstance(key.getAlgorithm());\r\n            dcipher = Cipher.getInstance(key.getAlgorithm());\r\n            // Prepare the parameters to the cipthers\r\n            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);\r\n            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\r\n            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\r\n        } catch (Exception e) {\r\n            System.out.println(\"EXCEPTION: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a single String as an argument and returns an Encrypted version\r\n     * of that String.\r\n     * @param str String to be encrypted\r\n     * @return <code>String</code> Encrypted version of the provided String\r\n     */\r\n    public String encrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Encode the string into bytes using utf-8\r\n            byte[] utf8 = str.getBytes(\"UTF8\");\r\n            // Encrypt\r\n            byte[] enc = ecipher.doFinal(utf8);\r\n            // Encode bytes to base64 to get a string\r\n            return StringEncoder64.encode(enc);\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Takes a encrypted String as an argument, decrypts and returns the\r\n     * decrypted String.\r\n     * @param str Encrypted String to be decrypted\r\n     * @return <code>String</code> Decrypted version of the provided String\r\n     */\r\n    public String decrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Decode base64 to get bytes\r\n            byte[] dec = StringEncoder64.decode(str);\r\n            // Decrypt\r\n            byte[] utf8 = dcipher.doFinal(dec);\r\n            // Decode using utf-8\r\n            return new String(utf8, \"UTF8\");\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypterTest0.java",
		"test_prompt": "// StringEncrypterTest0.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// StringEncrypter.java\n// -----------------------------------------------------------------------------\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncrypter}.\n* It contains ten unit test cases for the {@link StringEncrypter#getInstance(String)} method.\n*/\nclass StringEncrypterTest0 {"
	},
	{
		"original_code": "// StringEncrypter.java\npackage osa.ora.server.utils;\r\n\r\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.SecretKey;\r\nimport java.security.spec.KeySpec;\r\nimport java.security.spec.AlgorithmParameterSpec;\r\nimport javax.crypto.spec.PBEKeySpec;\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.PBEParameterSpec;\r\n\r\npublic class StringEncrypter {\r\n\r\n    public char[] keyUsed = \"FIM\".toCharArray();\r\n\r\n    Cipher ecipher;\r\n\r\n    Cipher dcipher;\r\n\r\n    //private static StringEncrypter stringEncrypter = null;\r\n    /**\r\n     * Singleton\r\n     */\r\n    public static StringEncrypter getInstance(String initKey) {\r\n        return new StringEncrypter(initKey);\r\n    }\r\n\r\n    /**\r\n     * private Constructor used to create this object.  Responsible for setting\r\n     * and initializing this object's encrypter and decrypter Chipher instances\r\n     * given a Pass Phrase and algorithm.\r\n     * @param passPhrase Pass Phrase used to initialize both the encrypter and\r\n     *                   decrypter instances.\r\n     */\r\n    private StringEncrypter(String initKey) {\r\n        keyUsed = initKey.toCharArray();\r\n        // 8-bytes Salt\r\n        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\r\n        // Iteration count\r\n        int iterationCount = 19;\r\n        try {\r\n            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);\r\n            SecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\r\n            ecipher = Cipher.getInstance(key.getAlgorithm());\r\n            dcipher = Cipher.getInstance(key.getAlgorithm());\r\n            // Prepare the parameters to the cipthers\r\n            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);\r\n            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\r\n            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\r\n        } catch (Exception e) {\r\n            System.out.println(\"EXCEPTION: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a single String as an argument and returns an Encrypted version\r\n     * of that String.\r\n     * @param str String to be encrypted\r\n     * @return <code>String</code> Encrypted version of the provided String\r\n     */\r\n    public String encrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Encode the string into bytes using utf-8\r\n            byte[] utf8 = str.getBytes(\"UTF8\");\r\n            // Encrypt\r\n            byte[] enc = ecipher.doFinal(utf8);\r\n            // Encode bytes to base64 to get a string\r\n            return StringEncoder64.encode(enc);\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Takes a encrypted String as an argument, decrypts and returns the\r\n     * decrypted String.\r\n     * @param str Encrypted String to be decrypted\r\n     * @return <code>String</code> Decrypted version of the provided String\r\n     */\r\n    public String decrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Decode base64 to get bytes\r\n            byte[] dec = StringEncoder64.decode(str);\r\n            // Decrypt\r\n            byte[] utf8 = dcipher.doFinal(dec);\r\n            // Decode using utf-8\r\n            return new String(utf8, \"UTF8\");\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypterTest1.java",
		"test_prompt": "// StringEncrypterTest1.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncrypter}.\n* It contains ten unit test cases for the {@link StringEncrypter#encrypt(String)} method.\n*/\nclass StringEncrypterTest1 {"
	},
	{
		"original_code": "// StringEncrypter.java\npackage osa.ora.server.utils;\r\n\r\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.SecretKey;\r\nimport java.security.spec.KeySpec;\r\nimport java.security.spec.AlgorithmParameterSpec;\r\nimport javax.crypto.spec.PBEKeySpec;\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.PBEParameterSpec;\r\n\r\npublic class StringEncrypter {\r\n\r\n    public char[] keyUsed = \"FIM\".toCharArray();\r\n\r\n    Cipher ecipher;\r\n\r\n    Cipher dcipher;\r\n\r\n    //private static StringEncrypter stringEncrypter = null;\r\n    /**\r\n     * Singleton\r\n     */\r\n    public static StringEncrypter getInstance(String initKey) {\r\n        return new StringEncrypter(initKey);\r\n    }\r\n\r\n    /**\r\n     * private Constructor used to create this object.  Responsible for setting\r\n     * and initializing this object's encrypter and decrypter Chipher instances\r\n     * given a Pass Phrase and algorithm.\r\n     * @param passPhrase Pass Phrase used to initialize both the encrypter and\r\n     *                   decrypter instances.\r\n     */\r\n    private StringEncrypter(String initKey) {\r\n        keyUsed = initKey.toCharArray();\r\n        // 8-bytes Salt\r\n        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\r\n        // Iteration count\r\n        int iterationCount = 19;\r\n        try {\r\n            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);\r\n            SecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\r\n            ecipher = Cipher.getInstance(key.getAlgorithm());\r\n            dcipher = Cipher.getInstance(key.getAlgorithm());\r\n            // Prepare the parameters to the cipthers\r\n            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);\r\n            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\r\n            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\r\n        } catch (Exception e) {\r\n            System.out.println(\"EXCEPTION: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a single String as an argument and returns an Encrypted version\r\n     * of that String.\r\n     * @param str String to be encrypted\r\n     * @return <code>String</code> Encrypted version of the provided String\r\n     */\r\n    public String encrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Encode the string into bytes using utf-8\r\n            byte[] utf8 = str.getBytes(\"UTF8\");\r\n            // Encrypt\r\n            byte[] enc = ecipher.doFinal(utf8);\r\n            // Encode bytes to base64 to get a string\r\n            return StringEncoder64.encode(enc);\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Takes a encrypted String as an argument, decrypts and returns the\r\n     * decrypted String.\r\n     * @param str Encrypted String to be decrypted\r\n     * @return <code>String</code> Decrypted version of the provided String\r\n     */\r\n    public String decrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Decode base64 to get bytes\r\n            byte[] dec = StringEncoder64.decode(str);\r\n            // Decrypt\r\n            byte[] utf8 = dcipher.doFinal(dec);\r\n            // Decode using utf-8\r\n            return new String(utf8, \"UTF8\");\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypterTest2.java",
		"test_prompt": "// StringEncrypterTest2.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncrypter}.\n* It contains ten unit test cases for the {@link StringEncrypter#decrypt(String)} method.\n*/\nclass StringEncrypterTest2 {"
	},
	{
		"original_code": "// StringEncoder64.java\npackage osa.ora.server.utils;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class StringEncoder64 {\r\n\r\n    static final char[] charTab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\r\n\r\n    public static String encodeStringUTF8(String data) {\r\n        try {\r\n            return encode(data.getBytes(\"UTF8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String decodeStringUTF8(String data) {\r\n        try {\r\n            return new String(decode(data), \"UTF8\");\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String encode(byte[] data) {\r\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n        String ret = null;\r\n        if (encode(data, 0, data.length, byteArrayOutputStream))\r\n            ret = new String(byteArrayOutputStream.toByteArray());\r\n        return ret;\r\n    }\r\n\r\n    public static String encode(byte[] data, int start, int len) {\r\n        StringBuffer buffer = null;\r\n        return encode(data, start, len, buffer).toString();\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * appended to the given StringBuffer. If no StringBuffer is given, a new one is created automatically. The\r\n     * StringBuffer is the return value of this method.\r\n     */\r\n    public static StringBuffer encode(byte[] data, int start, int len, StringBuffer buf) {\r\n        if (buf == null)\r\n            buf = new StringBuffer(data.length * 3 / 2);\r\n        int end = len - 3;\r\n        int i = start;\r\n        // int n = 0;\r\n        while (i <= end) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(charTab[d & 63]);\r\n            i += 3;\r\n            // if (n++ >= 14) {\r\n            // n = 0;\r\n            // buf.append(\"\\r\\n\");\r\n            // }\r\n        }\r\n        if (i == start + len - 2) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(\"=\");\r\n        } else if (i == start + len - 1) {\r\n            int d = (((int) data[i]) & 0x0ff) << 16;\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(\"==\");\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * written to the given {@link OutputStream}. If no OutputStream is given, a {@link NullPointerException} is thrown.\r\n     *\r\n     * @return true if succeded to encode, false otherwise\r\n     * @throws NullPointerException if outputStream is null.\r\n     */\r\n    public static boolean encode(byte[] data, int start, int len, OutputStream outputStream) {\r\n        try {\r\n            if (outputStream == null)\r\n                throw new NullPointerException();\r\n            int end = len - 3;\r\n            int i = start;\r\n            int n = 0;\r\n            while (i <= end) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write(charTab[d & 63]);\r\n                i += 3;\r\n                if (n++ >= 14) {\r\n                    n = 0;\r\n                    outputStream.write('\\r');\r\n                    outputStream.write('\\n');\r\n                }\r\n            }\r\n            if (i == start + len - 2) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write('=');\r\n            } else if (i == start + len - 1) {\r\n                int d = (((int) data[i]) & 0x0ff) << 16;\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write('=');\r\n                outputStream.write('=');\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static int decode(char c) {\r\n        if (c >= 'A' && c <= 'Z')\r\n            return ((int) c) - 65;\r\n        else if (c >= 'a' && c <= 'z')\r\n            return ((int) c) - 97 + 26;\r\n        else if (c >= '0' && c <= '9')\r\n            return ((int) c) - 48 + 26 + 26;\r\n        else\r\n            switch(c) {\r\n                case '+':\r\n                    return 62;\r\n                case '/':\r\n                    return 63;\r\n                case '=':\r\n                    return 0;\r\n                default:\r\n                    System.out.println(\"C=\" + c);\r\n                    throw new RuntimeException(\"unexpected code: \" + c);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Decodes the given StringEncoder64 encoded String to a new byte array. The byte array holding the decoded data is returned.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        //System.out.println(\"decode String s=\"+s);\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try {\r\n            decode(s, bos);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException();\r\n        }\r\n        return bos.toByteArray();\r\n    }\r\n\r\n    public static void decode(String s, OutputStream os) throws IOException {\r\n        int i = 0;\r\n        int len = s.length();\r\n        while (true) {\r\n            while (i < len && s.charAt(i) <= ' ') i++;\r\n            if (i + 3 >= len)\r\n                break;\r\n            int tri = (decode(s.charAt(i)) << 18) + (decode(s.charAt(i + 1)) << 12) + (decode(s.charAt(i + 2)) << 6) + (decode(s.charAt(i + 3)));\r\n            os.write((tri >> 16) & 255);\r\n            if (s.charAt(i + 2) == '=')\r\n                break;\r\n            os.write((tri >> 8) & 255);\r\n            if (s.charAt(i + 3) == '=')\r\n                break;\r\n            os.write(tri & 255);\r\n            i += 4;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncoder64Test0.java",
		"test_prompt": "// StringEncoder64Test0.java\npackage osa.ora.server.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncoder64}.\n* It contains ten unit test cases for the {@link StringEncoder64#encodeStringUTF8(String)} method.\n*/\nclass StringEncoder64Test0 {"
	},
	{
		"original_code": "// StringEncoder64.java\npackage osa.ora.server.utils;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class StringEncoder64 {\r\n\r\n    static final char[] charTab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\r\n\r\n    public static String encodeStringUTF8(String data) {\r\n        try {\r\n            return encode(data.getBytes(\"UTF8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String decodeStringUTF8(String data) {\r\n        try {\r\n            return new String(decode(data), \"UTF8\");\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String encode(byte[] data) {\r\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n        String ret = null;\r\n        if (encode(data, 0, data.length, byteArrayOutputStream))\r\n            ret = new String(byteArrayOutputStream.toByteArray());\r\n        return ret;\r\n    }\r\n\r\n    public static String encode(byte[] data, int start, int len) {\r\n        StringBuffer buffer = null;\r\n        return encode(data, start, len, buffer).toString();\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * appended to the given StringBuffer. If no StringBuffer is given, a new one is created automatically. The\r\n     * StringBuffer is the return value of this method.\r\n     */\r\n    public static StringBuffer encode(byte[] data, int start, int len, StringBuffer buf) {\r\n        if (buf == null)\r\n            buf = new StringBuffer(data.length * 3 / 2);\r\n        int end = len - 3;\r\n        int i = start;\r\n        // int n = 0;\r\n        while (i <= end) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(charTab[d & 63]);\r\n            i += 3;\r\n            // if (n++ >= 14) {\r\n            // n = 0;\r\n            // buf.append(\"\\r\\n\");\r\n            // }\r\n        }\r\n        if (i == start + len - 2) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(\"=\");\r\n        } else if (i == start + len - 1) {\r\n            int d = (((int) data[i]) & 0x0ff) << 16;\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(\"==\");\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * written to the given {@link OutputStream}. If no OutputStream is given, a {@link NullPointerException} is thrown.\r\n     *\r\n     * @return true if succeded to encode, false otherwise\r\n     * @throws NullPointerException if outputStream is null.\r\n     */\r\n    public static boolean encode(byte[] data, int start, int len, OutputStream outputStream) {\r\n        try {\r\n            if (outputStream == null)\r\n                throw new NullPointerException();\r\n            int end = len - 3;\r\n            int i = start;\r\n            int n = 0;\r\n            while (i <= end) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write(charTab[d & 63]);\r\n                i += 3;\r\n                if (n++ >= 14) {\r\n                    n = 0;\r\n                    outputStream.write('\\r');\r\n                    outputStream.write('\\n');\r\n                }\r\n            }\r\n            if (i == start + len - 2) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write('=');\r\n            } else if (i == start + len - 1) {\r\n                int d = (((int) data[i]) & 0x0ff) << 16;\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write('=');\r\n                outputStream.write('=');\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static int decode(char c) {\r\n        if (c >= 'A' && c <= 'Z')\r\n            return ((int) c) - 65;\r\n        else if (c >= 'a' && c <= 'z')\r\n            return ((int) c) - 97 + 26;\r\n        else if (c >= '0' && c <= '9')\r\n            return ((int) c) - 48 + 26 + 26;\r\n        else\r\n            switch(c) {\r\n                case '+':\r\n                    return 62;\r\n                case '/':\r\n                    return 63;\r\n                case '=':\r\n                    return 0;\r\n                default:\r\n                    System.out.println(\"C=\" + c);\r\n                    throw new RuntimeException(\"unexpected code: \" + c);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Decodes the given StringEncoder64 encoded String to a new byte array. The byte array holding the decoded data is returned.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        //System.out.println(\"decode String s=\"+s);\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try {\r\n            decode(s, bos);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException();\r\n        }\r\n        return bos.toByteArray();\r\n    }\r\n\r\n    public static void decode(String s, OutputStream os) throws IOException {\r\n        int i = 0;\r\n        int len = s.length();\r\n        while (true) {\r\n            while (i < len && s.charAt(i) <= ' ') i++;\r\n            if (i + 3 >= len)\r\n                break;\r\n            int tri = (decode(s.charAt(i)) << 18) + (decode(s.charAt(i + 1)) << 12) + (decode(s.charAt(i + 2)) << 6) + (decode(s.charAt(i + 3)));\r\n            os.write((tri >> 16) & 255);\r\n            if (s.charAt(i + 2) == '=')\r\n                break;\r\n            os.write((tri >> 8) & 255);\r\n            if (s.charAt(i + 3) == '=')\r\n                break;\r\n            os.write(tri & 255);\r\n            i += 4;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncoder64Test1.java",
		"test_prompt": "// StringEncoder64Test1.java\npackage osa.ora.server.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncoder64}.\n* It contains ten unit test cases for the {@link StringEncoder64#decodeStringUTF8(String)} method.\n*/\nclass StringEncoder64Test1 {"
	},
	{
		"original_code": "// StringEncoder64.java\npackage osa.ora.server.utils;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class StringEncoder64 {\r\n\r\n    static final char[] charTab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\r\n\r\n    public static String encodeStringUTF8(String data) {\r\n        try {\r\n            return encode(data.getBytes(\"UTF8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String decodeStringUTF8(String data) {\r\n        try {\r\n            return new String(decode(data), \"UTF8\");\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String encode(byte[] data) {\r\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n        String ret = null;\r\n        if (encode(data, 0, data.length, byteArrayOutputStream))\r\n            ret = new String(byteArrayOutputStream.toByteArray());\r\n        return ret;\r\n    }\r\n\r\n    public static String encode(byte[] data, int start, int len) {\r\n        StringBuffer buffer = null;\r\n        return encode(data, start, len, buffer).toString();\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * appended to the given StringBuffer. If no StringBuffer is given, a new one is created automatically. The\r\n     * StringBuffer is the return value of this method.\r\n     */\r\n    public static StringBuffer encode(byte[] data, int start, int len, StringBuffer buf) {\r\n        if (buf == null)\r\n            buf = new StringBuffer(data.length * 3 / 2);\r\n        int end = len - 3;\r\n        int i = start;\r\n        // int n = 0;\r\n        while (i <= end) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(charTab[d & 63]);\r\n            i += 3;\r\n            // if (n++ >= 14) {\r\n            // n = 0;\r\n            // buf.append(\"\\r\\n\");\r\n            // }\r\n        }\r\n        if (i == start + len - 2) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(\"=\");\r\n        } else if (i == start + len - 1) {\r\n            int d = (((int) data[i]) & 0x0ff) << 16;\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(\"==\");\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * written to the given {@link OutputStream}. If no OutputStream is given, a {@link NullPointerException} is thrown.\r\n     *\r\n     * @return true if succeded to encode, false otherwise\r\n     * @throws NullPointerException if outputStream is null.\r\n     */\r\n    public static boolean encode(byte[] data, int start, int len, OutputStream outputStream) {\r\n        try {\r\n            if (outputStream == null)\r\n                throw new NullPointerException();\r\n            int end = len - 3;\r\n            int i = start;\r\n            int n = 0;\r\n            while (i <= end) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write(charTab[d & 63]);\r\n                i += 3;\r\n                if (n++ >= 14) {\r\n                    n = 0;\r\n                    outputStream.write('\\r');\r\n                    outputStream.write('\\n');\r\n                }\r\n            }\r\n            if (i == start + len - 2) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write('=');\r\n            } else if (i == start + len - 1) {\r\n                int d = (((int) data[i]) & 0x0ff) << 16;\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write('=');\r\n                outputStream.write('=');\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static int decode(char c) {\r\n        if (c >= 'A' && c <= 'Z')\r\n            return ((int) c) - 65;\r\n        else if (c >= 'a' && c <= 'z')\r\n            return ((int) c) - 97 + 26;\r\n        else if (c >= '0' && c <= '9')\r\n            return ((int) c) - 48 + 26 + 26;\r\n        else\r\n            switch(c) {\r\n                case '+':\r\n                    return 62;\r\n                case '/':\r\n                    return 63;\r\n                case '=':\r\n                    return 0;\r\n                default:\r\n                    System.out.println(\"C=\" + c);\r\n                    throw new RuntimeException(\"unexpected code: \" + c);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Decodes the given StringEncoder64 encoded String to a new byte array. The byte array holding the decoded data is returned.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        //System.out.println(\"decode String s=\"+s);\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try {\r\n            decode(s, bos);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException();\r\n        }\r\n        return bos.toByteArray();\r\n    }\r\n\r\n    public static void decode(String s, OutputStream os) throws IOException {\r\n        int i = 0;\r\n        int len = s.length();\r\n        while (true) {\r\n            while (i < len && s.charAt(i) <= ' ') i++;\r\n            if (i + 3 >= len)\r\n                break;\r\n            int tri = (decode(s.charAt(i)) << 18) + (decode(s.charAt(i + 1)) << 12) + (decode(s.charAt(i + 2)) << 6) + (decode(s.charAt(i + 3)));\r\n            os.write((tri >> 16) & 255);\r\n            if (s.charAt(i + 2) == '=')\r\n                break;\r\n            os.write((tri >> 8) & 255);\r\n            if (s.charAt(i + 3) == '=')\r\n                break;\r\n            os.write(tri & 255);\r\n            i += 4;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncoder64Test2.java",
		"test_prompt": "// StringEncoder64Test2.java\npackage osa.ora.server.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncoder64}.\n* It contains ten unit test cases for the {@link StringEncoder64#encode(byte[])} method.\n*/\nclass StringEncoder64Test2 {"
	},
	{
		"original_code": "// StringEncoder64.java\npackage osa.ora.server.utils;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class StringEncoder64 {\r\n\r\n    static final char[] charTab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\r\n\r\n    public static String encodeStringUTF8(String data) {\r\n        try {\r\n            return encode(data.getBytes(\"UTF8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String decodeStringUTF8(String data) {\r\n        try {\r\n            return new String(decode(data), \"UTF8\");\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String encode(byte[] data) {\r\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n        String ret = null;\r\n        if (encode(data, 0, data.length, byteArrayOutputStream))\r\n            ret = new String(byteArrayOutputStream.toByteArray());\r\n        return ret;\r\n    }\r\n\r\n    public static String encode(byte[] data, int start, int len) {\r\n        StringBuffer buffer = null;\r\n        return encode(data, start, len, buffer).toString();\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * appended to the given StringBuffer. If no StringBuffer is given, a new one is created automatically. The\r\n     * StringBuffer is the return value of this method.\r\n     */\r\n    public static StringBuffer encode(byte[] data, int start, int len, StringBuffer buf) {\r\n        if (buf == null)\r\n            buf = new StringBuffer(data.length * 3 / 2);\r\n        int end = len - 3;\r\n        int i = start;\r\n        // int n = 0;\r\n        while (i <= end) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(charTab[d & 63]);\r\n            i += 3;\r\n            // if (n++ >= 14) {\r\n            // n = 0;\r\n            // buf.append(\"\\r\\n\");\r\n            // }\r\n        }\r\n        if (i == start + len - 2) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(\"=\");\r\n        } else if (i == start + len - 1) {\r\n            int d = (((int) data[i]) & 0x0ff) << 16;\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(\"==\");\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * written to the given {@link OutputStream}. If no OutputStream is given, a {@link NullPointerException} is thrown.\r\n     *\r\n     * @return true if succeded to encode, false otherwise\r\n     * @throws NullPointerException if outputStream is null.\r\n     */\r\n    public static boolean encode(byte[] data, int start, int len, OutputStream outputStream) {\r\n        try {\r\n            if (outputStream == null)\r\n                throw new NullPointerException();\r\n            int end = len - 3;\r\n            int i = start;\r\n            int n = 0;\r\n            while (i <= end) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write(charTab[d & 63]);\r\n                i += 3;\r\n                if (n++ >= 14) {\r\n                    n = 0;\r\n                    outputStream.write('\\r');\r\n                    outputStream.write('\\n');\r\n                }\r\n            }\r\n            if (i == start + len - 2) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write('=');\r\n            } else if (i == start + len - 1) {\r\n                int d = (((int) data[i]) & 0x0ff) << 16;\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write('=');\r\n                outputStream.write('=');\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static int decode(char c) {\r\n        if (c >= 'A' && c <= 'Z')\r\n            return ((int) c) - 65;\r\n        else if (c >= 'a' && c <= 'z')\r\n            return ((int) c) - 97 + 26;\r\n        else if (c >= '0' && c <= '9')\r\n            return ((int) c) - 48 + 26 + 26;\r\n        else\r\n            switch(c) {\r\n                case '+':\r\n                    return 62;\r\n                case '/':\r\n                    return 63;\r\n                case '=':\r\n                    return 0;\r\n                default:\r\n                    System.out.println(\"C=\" + c);\r\n                    throw new RuntimeException(\"unexpected code: \" + c);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Decodes the given StringEncoder64 encoded String to a new byte array. The byte array holding the decoded data is returned.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        //System.out.println(\"decode String s=\"+s);\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try {\r\n            decode(s, bos);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException();\r\n        }\r\n        return bos.toByteArray();\r\n    }\r\n\r\n    public static void decode(String s, OutputStream os) throws IOException {\r\n        int i = 0;\r\n        int len = s.length();\r\n        while (true) {\r\n            while (i < len && s.charAt(i) <= ' ') i++;\r\n            if (i + 3 >= len)\r\n                break;\r\n            int tri = (decode(s.charAt(i)) << 18) + (decode(s.charAt(i + 1)) << 12) + (decode(s.charAt(i + 2)) << 6) + (decode(s.charAt(i + 3)));\r\n            os.write((tri >> 16) & 255);\r\n            if (s.charAt(i + 2) == '=')\r\n                break;\r\n            os.write((tri >> 8) & 255);\r\n            if (s.charAt(i + 3) == '=')\r\n                break;\r\n            os.write(tri & 255);\r\n            i += 4;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncoder64Test3.java",
		"test_prompt": "// StringEncoder64Test3.java\npackage osa.ora.server.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncoder64}.\n* It contains ten unit test cases for the {@link StringEncoder64#encode(byte[], int, int)} method.\n*/\nclass StringEncoder64Test3 {"
	},
	{
		"original_code": "// StringEncoder64.java\npackage osa.ora.server.utils;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class StringEncoder64 {\r\n\r\n    static final char[] charTab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\r\n\r\n    public static String encodeStringUTF8(String data) {\r\n        try {\r\n            return encode(data.getBytes(\"UTF8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String decodeStringUTF8(String data) {\r\n        try {\r\n            return new String(decode(data), \"UTF8\");\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String encode(byte[] data) {\r\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n        String ret = null;\r\n        if (encode(data, 0, data.length, byteArrayOutputStream))\r\n            ret = new String(byteArrayOutputStream.toByteArray());\r\n        return ret;\r\n    }\r\n\r\n    public static String encode(byte[] data, int start, int len) {\r\n        StringBuffer buffer = null;\r\n        return encode(data, start, len, buffer).toString();\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * appended to the given StringBuffer. If no StringBuffer is given, a new one is created automatically. The\r\n     * StringBuffer is the return value of this method.\r\n     */\r\n    public static StringBuffer encode(byte[] data, int start, int len, StringBuffer buf) {\r\n        if (buf == null)\r\n            buf = new StringBuffer(data.length * 3 / 2);\r\n        int end = len - 3;\r\n        int i = start;\r\n        // int n = 0;\r\n        while (i <= end) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(charTab[d & 63]);\r\n            i += 3;\r\n            // if (n++ >= 14) {\r\n            // n = 0;\r\n            // buf.append(\"\\r\\n\");\r\n            // }\r\n        }\r\n        if (i == start + len - 2) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(\"=\");\r\n        } else if (i == start + len - 1) {\r\n            int d = (((int) data[i]) & 0x0ff) << 16;\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(\"==\");\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * written to the given {@link OutputStream}. If no OutputStream is given, a {@link NullPointerException} is thrown.\r\n     *\r\n     * @return true if succeded to encode, false otherwise\r\n     * @throws NullPointerException if outputStream is null.\r\n     */\r\n    public static boolean encode(byte[] data, int start, int len, OutputStream outputStream) {\r\n        try {\r\n            if (outputStream == null)\r\n                throw new NullPointerException();\r\n            int end = len - 3;\r\n            int i = start;\r\n            int n = 0;\r\n            while (i <= end) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write(charTab[d & 63]);\r\n                i += 3;\r\n                if (n++ >= 14) {\r\n                    n = 0;\r\n                    outputStream.write('\\r');\r\n                    outputStream.write('\\n');\r\n                }\r\n            }\r\n            if (i == start + len - 2) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write('=');\r\n            } else if (i == start + len - 1) {\r\n                int d = (((int) data[i]) & 0x0ff) << 16;\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write('=');\r\n                outputStream.write('=');\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static int decode(char c) {\r\n        if (c >= 'A' && c <= 'Z')\r\n            return ((int) c) - 65;\r\n        else if (c >= 'a' && c <= 'z')\r\n            return ((int) c) - 97 + 26;\r\n        else if (c >= '0' && c <= '9')\r\n            return ((int) c) - 48 + 26 + 26;\r\n        else\r\n            switch(c) {\r\n                case '+':\r\n                    return 62;\r\n                case '/':\r\n                    return 63;\r\n                case '=':\r\n                    return 0;\r\n                default:\r\n                    System.out.println(\"C=\" + c);\r\n                    throw new RuntimeException(\"unexpected code: \" + c);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Decodes the given StringEncoder64 encoded String to a new byte array. The byte array holding the decoded data is returned.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        //System.out.println(\"decode String s=\"+s);\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try {\r\n            decode(s, bos);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException();\r\n        }\r\n        return bos.toByteArray();\r\n    }\r\n\r\n    public static void decode(String s, OutputStream os) throws IOException {\r\n        int i = 0;\r\n        int len = s.length();\r\n        while (true) {\r\n            while (i < len && s.charAt(i) <= ' ') i++;\r\n            if (i + 3 >= len)\r\n                break;\r\n            int tri = (decode(s.charAt(i)) << 18) + (decode(s.charAt(i + 1)) << 12) + (decode(s.charAt(i + 2)) << 6) + (decode(s.charAt(i + 3)));\r\n            os.write((tri >> 16) & 255);\r\n            if (s.charAt(i + 2) == '=')\r\n                break;\r\n            os.write((tri >> 8) & 255);\r\n            if (s.charAt(i + 3) == '=')\r\n                break;\r\n            os.write(tri & 255);\r\n            i += 4;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncoder64Test4.java",
		"test_prompt": "// StringEncoder64Test4.java\npackage osa.ora.server.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncoder64}.\n* It contains ten unit test cases for the {@link StringEncoder64#encode(byte[], int, int, StringBuffer)} method.\n*/\nclass StringEncoder64Test4 {"
	},
	{
		"original_code": "// StringEncoder64.java\npackage osa.ora.server.utils;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class StringEncoder64 {\r\n\r\n    static final char[] charTab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\r\n\r\n    public static String encodeStringUTF8(String data) {\r\n        try {\r\n            return encode(data.getBytes(\"UTF8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String decodeStringUTF8(String data) {\r\n        try {\r\n            return new String(decode(data), \"UTF8\");\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String encode(byte[] data) {\r\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n        String ret = null;\r\n        if (encode(data, 0, data.length, byteArrayOutputStream))\r\n            ret = new String(byteArrayOutputStream.toByteArray());\r\n        return ret;\r\n    }\r\n\r\n    public static String encode(byte[] data, int start, int len) {\r\n        StringBuffer buffer = null;\r\n        return encode(data, start, len, buffer).toString();\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * appended to the given StringBuffer. If no StringBuffer is given, a new one is created automatically. The\r\n     * StringBuffer is the return value of this method.\r\n     */\r\n    public static StringBuffer encode(byte[] data, int start, int len, StringBuffer buf) {\r\n        if (buf == null)\r\n            buf = new StringBuffer(data.length * 3 / 2);\r\n        int end = len - 3;\r\n        int i = start;\r\n        // int n = 0;\r\n        while (i <= end) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(charTab[d & 63]);\r\n            i += 3;\r\n            // if (n++ >= 14) {\r\n            // n = 0;\r\n            // buf.append(\"\\r\\n\");\r\n            // }\r\n        }\r\n        if (i == start + len - 2) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(\"=\");\r\n        } else if (i == start + len - 1) {\r\n            int d = (((int) data[i]) & 0x0ff) << 16;\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(\"==\");\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * written to the given {@link OutputStream}. If no OutputStream is given, a {@link NullPointerException} is thrown.\r\n     *\r\n     * @return true if succeded to encode, false otherwise\r\n     * @throws NullPointerException if outputStream is null.\r\n     */\r\n    public static boolean encode(byte[] data, int start, int len, OutputStream outputStream) {\r\n        try {\r\n            if (outputStream == null)\r\n                throw new NullPointerException();\r\n            int end = len - 3;\r\n            int i = start;\r\n            int n = 0;\r\n            while (i <= end) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write(charTab[d & 63]);\r\n                i += 3;\r\n                if (n++ >= 14) {\r\n                    n = 0;\r\n                    outputStream.write('\\r');\r\n                    outputStream.write('\\n');\r\n                }\r\n            }\r\n            if (i == start + len - 2) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write('=');\r\n            } else if (i == start + len - 1) {\r\n                int d = (((int) data[i]) & 0x0ff) << 16;\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write('=');\r\n                outputStream.write('=');\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static int decode(char c) {\r\n        if (c >= 'A' && c <= 'Z')\r\n            return ((int) c) - 65;\r\n        else if (c >= 'a' && c <= 'z')\r\n            return ((int) c) - 97 + 26;\r\n        else if (c >= '0' && c <= '9')\r\n            return ((int) c) - 48 + 26 + 26;\r\n        else\r\n            switch(c) {\r\n                case '+':\r\n                    return 62;\r\n                case '/':\r\n                    return 63;\r\n                case '=':\r\n                    return 0;\r\n                default:\r\n                    System.out.println(\"C=\" + c);\r\n                    throw new RuntimeException(\"unexpected code: \" + c);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Decodes the given StringEncoder64 encoded String to a new byte array. The byte array holding the decoded data is returned.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        //System.out.println(\"decode String s=\"+s);\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try {\r\n            decode(s, bos);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException();\r\n        }\r\n        return bos.toByteArray();\r\n    }\r\n\r\n    public static void decode(String s, OutputStream os) throws IOException {\r\n        int i = 0;\r\n        int len = s.length();\r\n        while (true) {\r\n            while (i < len && s.charAt(i) <= ' ') i++;\r\n            if (i + 3 >= len)\r\n                break;\r\n            int tri = (decode(s.charAt(i)) << 18) + (decode(s.charAt(i + 1)) << 12) + (decode(s.charAt(i + 2)) << 6) + (decode(s.charAt(i + 3)));\r\n            os.write((tri >> 16) & 255);\r\n            if (s.charAt(i + 2) == '=')\r\n                break;\r\n            os.write((tri >> 8) & 255);\r\n            if (s.charAt(i + 3) == '=')\r\n                break;\r\n            os.write(tri & 255);\r\n            i += 4;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncoder64Test5.java",
		"test_prompt": "// StringEncoder64Test5.java\npackage osa.ora.server.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncoder64}.\n* It contains ten unit test cases for the {@link StringEncoder64#encode(byte[], int, int, OutputStream)} method.\n*/\nclass StringEncoder64Test5 {"
	},
	{
		"original_code": "// StringEncoder64.java\npackage osa.ora.server.utils;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.UnsupportedEncodingException;\r\n\r\npublic class StringEncoder64 {\r\n\r\n    static final char[] charTab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\r\n\r\n    public static String encodeStringUTF8(String data) {\r\n        try {\r\n            return encode(data.getBytes(\"UTF8\"));\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String decodeStringUTF8(String data) {\r\n        try {\r\n            return new String(decode(data), \"UTF8\");\r\n        } catch (UnsupportedEncodingException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static String encode(byte[] data) {\r\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\r\n        String ret = null;\r\n        if (encode(data, 0, data.length, byteArrayOutputStream))\r\n            ret = new String(byteArrayOutputStream.toByteArray());\r\n        return ret;\r\n    }\r\n\r\n    public static String encode(byte[] data, int start, int len) {\r\n        StringBuffer buffer = null;\r\n        return encode(data, start, len, buffer).toString();\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * appended to the given StringBuffer. If no StringBuffer is given, a new one is created automatically. The\r\n     * StringBuffer is the return value of this method.\r\n     */\r\n    public static StringBuffer encode(byte[] data, int start, int len, StringBuffer buf) {\r\n        if (buf == null)\r\n            buf = new StringBuffer(data.length * 3 / 2);\r\n        int end = len - 3;\r\n        int i = start;\r\n        // int n = 0;\r\n        while (i <= end) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(charTab[d & 63]);\r\n            i += 3;\r\n            // if (n++ >= 14) {\r\n            // n = 0;\r\n            // buf.append(\"\\r\\n\");\r\n            // }\r\n        }\r\n        if (i == start + len - 2) {\r\n            int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(charTab[(d >> 6) & 63]);\r\n            buf.append(\"=\");\r\n        } else if (i == start + len - 1) {\r\n            int d = (((int) data[i]) & 0x0ff) << 16;\r\n            buf.append(charTab[(d >> 18) & 63]);\r\n            buf.append(charTab[(d >> 12) & 63]);\r\n            buf.append(\"==\");\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * Encodes the part of the given byte array denoted by start and len to the StringEncoder64 format. The encoded data is\r\n     * written to the given {@link OutputStream}. If no OutputStream is given, a {@link NullPointerException} is thrown.\r\n     *\r\n     * @return true if succeded to encode, false otherwise\r\n     * @throws NullPointerException if outputStream is null.\r\n     */\r\n    public static boolean encode(byte[] data, int start, int len, OutputStream outputStream) {\r\n        try {\r\n            if (outputStream == null)\r\n                throw new NullPointerException();\r\n            int end = len - 3;\r\n            int i = start;\r\n            int n = 0;\r\n            while (i <= end) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 0x0ff) << 8) | (((int) data[i + 2]) & 0x0ff);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write(charTab[d & 63]);\r\n                i += 3;\r\n                if (n++ >= 14) {\r\n                    n = 0;\r\n                    outputStream.write('\\r');\r\n                    outputStream.write('\\n');\r\n                }\r\n            }\r\n            if (i == start + len - 2) {\r\n                int d = ((((int) data[i]) & 0x0ff) << 16) | ((((int) data[i + 1]) & 255) << 8);\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write(charTab[(d >> 6) & 63]);\r\n                outputStream.write('=');\r\n            } else if (i == start + len - 1) {\r\n                int d = (((int) data[i]) & 0x0ff) << 16;\r\n                outputStream.write(charTab[(d >> 18) & 63]);\r\n                outputStream.write(charTab[(d >> 12) & 63]);\r\n                outputStream.write('=');\r\n                outputStream.write('=');\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static int decode(char c) {\r\n        if (c >= 'A' && c <= 'Z')\r\n            return ((int) c) - 65;\r\n        else if (c >= 'a' && c <= 'z')\r\n            return ((int) c) - 97 + 26;\r\n        else if (c >= '0' && c <= '9')\r\n            return ((int) c) - 48 + 26 + 26;\r\n        else\r\n            switch(c) {\r\n                case '+':\r\n                    return 62;\r\n                case '/':\r\n                    return 63;\r\n                case '=':\r\n                    return 0;\r\n                default:\r\n                    System.out.println(\"C=\" + c);\r\n                    throw new RuntimeException(\"unexpected code: \" + c);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Decodes the given StringEncoder64 encoded String to a new byte array. The byte array holding the decoded data is returned.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        //System.out.println(\"decode String s=\"+s);\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        try {\r\n            decode(s, bos);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException();\r\n        }\r\n        return bos.toByteArray();\r\n    }\r\n\r\n    public static void decode(String s, OutputStream os) throws IOException {\r\n        int i = 0;\r\n        int len = s.length();\r\n        while (true) {\r\n            while (i < len && s.charAt(i) <= ' ') i++;\r\n            if (i + 3 >= len)\r\n                break;\r\n            int tri = (decode(s.charAt(i)) << 18) + (decode(s.charAt(i + 1)) << 12) + (decode(s.charAt(i + 2)) << 6) + (decode(s.charAt(i + 3)));\r\n            os.write((tri >> 16) & 255);\r\n            if (s.charAt(i + 2) == '=')\r\n                break;\r\n            os.write((tri >> 8) & 255);\r\n            if (s.charAt(i + 3) == '=')\r\n                break;\r\n            os.write(tri & 255);\r\n            i += 4;\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncoder64Test6.java",
		"test_prompt": "// StringEncoder64Test6.java\npackage osa.ora.server.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncoder64}.\n* It contains ten unit test cases for the {@link StringEncoder64#decode(String)} method.\n*/\nclass StringEncoder64Test6 {"
	},
	{
		"original_code": "// XMLParser.java\n/*\n * Created on 27/06/2006\n */\npackage osa.ora.server.utils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Text;\nimport org.w3c.dom.NodeList;\n\n/**\n * @author Osama Oransa\n *\n * reads writs an XML file\n */\npublic class XMLParser {\n\n    private Element root;\n\n    private String fileName;\n\n    File file;\n\n    Document doc;\n\n    Transformer transformer;\n\n    TransformerFactory tFactory;\n\n    DocumentBuilder builder = null;\n\n    DocumentBuilderFactory factory;\n\n    /**\n     * the constructor to read or write a file\n     * @param fileName\n     */\n    public XMLParser(File file) throws Exception {\n        this.fileName = file.getAbsolutePath();\n        try {\n            tFactory = TransformerFactory.newInstance();\n            transformer = tFactory.newTransformer();\n        } catch (TransformerConfigurationException e) {\n            e.printStackTrace();\n        }\n        // make your xml doc into a DOMSource\n        /* get an xml doc */\n        factory = DocumentBuilderFactory.newInstance();\n        try {\n            builder = factory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        init();\n    }\n\n    public XMLParser(String fileName) throws Exception {\n        this.fileName = fileName;\n        try {\n            tFactory = TransformerFactory.newInstance();\n            transformer = tFactory.newTransformer();\n        } catch (TransformerConfigurationException e) {\n            e.printStackTrace();\n        }\n        // make your xml doc into a DOMSource\n        /* get an xml doc */\n        factory = DocumentBuilderFactory.newInstance();\n        try {\n            builder = factory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        init();\n    }\n\n    /**\n     * initializes the document\n     */\n    private void init() throws Exception {\n        file = new File(fileName);\n        try {\n            if (file.exists()) {\n                builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                doc = builder.parse(file);\n                root = doc.getDocumentElement();\n            } else {\n                doc = builder.newDocument();\n                root = doc.createElement(\"data\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new Exception(\"Not A Valid Format!\");\n        }\n    }\n\n    /**\n     * sets a tagName of certain id with its elements and values\n     * as\n     * <tagName>\n     * \t\t<element1>val1<element1>\n     *  \t<element2>val1<element2>\n     * \t\t<element3>val1<element3>\n     * </tagName>\n     * @param tagName\n     * @param id\n     * @param elements\n     */\n    public void setProperty(String tagName, String id, Hashtable elements) {\n        elements.remove(\"id\");\n        boolean replaced = false;\n        /* create the root node */\n        Element rowElement = doc.createElement(tagName);\n        rowElement.setAttribute(\"id\", id);\n        NodeList nodeList = root.getElementsByTagName(tagName);\n        String temp = null;\n        /* create the column nodes and append each to the row node */\n        Element columnElement;\n        Text textData;\n        Enumeration attributeEnum = elements.keys();\n        while (attributeEnum.hasMoreElements()) {\n            temp = (String) attributeEnum.nextElement();\n            columnElement = doc.createElement(temp);\n            textData = doc.createTextNode((String) elements.get(temp));\n            columnElement.appendChild(textData);\n            rowElement.appendChild(columnElement);\n        }\n        //*********************************************\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            String keyID = ((Element) nodeList.item(i)).getAttribute(\"id\");\n            if (keyID.equalsIgnoreCase(id)) {\n                root.replaceChild(rowElement, nodeList.item(i));\n                replaced = true;\n            }\n        }\n        //*********************************************************\n        if (!replaced) {\n            root.appendChild(rowElement);\n        }\n    }\n\n    public void addProperty(String tagName, String id, Hashtable elements) {\n        /* create the root node */\n        Element rowElement = doc.createElement(tagName);\n        rowElement.setAttribute(\"id\", id);\n        NodeList nodeList = root.getElementsByTagName(tagName);\n        String temp = null;\n        /* create the column nodes and append each to the row node */\n        Element columnElement;\n        Text textData;\n        Enumeration attributeEnum = elements.keys();\n        int k = 0;\n        while (attributeEnum.hasMoreElements()) {\n            temp = (String) attributeEnum.nextElement();\n            columnElement = doc.createElement(temp);\n            textData = doc.createTextNode((String) elements.get(temp));\n            columnElement.appendChild(textData);\n            rowElement.appendChild(columnElement);\n        }\n        //*********************************************\n        root.appendChild(rowElement);\n    }\n\n    /**\n     * gets all elments and values of all tags carry tagName\n     * @param tagName\n     * @return a vector of hashTable of all elements and values\n     */\n    public Vector getProperty(String tagName) {\n        Vector text = new Vector();\n        String text2 = new String();\n        String subTag = new String();\n        boolean found = false;\n        File file = new File(fileName);\n        NodeList nodes = root.getElementsByTagName(tagName);\n        //System.out.println(\"[XMLReader] Found shape nodes \"+nodes.getLength());\n        String keyID = null;\n        int i = 0;\n        if (nodes.getLength() != 0)\n            do {\n                Hashtable table = new Hashtable();\n                keyID = ((Element) nodes.item(i)).getAttribute(\"id\");\n                table.put(\"id\", keyID);\n                NodeList lines = nodes.item(i).getChildNodes();\n                for (int j = 0; j < lines.getLength(); j++) {\n                    Node name = (Node) lines.item(j);\n                    // Collect the text from the <Line> element\n                    StringBuffer sb = new StringBuffer();\n                    for (Node child = name.getFirstChild(); child != null; child = child.getNextSibling()) {\n                        if (child instanceof CharacterData) {\n                            CharacterData cd = (CharacterData) child;\n                            sb.append(cd.getData());\n                            text2 = sb.toString().trim();\n                            //System.out.println(\"[XMLReader] \"+child.getParentNode().getNodeName()+\"=\"+text2);\n                            table.put(child.getParentNode().getNodeName(), text2);\n                        }\n                    }\n                }\n                i++;\n                text.addElement(table);\n            } while (i < nodes.getLength() && !found);\n        return text;\n    }\n\n    /**\n     * gets a value of a tag name having the id ==id\n     * @param tagName\n     * @param id\n     * @return String  the value of the tag\n     */\n    public String getSingleProperty(String tagName) {\n        String text = new String();\n        boolean found = false;\n        Hashtable table = new Hashtable();\n        NodeList nodes = root.getElementsByTagName(tagName);\n        int i = 0;\n        if (nodes.getLength() != 0)\n            do {\n                StringBuffer sb = new StringBuffer();\n                for (Node child = nodes.item(i).getFirstChild(); child != null; child = child.getNextSibling()) {\n                    if (child instanceof CharacterData) {\n                        CharacterData cd = (CharacterData) child;\n                        sb.append(cd.getData());\n                        text = sb.toString().trim();\n                    }\n                }\n                i++;\n            } while (i < nodes.getLength() && !found);\n        return text;\n    }\n\n    /**\n     * stores the file in XML formate\n     */\n    public void store() throws Exception {\n        DOMSource source = new DOMSource(root);\n        if (!file.exists()) {\n            try {\n                file.createNewFile();\n            } catch (IOException e) {\n                e.printStackTrace();\n                throw e;\n            }\n        }\n        Result result = new StreamResult(file);\n        try {\n            //\t\t stream it out\n            transformer.transform(source, result);\n        } catch (TransformerException e1) {\n            e1.printStackTrace();\n            throw e1;\n        }\n    }\n\n    public static String returnSpecial(String input) {\n        String output = input.replaceAll(\"&lt;\", \"<\");\n        return output;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/XMLParserTest.java",
		"test_prompt": "// XMLParserTest.java\npackage osa.ora.server.utils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Text;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLParser}.\n* It contains ten unit test cases for the {@link XMLParser#returnSpecial(String)} method.\n*/\nclass XMLParserTest {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest0.java",
		"test_prompt": "// FileBOTest0.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#loadGroupsAndUsers()} method.\n*/\nclass FileBOTest0 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest1.java",
		"test_prompt": "// FileBOTest1.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#loadRooms()} method.\n*/\nclass FileBOTest1 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest2.java",
		"test_prompt": "// FileBOTest2.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#createUser(User)} method.\n*/\nclass FileBOTest2 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest3.java",
		"test_prompt": "// FileBOTest3.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#createGroup(Group)} method.\n*/\nclass FileBOTest3 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest4.java",
		"test_prompt": "// FileBOTest4.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#createRoom(Room)} method.\n*/\nclass FileBOTest4 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest5.java",
		"test_prompt": "// FileBOTest5.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#delUser(User)} method.\n*/\nclass FileBOTest5 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest6.java",
		"test_prompt": "// FileBOTest6.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#delGroup(Group)} method.\n*/\nclass FileBOTest6 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest7.java",
		"test_prompt": "// FileBOTest7.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#delRoom(Room)} method.\n*/\nclass FileBOTest7 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest8.java",
		"test_prompt": "// FileBOTest8.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#updateUser(User)} method.\n*/\nclass FileBOTest8 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest9.java",
		"test_prompt": "// FileBOTest9.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#updateGroup(Group)} method.\n*/\nclass FileBOTest9 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest10.java",
		"test_prompt": "// FileBOTest10.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#updateRoom(Room)} method.\n*/\nclass FileBOTest10 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest11.java",
		"test_prompt": "// FileBOTest11.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#updatePassword(int, String, String)} method.\n*/\nclass FileBOTest11 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest12.java",
		"test_prompt": "// FileBOTest12.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#resetUserPass(User)} method.\n*/\nclass FileBOTest12 {"
	},
	{
		"original_code": "// FileBO.java\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.bo;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.util.Calendar;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\nimport java.util.Vector;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport osa.ora.server.ModernChatServer;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileBO implements IBO {\r\n\r\n    String path;\r\n\r\n    XMLParser parser1;\r\n\r\n    XMLParser parser2;\r\n\r\n    XMLParser parser3;\r\n\r\n    Properties config;\r\n\r\n    private Logger logger;\r\n\r\n    private User adminUser;\r\n\r\n    private ModernChatServer modernServer;\r\n\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private static final String SERVER_DATA_1_FILE_NAME = \"/config/data1.xml\";\r\n\r\n    private static final String SERVER_DATA_2_FILE_NAME = \"/config/data2.xml\";\r\n\r\n    private static final String SERVER_DATA_3_FILE_NAME = \"/config/data3.xml\";\r\n\r\n    private static final String SERVER_TRANS_FILE_NAME = \"/config/trans.dat\";\r\n\r\n    public FileBO(String path, ModernChatServer modernServer) throws Exception {\r\n        this.path = path;\r\n        this.modernServer = modernServer;\r\n        this.logger = ModernChatServer.getLogger();\r\n        loadXMLFile(path);\r\n        config = new Properties();\r\n        try {\r\n            config.load(new FileInputStream(path + SERVER_TRANS_FILE_NAME));\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't load user passwords!\", e);\r\n        }\r\n        passwords = new Hashtable<Integer, String>();\r\n    }\r\n\r\n    private void loadXMLFile(String path) throws Exception {\r\n        parser1 = new XMLParser(path + SERVER_DATA_1_FILE_NAME);\r\n        parser2 = new XMLParser(path + SERVER_DATA_2_FILE_NAME);\r\n        parser3 = new XMLParser(path + SERVER_DATA_3_FILE_NAME);\r\n    }\r\n\r\n    public Vector<Group> loadGroupsAndUsers() {\r\n        logger.log(Level.FINE, \"Load All Users and Groups\");\r\n        Vector<Group> result = new Vector<Group>(0);\r\n        //load groups\r\n        Vector tempVector = parser1.getProperty(\"group\");\r\n        logger.log(Level.FINE, \"All Groups size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Group groupTemp = new Group();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            groupTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            groupTemp.setName((String) hashTemp.get(\"name\"));\r\n            groupTemp.setUsers(new Vector<User>());\r\n            result.add(groupTemp);\r\n        }\r\n        tempVector = parser2.getProperty(\"user\");\r\n        logger.log(Level.FINE, \"All Users size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            User userTemp = new User();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            userTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            userTemp.setName((String) hashTemp.get(\"name\"));\r\n            userTemp.setEmail((String) hashTemp.get(\"email\"));\r\n            userTemp.setDirectPhone((String) hashTemp.get(\"directPhone\"));\r\n            userTemp.setJobTitle((String) hashTemp.get(\"jobTitle\"));\r\n            userTemp.setGroup_id(Integer.parseInt((String) hashTemp.get(\"groupId\")));\r\n            userTemp.setCanJoinChatRoom(Boolean.parseBoolean((String) hashTemp.get(\"canJoinChatRoom\")));\r\n            userTemp.setOnlyStartChat(Boolean.parseBoolean((String) hashTemp.get(\"onlyStartChat\")));\r\n            userTemp.setShowMyStatus(Boolean.parseBoolean((String) hashTemp.get(\"showStatus\")));\r\n            userTemp.setStatus_id(IConstant.SIGN_OUT);\r\n            String password = config.getProperty(\"\" + userTemp.getId());\r\n            //only add user if he has group :)\r\n            //admin user doesn't have group\r\n            if (userTemp.getId() == 1000) {\r\n                adminUser = userTemp;\r\n                getPasswords().put(userTemp.getId(), password);\r\n            } else {\r\n                for (int n = 0; n < result.size(); n++) {\r\n                    if (result.get(n).getId() == userTemp.getGroup_id()) {\r\n                        result.get(n).getUsers().add(userTemp);\r\n                        getPasswords().put(userTemp.getId(), password);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public Vector<Room> loadRooms() {\r\n        logger.log(Level.FINE, \"Load All Rooms\");\r\n        Vector<Room> result = new Vector<Room>();\r\n        Vector tempVector = parser3.getProperty(\"room\");\r\n        logger.log(Level.FINE, \"All rooms size=\" + tempVector.size());\r\n        for (int i = 0; i < tempVector.size(); i++) {\r\n            Room roomTemp = new Room();\r\n            Hashtable hashTemp = (Hashtable) tempVector.get(i);\r\n            roomTemp.setId(Integer.parseInt((String) hashTemp.get(\"id\")));\r\n            roomTemp.setName((String) hashTemp.get(\"name\"));\r\n            String users = (String) hashTemp.get(\"users\");\r\n            if (users != null && users.length() > 0) {\r\n                String[] userIds = users.split(\":\");\r\n                if (userIds != null && userIds.length > 0) {\r\n                    int[] roomUsers = new int[userIds.length];\r\n                    for (int n = 0; n < userIds.length; n++) {\r\n                        roomUsers[n] = Integer.parseInt(userIds[n]);\r\n                    }\r\n                    roomTemp.setUserId(roomUsers);\r\n                    //this is done here to enuse no room is added unless it\r\n                    //has users assigened on it.\r\n                    result.add(roomTemp);\r\n                }\r\n            }\r\n        }\r\n        System.gc();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @return the passwords\r\n     */\r\n    public Hashtable<Integer, String> getPasswords() {\r\n        return passwords;\r\n    }\r\n\r\n    private Group saveNewGroup(Vector<Group> groups, Group newGroup) {\r\n        logger.log(Level.FINE, \"Save New Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                groups.get(i).writeToFile(out);\r\n                if (groups.get(i).getId() > maxId) {\r\n                    maxId = groups.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 100)\r\n                maxId = 100;\r\n            newGroup.setId(maxId + 1);\r\n            newGroup.writeToFile(out);\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.add(newGroup);\r\n            return newGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!,Can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User saveNewUser(Vector<Group> groups, User adminUser, User newUser, String defaultPass) {\r\n        logger.log(Level.FINE, \"Save New User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            int maxId = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    tempUsers.get(n).writeToFile(out);\r\n                    if (tempUsers.get(n).getId() > maxId) {\r\n                        maxId = tempUsers.get(n).getId();\r\n                    }\r\n                }\r\n            }\r\n            if (maxId < 1000)\r\n                maxId = 1000;\r\n            newUser.setId(maxId + 1);\r\n            newUser.writeToFile(out);\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == newUser.getGroup_id()) {\r\n                    newUser.setStatus_id(IConstant.SIGN_OUT);\r\n                    groups.get(i).getUsers().add(newUser);\r\n                    break;\r\n                }\r\n            }\r\n            config.setProperty(\"\" + newUser.getId(), defaultPass);\r\n            savePasswordFile();\r\n            return newUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, Can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void savePasswordFile() throws Exception {\r\n        logger.log(Level.FINE, \"Save Password File\");\r\n        try {\r\n            BufferedWriter out = null;\r\n            File tempFile = new File(path + SERVER_TRANS_FILE_NAME);\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            config.store(out, \"Updated AT :\" + Calendar.getInstance());\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save password file!\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private Room saveNewRoom(Vector<Room> rooms, Room newRoom) {\r\n        logger.log(Level.FINE, \"Save New Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int maxId = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                rooms.get(i).writeToFile(out);\r\n                if (rooms.get(i).getId() > maxId) {\r\n                    maxId = rooms.get(i).getId();\r\n                }\r\n            }\r\n            if (maxId < 10000)\r\n                maxId = 10000;\r\n            newRoom.setId(maxId + 1);\r\n            newRoom.writeToFile(out);\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.add(newRoom);\r\n            return newRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group deleteGroup(Vector<Group> groups, Group delGroup) {\r\n        logger.log(Level.FINE, \"Delete Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != delGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.remove(index);\r\n            return delGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room deleteRoom(Vector<Room> rooms, Room delRoom) {\r\n        logger.log(Level.FINE, \"Delete Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = -1;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != delRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.remove(index);\r\n            return delRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User deleteUser(Vector<Group> groups, User adminUser, User delUser) {\r\n        logger.log(Level.FINE, \"Delete User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != delUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == delUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == delUser.getId()) {\r\n                            groups.get(i).getUsers().remove(n);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return delUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUser(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    for (int n = 0; n < tempUsers.size(); n++) {\r\n                        if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                            groups.get(i).getUsers().set(n, updUser);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private User updateUserGroup(Vector<Group> groups, User adminUser, User updUser) {\r\n        logger.log(Level.FINE, \"Update User Group\");\r\n        File tempFile = new File(path + SERVER_DATA_2_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<users>\");\r\n            out.newLine();\r\n            adminUser.writeToFile(out);\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() != updUser.getId()) {\r\n                        tempUsers.get(n).writeToFile(out);\r\n                    } else {\r\n                        updUser.writeToFile(out);\r\n                    }\r\n                }\r\n            }\r\n            out.write(\"</users>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            //remove from old group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (tempUsers.get(n).getId() == updUser.getId()) {\r\n                        groups.get(i).getUsers().remove(n);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //add to the new group\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() == updUser.getGroup_id()) {\r\n                    groups.get(i).getUsers().add(updUser);\r\n                    break;\r\n                }\r\n            }\r\n            return updUser;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save users!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Group updateGroup(Vector<Group> groups, Group updateGroup) {\r\n        logger.log(Level.FINE, \"Update Group\");\r\n        File tempFile = new File(path + SERVER_DATA_1_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<groups>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (groups.get(i).getId() != updateGroup.getId()) {\r\n                    groups.get(i).writeToFile(out);\r\n                } else {\r\n                    updateGroup.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</groups>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            groups.set(index, updateGroup);\r\n            return updateGroup;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save groups!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private Room updateRoom(Vector<Room> rooms, Room updateRoom) {\r\n        logger.log(Level.FINE, \"Update Room\");\r\n        File tempFile = new File(path + SERVER_DATA_3_FILE_NAME);\r\n        BufferedWriter out = null;\r\n        try {\r\n            tempFile.createNewFile();\r\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), \"UTF8\"));\r\n            out.write(\"<data>\");\r\n            out.newLine();\r\n            out.write(\"<rooms>\");\r\n            out.newLine();\r\n            int index = 0;\r\n            for (int i = 0; i < rooms.size(); i++) {\r\n                if (rooms.get(i).getId() != updateRoom.getId()) {\r\n                    rooms.get(i).writeToFile(out);\r\n                } else {\r\n                    updateRoom.writeToFile(out);\r\n                    index = i;\r\n                }\r\n            }\r\n            out.write(\"</rooms>\");\r\n            out.newLine();\r\n            out.write(\"</data>\");\r\n            out.newLine();\r\n            out.flush();\r\n            out.close();\r\n            rooms.set(index, updateRoom);\r\n            return updateRoom;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't save rooms!\", e);\r\n            return null;\r\n        } finally {\r\n            if (out != null) {\r\n                try {\r\n                    out.close();\r\n                } catch (Exception e) {\r\n                    //e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public User createUser(User user) {\r\n        return saveNewUser(modernServer.getGroups(), modernServer.getAdminUser(), user, modernServer.getServerSettingBean().getDefualtPassword());\r\n    }\r\n\r\n    public Group createGroup(Group group) {\r\n        return saveNewGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room createRoom(Room room) {\r\n        return saveNewRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User delUser(User user) {\r\n        return deleteUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group delGroup(Group group) {\r\n        return deleteGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room delRoom(Room room) {\r\n        return deleteRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public User updateUser(User user) {\r\n        return updateUser(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n\r\n    public Group updateGroup(Group group) {\r\n        return updateGroup(modernServer.getGroups(), group);\r\n    }\r\n\r\n    public Room updateRoom(Room room) {\r\n        return updateRoom(modernServer.getRooms(), room);\r\n    }\r\n\r\n    public boolean updatePassword(int userId, String oldPass, String newPass) {\r\n        logger.log(Level.FINE, \"Update Password\");\r\n        config.setProperty(\"\" + userId, newPass);\r\n        try {\r\n            savePasswordFile();\r\n            return true;\r\n        } catch (Exception ex) {\r\n            config.setProperty(\"\" + userId, oldPass);\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't update user password!\", ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public User resetUserPass(User user) {\r\n        logger.log(Level.FINE, \"Reset User Password\");\r\n        config.setProperty(\"\" + user.getId(), modernServer.getServerSettingBean().getDefualtPassword());\r\n        try {\r\n            savePasswordFile();\r\n            return user;\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Server Data Error!, can't reset user password!\", ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public User updateUserGroup(User user) {\r\n        return updateUserGroup(modernServer.getGroups(), modernServer.getAdminUser(), user);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/bo/FileBOTest13.java",
		"test_prompt": "// FileBOTest13.java\npackage osa.ora.server.bo;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Calendar;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport osa.ora.server.ModernChatServer;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBO}.\n* It contains ten unit test cases for the {@link FileBO#updateUserGroup(User)} method.\n*/\nclass FileBOTest13 {"
	},
	{
		"original_code": "// User.java\n/*\r\n * User.java\r\n *\r\n * Created on October 27, 2009, 12:25 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.beans;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.Serializable;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class User implements Serializable {\r\n\r\n    /**\r\n     * Creates a new instance of User\r\n     */\r\n    private int id;\r\n\r\n    private String name;\r\n\r\n    private String email;\r\n\r\n    private String jobTitle;\r\n\r\n    private String directPhone;\r\n\r\n    private int group_id;\r\n\r\n    private int status_id;\r\n\r\n    //won't show user status to others\r\n    private boolean showMyStatus;\r\n\r\n    //no one can start chat with him unless he start the chat window.\r\n    private boolean onlyStartChat;\r\n\r\n    //this attribute for admin when select users for rooms..\r\n    private boolean canJoinChatRoom;\r\n\r\n    public User() {\r\n    }\r\n\r\n    public String toString() {\r\n        return name;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getGroup_id() {\r\n        return group_id;\r\n    }\r\n\r\n    public void setGroup_id(int group_id) {\r\n        this.group_id = group_id;\r\n    }\r\n\r\n    public boolean isShowMyStatus() {\r\n        return showMyStatus;\r\n    }\r\n\r\n    public void setShowMyStatus(boolean showMyStatus) {\r\n        this.showMyStatus = showMyStatus;\r\n    }\r\n\r\n    public boolean isOnlyStartChat() {\r\n        return onlyStartChat;\r\n    }\r\n\r\n    public void setOnlyStartChat(boolean onlyStartChat) {\r\n        this.onlyStartChat = onlyStartChat;\r\n    }\r\n\r\n    public String getEmail() {\r\n        return email;\r\n    }\r\n\r\n    public void setEmail(String email) {\r\n        this.email = email;\r\n    }\r\n\r\n    public boolean isCanJoinChatRoom() {\r\n        return canJoinChatRoom;\r\n    }\r\n\r\n    public void setCanJoinChatRoom(boolean canJoinChatRoom) {\r\n        this.canJoinChatRoom = canJoinChatRoom;\r\n    }\r\n\r\n    /**\r\n     * @return the directPhone\r\n     */\r\n    public String getDirectPhone() {\r\n        return directPhone;\r\n    }\r\n\r\n    /**\r\n     * @param directPhone the directPhone to set\r\n     */\r\n    public void setDirectPhone(String directPhone) {\r\n        this.directPhone = directPhone;\r\n    }\r\n\r\n    public void writeToFile(BufferedWriter out) throws Exception {\r\n        out.write(\"<user>\");\r\n        out.newLine();\r\n        out.write(\"<id>\" + id + \"</id>\");\r\n        out.newLine();\r\n        out.write(\"<name>\" + XMLParser.returnSpecial(name) + \"</name>\");\r\n        out.newLine();\r\n        out.write(\"<email>\" + XMLParser.returnSpecial(email) + \"</email>\");\r\n        out.newLine();\r\n        out.write(\"<directPhone>\" + XMLParser.returnSpecial(directPhone) + \"</directPhone>\");\r\n        out.newLine();\r\n        out.write(\"<jobTitle>\" + XMLParser.returnSpecial(jobTitle) + \"</jobTitle>\");\r\n        out.newLine();\r\n        out.write(\"<groupId>\" + group_id + \"</groupId>\");\r\n        out.newLine();\r\n        out.write(\"<showStatus>\" + showMyStatus + \"</showStatus>\");\r\n        out.newLine();\r\n        out.write(\"<onlyStartChat>\" + onlyStartChat + \"</onlyStartChat>\");\r\n        out.newLine();\r\n        out.write(\"<canJoinChatRoom>\" + canJoinChatRoom + \"</canJoinChatRoom>\");\r\n        out.newLine();\r\n        out.write(\"</user>\");\r\n        out.newLine();\r\n    }\r\n\r\n    /**\r\n     * @return the status_id\r\n     */\r\n    public int getStatus_id() {\r\n        return status_id;\r\n    }\r\n\r\n    /**\r\n     * @param status_id the status_id to set\r\n     */\r\n    public void setStatus_id(int status_id) {\r\n        this.status_id = status_id;\r\n    }\r\n\r\n    /**\r\n     * @return the jobTitle\r\n     */\r\n    public String getJobTitle() {\r\n        return jobTitle;\r\n    }\r\n\r\n    /**\r\n     * @param jobTitle the jobTitle to set\r\n     */\r\n    public void setJobTitle(String jobTitle) {\r\n        this.jobTitle = jobTitle;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/beans/UserTest0.java",
		"test_prompt": "// UserTest0.java\npackage osa.ora.server.beans;\n\nimport java.io.BufferedWriter;\nimport java.io.Serializable;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link User}.\n* It contains ten unit test cases for the {@link User#isShowMyStatus()} method.\n*/\nclass UserTest0 {"
	},
	{
		"original_code": "// User.java\n/*\r\n * User.java\r\n *\r\n * Created on October 27, 2009, 12:25 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.beans;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.Serializable;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class User implements Serializable {\r\n\r\n    /**\r\n     * Creates a new instance of User\r\n     */\r\n    private int id;\r\n\r\n    private String name;\r\n\r\n    private String email;\r\n\r\n    private String jobTitle;\r\n\r\n    private String directPhone;\r\n\r\n    private int group_id;\r\n\r\n    private int status_id;\r\n\r\n    //won't show user status to others\r\n    private boolean showMyStatus;\r\n\r\n    //no one can start chat with him unless he start the chat window.\r\n    private boolean onlyStartChat;\r\n\r\n    //this attribute for admin when select users for rooms..\r\n    private boolean canJoinChatRoom;\r\n\r\n    public User() {\r\n    }\r\n\r\n    public String toString() {\r\n        return name;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getGroup_id() {\r\n        return group_id;\r\n    }\r\n\r\n    public void setGroup_id(int group_id) {\r\n        this.group_id = group_id;\r\n    }\r\n\r\n    public boolean isShowMyStatus() {\r\n        return showMyStatus;\r\n    }\r\n\r\n    public void setShowMyStatus(boolean showMyStatus) {\r\n        this.showMyStatus = showMyStatus;\r\n    }\r\n\r\n    public boolean isOnlyStartChat() {\r\n        return onlyStartChat;\r\n    }\r\n\r\n    public void setOnlyStartChat(boolean onlyStartChat) {\r\n        this.onlyStartChat = onlyStartChat;\r\n    }\r\n\r\n    public String getEmail() {\r\n        return email;\r\n    }\r\n\r\n    public void setEmail(String email) {\r\n        this.email = email;\r\n    }\r\n\r\n    public boolean isCanJoinChatRoom() {\r\n        return canJoinChatRoom;\r\n    }\r\n\r\n    public void setCanJoinChatRoom(boolean canJoinChatRoom) {\r\n        this.canJoinChatRoom = canJoinChatRoom;\r\n    }\r\n\r\n    /**\r\n     * @return the directPhone\r\n     */\r\n    public String getDirectPhone() {\r\n        return directPhone;\r\n    }\r\n\r\n    /**\r\n     * @param directPhone the directPhone to set\r\n     */\r\n    public void setDirectPhone(String directPhone) {\r\n        this.directPhone = directPhone;\r\n    }\r\n\r\n    public void writeToFile(BufferedWriter out) throws Exception {\r\n        out.write(\"<user>\");\r\n        out.newLine();\r\n        out.write(\"<id>\" + id + \"</id>\");\r\n        out.newLine();\r\n        out.write(\"<name>\" + XMLParser.returnSpecial(name) + \"</name>\");\r\n        out.newLine();\r\n        out.write(\"<email>\" + XMLParser.returnSpecial(email) + \"</email>\");\r\n        out.newLine();\r\n        out.write(\"<directPhone>\" + XMLParser.returnSpecial(directPhone) + \"</directPhone>\");\r\n        out.newLine();\r\n        out.write(\"<jobTitle>\" + XMLParser.returnSpecial(jobTitle) + \"</jobTitle>\");\r\n        out.newLine();\r\n        out.write(\"<groupId>\" + group_id + \"</groupId>\");\r\n        out.newLine();\r\n        out.write(\"<showStatus>\" + showMyStatus + \"</showStatus>\");\r\n        out.newLine();\r\n        out.write(\"<onlyStartChat>\" + onlyStartChat + \"</onlyStartChat>\");\r\n        out.newLine();\r\n        out.write(\"<canJoinChatRoom>\" + canJoinChatRoom + \"</canJoinChatRoom>\");\r\n        out.newLine();\r\n        out.write(\"</user>\");\r\n        out.newLine();\r\n    }\r\n\r\n    /**\r\n     * @return the status_id\r\n     */\r\n    public int getStatus_id() {\r\n        return status_id;\r\n    }\r\n\r\n    /**\r\n     * @param status_id the status_id to set\r\n     */\r\n    public void setStatus_id(int status_id) {\r\n        this.status_id = status_id;\r\n    }\r\n\r\n    /**\r\n     * @return the jobTitle\r\n     */\r\n    public String getJobTitle() {\r\n        return jobTitle;\r\n    }\r\n\r\n    /**\r\n     * @param jobTitle the jobTitle to set\r\n     */\r\n    public void setJobTitle(String jobTitle) {\r\n        this.jobTitle = jobTitle;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/beans/UserTest1.java",
		"test_prompt": "// UserTest1.java\npackage osa.ora.server.beans;\n\nimport java.io.BufferedWriter;\nimport java.io.Serializable;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link User}.\n* It contains ten unit test cases for the {@link User#isOnlyStartChat()} method.\n*/\nclass UserTest1 {"
	},
	{
		"original_code": "// User.java\n/*\r\n * User.java\r\n *\r\n * Created on October 27, 2009, 12:25 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.beans;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.Serializable;\r\nimport osa.ora.server.utils.XMLParser;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class User implements Serializable {\r\n\r\n    /**\r\n     * Creates a new instance of User\r\n     */\r\n    private int id;\r\n\r\n    private String name;\r\n\r\n    private String email;\r\n\r\n    private String jobTitle;\r\n\r\n    private String directPhone;\r\n\r\n    private int group_id;\r\n\r\n    private int status_id;\r\n\r\n    //won't show user status to others\r\n    private boolean showMyStatus;\r\n\r\n    //no one can start chat with him unless he start the chat window.\r\n    private boolean onlyStartChat;\r\n\r\n    //this attribute for admin when select users for rooms..\r\n    private boolean canJoinChatRoom;\r\n\r\n    public User() {\r\n    }\r\n\r\n    public String toString() {\r\n        return name;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getGroup_id() {\r\n        return group_id;\r\n    }\r\n\r\n    public void setGroup_id(int group_id) {\r\n        this.group_id = group_id;\r\n    }\r\n\r\n    public boolean isShowMyStatus() {\r\n        return showMyStatus;\r\n    }\r\n\r\n    public void setShowMyStatus(boolean showMyStatus) {\r\n        this.showMyStatus = showMyStatus;\r\n    }\r\n\r\n    public boolean isOnlyStartChat() {\r\n        return onlyStartChat;\r\n    }\r\n\r\n    public void setOnlyStartChat(boolean onlyStartChat) {\r\n        this.onlyStartChat = onlyStartChat;\r\n    }\r\n\r\n    public String getEmail() {\r\n        return email;\r\n    }\r\n\r\n    public void setEmail(String email) {\r\n        this.email = email;\r\n    }\r\n\r\n    public boolean isCanJoinChatRoom() {\r\n        return canJoinChatRoom;\r\n    }\r\n\r\n    public void setCanJoinChatRoom(boolean canJoinChatRoom) {\r\n        this.canJoinChatRoom = canJoinChatRoom;\r\n    }\r\n\r\n    /**\r\n     * @return the directPhone\r\n     */\r\n    public String getDirectPhone() {\r\n        return directPhone;\r\n    }\r\n\r\n    /**\r\n     * @param directPhone the directPhone to set\r\n     */\r\n    public void setDirectPhone(String directPhone) {\r\n        this.directPhone = directPhone;\r\n    }\r\n\r\n    public void writeToFile(BufferedWriter out) throws Exception {\r\n        out.write(\"<user>\");\r\n        out.newLine();\r\n        out.write(\"<id>\" + id + \"</id>\");\r\n        out.newLine();\r\n        out.write(\"<name>\" + XMLParser.returnSpecial(name) + \"</name>\");\r\n        out.newLine();\r\n        out.write(\"<email>\" + XMLParser.returnSpecial(email) + \"</email>\");\r\n        out.newLine();\r\n        out.write(\"<directPhone>\" + XMLParser.returnSpecial(directPhone) + \"</directPhone>\");\r\n        out.newLine();\r\n        out.write(\"<jobTitle>\" + XMLParser.returnSpecial(jobTitle) + \"</jobTitle>\");\r\n        out.newLine();\r\n        out.write(\"<groupId>\" + group_id + \"</groupId>\");\r\n        out.newLine();\r\n        out.write(\"<showStatus>\" + showMyStatus + \"</showStatus>\");\r\n        out.newLine();\r\n        out.write(\"<onlyStartChat>\" + onlyStartChat + \"</onlyStartChat>\");\r\n        out.newLine();\r\n        out.write(\"<canJoinChatRoom>\" + canJoinChatRoom + \"</canJoinChatRoom>\");\r\n        out.newLine();\r\n        out.write(\"</user>\");\r\n        out.newLine();\r\n    }\r\n\r\n    /**\r\n     * @return the status_id\r\n     */\r\n    public int getStatus_id() {\r\n        return status_id;\r\n    }\r\n\r\n    /**\r\n     * @param status_id the status_id to set\r\n     */\r\n    public void setStatus_id(int status_id) {\r\n        this.status_id = status_id;\r\n    }\r\n\r\n    /**\r\n     * @return the jobTitle\r\n     */\r\n    public String getJobTitle() {\r\n        return jobTitle;\r\n    }\r\n\r\n    /**\r\n     * @param jobTitle the jobTitle to set\r\n     */\r\n    public void setJobTitle(String jobTitle) {\r\n        this.jobTitle = jobTitle;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/beans/UserTest2.java",
		"test_prompt": "// UserTest2.java\npackage osa.ora.server.beans;\n\nimport java.io.BufferedWriter;\nimport java.io.Serializable;\nimport osa.ora.server.utils.XMLParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link User}.\n* It contains ten unit test cases for the {@link User#isCanJoinChatRoom()} method.\n*/\nclass UserTest2 {"
	},
	{
		"original_code": "// ResultBean.java\n/*\r\n * ResultBean.java\r\n *\r\n * Created on October 29, 2009, 12:37 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.beans;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ResultBean implements Serializable {\r\n\r\n    private boolean success;\r\n\r\n    private int action;\r\n\r\n    private String message;\r\n\r\n    /**\r\n     * Creates a new instance of ResultBean\r\n     */\r\n    public ResultBean() {\r\n    }\r\n\r\n    public ResultBean(boolean result, int action, String message) {\r\n        this.setSuccess(result);\r\n        this.action = action;\r\n        this.message = message;\r\n    }\r\n\r\n    public int getAction() {\r\n        return action;\r\n    }\r\n\r\n    public void setAction(int action) {\r\n        this.action = action;\r\n    }\r\n\r\n    public String getMessage() {\r\n        return message;\r\n    }\r\n\r\n    public void setMessage(String message) {\r\n        this.message = message;\r\n    }\r\n\r\n    public boolean isSuccess() {\r\n        return success;\r\n    }\r\n\r\n    public void setSuccess(boolean success) {\r\n        this.success = success;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/beans/ResultBeanTest.java",
		"test_prompt": "// ResultBeanTest.java\npackage osa.ora.server.beans;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResultBean}.\n* It contains ten unit test cases for the {@link ResultBean#isSuccess()} method.\n*/\nclass ResultBeanTest {"
	},
	{
		"original_code": "// JFontChooser.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\n\n/**\n * <code>JFontChooser</code> provides a pane of controls designed to allow\n * a user to manipulate and select a font.\n *\n * This class provides three levels of API:\n * <ol>\n * <li>A static convenience method which shows a modal font-chooser\n * dialog and returns the font selected by the user.\n * <li>A static convenience method for creating a font-chooser dialog\n * where <code>ActionListeners</code> can be specified to be invoked when\n * the user presses one of the dialog buttons.\n * <li>The ability to create instances of <code>JFontChooser</code> panes\n * directly (within any container). <code>PropertyChange</code> listeners\n * can be added to detect when the current \"font\" property changes.\n * </ol>\n * <p>\n *\n * @author Adrian BER\n */\npublic class JFontChooser extends JComponent {\n\n    /**\n     * The list of possible font sizes.\n     */\n    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };\n\n    /**\n     * The list of possible fonts.\n     */\n    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n\n    private FontSelectionModel selectionModel;\n\n    private JList fontList;\n\n    private JList sizeList;\n\n    private JCheckBox boldCheckBox;\n\n    private JCheckBox italicCheckBox;\n\n    private JLabel previewLabel;\n\n    /**\n     * The preview text, if null the font name will be the preview text.\n     */\n    private String previewText;\n\n    /**\n     * Listener used to update the font of the selection model.\n     */\n    private SelectionUpdater selectionUpdater = new SelectionUpdater();\n\n    /**\n     * Listener used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private LabelUpdater labelUpdater = new LabelUpdater();\n\n    /**\n     * True if the components are being updated and no event should be generated.\n     */\n    private boolean updatingComponents = false;\n\n    /**\n     * Listener class used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private class LabelUpdater implements ChangeListener {\n\n        public void stateChanged(ChangeEvent e) {\n            updateComponents();\n        }\n    }\n\n    /**\n     * Listener class used to update the font of the preview label.\n     */\n    private class SelectionUpdater implements ChangeListener, ListSelectionListener {\n\n        public void stateChanged(ChangeEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n\n        public void valueChanged(ListSelectionEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n    }\n\n    /**\n     * Shows a modal font-chooser dialog and blocks until the\n     * dialog is hidden.  If the user presses the \"OK\" button, then\n     * this method hides/disposes the dialog and returns the selected color.\n     * If the user presses the \"Cancel\" button or closes the dialog without\n     * pressing \"OK\", then this method hides/disposes the dialog and returns\n     * <code>null</code>.\n     *\n     * @param component    the parent <code>Component</code> for the dialog\n     * @param title        the String containing the dialog's title\n     * @return the selected font or <code>null</code> if the user opted out\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public Font showDialog(Component component, String title) {\n        FontTracker ok = new FontTracker(this);\n        JDialog dialog = createDialog(component, title, true, ok, null);\n        dialog.addWindowListener(new FontChooserDialog.Closer());\n        dialog.addComponentListener(new FontChooserDialog.DisposeOnClose());\n        dialog.setAlwaysOnTop(true);\n        // blocks until user brings dialog down...\n        dialog.setVisible(true);\n        return ok.getFont();\n    }\n\n    /**\n     * Creates and returns a new dialog containing the specified\n     * <code>ColorChooser</code> pane along with \"OK\", \"Cancel\", and \"Reset\"\n     * buttons. If the \"OK\" or \"Cancel\" buttons are pressed, the dialog is\n     * automatically hidden (but not disposed).  If the \"Reset\"\n     * button is pressed, the color-chooser's color will be reset to the\n     * font which was set the last time <code>show</code> was invoked on the\n     * dialog and the dialog will remain showing.\n     *\n     * @param c              the parent component for the dialog\n     * @param title          the title for the dialog\n     * @param modal          a boolean. When true, the remainder of the program\n     *                       is inactive until the dialog is closed.\n     * @param okListener     the ActionListener invoked when \"OK\" is pressed\n     * @param cancelListener the ActionListener invoked when \"Cancel\" is pressed\n     * @return a new dialog containing the font-chooser pane\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {\n        return new FontChooserDialog(c, title, modal, this, okListener, cancelListener);\n    }\n\n    /**\n     * Creates a color chooser pane with an initial font which is the same font\n     * as the default font for labels.\n     */\n    public JFontChooser() {\n        this(new DefaultFontSelectionModel());\n    }\n\n    /**\n     * Creates a font chooser pane with the specified initial font.\n     *\n     * @param initialFont the initial font set in the chooser\n     */\n    public JFontChooser(Font initialFont) {\n        this(new DefaultFontSelectionModel(initialFont));\n    }\n\n    /**\n     * Creates a font chooser pane with the specified\n     * <code>FontSelectionModel</code>.\n     *\n     * @param model the font selection model used by this component\n     */\n    public JFontChooser(FontSelectionModel model) {\n        selectionModel = model;\n        init(model.getSelectedFont());\n        selectionModel.addChangeListener(labelUpdater);\n    }\n\n    private void init(Font font) {\n        setLayout(new GridBagLayout());\n        Insets ins = new Insets(2, 2, 2, 2);\n        fontList = new JList(FONTS);\n        fontList.setVisibleRowCount(10);\n        fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(fontList), new GridBagConstraints(0, 0, 1, 1, 2, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        sizeList = new JList(SIZES);\n        ((JLabel) sizeList.getCellRenderer()).setHorizontalAlignment(JLabel.RIGHT);\n        sizeList.setVisibleRowCount(10);\n        sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(sizeList), new GridBagConstraints(1, 0, 1, 1, 1, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        boldCheckBox = new JCheckBox(\"Bold\");\n        add(boldCheckBox, new GridBagConstraints(0, 1, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        italicCheckBox = new JCheckBox(\"Italic\");\n        add(italicCheckBox, new GridBagConstraints(0, 2, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        previewLabel = new JLabel(\"\");\n        previewLabel.setHorizontalAlignment(JLabel.CENTER);\n        previewLabel.setVerticalAlignment(JLabel.CENTER);\n        add(new JScrollPane(previewLabel), new GridBagConstraints(0, 3, 2, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        setFont(font == null ? previewLabel.getFont() : font);\n        fontList.addListSelectionListener(selectionUpdater);\n        sizeList.addListSelectionListener(selectionUpdater);\n        boldCheckBox.addChangeListener(selectionUpdater);\n        italicCheckBox.addChangeListener(selectionUpdater);\n    }\n\n    private Font buildFont() {\n        //        Font labelFont = previewLabel.getFont();\n        String fontName = (String) fontList.getSelectedValue();\n        if (fontName == null) {\n            return null;\n            //            fontName = labelFont.getName();\n        }\n        Integer sizeInt = (Integer) sizeList.getSelectedValue();\n        if (sizeInt == null) {\n            //            size = labelFont.getSize();\n            return null;\n        }\n        // create the font\n        //        // first create the font attributes\n        //        HashMap map = new HashMap();\n        //        map.put(TextAttribute.BACKGROUND, Color.white);\n        //        map.put(TextAttribute.FAMILY, fontName);\n        //        map.put(TextAttribute.FOREGROUND, Color.black);\n        //        map.put(TextAttribute.SIZE , new Float(size));\n        //        map.put(TextAttribute.UNDERLINE, italicCheckBox.isSelected() ? TextAttribute.UNDERLINE_LOW_ONE_PIXEL : TextAttribute.UNDERLINE_LOW_TWO_PIXEL);\n        //        map.put(TextAttribute.STRIKETHROUGH, italicCheckBox.isSelected() ? TextAttribute.STRIKETHROUGH_ON : Boolean.FALSE);\n        //        map.put(TextAttribute.WEIGHT, boldCheckBox.isSelected() ? TextAttribute.WEIGHT_BOLD : TextAttribute.WEIGHT_REGULAR);\n        //        map.put(TextAttribute.POSTURE,\n        //                italicCheckBox.isSelected() ? TextAttribute.POSTURE_OBLIQUE : TextAttribute.POSTURE_REGULAR);\n        //\n        //        return new Font(map);\n        return new Font(fontName, (italicCheckBox.isSelected() ? Font.ITALIC : Font.PLAIN) | (boldCheckBox.isSelected() ? Font.BOLD : Font.PLAIN), sizeInt);\n    }\n\n    /**\n     * Updates the font in the preview component according to the selected values.\n     */\n    private void updateComponents() {\n        updatingComponents = true;\n        Font font = getFont();\n        fontList.setSelectedValue(font.getName(), true);\n        sizeList.setSelectedValue(font.getSize(), true);\n        boldCheckBox.setSelected(font.isBold());\n        italicCheckBox.setSelected(font.isItalic());\n        if (previewText == null) {\n            previewLabel.setText(font.getName());\n        }\n        // set the font and fire a property change\n        Font oldValue = previewLabel.getFont();\n        previewLabel.setFont(font);\n        firePropertyChange(\"font\", oldValue, font);\n        updatingComponents = false;\n    }\n\n    /**\n     * Returns the data model that handles font selections.\n     *\n     * @return a FontSelectionModel object\n     */\n    public FontSelectionModel getSelectionModel() {\n        return selectionModel;\n    }\n\n    /**\n     * Set the model containing the selected font.\n     *\n     * @param newModel   the new FontSelectionModel object\n     */\n    public void setSelectionModel(FontSelectionModel newModel) {\n        FontSelectionModel oldModel = selectionModel;\n        selectionModel = newModel;\n        oldModel.removeChangeListener(labelUpdater);\n        newModel.addChangeListener(labelUpdater);\n        firePropertyChange(\"selectionModel\", oldModel, newModel);\n    }\n\n    /**\n     * Gets the current font value from the font chooser.\n     *\n     * @return the current font value of the font chooser\n     */\n    public Font getFont() {\n        return selectionModel.getSelectedFont();\n    }\n\n    /**\n     * Sets the current font of the font chooser to the specified font.\n     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>\n     * @param font the font to be set in the font chooser\n     * @see JComponent#addPropertyChangeListener\n     */\n    public void setFont(Font font) {\n        selectionModel.setSelectedFont(font);\n    }\n\n    /**\n     * Returns the preview text displayed in the preview component.\n     * @return the preview text, if null the font name will be displayed\n     */\n    public String getPreviewText() {\n        return previewText;\n    }\n\n    /**\n     * Sets the preview text displayed in the preview component.\n     * @param previewText the preview text, if null the font name will be displayed\n     */\n    public void setPreviewText(String previewText) {\n        this.previewText = previewText;\n        previewLabel.setText(\"\");\n        updateComponents();\n    }\n}\n\n/*\n * Class which builds a font chooser dialog consisting of\n * a JFontChooser with \"Ok\", \"Cancel\", and \"Reset\" buttons.\n *\n * Note: This needs to be fixed to deal with localization!\n */\nclass FontChooserDialog extends JDialog {\n\n    private Font initialFont;\n\n    private JFontChooser chooserPane;\n\n    public FontChooserDialog(Component c, String title, boolean modal, JFontChooser chooserPane, ActionListener okListener, ActionListener cancelListener) {\n        super(JOptionPane.getFrameForComponent(c), title, modal);\n        //setResizable(false);\n        String okString = UIManager.getString(\"ColorChooser.okText\");\n        String cancelString = UIManager.getString(\"ColorChooser.cancelText\");\n        String resetString = UIManager.getString(\"ColorChooser.resetText\");\n        /*\n         * Create Lower button panel\n         */\n        JPanel buttonPane = new JPanel();\n        buttonPane.setLayout(new FlowLayout(FlowLayout.CENTER));\n        JButton okButton = new JButton(okString);\n        getRootPane().setDefaultButton(okButton);\n        okButton.setActionCommand(\"OK\");\n        if (okListener != null) {\n            okButton.addActionListener(okListener);\n        }\n        okButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(okButton);\n        JButton cancelButton = new JButton(cancelString);\n        // The following few lines are used to register esc to close the dialog\n        Action cancelKeyAction = new AbstractAction() {\n\n            public void actionPerformed(ActionEvent e) {\n                // todo make it in 1.3\n                //                ActionListener[] listeners\n                //                        = ((AbstractButton) e.getSource()).getActionListeners();\n                //                for (int i = 0; i < listeners.length; i++) {\n                //                    listeners[i].actionPerformed(e);\n                //                }\n            }\n        };\n        KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke((char) KeyEvent.VK_ESCAPE);\n        InputMap inputMap = cancelButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);\n        ActionMap actionMap = cancelButton.getActionMap();\n        if (inputMap != null && actionMap != null) {\n            inputMap.put(cancelKeyStroke, \"cancel\");\n            actionMap.put(\"cancel\", cancelKeyAction);\n        }\n        // end esc handling\n        cancelButton.setActionCommand(\"cancel\");\n        if (cancelListener != null) {\n            cancelButton.addActionListener(cancelListener);\n        }\n        cancelButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(cancelButton);\n        JButton resetButton = new JButton(resetString);\n        resetButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                reset();\n            }\n        });\n        int mnemonic = UIManager.getInt(\"ColorChooser.resetMnemonic\");\n        if (mnemonic != -1) {\n            resetButton.setMnemonic(mnemonic);\n        }\n        buttonPane.add(resetButton);\n        // initialiase the content pane\n        this.chooserPane = chooserPane;\n        Container contentPane = getContentPane();\n        contentPane.setLayout(new BorderLayout());\n        contentPane.add(chooserPane, BorderLayout.CENTER);\n        contentPane.add(buttonPane, BorderLayout.SOUTH);\n        pack();\n        setLocationRelativeTo(c);\n    }\n\n    public void setVisible(boolean visible) {\n        if (visible)\n            initialFont = chooserPane.getFont();\n        super.setVisible(visible);\n    }\n\n    public void reset() {\n        chooserPane.setFont(initialFont);\n    }\n\n    static class Closer extends WindowAdapter implements Serializable {\n\n        public void windowClosing(WindowEvent e) {\n            Window w = e.getWindow();\n            w.setVisible(false);\n        }\n    }\n\n    static class DisposeOnClose extends ComponentAdapter implements Serializable {\n\n        public void componentHidden(ComponentEvent e) {\n            Window w = (Window) e.getComponent();\n            w.dispose();\n        }\n    }\n}\n\nclass FontTracker implements ActionListener, Serializable {\n\n    JFontChooser chooser;\n\n    Font color;\n\n    public FontTracker(JFontChooser c) {\n        chooser = c;\n    }\n\n    public void actionPerformed(ActionEvent e) {\n        color = chooser.getFont();\n    }\n\n    public Font getFont() {\n        return color;\n    }\n}\n\n/**\n * A generic implementation of <code>{@link FontSelectionModel}</code>.\n *\n * @author Adrian BER\n */\nclass DefaultFontSelectionModel implements FontSelectionModel {\n\n    /**\n     * The default selected font.\n     */\n    private static final Font DEFAULT_INITIAL_FONT = new Font(\"Dialog\", Font.PLAIN, 12);\n\n    /**\n     * The selected font.\n     */\n    private Font selectedFont;\n\n    /**\n     * The change listeners notified by a change in this model.\n     */\n    private EventListenerList listeners = new EventListenerList();\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>Dialog, 12</code>.  This is\n     * the default constructor.\n     */\n    public DefaultFontSelectionModel() {\n        this(DEFAULT_INITIAL_FONT);\n    }\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>font</code>, which should be\n     * non-<code>null</code>.  Note that setting the font to\n     * <code>null</code> is undefined and may have unpredictable\n     * results.\n     *\n     * @param selectedFont the new <code>Font</code>\n     */\n    public DefaultFontSelectionModel(Font selectedFont) {\n        if (selectedFont == null) {\n            selectedFont = DEFAULT_INITIAL_FONT;\n        }\n        this.selectedFont = selectedFont;\n    }\n\n    public Font getSelectedFont() {\n        return selectedFont;\n    }\n\n    public void setSelectedFont(Font selectedFont) {\n        if (selectedFont != null) {\n            this.selectedFont = selectedFont;\n            fireChangeListeners();\n        }\n    }\n\n    public void addChangeListener(ChangeListener listener) {\n        listeners.add(ChangeListener.class, listener);\n    }\n\n    public void removeChangeListener(ChangeListener listener) {\n        listeners.remove(ChangeListener.class, listener);\n    }\n\n    /**\n     * Fires the listeners registered with this model.\n     */\n    protected void fireChangeListeners() {\n        ChangeEvent ev = new ChangeEvent(this);\n        Object[] l = listeners.getListeners(ChangeListener.class);\n        for (Object listener : l) {\n            ((ChangeListener) listener).stateChanged(ev);\n        }\n    }\n}\n\n/**\n * A model that supports selecting a <code>Font</code>.\n *\n * @author Adrian BER\n *\n * @see java.awt.Font\n */\ninterface FontSelectionModel {\n\n    /**\n     * Returns the selected <code>Font</code> which should be\n     * non-<code>null</code>.\n     *\n     * @return  the selected <code>Font</code>\n     * @see     #setSelectedFont\n     */\n    Font getSelectedFont();\n\n    /**\n     * Sets the selected font to <code>font</code>.\n     * Note that setting the font to <code>null</code>\n     * is undefined and may have unpredictable results.\n     * This method fires a state changed event if it sets the\n     * current font to a new non-<code>null</code> font.\n     *\n     * @param font the new <code>Font</code>\n     * @see   #getSelectedFont\n     * @see   #addChangeListener\n     */\n    void setSelectedFont(Font font);\n\n    /**\n     * Adds <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be added\n     */\n    void addChangeListener(ChangeListener listener);\n\n    /**\n     * Removes <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be removed\n     */\n    void removeChangeListener(ChangeListener listener);\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooserTest0.java",
		"test_prompt": "// JFontChooserTest0.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JFontChooser}.\n* It contains ten unit test cases for the {@link JFontChooser#showDialog(Component, String)} method.\n*/\nclass JFontChooserTest0 {"
	},
	{
		"original_code": "// JFontChooser.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\n\n/**\n * <code>JFontChooser</code> provides a pane of controls designed to allow\n * a user to manipulate and select a font.\n *\n * This class provides three levels of API:\n * <ol>\n * <li>A static convenience method which shows a modal font-chooser\n * dialog and returns the font selected by the user.\n * <li>A static convenience method for creating a font-chooser dialog\n * where <code>ActionListeners</code> can be specified to be invoked when\n * the user presses one of the dialog buttons.\n * <li>The ability to create instances of <code>JFontChooser</code> panes\n * directly (within any container). <code>PropertyChange</code> listeners\n * can be added to detect when the current \"font\" property changes.\n * </ol>\n * <p>\n *\n * @author Adrian BER\n */\npublic class JFontChooser extends JComponent {\n\n    /**\n     * The list of possible font sizes.\n     */\n    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };\n\n    /**\n     * The list of possible fonts.\n     */\n    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n\n    private FontSelectionModel selectionModel;\n\n    private JList fontList;\n\n    private JList sizeList;\n\n    private JCheckBox boldCheckBox;\n\n    private JCheckBox italicCheckBox;\n\n    private JLabel previewLabel;\n\n    /**\n     * The preview text, if null the font name will be the preview text.\n     */\n    private String previewText;\n\n    /**\n     * Listener used to update the font of the selection model.\n     */\n    private SelectionUpdater selectionUpdater = new SelectionUpdater();\n\n    /**\n     * Listener used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private LabelUpdater labelUpdater = new LabelUpdater();\n\n    /**\n     * True if the components are being updated and no event should be generated.\n     */\n    private boolean updatingComponents = false;\n\n    /**\n     * Listener class used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private class LabelUpdater implements ChangeListener {\n\n        public void stateChanged(ChangeEvent e) {\n            updateComponents();\n        }\n    }\n\n    /**\n     * Listener class used to update the font of the preview label.\n     */\n    private class SelectionUpdater implements ChangeListener, ListSelectionListener {\n\n        public void stateChanged(ChangeEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n\n        public void valueChanged(ListSelectionEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n    }\n\n    /**\n     * Shows a modal font-chooser dialog and blocks until the\n     * dialog is hidden.  If the user presses the \"OK\" button, then\n     * this method hides/disposes the dialog and returns the selected color.\n     * If the user presses the \"Cancel\" button or closes the dialog without\n     * pressing \"OK\", then this method hides/disposes the dialog and returns\n     * <code>null</code>.\n     *\n     * @param component    the parent <code>Component</code> for the dialog\n     * @param title        the String containing the dialog's title\n     * @return the selected font or <code>null</code> if the user opted out\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public Font showDialog(Component component, String title) {\n        FontTracker ok = new FontTracker(this);\n        JDialog dialog = createDialog(component, title, true, ok, null);\n        dialog.addWindowListener(new FontChooserDialog.Closer());\n        dialog.addComponentListener(new FontChooserDialog.DisposeOnClose());\n        dialog.setAlwaysOnTop(true);\n        // blocks until user brings dialog down...\n        dialog.setVisible(true);\n        return ok.getFont();\n    }\n\n    /**\n     * Creates and returns a new dialog containing the specified\n     * <code>ColorChooser</code> pane along with \"OK\", \"Cancel\", and \"Reset\"\n     * buttons. If the \"OK\" or \"Cancel\" buttons are pressed, the dialog is\n     * automatically hidden (but not disposed).  If the \"Reset\"\n     * button is pressed, the color-chooser's color will be reset to the\n     * font which was set the last time <code>show</code> was invoked on the\n     * dialog and the dialog will remain showing.\n     *\n     * @param c              the parent component for the dialog\n     * @param title          the title for the dialog\n     * @param modal          a boolean. When true, the remainder of the program\n     *                       is inactive until the dialog is closed.\n     * @param okListener     the ActionListener invoked when \"OK\" is pressed\n     * @param cancelListener the ActionListener invoked when \"Cancel\" is pressed\n     * @return a new dialog containing the font-chooser pane\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {\n        return new FontChooserDialog(c, title, modal, this, okListener, cancelListener);\n    }\n\n    /**\n     * Creates a color chooser pane with an initial font which is the same font\n     * as the default font for labels.\n     */\n    public JFontChooser() {\n        this(new DefaultFontSelectionModel());\n    }\n\n    /**\n     * Creates a font chooser pane with the specified initial font.\n     *\n     * @param initialFont the initial font set in the chooser\n     */\n    public JFontChooser(Font initialFont) {\n        this(new DefaultFontSelectionModel(initialFont));\n    }\n\n    /**\n     * Creates a font chooser pane with the specified\n     * <code>FontSelectionModel</code>.\n     *\n     * @param model the font selection model used by this component\n     */\n    public JFontChooser(FontSelectionModel model) {\n        selectionModel = model;\n        init(model.getSelectedFont());\n        selectionModel.addChangeListener(labelUpdater);\n    }\n\n    private void init(Font font) {\n        setLayout(new GridBagLayout());\n        Insets ins = new Insets(2, 2, 2, 2);\n        fontList = new JList(FONTS);\n        fontList.setVisibleRowCount(10);\n        fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(fontList), new GridBagConstraints(0, 0, 1, 1, 2, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        sizeList = new JList(SIZES);\n        ((JLabel) sizeList.getCellRenderer()).setHorizontalAlignment(JLabel.RIGHT);\n        sizeList.setVisibleRowCount(10);\n        sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(sizeList), new GridBagConstraints(1, 0, 1, 1, 1, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        boldCheckBox = new JCheckBox(\"Bold\");\n        add(boldCheckBox, new GridBagConstraints(0, 1, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        italicCheckBox = new JCheckBox(\"Italic\");\n        add(italicCheckBox, new GridBagConstraints(0, 2, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        previewLabel = new JLabel(\"\");\n        previewLabel.setHorizontalAlignment(JLabel.CENTER);\n        previewLabel.setVerticalAlignment(JLabel.CENTER);\n        add(new JScrollPane(previewLabel), new GridBagConstraints(0, 3, 2, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        setFont(font == null ? previewLabel.getFont() : font);\n        fontList.addListSelectionListener(selectionUpdater);\n        sizeList.addListSelectionListener(selectionUpdater);\n        boldCheckBox.addChangeListener(selectionUpdater);\n        italicCheckBox.addChangeListener(selectionUpdater);\n    }\n\n    private Font buildFont() {\n        //        Font labelFont = previewLabel.getFont();\n        String fontName = (String) fontList.getSelectedValue();\n        if (fontName == null) {\n            return null;\n            //            fontName = labelFont.getName();\n        }\n        Integer sizeInt = (Integer) sizeList.getSelectedValue();\n        if (sizeInt == null) {\n            //            size = labelFont.getSize();\n            return null;\n        }\n        // create the font\n        //        // first create the font attributes\n        //        HashMap map = new HashMap();\n        //        map.put(TextAttribute.BACKGROUND, Color.white);\n        //        map.put(TextAttribute.FAMILY, fontName);\n        //        map.put(TextAttribute.FOREGROUND, Color.black);\n        //        map.put(TextAttribute.SIZE , new Float(size));\n        //        map.put(TextAttribute.UNDERLINE, italicCheckBox.isSelected() ? TextAttribute.UNDERLINE_LOW_ONE_PIXEL : TextAttribute.UNDERLINE_LOW_TWO_PIXEL);\n        //        map.put(TextAttribute.STRIKETHROUGH, italicCheckBox.isSelected() ? TextAttribute.STRIKETHROUGH_ON : Boolean.FALSE);\n        //        map.put(TextAttribute.WEIGHT, boldCheckBox.isSelected() ? TextAttribute.WEIGHT_BOLD : TextAttribute.WEIGHT_REGULAR);\n        //        map.put(TextAttribute.POSTURE,\n        //                italicCheckBox.isSelected() ? TextAttribute.POSTURE_OBLIQUE : TextAttribute.POSTURE_REGULAR);\n        //\n        //        return new Font(map);\n        return new Font(fontName, (italicCheckBox.isSelected() ? Font.ITALIC : Font.PLAIN) | (boldCheckBox.isSelected() ? Font.BOLD : Font.PLAIN), sizeInt);\n    }\n\n    /**\n     * Updates the font in the preview component according to the selected values.\n     */\n    private void updateComponents() {\n        updatingComponents = true;\n        Font font = getFont();\n        fontList.setSelectedValue(font.getName(), true);\n        sizeList.setSelectedValue(font.getSize(), true);\n        boldCheckBox.setSelected(font.isBold());\n        italicCheckBox.setSelected(font.isItalic());\n        if (previewText == null) {\n            previewLabel.setText(font.getName());\n        }\n        // set the font and fire a property change\n        Font oldValue = previewLabel.getFont();\n        previewLabel.setFont(font);\n        firePropertyChange(\"font\", oldValue, font);\n        updatingComponents = false;\n    }\n\n    /**\n     * Returns the data model that handles font selections.\n     *\n     * @return a FontSelectionModel object\n     */\n    public FontSelectionModel getSelectionModel() {\n        return selectionModel;\n    }\n\n    /**\n     * Set the model containing the selected font.\n     *\n     * @param newModel   the new FontSelectionModel object\n     */\n    public void setSelectionModel(FontSelectionModel newModel) {\n        FontSelectionModel oldModel = selectionModel;\n        selectionModel = newModel;\n        oldModel.removeChangeListener(labelUpdater);\n        newModel.addChangeListener(labelUpdater);\n        firePropertyChange(\"selectionModel\", oldModel, newModel);\n    }\n\n    /**\n     * Gets the current font value from the font chooser.\n     *\n     * @return the current font value of the font chooser\n     */\n    public Font getFont() {\n        return selectionModel.getSelectedFont();\n    }\n\n    /**\n     * Sets the current font of the font chooser to the specified font.\n     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>\n     * @param font the font to be set in the font chooser\n     * @see JComponent#addPropertyChangeListener\n     */\n    public void setFont(Font font) {\n        selectionModel.setSelectedFont(font);\n    }\n\n    /**\n     * Returns the preview text displayed in the preview component.\n     * @return the preview text, if null the font name will be displayed\n     */\n    public String getPreviewText() {\n        return previewText;\n    }\n\n    /**\n     * Sets the preview text displayed in the preview component.\n     * @param previewText the preview text, if null the font name will be displayed\n     */\n    public void setPreviewText(String previewText) {\n        this.previewText = previewText;\n        previewLabel.setText(\"\");\n        updateComponents();\n    }\n}\n\n/*\n * Class which builds a font chooser dialog consisting of\n * a JFontChooser with \"Ok\", \"Cancel\", and \"Reset\" buttons.\n *\n * Note: This needs to be fixed to deal with localization!\n */\nclass FontChooserDialog extends JDialog {\n\n    private Font initialFont;\n\n    private JFontChooser chooserPane;\n\n    public FontChooserDialog(Component c, String title, boolean modal, JFontChooser chooserPane, ActionListener okListener, ActionListener cancelListener) {\n        super(JOptionPane.getFrameForComponent(c), title, modal);\n        //setResizable(false);\n        String okString = UIManager.getString(\"ColorChooser.okText\");\n        String cancelString = UIManager.getString(\"ColorChooser.cancelText\");\n        String resetString = UIManager.getString(\"ColorChooser.resetText\");\n        /*\n         * Create Lower button panel\n         */\n        JPanel buttonPane = new JPanel();\n        buttonPane.setLayout(new FlowLayout(FlowLayout.CENTER));\n        JButton okButton = new JButton(okString);\n        getRootPane().setDefaultButton(okButton);\n        okButton.setActionCommand(\"OK\");\n        if (okListener != null) {\n            okButton.addActionListener(okListener);\n        }\n        okButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(okButton);\n        JButton cancelButton = new JButton(cancelString);\n        // The following few lines are used to register esc to close the dialog\n        Action cancelKeyAction = new AbstractAction() {\n\n            public void actionPerformed(ActionEvent e) {\n                // todo make it in 1.3\n                //                ActionListener[] listeners\n                //                        = ((AbstractButton) e.getSource()).getActionListeners();\n                //                for (int i = 0; i < listeners.length; i++) {\n                //                    listeners[i].actionPerformed(e);\n                //                }\n            }\n        };\n        KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke((char) KeyEvent.VK_ESCAPE);\n        InputMap inputMap = cancelButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);\n        ActionMap actionMap = cancelButton.getActionMap();\n        if (inputMap != null && actionMap != null) {\n            inputMap.put(cancelKeyStroke, \"cancel\");\n            actionMap.put(\"cancel\", cancelKeyAction);\n        }\n        // end esc handling\n        cancelButton.setActionCommand(\"cancel\");\n        if (cancelListener != null) {\n            cancelButton.addActionListener(cancelListener);\n        }\n        cancelButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(cancelButton);\n        JButton resetButton = new JButton(resetString);\n        resetButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                reset();\n            }\n        });\n        int mnemonic = UIManager.getInt(\"ColorChooser.resetMnemonic\");\n        if (mnemonic != -1) {\n            resetButton.setMnemonic(mnemonic);\n        }\n        buttonPane.add(resetButton);\n        // initialiase the content pane\n        this.chooserPane = chooserPane;\n        Container contentPane = getContentPane();\n        contentPane.setLayout(new BorderLayout());\n        contentPane.add(chooserPane, BorderLayout.CENTER);\n        contentPane.add(buttonPane, BorderLayout.SOUTH);\n        pack();\n        setLocationRelativeTo(c);\n    }\n\n    public void setVisible(boolean visible) {\n        if (visible)\n            initialFont = chooserPane.getFont();\n        super.setVisible(visible);\n    }\n\n    public void reset() {\n        chooserPane.setFont(initialFont);\n    }\n\n    static class Closer extends WindowAdapter implements Serializable {\n\n        public void windowClosing(WindowEvent e) {\n            Window w = e.getWindow();\n            w.setVisible(false);\n        }\n    }\n\n    static class DisposeOnClose extends ComponentAdapter implements Serializable {\n\n        public void componentHidden(ComponentEvent e) {\n            Window w = (Window) e.getComponent();\n            w.dispose();\n        }\n    }\n}\n\nclass FontTracker implements ActionListener, Serializable {\n\n    JFontChooser chooser;\n\n    Font color;\n\n    public FontTracker(JFontChooser c) {\n        chooser = c;\n    }\n\n    public void actionPerformed(ActionEvent e) {\n        color = chooser.getFont();\n    }\n\n    public Font getFont() {\n        return color;\n    }\n}\n\n/**\n * A generic implementation of <code>{@link FontSelectionModel}</code>.\n *\n * @author Adrian BER\n */\nclass DefaultFontSelectionModel implements FontSelectionModel {\n\n    /**\n     * The default selected font.\n     */\n    private static final Font DEFAULT_INITIAL_FONT = new Font(\"Dialog\", Font.PLAIN, 12);\n\n    /**\n     * The selected font.\n     */\n    private Font selectedFont;\n\n    /**\n     * The change listeners notified by a change in this model.\n     */\n    private EventListenerList listeners = new EventListenerList();\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>Dialog, 12</code>.  This is\n     * the default constructor.\n     */\n    public DefaultFontSelectionModel() {\n        this(DEFAULT_INITIAL_FONT);\n    }\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>font</code>, which should be\n     * non-<code>null</code>.  Note that setting the font to\n     * <code>null</code> is undefined and may have unpredictable\n     * results.\n     *\n     * @param selectedFont the new <code>Font</code>\n     */\n    public DefaultFontSelectionModel(Font selectedFont) {\n        if (selectedFont == null) {\n            selectedFont = DEFAULT_INITIAL_FONT;\n        }\n        this.selectedFont = selectedFont;\n    }\n\n    public Font getSelectedFont() {\n        return selectedFont;\n    }\n\n    public void setSelectedFont(Font selectedFont) {\n        if (selectedFont != null) {\n            this.selectedFont = selectedFont;\n            fireChangeListeners();\n        }\n    }\n\n    public void addChangeListener(ChangeListener listener) {\n        listeners.add(ChangeListener.class, listener);\n    }\n\n    public void removeChangeListener(ChangeListener listener) {\n        listeners.remove(ChangeListener.class, listener);\n    }\n\n    /**\n     * Fires the listeners registered with this model.\n     */\n    protected void fireChangeListeners() {\n        ChangeEvent ev = new ChangeEvent(this);\n        Object[] l = listeners.getListeners(ChangeListener.class);\n        for (Object listener : l) {\n            ((ChangeListener) listener).stateChanged(ev);\n        }\n    }\n}\n\n/**\n * A model that supports selecting a <code>Font</code>.\n *\n * @author Adrian BER\n *\n * @see java.awt.Font\n */\ninterface FontSelectionModel {\n\n    /**\n     * Returns the selected <code>Font</code> which should be\n     * non-<code>null</code>.\n     *\n     * @return  the selected <code>Font</code>\n     * @see     #setSelectedFont\n     */\n    Font getSelectedFont();\n\n    /**\n     * Sets the selected font to <code>font</code>.\n     * Note that setting the font to <code>null</code>\n     * is undefined and may have unpredictable results.\n     * This method fires a state changed event if it sets the\n     * current font to a new non-<code>null</code> font.\n     *\n     * @param font the new <code>Font</code>\n     * @see   #getSelectedFont\n     * @see   #addChangeListener\n     */\n    void setSelectedFont(Font font);\n\n    /**\n     * Adds <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be added\n     */\n    void addChangeListener(ChangeListener listener);\n\n    /**\n     * Removes <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be removed\n     */\n    void removeChangeListener(ChangeListener listener);\n}\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooserTest1.java",
		"test_prompt": "// JFontChooserTest1.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JFontChooser}.\n* It contains ten unit test cases for the {@link JFontChooser#createDialog(Component, String, boolean, ActionListener, ActionListener)} method.\n*/\nclass JFontChooserTest1 {"
	},
	{
		"original_code": "// FileTransferHandler.java\n/*\r\n * FileTransferHandler.java\r\n *\r\n * Created on November 4, 2009, 10:19 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client.ui.utils;\r\n\r\nimport java.awt.datatransfer.*;\r\nimport java.io.*;\r\nimport javax.swing.*;\r\nimport osa.ora.server.client.ui.ParentPanel;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileTransferHandler extends TransferHandler {\r\n\r\n    ParentPanel parentPanel;\r\n\r\n    /**\r\n     * Creates a new instance of FileTransferHandler\r\n     */\r\n    public FileTransferHandler(ParentPanel chatPanel) {\r\n        super();\r\n        this.parentPanel = chatPanel;\r\n    }\r\n\r\n    public static final DataFlavor[] flavors = { DataFlavor.javaFileListFlavor };\r\n\r\n    public int getSourceActions(JComponent c) {\r\n        return TransferHandler.COPY;\r\n    }\r\n\r\n    public boolean canImport(JComponent comp, DataFlavor[] flavor) {\r\n        for (int i = 0, n = flavor.length; i < n; i++) {\r\n            for (int j = 0, m = flavors.length; j < m; j++) {\r\n                if (flavor[i].equals(flavors[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean importData(JComponent comp, Transferable t) {\r\n        if (t.isDataFlavorSupported(flavors[0])) {\r\n            try {\r\n                java.util.List list = (java.util.List) t.getTransferData(flavors[0]);\r\n                for (int i = 0; i < list.size(); i++) {\r\n                    if (!((File) list.get(i)).isFile()) {\r\n                        // not a file, do something\r\n                        return false;\r\n                    }\r\n                    // is a file, check for file suffix and see if it's one that you want to support\r\n                    //System.out.println(((File) list.get(i)).toURL());\r\n                    File file = (((File) list.get(i)));\r\n                    parentPanel.sendFileInit(file);\r\n                    //stream the file...\r\n                    return true;\r\n                }\r\n            } catch (UnsupportedFlavorException ignored) {\r\n            } catch (java.io.IOException ignored) {\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/FileTransferHandlerTest0.java",
		"test_prompt": "// FileTransferHandlerTest0.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport javax.swing.*;\nimport osa.ora.server.client.ui.ParentPanel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileTransferHandler}.\n* It contains ten unit test cases for the {@link FileTransferHandler#canImport(JComponent, DataFlavor[])} method.\n*/\nclass FileTransferHandlerTest0 {"
	},
	{
		"original_code": "// FileTransferHandler.java\n/*\r\n * FileTransferHandler.java\r\n *\r\n * Created on November 4, 2009, 10:19 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client.ui.utils;\r\n\r\nimport java.awt.datatransfer.*;\r\nimport java.io.*;\r\nimport javax.swing.*;\r\nimport osa.ora.server.client.ui.ParentPanel;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class FileTransferHandler extends TransferHandler {\r\n\r\n    ParentPanel parentPanel;\r\n\r\n    /**\r\n     * Creates a new instance of FileTransferHandler\r\n     */\r\n    public FileTransferHandler(ParentPanel chatPanel) {\r\n        super();\r\n        this.parentPanel = chatPanel;\r\n    }\r\n\r\n    public static final DataFlavor[] flavors = { DataFlavor.javaFileListFlavor };\r\n\r\n    public int getSourceActions(JComponent c) {\r\n        return TransferHandler.COPY;\r\n    }\r\n\r\n    public boolean canImport(JComponent comp, DataFlavor[] flavor) {\r\n        for (int i = 0, n = flavor.length; i < n; i++) {\r\n            for (int j = 0, m = flavors.length; j < m; j++) {\r\n                if (flavor[i].equals(flavors[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean importData(JComponent comp, Transferable t) {\r\n        if (t.isDataFlavorSupported(flavors[0])) {\r\n            try {\r\n                java.util.List list = (java.util.List) t.getTransferData(flavors[0]);\r\n                for (int i = 0; i < list.size(); i++) {\r\n                    if (!((File) list.get(i)).isFile()) {\r\n                        // not a file, do something\r\n                        return false;\r\n                    }\r\n                    // is a file, check for file suffix and see if it's one that you want to support\r\n                    //System.out.println(((File) list.get(i)).toURL());\r\n                    File file = (((File) list.get(i)));\r\n                    parentPanel.sendFileInit(file);\r\n                    //stream the file...\r\n                    return true;\r\n                }\r\n            } catch (UnsupportedFlavorException ignored) {\r\n            } catch (java.io.IOException ignored) {\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/FileTransferHandlerTest1.java",
		"test_prompt": "// FileTransferHandlerTest1.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport javax.swing.*;\nimport osa.ora.server.client.ui.ParentPanel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileTransferHandler}.\n* It contains ten unit test cases for the {@link FileTransferHandler#importData(JComponent, Transferable)} method.\n*/\nclass FileTransferHandlerTest1 {"
	},
	{
		"original_code": "// TreeModelGenerator.java\n/*\r\n * TreeModelGenerator.java\r\n *\r\n * Created on October 29, 2009, 10:35 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client.ui.utils;\r\n\r\nimport java.util.Vector;\r\nimport javax.swing.tree.DefaultMutableTreeNode;\r\nimport javax.swing.tree.DefaultTreeModel;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.User;\r\n\r\npublic class TreeModelGenerator {\r\n\r\n    /**\r\n     * @param spaces\r\n     * @return\r\n     */\r\n    public static DefaultTreeModel getModel(String rootNodeStr, Vector groups, Vector rooms, User user, boolean showOnlineOnly, boolean showUsersOnly) {\r\n        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(rootNodeStr);\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            if (showUsersOnly) {\r\n                if (((Group) groups.get(i)).getUsers() != null) {\r\n                    setChildes(rootNode, ((Group) groups.get(i)).getUsers(), user, showOnlineOnly);\r\n                }\r\n            } else {\r\n                DefaultMutableTreeNode nodeTemp = new DefaultMutableTreeNode(groups.get(i));\r\n                rootNode.add(nodeTemp);\r\n                if (((Group) groups.get(i)).getUsers() != null) {\r\n                    setChildes(nodeTemp, ((Group) groups.get(i)).getUsers(), user, showOnlineOnly);\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i < rooms.size(); i++) {\r\n            DefaultMutableTreeNode nodeTemp = new DefaultMutableTreeNode(rooms.get(i));\r\n            rootNode.add(nodeTemp);\r\n        }\r\n        return new DefaultTreeModel(rootNode);\r\n    }\r\n\r\n    /**\r\n     * @param selectedNode\r\n     * @param content\r\n     */\r\n    public static void setChildes(DefaultMutableTreeNode selectedNode, Vector<User> content, User user, boolean showOnlineOnly) {\r\n        for (int i = 0; i < content.size(); i++) {\r\n            if (user != null && user.getId() != content.get(i).getId()) {\r\n                if (showOnlineOnly) {\r\n                    if (content.get(i).getStatus_id() > 0) {\r\n                        DefaultMutableTreeNode dmn = new DefaultMutableTreeNode(content.get(i));\r\n                        selectedNode.add(dmn);\r\n                    }\r\n                } else {\r\n                    DefaultMutableTreeNode dmn = new DefaultMutableTreeNode(content.get(i));\r\n                    selectedNode.add(dmn);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/TreeModelGeneratorTest.java",
		"test_prompt": "// TreeModelGeneratorTest.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.util.Vector;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport javax.swing.tree.DefaultTreeModel;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.User;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TreeModelGenerator}.\n* It contains ten unit test cases for the {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.\n*/\nclass TreeModelGeneratorTest {"
	},
	{
		"original_code": "// ChatFrame.java\n/*\r\n * ChatFrame.java\r\n *\r\n * Created on October 29, 2009, 2:48 PM\r\n */\r\npackage osa.ora.server.client.ui;\r\n\r\nimport java.awt.event.ItemEvent;\r\nimport javax.swing.Icon;\r\nimport javax.swing.JButton;\r\nimport javax.swing.JPanel;\r\nimport osa.ora.server.client.*;\r\nimport osa.ora.server.client.ui.utils.ClosableTabbedPaneUI;\r\n\r\n/**\r\n * @author  ooransa\r\n */\r\npublic class ChatFrame extends javax.swing.JFrame {\r\n\r\n    private int initial_status = 0;\r\n\r\n    /**\r\n     * Creates new form ChatFrame\r\n     */\r\n    ChatClientApp chatApp;\r\n\r\n    AboutDialog aboutUI;\r\n\r\n    public ChatFrame(ChatClientApp chatApp) {\r\n        this.chatApp = chatApp;\r\n        //will changed to accept initalization of initial_status\r\n        initComponents();\r\n        aboutUI = new AboutDialog(this, true);\r\n        aboutUI.setTitle(\"Free Instant Messenger\");\r\n        aboutUI.setResizable(false);\r\n        aboutUI.setSize(230, 205);\r\n        aboutUI.setLocationRelativeTo(copyrightButton);\r\n        aboutUI.setAlwaysOnTop(true);\r\n    }\r\n\r\n    /**\r\n     * This method is called from within the constructor to\r\n     * initialize the form.\r\n     * WARNING: Do NOT modify this code. The content of this method is\r\n     * always regenerated by the Form Editor.\r\n     */\r\n    private void initComponents() {\r\n        jLabel1 = new javax.swing.JLabel();\r\n        jPanel1 = new javax.swing.JPanel();\r\n        jLabel2 = new javax.swing.JLabel();\r\n        statsComboBox = new javax.swing.JComboBox();\r\n        settingsButton = new javax.swing.JButton();\r\n        copyrightButton = new JButton();\r\n        jPanel2 = new javax.swing.JPanel();\r\n        JPanel jPanel5 = new javax.swing.JPanel();\r\n        setParentTabbedPane(new javax.swing.JTabbedPane());\r\n        ClosableTabbedPaneUI myTestPlaf = new ClosableTabbedPaneUI(chatApp);\r\n        getParentTabbedPane().setUI(myTestPlaf);\r\n        contactsPanel = new javax.swing.JPanel();\r\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\r\n        //jLabel1.setIcon(new ImageIcon(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/banner1.JPG\")).getScaledInstance(jLabel1.getWidth(), jLabel1.getHeight(), Image.SCALE_SMOOTH)));\r\n        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/banner.png\")));\r\n        getContentPane().add(jPanel5, java.awt.BorderLayout.NORTH);\r\n        jPanel5.add(jLabel1);\r\n        jPanel1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));\r\n        jLabel2.setText(\"Status\");\r\n        jPanel1.add(jLabel2);\r\n        statsComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"Sign Out\" }));\r\n        statsComboBox.setPreferredSize(new java.awt.Dimension(99, 22));\r\n        statsComboBox.setSelectedIndex(initial_status);\r\n        statsComboBox.setEnabled(false);\r\n        jPanel1.add(statsComboBox);\r\n        settingsButton.setText(\"Settings\");\r\n        settingsButton.addActionListener(new java.awt.event.ActionListener() {\r\n\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                settingsButtonActionPerformed(evt);\r\n            }\r\n        });\r\n        jPanel1.add(settingsButton);\r\n        copyrightButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/chat.png\")));\r\n        copyrightButton.addActionListener(new java.awt.event.ActionListener() {\r\n\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                copyRightButtonActionPerformed(evt);\r\n            }\r\n        });\r\n        jPanel1.add(copyrightButton);\r\n        getContentPane().add(jPanel1, java.awt.BorderLayout.SOUTH);\r\n        jPanel2.setLayout(new java.awt.BorderLayout());\r\n        getParentTabbedPane().setTabLayoutPolicy(javax.swing.JTabbedPane.SCROLL_TAB_LAYOUT);\r\n        contactsPanel.setLayout(new java.awt.BorderLayout());\r\n        getParentTabbedPane().addTab(\"Login\", new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")), contactsPanel);\r\n        jPanel2.add(getParentTabbedPane(), java.awt.BorderLayout.CENTER);\r\n        getContentPane().add(jPanel2, java.awt.BorderLayout.CENTER);\r\n        /*\r\n        this.addMouseMotionListener(new MouseMotionListener() {\r\n            public void mouseDragged(MouseEvent e) {\r\n            }\r\n            public void mouseMoved(MouseEvent e) {\r\n                //System.out.println(\"mouse over\");\r\n                chatApp.number=20;                \r\n            }\r\n        });*/\r\n        pack();\r\n    }\r\n\r\n    private void statusChanged() {\r\n        if (initial_status != statsComboBox.getSelectedIndex()) {\r\n            chatApp.updateMyStatus(statsComboBox.getSelectedIndex());\r\n            initial_status = statsComboBox.getSelectedIndex();\r\n        }\r\n    }\r\n\r\n    private void settingsButtonActionPerformed(java.awt.event.ActionEvent evt) {\r\n        //GEN-FIRST:event_settingsButtonActionPerformed\r\n        chatApp.showSettings();\r\n    }\r\n\r\n    //GEN-LAST:event_settingsButtonActionPerformed\r\n    private void copyRightButtonActionPerformed(java.awt.event.ActionEvent evt) {\r\n        aboutUI.setVisible(true);\r\n    }\r\n\r\n    public void updateStatusList(String[] statusList, int defaultStatus) {\r\n        statsComboBox.setModel(new javax.swing.DefaultComboBoxModel(statusList));\r\n        statsComboBox.setSelectedIndex(defaultStatus);\r\n        initial_status = defaultStatus;\r\n        statsComboBox.addItemListener(new java.awt.event.ItemListener() {\r\n\r\n            public void itemStateChanged(ItemEvent e) {\r\n                statusChanged();\r\n            }\r\n        });\r\n        statsComboBox.validate();\r\n    }\r\n\r\n    /**\r\n     * @param args the command line arguments\r\n     */\r\n    public static void main(String[] args) {\r\n        java.awt.EventQueue.invokeLater(new Runnable() {\r\n\r\n            public void run() {\r\n                new ChatFrame(null).setVisible(true);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Variables declaration - do not modify//GEN-BEGIN:variables\r\n    private javax.swing.JPanel contactsPanel;\r\n\r\n    private javax.swing.JLabel jLabel1;\r\n\r\n    private javax.swing.JLabel jLabel2;\r\n\r\n    private javax.swing.JPanel jPanel1;\r\n\r\n    private javax.swing.JPanel jPanel2;\r\n\r\n    private javax.swing.JTabbedPane parentTabbedPane;\r\n\r\n    private javax.swing.JButton settingsButton;\r\n\r\n    private javax.swing.JComboBox statsComboBox;\r\n\r\n    // End of variables declaration//GEN-END:variables\r\n    private JButton copyrightButton;\r\n\r\n    public JPanel getContactPanel() {\r\n        return contactsPanel;\r\n    }\r\n\r\n    public boolean addNewFrame(String title, Icon icon, ChatWindowPanel newPanel) {\r\n        int n = getParentTabbedPane().getTabCount();\r\n        boolean not_exist = true;\r\n        for (int i = 0; i < n; i++) {\r\n            if (getParentTabbedPane().getTitleAt(i).equals(title)) {\r\n                not_exist = false;\r\n                getParentTabbedPane().setSelectedIndex(i);\r\n                return false;\r\n            }\r\n        }\r\n        if (not_exist) {\r\n            getParentTabbedPane().addTab(title, icon, newPanel);\r\n            getParentTabbedPane().setSelectedIndex(getParentTabbedPane().getTabCount() - 1);\r\n            getParentTabbedPane().validate();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public void updateFrameIconForUser(String title, Icon icon) {\r\n        int n = getParentTabbedPane().getTabCount();\r\n        for (int i = 0; i < n; i++) {\r\n            if (getParentTabbedPane().getTitleAt(i).equals(title)) {\r\n                getParentTabbedPane().setIconAt(i, icon);\r\n                getParentTabbedPane().repaint();\r\n                getParentTabbedPane().validate();\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    public void setIconAt(int index, Icon icon) {\r\n        getParentTabbedPane().setIconAt(index, icon);\r\n    }\r\n\r\n    public void setTitleAt(int index, String title) {\r\n        getParentTabbedPane().setTitleAt(index, title);\r\n    }\r\n\r\n    public void removeFrame(int index) {\r\n        getParentTabbedPane().removeTabAt(index);\r\n    }\r\n\r\n    public int getCurrentStatus() {\r\n        return statsComboBox.getSelectedIndex();\r\n    }\r\n\r\n    public void changeStatusEnabled(boolean enable) {\r\n        statsComboBox.setEnabled(enable);\r\n    }\r\n\r\n    ////////////////////////clasees to add close button to the tab...\r\n    public void updateUserStatus(int status) {\r\n        statsComboBox.setSelectedIndex(status);\r\n    }\r\n\r\n    public int getInitial_status() {\r\n        return initial_status;\r\n    }\r\n\r\n    public void setInitial_status(int initial_status) {\r\n        this.initial_status = initial_status;\r\n    }\r\n\r\n    public javax.swing.JTabbedPane getParentTabbedPane() {\r\n        return parentTabbedPane;\r\n    }\r\n\r\n    public void setParentTabbedPane(javax.swing.JTabbedPane parentTabbedPane) {\r\n        this.parentTabbedPane = parentTabbedPane;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/ChatFrameTest.java",
		"test_prompt": "// ChatFrameTest.java\npackage osa.ora.server.client.ui;\n\nimport java.awt.event.ItemEvent;\nimport javax.swing.Icon;\nimport javax.swing.JButton;\nimport javax.swing.JPanel;\nimport osa.ora.server.client.*;\nimport osa.ora.server.client.ui.utils.ClosableTabbedPaneUI;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatFrame}.\n* It contains ten unit test cases for the {@link ChatFrame#addNewFrame(String, Icon, ChatWindowPanel)} method.\n*/\nclass ChatFrameTest {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest0.java",
		"test_prompt": "// ChatClientAppTest0.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#ping()} method.\n*/\nclass ChatClientAppTest0 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest1.java",
		"test_prompt": "// ChatClientAppTest1.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#changePassword(String, String)} method.\n*/\nclass ChatClientAppTest1 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest2.java",
		"test_prompt": "// ChatClientAppTest2.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#sendTextMessage(TextMessage)} method.\n*/\nclass ChatClientAppTest2 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest3.java",
		"test_prompt": "// ChatClientAppTest3.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ChatClientAppTest3 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest4.java",
		"test_prompt": "// ChatClientAppTest4.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#receiveTextMessage(TextMessage)} method.\n*/\nclass ChatClientAppTest4 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest5.java",
		"test_prompt": "// ChatClientAppTest5.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#receiveBinaryMessageRequest(BinaryMessage)} method.\n*/\nclass ChatClientAppTest5 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest6.java",
		"test_prompt": "// ChatClientAppTest6.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#receiveSecureTextMessage(TextMessage)} method.\n*/\nclass ChatClientAppTest6 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest7.java",
		"test_prompt": "// ChatClientAppTest7.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#receiveSecureBinaryMessageRequest(BinaryMessage)} method.\n*/\nclass ChatClientAppTest7 {"
	},
	{
		"original_code": "// ChatClientApp.java\n/*\r\n * ChatClientApp.java\r\n *\r\n * Created on October 27, 2009, 1:45 PM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server.client;\r\n\r\nimport com.birosoft.liquid.LiquidLookAndFeel;\r\nimport java.applet.Applet;\r\nimport java.applet.AudioClip;\r\nimport java.awt.Dimension;\r\nimport java.awt.Image;\r\nimport java.awt.Toolkit;\r\nimport java.awt.event.WindowEvent;\r\nimport java.awt.event.WindowListener;\r\nimport java.io.File;\r\nimport java.io.Serializable;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.SwingUtilities;\r\nimport javax.swing.UIManager;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.Status;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport javax.swing.JDialog;\r\nimport javax.swing.JFileChooser;\r\nimport osa.ora.server.ServerClientInterface;\r\nimport osa.ora.server.beans.ClientSettingBean;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.client.threads.PingServerThread;\r\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\r\nimport osa.ora.server.client.threads.ReceiveFileThread;\r\nimport osa.ora.server.client.threads.SendAnnouncementThread;\r\nimport osa.ora.server.client.threads.SendMyStatusThread;\r\nimport osa.ora.server.client.ui.ChangePassPanel;\r\nimport osa.ora.server.client.ui.ChatFrame;\r\nimport osa.ora.server.client.ui.ChatSysTray;\r\nimport osa.ora.server.client.ui.ChatWindowPanel;\r\nimport osa.ora.server.client.ui.ContactsPanel;\r\nimport osa.ora.server.client.ui.EmotionPanel;\r\nimport osa.ora.server.client.ui.FontPanel;\r\nimport osa.ora.server.client.ui.LoginPanel;\r\nimport osa.ora.server.client.ui.SettingPanel;\r\nimport osa.ora.server.utils.FileEncrypter;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n */\r\npublic class ChatClientApp extends UnicastRemoteObject implements ClientInterface, Serializable, Runnable, WindowListener {\r\n\r\n    private ServerClientInterface serverInterface;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    private Hashtable<Integer, Status> statusLookup;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanels;\r\n\r\n    private Hashtable<Integer, ChatWindowPanel> openChatPanelsByIndex;\r\n\r\n    private static Hashtable<String, String> emotionImages;\r\n\r\n    private String lookString = \"com.birosoft.liquid.LiquidLookAndFeel\";\r\n\r\n    private User user;\r\n\r\n    private ChatSysTray chatSysTray;\r\n\r\n    private LoginPanel loginPanel;\r\n\r\n    private ContactsPanel contactsPanel;\r\n\r\n    private ChatFrame chatClientFrame;\r\n\r\n    private EmotionPanel emotionPanel;\r\n\r\n    private FontPanel fontPanel;\r\n\r\n    private JDialog emotionFrame;\r\n\r\n    private JDialog fontFrame;\r\n\r\n    private JDialog settingsFrame;\r\n\r\n    private JDialog changePassFrame;\r\n\r\n    private SettingPanel settingPanel;\r\n\r\n    private ChangePassPanel changePassPanel;\r\n\r\n    private static String path = \"\";\r\n\r\n    private ImageIcon group_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon room_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/room.png\")).getScaledInstance(25, 25, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon online_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/online.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon offline_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/offline.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon busy_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/busy.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon away_icon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/away.png\")).getScaledInstance(20, 20, Image.SCALE_SMOOTH));\r\n\r\n    private ImageIcon[] userStatusIcons = new ImageIcon[5];\r\n\r\n    private ImageIcon errorIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/error.png\")));\r\n\r\n    //private ImageIcon chatIcon = new ImageIcon(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n    private Thread th;\r\n\r\n    private int number = 0;\r\n\r\n    private String title = \"\";\r\n\r\n    private JFileChooser jfm;\r\n\r\n    private AudioClip ac;\r\n\r\n    private ClientSettingBean clientSettingBean;\r\n\r\n    private InetAddress ownIP;\r\n\r\n    private PingServerThread pingServerThread;\r\n\r\n    private int securityMode;\r\n\r\n    private String rootNode;\r\n\r\n    private String securityToke;\r\n\r\n    private StringEncrypter stringEnc;\r\n\r\n    /**\r\n     * Creates a new instance of ChatClientApp\r\n     */\r\n    public ChatClientApp() throws RemoteException {\r\n        userStatusIcons[0] = offline_icon;\r\n        userStatusIcons[1] = offline_icon;\r\n        userStatusIcons[2] = online_icon;\r\n        userStatusIcons[3] = busy_icon;\r\n        userStatusIcons[4] = away_icon;\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n        try {\r\n            path = ChatClientApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        path = getPath().substring(0, getPath().lastIndexOf('/') + 1);\r\n        try {\r\n            ownIP = InetAddress.getLocalHost();\r\n        } catch (Exception e) {\r\n        }\r\n        clientSettingBean = new ClientSettingBean(path);\r\n        System.out.println(\"ServerIP=\" + clientSettingBean.getServerURL());\r\n        System.out.println(\"ServerPort=\" + clientSettingBean.getServerPort());\r\n        initSound();\r\n        jfm = new JFileChooser();\r\n        jfm.setMultiSelectionEnabled(false);\r\n        jfm.setFileSelectionMode(JFileChooser.FILES_ONLY);\r\n        jfm.setDialogTitle(\"Select File To Send\");\r\n        try {\r\n            if (lookString instanceof String) {\r\n                LiquidLookAndFeel.setLiquidDecorations(true);\r\n                UIManager.setLookAndFeel((String) lookString);\r\n                SwingUtilities.updateComponentTreeUI(jfm);\r\n            }\r\n        } catch (Exception e1) {\r\n            e1.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in applying look and feel!!\");\r\n        }\r\n        loginPanel = new LoginPanel(this);\r\n        chatClientFrame = new ChatFrame(this);\r\n        chatClientFrame.getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n        chatClientFrame.setSize(300, 500);\r\n        Dimension frameSize = chatClientFrame.getSize();\r\n        if (frameSize.height > screenSize.height) {\r\n            frameSize.height = screenSize.height;\r\n        }\r\n        if (frameSize.width > screenSize.width) {\r\n            frameSize.width = screenSize.width;\r\n        }\r\n        chatClientFrame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\r\n        chatClientFrame.repaint();\r\n        chatClientFrame.addWindowListener(this);\r\n        chatClientFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\r\n        chatClientFrame.setVisible(true);\r\n        emotionImages = new Hashtable<String, String>();\r\n        emotionImages.put(\":)\", \"smile.png\");\r\n        emotionImages.put(\":D\", \"bigSmile.png\");\r\n        emotionImages.put(\";)\", \"wink.png\");\r\n        emotionImages.put(\":|\", \"shocked.png\");\r\n        emotionImages.put(\":(\", \"sad.png\");\r\n        emotionImages.put(\":S\", \"confused.png\");\r\n        emotionImages.put(\":P\", \"evilSmile.png\");\r\n        emotionImages.put(\":E\", \"lol.png\");\r\n        emotionImages.put(\":@\", \"angery.png\");\r\n        chatSysTray = new ChatSysTray(this);\r\n        emotionFrame = new JDialog(chatClientFrame, false);\r\n        emotionFrame.addMouseListener(new java.awt.event.MouseAdapter() {\r\n\r\n            public void mouseExited(java.awt.event.MouseEvent evt) {\r\n                emotionFrame.setVisible(false);\r\n            }\r\n        });\r\n        emotionFrame.setSize(100, 120);\r\n        emotionFrame.setAlwaysOnTop(true);\r\n        emotionFrame.setResizable(false);\r\n        emotionFrame.setUndecorated(true);\r\n        emotionPanel = new EmotionPanel(emotionFrame);\r\n        emotionFrame.getContentPane().add(emotionPanel);\r\n        fontFrame = new JDialog(chatClientFrame, \"Change Font And Color\", true);\r\n        fontPanel = new FontPanel(fontFrame, this);\r\n        fontFrame.setSize(270, 200);\r\n        fontFrame.setAlwaysOnTop(true);\r\n        fontFrame.setResizable(false);\r\n        fontFrame.setLocationRelativeTo(chatClientFrame);\r\n        fontFrame.getContentPane().add(fontPanel);\r\n        settingsFrame = new JDialog(chatClientFrame, \"Change Settings\", true);\r\n        settingPanel = new SettingPanel(settingsFrame, this);\r\n        settingsFrame.setSize(200, 450);\r\n        settingsFrame.setAlwaysOnTop(true);\r\n        settingsFrame.setResizable(false);\r\n        settingsFrame.getContentPane().add(settingPanel);\r\n        changePassFrame = new JDialog(chatClientFrame, \"Change Password\", true);\r\n        changePassPanel = new ChangePassPanel(changePassFrame, this);\r\n        changePassFrame.setSize(190, 200);\r\n        changePassFrame.setAlwaysOnTop(true);\r\n        changePassFrame.setResizable(false);\r\n        changePassFrame.getContentPane().add(changePassPanel);\r\n        loadStatusLookup();\r\n        String[] statusList = new String[getStatusLookup().size() - 1];\r\n        for (int i = 1; i < getStatusLookup().size(); i++) {\r\n            statusList[i - 1] = getStatusLookup().get(i).getDesc();\r\n        }\r\n        settingPanel.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n    }\r\n\r\n    public void initServer() throws Exception {\r\n        //lookup for the server\r\n        Registry reg = null;\r\n        System.out.println(\"Starting Client .....\");\r\n        reg = LocateRegistry.getRegistry(clientSettingBean.getServerURL(), Integer.parseInt(clientSettingBean.getServerPort()));\r\n        System.out.println(\"trying to connect to the FIM server .....\");\r\n        try {\r\n            serverInterface = (ServerClientInterface) reg.lookup(\"ModernChatServer\");\r\n            System.out.println(\"connected to the FIM server .....\");\r\n        } catch (Exception ex) {\r\n            //ex.printStackTrace();\r\n            throw new Exception(\"Can't find FIM Server at:\" + clientSettingBean.getServerURL() + \":\" + clientSettingBean.getServerPort());\r\n        }\r\n    }\r\n\r\n    public void login(String userEmail, String password) throws Exception {\r\n        if (getServerInterface() == null) {\r\n            initServer();\r\n        }\r\n        stringEnc = StringEncrypter.getInstance(password);\r\n        LoginBean loginBean = serverInterface.signIn(this, StringEncoder64.encodeStringUTF8(userEmail), stringEnc.encrypt(password), StringEncoder64.encodeStringUTF8(ownIP.getHostAddress()));\r\n        if (loginBean == null) {\r\n            throw new Exception(\"Invalid User Email or Password!\");\r\n        } else {\r\n            user = loginBean.getUser();\r\n            securityToke = stringEnc.decrypt(loginBean.getSecureToken());\r\n            stringEnc = StringEncrypter.getInstance(securityToke);\r\n            FileEncrypter.getInstanceInit(securityToke.getBytes());\r\n            securityMode = serverInterface.getSecurityMode();\r\n            rootNode = serverInterface.getRootNode();\r\n            getChatClientFrame().setTitle(user.getName());\r\n            chatClientFrame.changeStatusEnabled(true);\r\n            try {\r\n                groups = getServerInterface().loadGroupsAndUsers(loginBean.getAuthToken());\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Contacts List From FIM Server!\");\r\n            }\r\n            try {\r\n                setRooms(getServerInterface().getMyRooms(user, loginBean.getAuthToken()));\r\n            } catch (RemoteException ex) {\r\n                ex.printStackTrace();\r\n                throw new Exception(\"Error During Getting User Rooms List From FIM Server!\");\r\n            }\r\n            String[] statusList = new String[getStatusLookup().size()];\r\n            for (int i = 0; i < getStatusLookup().size(); i++) {\r\n                statusList[i] = getStatusLookup().get(i).getDesc();\r\n            }\r\n            //default status from setting file\r\n            chatClientFrame.updateStatusList(statusList, Integer.parseInt(clientSettingBean.getDefaultStatus()));\r\n            updateMyStatus(Integer.parseInt(getClientSettingBean().getDefaultStatus()));\r\n            getChatSysTray().login();\r\n            clientSettingBean.setUserEmail(userEmail);\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                clientSettingBean.setPassword(password);\r\n            }\r\n            clientSettingBean.updateSettings();\r\n            pingServerThread = new PingServerThread(this);\r\n            pingServerThread.start();\r\n        }\r\n    }\r\n\r\n    public void kickOffByAdmin(String justification) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (justification == null || justification.equals(\"\")) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out by the Admin!\", \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been signed out off by the Admin for: \" + justification, \"Admin Sign Out\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void kickOffByLogin(boolean sameMachine) throws RemoteException {\r\n        chatClientFrame.changeStatusEnabled(false);\r\n        settingsFrame.setVisible(false);\r\n        fontFrame.setVisible(false);\r\n        //need to hide it also :)\r\n        //jfm.setAcVisible(false);\r\n        number = 20;\r\n        pingServerThread = null;\r\n        //if change status throws exception than also sign from the GUI , server may be down!\r\n        getChatSysTray().logOut();\r\n        //adjust UI again\r\n        showLoginAgain();\r\n        setUser(null);\r\n        if (sameMachine) {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in the same machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        } else {\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"You have been logged off by login from client in another machine!\", \"Concurrent Login\", JOptionPane.ERROR_MESSAGE, getErrorIcon());\r\n        }\r\n    }\r\n\r\n    public void updateMyStatus(int statusNo) {\r\n        if (statusNo != 0 && user != null) {\r\n            user.setStatus_id(getStatusLookup().get(statusNo).getId());\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.UPDATE_STATUS);\r\n            sendMyStatusThread.start();\r\n        } else {\r\n            chatClientFrame.changeStatusEnabled(false);\r\n            settingsFrame.setVisible(false);\r\n            fontFrame.setVisible(false);\r\n            //need to hide it also :)\r\n            //jfm.setAcVisible(false);\r\n            number = 20;\r\n            pingServerThread = null;\r\n            SendMyStatusThread sendMyStatusThread = new SendMyStatusThread(this, SendMyStatusThread.SIGN_OUT);\r\n            sendMyStatusThread.start();\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    public boolean ping() throws RemoteException {\r\n        return true;\r\n    }\r\n\r\n    public void receiveUpdatedUserStatus(User updatedUser) throws RemoteException {\r\n        if (updatedUser.getId() != user.getId()) {\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                if (updatedUser.getGroup_id() == groups.get(i).getId()) {\r\n                    Vector<User> tempUsers = groups.get(i).getUsers();\r\n                    if (tempUsers != null && tempUsers.size() > 0) {\r\n                        for (int n = 0; n < tempUsers.size(); n++) {\r\n                            if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                                tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                                if (contactsPanel != null) {\r\n                                    contactsPanel.updateContactList();\r\n                                }\r\n                                chatClientFrame.updateFrameIconForUser(updatedUser.getName(), userStatusIcons[updatedUser.getStatus_id()]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void refreshGroupsAndUsers(Vector<Group> groups) throws RemoteException {\r\n        this.groups = groups;\r\n        if (contactsPanel != null) {\r\n            closeAllChat();\r\n            contactsPanel.updateContactList();\r\n            JOptionPane.showMessageDialog(getChatClientFrame(), \"Your contact list is refreshed by the Admin!\", \"Contact List Updated\", JOptionPane.INFORMATION_MESSAGE);\r\n        }\r\n    }\r\n\r\n    public void openChat(Group group, boolean fileTransfer, File file) {\r\n        //check if group can have a chat room or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, group);\r\n        if (getChatClientFrame().addNewFrame(group.getName(), group_icon, temp)) {\r\n            openChatPanels.put(group.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(Room room, boolean fileTransfer, File file) {\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, room);\r\n        if (getChatClientFrame().addNewFrame(room.getName(), room_icon, temp)) {\r\n            openChatPanels.put(room.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n            if (fileTransfer) {\r\n                if (file == null) {\r\n                    temp.openSendFileDialog();\r\n                } else {\r\n                    temp.sendFileInit(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void openChat(User chatUser, boolean fileTransfer, File file) {\r\n        //check if user can't accept chat or not\r\n        ChatWindowPanel temp = new ChatWindowPanel(this, chatUser);\r\n        //if user status not exist , get it from the groups we have\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (chatUser.getId() == tempUsers.get(n).getId()) {\r\n                        chatUser.setStatus_id(tempUsers.get(n).getStatus_id());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (chatClientFrame.addNewFrame(chatUser.getName(), userStatusIcons[chatUser.getStatus_id()], temp)) {\r\n            openChatPanels.put(chatUser.getId(), temp);\r\n            getOpenChatPanelsByIndex().put(getChatClientFrame().getParentTabbedPane().getSelectedIndex() - 1, temp);\r\n        }\r\n        if (fileTransfer) {\r\n            if (file == null) {\r\n                temp.openSendFileDialog();\r\n            } else {\r\n                temp.sendFileInit(file);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void closeAllChat() {\r\n        int n = getChatClientFrame().getParentTabbedPane().getTabCount() - 1;\r\n        for (int i = n; i > 0; i--) {\r\n            getChatClientFrame().removeFrame(i);\r\n        }\r\n        openChatPanels = new Hashtable<Integer, ChatWindowPanel>();\r\n        openChatPanelsByIndex = new Hashtable<Integer, ChatWindowPanel>();\r\n    }\r\n\r\n    public void closeChatAtIndex(int index) {\r\n        String name = getChatClientFrame().getParentTabbedPane().getTitleAt(index);\r\n        openChatPanelsByIndex.remove(index);\r\n        getChatClientFrame().removeFrame(index);\r\n        Enumeration en = openChatPanels.elements();\r\n        while (en.hasMoreElements()) {\r\n            ChatWindowPanel obj = (ChatWindowPanel) en.nextElement();\r\n            if (obj.getChat_type() == IConstant.USER_CHAT) {\r\n                if (obj.getUser().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getUser().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.GROUP_CHAT) {\r\n                if (obj.getGroup().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getGroup().getId());\r\n                }\r\n            } else if (obj.getChat_type() == IConstant.ROOM_CHAT) {\r\n                if (obj.getRoom().getName().equals(name)) {\r\n                    openChatPanels.remove(obj.getRoom().getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public String changePassword(String oldPass, String newPass) {\r\n        ResultBean result = null;\r\n        oldPass = stringEnc.encrypt(oldPass);\r\n        newPass = stringEnc.encrypt(newPass);\r\n        String email = StringEncoder64.encodeStringUTF8(user.getEmail());\r\n        try {\r\n            result = getServerInterface().changePassword(email, oldPass, newPass);\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Connect To Server!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n                newPass = stringEnc.decrypt(newPass);\r\n                clientSettingBean.setPassword(newPass);\r\n                clientSettingBean.updateSettings();\r\n                loginPanel.updatePassword(newPass);\r\n            }\r\n            return \"New Password Applied Successfully!\";\r\n        } else {\r\n            if (result.getAction() == IConstant.ERROR) {\r\n                //set user status in the tab and list as offline !\r\n                return result.getMessage();\r\n            } else {\r\n                return \"Failed to Change Password!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public String sendTextMessage(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        boolean result = false;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendTextMessage(textMessage);\r\n            } else {\r\n                textMessage.setMessage(stringEnc.encrypt(textMessage.getMessage()));\r\n                textMessage.setTitle(stringEnc.encrypt(textMessage.getTitle()));\r\n                result = getServerInterface().sendSecureTextMessage(textMessage);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n        if (result) {\r\n            return null;\r\n        } else {\r\n            return \"Error:Failed to Deliver This Message!\";\r\n        }\r\n    }\r\n\r\n    public String sendBinaryMessage(BinaryMessage bm) {\r\n        bm.setFromUserId(user.getId());\r\n        bm.setTitle(user.getName());\r\n        ResultBean result = null;\r\n        try {\r\n            if (getSecurityMode() == 0) {\r\n                result = getServerInterface().sendBinaryMessage(bm);\r\n            } else {\r\n                bm.setDesc(stringEnc.encrypt(bm.getDesc()));\r\n                bm.setTitle(stringEnc.encrypt(bm.getTitle()));\r\n                result = getServerInterface().sendSecureBinaryMessage(bm);\r\n            }\r\n        } catch (RemoteException ex) {\r\n            return \"Error:Failed to Deliver This File!\";\r\n        }\r\n        if (result.isSuccess()) {\r\n            return null;\r\n        } else {\r\n            if (result.getAction() == IConstant.REJECTED) {\r\n                return \"Rejected:File Transfer Declined by the User!\";\r\n            } else {\r\n                return \"Error:Failed to Deliver This File!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    public void sendAnnouncement(TextMessage textMessage) {\r\n        textMessage.setFromUserId(user.getId());\r\n        textMessage.setTitle(user.getName());\r\n        SendAnnouncementThread sendThread = new SendAnnouncementThread(this, textMessage);\r\n        sendThread.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            ChatClientApp clientApp = new ChatClientApp();\r\n        } catch (RemoteException ex) {\r\n            ex.printStackTrace();\r\n            System.out.println(\"Error in Running!\");\r\n        }\r\n    }\r\n\r\n    public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = null;\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            if (tempPanel == null) {\r\n                User temp = new User();\r\n                temp.setId(msg.getFromUserId());\r\n                temp.setName(msg.getTitle());\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getFromUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Group temp = new Group();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    if (groups.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(groups.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            tempPanel = openChatPanels.get(msg.getToUserId());\r\n            if (tempPanel == null) {\r\n                Room temp = new Room();\r\n                temp.setId(msg.getToUserId());\r\n                for (int i = 0; i < rooms.size(); i++) {\r\n                    if (rooms.get(i).getId() == msg.getToUserId()) {\r\n                        temp.setName(rooms.get(i).getName());\r\n                    }\r\n                }\r\n                //to gurantee user tab is exist.\r\n                openChat(temp, false, null);\r\n                tempPanel = openChatPanels.get(msg.getToUserId());\r\n            }\r\n        }\r\n        tempPanel.addTextChat(msg);\r\n        title = msg.getTitle();\r\n        startThread();\r\n        return true;\r\n    }\r\n\r\n    public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        tempPanel.addTextChat(msg.getTitle() + \" want to send you the file [\" + msg.getDesc() + \"], Accept?\");\r\n        int n = JOptionPane.showConfirmDialog(getChatClientFrame(), msg.getTitle() + \" : want to send you the file [\" + msg.getDesc() + \"], Accept?\", \"Accept File Transfer\", JOptionPane.OK_CANCEL_OPTION);\r\n        if (n == JOptionPane.OK_OPTION) {\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        } else {\r\n            tempPanel.addTextChat(\"File transfer rejected!\");\r\n            TextMessage tm = new TextMessage();\r\n            tm.setTitle(user.getName());\r\n            tm.setFromUserId(user.getId());\r\n            tm.setMessage(\"File [\" + msg.getDesc() + \"] transfer rejected by \" + user.getName());\r\n            tm.setToUserId(msg.getFromUserId());\r\n            tm.setTargetType(IConstant.USER_CHAT);\r\n            getServerInterface().sendTextMessage(tm);\r\n            return new ResultBean(false, IConstant.REJECTED, null);\r\n        }\r\n    }\r\n\r\n    public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        ChatWindowPanel tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        if (tempPanel == null) {\r\n            User temp = new User();\r\n            temp.setId(msg.getFromUserId());\r\n            temp.setName(msg.getTitle());\r\n            //to gurantee user tab is exist.\r\n            openChat(temp, false, null);\r\n            tempPanel = openChatPanels.get(msg.getFromUserId());\r\n        }\r\n        title = msg.getTitle();\r\n        startThread();\r\n        ReceiveFileThread receiveFileThread = new ReceiveFileThread(tempPanel, msg, this);\r\n        receiveFileThread.start();\r\n    }\r\n\r\n    public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        ReceiveAnnouncementThread receiveThread = new ReceiveAnnouncementThread(this, msg);\r\n        receiveThread.start();\r\n        title = msg.getTitle();\r\n        startThread();\r\n    }\r\n\r\n    public void receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveTextAnnouncement(msg);\r\n    }\r\n\r\n    public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        msg.setMessage(stringEnc.decrypt(msg.getMessage()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveTextMessage(msg);\r\n    }\r\n\r\n    public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        return receiveBinaryMessageRequest(msg);\r\n    }\r\n\r\n    public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\r\n        msg.setDesc(stringEnc.decrypt(msg.getDesc()));\r\n        msg.setTitle(stringEnc.decrypt(msg.getTitle()));\r\n        receiveBinaryMessageLoad(msg);\r\n    }\r\n\r\n    private void startThread() {\r\n        if (chatClientFrame.isVisible() == false) {\r\n            getChatSysTray().showMessage(title);\r\n        }\r\n        chatClientFrame.setVisible(true);\r\n        chatClientFrame.toFront();\r\n        chatClientFrame.requestFocusInWindow();\r\n        //don't disturb me if in busy status\r\n        if (user.getStatus_id() != IConstant.BUSY) {\r\n            if (number == 0 || number >= 16) {\r\n                number = 0;\r\n                if (ac != null)\r\n                    ac.play();\r\n                th = new Thread(this);\r\n                th.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void showChangePass() {\r\n        changePassFrame.setLocationRelativeTo(settingsFrame);\r\n        changePassPanel.clearFields();\r\n        changePassFrame.setVisible(true);\r\n    }\r\n\r\n    public void showSettings() {\r\n        settingsFrame.setLocationRelativeTo(getChatClientFrame());\r\n        settingPanel.updateSettings();\r\n        settingsFrame.setVisible(true);\r\n    }\r\n\r\n    public void showLoginAgain() {\r\n        closeAllChat();\r\n        if (\"1\".equals(clientSettingBean.getRememberPass())) {\r\n            loginPanel.updatePassword(clientSettingBean.getPassword());\r\n        } else {\r\n            loginPanel.updatePassword(\"\");\r\n        }\r\n        getChatClientFrame().getContactPanel().remove(contactsPanel);\r\n        getChatClientFrame().changeStatusEnabled(false);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(loginPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, new javax.swing.ImageIcon(getClass().getResource(\"/images/login.gif\")));\r\n        getChatClientFrame().setTitleAt(0, \"Login\");\r\n        getChatClientFrame().setTitle(\"Free Instant Messenger\");\r\n        //getChatClientFrame().setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/groups.png\")));\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void showContactList() {\r\n        getChatClientFrame().getContactPanel().remove(loginPanel);\r\n        contactsPanel = new ContactsPanel(this);\r\n        getChatClientFrame().getContactPanel().add(contactsPanel, java.awt.BorderLayout.CENTER);\r\n        getChatClientFrame().setIconAt(0, group_icon);\r\n        getChatClientFrame().setTitleAt(0, \"Contact List\");\r\n        getChatClientFrame().repaint();\r\n    }\r\n\r\n    public void initSound() {\r\n        if (clientSettingBean.getSoundType() != null && !\"0\".equals(clientSettingBean.getSoundType())) {\r\n            try {\r\n                if (\"1\".equals(getClientSettingBean().getSoundType())) {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/alert.mid\").toURI().toURL());\r\n                } else {\r\n                    ac = Applet.newAudioClip(new File(path + \"/sound/bird.mid\").toURI().toURL());\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        } else {\r\n            ac = null;\r\n        }\r\n    }\r\n\r\n    public void forcedSignOff() throws RemoteException {\r\n    }\r\n\r\n    private void exitME() {\r\n        chatClientFrame.setVisible(false);\r\n    }\r\n\r\n    public void run() {\r\n        while (number < 16) {\r\n            if (chatClientFrame.isVisible()) {\r\n                if (number % 2 == 0) {\r\n                    chatClientFrame.setTitle(title + \" is talking!\");\r\n                    chatClientFrame.setIconImage(java.awt.Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/images/chat.jpg\")));\r\n                } else {\r\n                    if (user != null) {\r\n                        chatClientFrame.setTitle(user.getName());\r\n                    } else {\r\n                        chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n                    }\r\n                    chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n                }\r\n            }\r\n            try {\r\n                number++;\r\n                th.sleep(1500);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (user != null) {\r\n            chatClientFrame.setTitle(user.getName());\r\n        } else {\r\n            chatClientFrame.setTitle(\"Free Instant Messenger\");\r\n        }\r\n        chatClientFrame.setIconImage(getChatSysTray().getStatusImage());\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    public User getUser() {\r\n        return user;\r\n    }\r\n\r\n    public void setUser(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public void setRooms(Vector<Room> rooms) {\r\n        this.rooms = rooms;\r\n    }\r\n\r\n    public Hashtable<Integer, ChatWindowPanel> getOpenChatPanelsByIndex() {\r\n        return openChatPanelsByIndex;\r\n    }\r\n\r\n    public static Hashtable<String, String> getEmotionImages() {\r\n        return emotionImages;\r\n    }\r\n\r\n    public JFileChooser getJfm() {\r\n        return jfm;\r\n    }\r\n\r\n    public ChatFrame getChatClientFrame() {\r\n        return chatClientFrame;\r\n    }\r\n\r\n    public void windowOpened(WindowEvent arg0) {\r\n        //about();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosing(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosing(WindowEvent arg0) {\r\n        exitME();\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowClosed(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowClosed(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowIconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowIconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeiconified(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeiconified(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowActivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowActivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.awt.event.WindowListener#windowDeactivated(java.awt.event.WindowEvent)\r\n     */\r\n    public void windowDeactivated(WindowEvent arg0) {\r\n    }\r\n\r\n    /**\r\n     * @return the statusLookup\r\n     */\r\n    public Hashtable<Integer, Status> getStatusLookup() {\r\n        return statusLookup;\r\n    }\r\n\r\n    private void loadStatusLookup() {\r\n        statusLookup = new Hashtable<Integer, Status>();\r\n        Status status0 = new Status();\r\n        status0.setId(0);\r\n        status0.setDesc(\"Sign Out\");\r\n        Status status1 = new Status();\r\n        status1.setId(1);\r\n        status1.setDesc(\"Offline\");\r\n        Status status2 = new Status();\r\n        status2.setId(2);\r\n        status2.setDesc(\"Online\");\r\n        Status status3 = new Status();\r\n        status3.setId(3);\r\n        status3.setDesc(\"Busy\");\r\n        Status status4 = new Status();\r\n        status4.setId(4);\r\n        status4.setDesc(\"Away\");\r\n        statusLookup.put(IConstant.SIGN_OUT, status0);\r\n        statusLookup.put(IConstant.OFFLINE, status1);\r\n        statusLookup.put(IConstant.ONLINE, status2);\r\n        statusLookup.put(IConstant.BUSY, status3);\r\n        statusLookup.put(IConstant.AWAY, status4);\r\n    }\r\n\r\n    /**\r\n     * @return the serverInterface\r\n     */\r\n    public ServerClientInterface getServerInterface() {\r\n        return serverInterface;\r\n    }\r\n\r\n    /**\r\n     * @return the chatSysTray\r\n     */\r\n    public ChatSysTray getChatSysTray() {\r\n        return chatSysTray;\r\n    }\r\n\r\n    /**\r\n     * @return the errorIcon\r\n     */\r\n    public ImageIcon getErrorIcon() {\r\n        return errorIcon;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionPanel\r\n     */\r\n    public EmotionPanel getEmotionPanel() {\r\n        return emotionPanel;\r\n    }\r\n\r\n    /**\r\n     * @return the emotionFrame\r\n     */\r\n    public JDialog getEmotionFrame() {\r\n        return emotionFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the fontFrame\r\n     */\r\n    public JDialog getFontFrame() {\r\n        return fontFrame;\r\n    }\r\n\r\n    /**\r\n     * @return the clientSettingBean\r\n     */\r\n    public ClientSettingBean getClientSettingBean() {\r\n        return clientSettingBean;\r\n    }\r\n\r\n    /**\r\n     * @return the securityMode\r\n     */\r\n    public int getSecurityMode() {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() {\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * @return the stringEnc\r\n     */\r\n    public StringEncrypter getStringEnc() {\r\n        return stringEnc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ChatClientAppTest8.java",
		"test_prompt": "// ChatClientAppTest8.java\npackage osa.ora.server.client;\n\nimport com.birosoft.liquid.LiquidLookAndFeel;\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.Status;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport osa.ora.server.ServerClientInterface;\nimport osa.ora.server.beans.ClientSettingBean;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.client.threads.PingServerThread;\nimport osa.ora.server.client.threads.ReceiveAnnouncementThread;\nimport osa.ora.server.client.threads.ReceiveFileThread;\nimport osa.ora.server.client.threads.SendAnnouncementThread;\nimport osa.ora.server.client.threads.SendMyStatusThread;\nimport osa.ora.server.client.ui.ChangePassPanel;\nimport osa.ora.server.client.ui.ChatFrame;\nimport osa.ora.server.client.ui.ChatSysTray;\nimport osa.ora.server.client.ui.ChatWindowPanel;\nimport osa.ora.server.client.ui.ContactsPanel;\nimport osa.ora.server.client.ui.EmotionPanel;\nimport osa.ora.server.client.ui.FontPanel;\nimport osa.ora.server.client.ui.LoginPanel;\nimport osa.ora.server.client.ui.SettingPanel;\nimport osa.ora.server.utils.FileEncrypter;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatClientApp}.\n* It contains ten unit test cases for the {@link ChatClientApp#getEmotionImages()} method.\n*/\nclass ChatClientAppTest8 {"
	}
]